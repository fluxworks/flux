#![feature
(
    
)]

#![allow
(
    unused_attributes,
    unused_imports,
    unused_macros,
    unused_unsafe,
    unused_variables,
)]
/*
extern crates */
extern crate clap; // clap 4.5.20
extern crate fnv; // fnv 1.0
extern crate lazy_static; // lazy-static 1.4.0
extern crate libc; // libc 0.2.126
extern crate memchr; // memchr 2.5.0
extern crate nix; // nix 0.28.0
extern crate phf; // phf 0.11
extern crate regex; // regex 1.5.6
extern crate smallvec; // smallvec 1.8.0
extern crate time as timecrate; // time 0.3.9
extern crate unicode_normalization; // unicode-normalization 0.19
extern crate unicode_width; // unicode-width 0.19
/*
Rust Standard Library */
pub use std::{*};
/*
errno v0.3.10*/
pub mod errno
{
    //! Cross-platform interface to the `errno` variable.
    use crate::
    {
        error::{ Error },
        fmt, io, 
    };
    /*
    Unix */
    pub mod sys
    {
        use crate::
        {
            fmt, str,
        };
        
        use libc::{self, c_int, size_t, strerror_r, strlen};
        use super::Errno;

        pub const STRERROR_NAME: &str = "strerror_r";

        extern "C" 
        {
            #[cfg_attr
            (
                any
                (
                    target_os = "linux",
                    target_os = "hurd",
                    target_os = "redox",
                    target_os = "dragonfly",
                    target_os = "emscripten",
                ),
                link_name = "__errno_location"
            )]
            fn errno_location() -> *mut c_int;
        }

        pub fn with_description<F, T>(err: Errno, callback: F) -> T where
        F: FnOnce(Result<&str, Errno>) -> T,
        {
            let mut buf = [0u8; 1024];
            let c_str = unsafe 
            {
                let rc = strerror_r(err.0, buf.as_mut_ptr() as *mut _, buf.len() as size_t);
                if rc != 0 
                {
                    // Handle negative return codes for compatibility with glibc < 2.13
                    let fm_err = match rc < 0 
                    {
                        true => errno(),
                        false => Errno(rc),
                    };
                    
                    if fm_err != Errno(libc::ERANGE) 
                    { return callback(Err(fm_err)); }
                }

                let c_str_len = strlen(buf.as_ptr() as *const _);
                &buf[..c_str_len]
            };

            callback(Ok(from_utf8_lossy(c_str)))
        }

        pub fn errno() -> Errno 
        {
            unsafe { Errno(*errno_location()) }
        }

        pub fn set_errno(Errno(errno): Errno) 
        {
            unsafe { *errno_location() = errno; }
        }

        fn from_utf8_lossy(input: &[u8]) -> &str 
        {
            match str::from_utf8(input) 
            {
                Ok(valid) => valid,
                Err(error) => unsafe { str::from_utf8_unchecked(&input[..error.valid_up_to()]) },
            }
        }
    }
    /*
    Wraps a platform-specific error code. */
    #[derive( Copy, Clone, Eq, Ord, PartialEq, PartialOrd, Hash )]
    pub struct Errno( pub i32 );

    impl fmt::Debug for Errno 
    {
        fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
        {
            sys::with_description(*self, |desc| 
            {
                fmt.debug_struct("Errno")
                   .field("code", &self.0)
                   .field("description", &desc.ok())
                   .finish()
            })
        }
    }

    impl fmt::Display for Errno 
    {
        fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
        {
            sys::with_description(*self, |desc| match desc 
            {
                Ok(desc) => fmt.write_str(desc),
                Err(fm_err) => write!
                (
                    fmt,
                    "OS error {} ({} returned error {})",
                    self.0,
                    sys::STRERROR_NAME,
                    fm_err.0
                ),
            })
        }
    }

    impl From<Errno> for i32 
    {
        fn from(e: Errno) -> Self 
        {
            e.0
        }
    }
    
    impl Error for Errno 
    {
        #[allow(deprecated)]
        fn description(&self) -> &str 
        {
            "system error"
        }
    }
    
    impl From<Errno> for io::Error 
    {
        fn from(errno: Errno) -> Self 
        {
            io::Error::from_raw_os_error(errno.0)
        }
    }

    /// Returns the platform-specific value of `errno`.
    pub fn errno() -> Errno 
    {
        sys::errno()
    }

    /// Sets the platform-specific value of `errno`.
    pub fn set_errno(err: Errno) 
    {
        sys::set_errno(err)
    }
}
/*
Use the POSIX exec function to replace the running program with another. */
pub mod exec
{
    use ::
    {
        errno::{Errno, errno},
        error::{ self, Error as ErrorTrait, },
        ffi::{ CString, NulError, OsStr, OsString },
        iter::{ IntoIterator, Iterator },
        os::unix::ffi::{ OsStrExt },
        fmt, ptr,
    };
    /**
    Like `try!`, but it just returns the error directly without wrapping it in `Err`. */
    macro_rules! exec_try 
    {
        ( $ expr : expr ) => 
        {
            match $expr 
            {
                Ok(val) => val,
                Err(err) => return From::from(err),
            }
        };
    }
    /**
    Represents an error calling `exec`. This is marked `#[must_use]`, which is unusual for error types. */
    #[derive(Debug)] #[must_use]
    pub enum Errors
    {
        /** One of the strings passed to `execv` contained an internal null byte and can't be passed correctly to C. */
        BadArgument(NulError),
        /// An error was returned by the system.
        Errno(Errno),
    }
    
    impl error::Error for Errors 
    {
        fn description(&self) -> &str 
        {
            match self 
            {
                &Errors::BadArgument(_) => "bad argument to exec",
                &Errors::Errno(_) => "couldn't exec process",
            }
        }

        fn cause(&self) -> Option<&dyn error::Error> 
        {
            match self 
            {
                &Errors::BadArgument(ref err) => Some(err),
                &Errors::Errno(_) => None,
            }
        }
    }

    impl fmt::Display for Errors 
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
        {
            match self 
            {
                &Errors::BadArgument(ref err) => write!(f, "{}: {}", "bad argument to exec", err),
                &Errors::Errno(err) => write!(f, "{}: {}", "couldn't exec process", err),
            }
        }
    }

    impl From<NulError> for Errors
    {
        /// Convert a `NulError` into an `ExecError`.
        fn from(err: NulError) -> Errors
        {
            Errors::BadArgument(err)
        }
    }
    /**
    Run `program` with `args`, completely replacing the currently running program. */
    pub fn execvp<S, I>(program: S, args: I) -> Errors where 
    S:AsRef<OsStr>, 
    I:IntoIterator, 
    I::Item:AsRef<OsStr>
    {
        // Add null terminations to our strings and our argument array
        let program_cstring = exec_try!(CString::new(program.as_ref().as_bytes()));
        let arg_cstrings = exec_try!(args.into_iter().map(|arg| 
        { CString::new(arg.as_ref().as_bytes()) }).collect::<Result<Vec<_>, _>>());

        let mut arg_charptrs: Vec<_> = arg_cstrings.iter().map(|arg| 
        { arg.as_ptr() }).collect();

        arg_charptrs.push(ptr::null());

        // Use an `unsafe` block so that we can call directly into C.
        let res = unsafe 
        {
            libc::execvp(program_cstring.as_ptr(), arg_charptrs.as_ptr())
        };

        // Handle our error result.
        if res < 0 { Errors::Errno(errno()) } 
        else { panic!("execvp returned unexpectedly") }
    }
    /**
    Build a command to execute. */
    pub struct Command 
    {
        argv: Vec<OsString>,
    }

    impl Command 
    {
        /**
        Create a new command builder, specifying the program to run.*/
        pub fn new<S: AsRef<OsStr>>(program: S) -> Command 
        {
            Command 
            {
                argv: vec!(program.as_ref().to_owned()),
            }
        }
        /**
        Add an argument to the command builder.  This can be chained. */
        pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command 
        {
            self.argv.push(arg.as_ref().to_owned());
            self
        }
        /**
        Add multiple arguments to the command builder.  This can be chained. */
        pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command 
        {
            for arg in args 
            {
                self.arg(arg.as_ref());
            }
            self
        }
        /**
        Execute the command we built. */
        pub fn exec(&mut self) -> Errors 
        {
            execvp(&self.argv[0], &self.argv)
        }
    }
}
/*
*/
pub mod glob
{
    /*!
    Support for matching file paths against Unix shell style patterns. */
    use ::
    {
        cmp::{ self, Ordering },
        error::{Error},
        fs::{self, DirEntry},
        glob::
        {
            CharSpecifier::{CharRange, SingleChar},
            MatchResult::{EntirePatternDoesntMatch, Match, SubPatternDoesntMatch},
            PatternToken::{AnyChar, AnyExcept, AnyRecursiveSequence, AnySequence, AnyWithin, Char}
        },
        ops::{ Deref },
        path::{self, Component, Path, PathBuf},
        str::{FromStr},
        fmt, io,
    };

    const ERROR_WILDCARDS: &str = "wildcards are either regular `*` or recursive `**`";
    const ERROR_RECURSIVE_WILDCARDS: &str = "recursive wildcards must form a single path component";
    const ERROR_INVALID_RANGE: &str = "invalid range pattern";
    /**
    An alias for a glob iteration result. */
    pub type GlobResult = Result<PathBuf, GlobError>;
    /**
    An iterator that yields `Path`s from the filesystem that match a particular pattern. */
    #[derive(Debug)]
    pub struct Paths 
    {
        dir_patterns: Vec<Pattern>,
        require_dir: bool,
        options: MatchOptions,
        todo: Vec<Result<(PathWrapper, usize), GlobError>>,
        scope: Option<PathWrapper>,
    }
    /*
    Return an iterator that produces all `Path`s that match a pattern using default match options,
    which may be absolute or relative to the current working directory. */
    pub fn glob(pattern: &str) -> Result<Paths, PatternError> 
    {
        glob_with(pattern, MatchOptions::new())
    }
    /**    
    Return an iterator that produces all the `Path`s that match the given pattern using 
    the match options, which may be absolute or relative to the current working directory. */
    pub fn glob_with(pattern: &str, options: MatchOptions) -> Result<Paths, PatternError> 
    {
        fn check_windows_verbatim(_: &Path) -> bool { false }
        
        fn to_scope(p: &Path) -> PathBuf { p.to_path_buf() }

        // make sure that the pattern is valid first, else early return with error
        let _ = Pattern::new(pattern)?;

        let mut components = Path::new(pattern).components().peekable();
        loop 
        {
            match components.peek() 
            {
                Some(&Component::Prefix(..)) | Some(&Component::RootDir) => 
                {
                    components.next();
                }
                _ => break,
            }
        }

        let rest = components.map(|s| s.as_os_str()).collect::<PathBuf>();
        let normalized_pattern = Path::new(pattern).iter().collect::<PathBuf>();
        let root_len = normalized_pattern.to_str().unwrap().len() - rest.to_str().unwrap().len();
        
        let root = if root_len > 0 { Some(Path::new(&pattern[..root_len])) }        
        else { None };

        if root_len > 0 && check_windows_verbatim(root.unwrap()) 
        {
            return Ok(Paths 
            {
                dir_patterns: Vec::new(),
                require_dir: false,
                options,
                todo: Vec::new(),
                scope: None,
            });
        }

        let scope = root.map_or_else(|| PathBuf::from("."), to_scope);
        let scope = PathWrapper::from_path(scope);

        let mut dir_patterns = Vec::new();
        let components =
            pattern[cmp::min(root_len, pattern.len())..]
            .split_terminator(path::is_separator);

        for component in components { dir_patterns.push(Pattern::new(component)?); }

        if root_len == pattern.len() 
        {
            dir_patterns.push(Pattern 
            {
                original: "".to_string(),
                tokens: Vec::new(),
                is_recursive: false,
            });
        }

        let last_is_separator = pattern.chars().next_back().map(path::is_separator);
        let require_dir = last_is_separator == Some(true);
        let todo = Vec::new();

        Ok(Paths 
        {
            dir_patterns,
            require_dir,
            options,
            todo,
            scope: Some(scope),
        })
    }
    /**
    A glob iteration error. */
    #[derive(Debug)]
    pub struct GlobError 
    {
        path: PathBuf,
        error: io::Error,
    }

    impl GlobError 
    {
        /// The Path that the error corresponds to.
        pub fn path(&self) -> &Path { &self.path }

        /// The error in question.
        pub fn error(&self) -> &io::Error { &self.error }

        /// Consumes self, returning the _raw_ underlying `io::Error`
        pub fn into_error(self) -> io::Error { self.error }
    }

    impl Error for GlobError 
    {
        fn description(&self) -> &str { self.error.description() }
        
        fn cause(&self) -> Option<&dyn Error> { Some(&self.error) }
    }

    impl fmt::Display for GlobError 
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
        {
            write!
            (
                f,
                "attempting to read `{}` resulted in an error: {}",
                self.path.display(),
                self.error
            )
        }
    }

    #[derive(Debug)]
    struct PathWrapper 
    {
        path: PathBuf,
        is_directory: bool,
    }

    impl PathWrapper
    {
        fn from_dir_entry(path: PathBuf, e: DirEntry) -> Self 
        {
            let is_directory = e
                .file_type()
                .ok()
                .and_then
                (
                    |file_type| 
                    {
                        // We need to use fs::metadata to resolve the actual path if it's a symlink.
                        if file_type.is_symlink(){ None } 
                        else { Some(file_type.is_dir()) }
                    }
                )
                .or_else(|| fs::metadata(&path).map(|m| m.is_dir()).ok())
                .unwrap_or(false);
            Self { path, is_directory }
        }

        fn from_path(path: PathBuf) -> Self 
        {
            let is_directory = fs::metadata(&path).map(|m| m.is_dir()).unwrap_or(false);
            Self { path, is_directory }
        }

        fn into_path(self) -> PathBuf 
        {
            self.path
        }
    }

    impl Deref for PathWrapper 
    {
        type Target = Path;

        fn deref(&self) -> &Self::Target { self.path.deref() }
    }

    impl AsRef<Path> for PathWrapper 
    {
        fn as_ref(&self) -> &Path { self.path.as_ref() }
    }

    impl Iterator for Paths 
    {
        type Item = GlobResult;

        fn next(&mut self) -> Option<GlobResult> 
        {
            if let Some(scope) = self.scope.take() 
            {
                if !self.dir_patterns.is_empty() 
                {
                    // Shouldn't happen, but we're using -1 as a special index.
                    assert!(self.dir_patterns.len() < std::usize::MAX);

                    fill_todo(&mut self.todo, &self.dir_patterns, 0, &scope, self.options);
                }
            }

            loop 
            {
                if self.dir_patterns.is_empty() || self.todo.is_empty() { return None; }

                let (path, mut idx) = match self.todo.pop().unwrap() 
                {
                    Ok(pair) => pair,
                    Err(e) => return Some(Err(e)),
                };
                
                if idx == std::usize::MAX 
                {
                    if self.require_dir && !path.is_directory { continue; }
                    return Some(Ok(path.into_path()));
                }

                if self.dir_patterns[idx].is_recursive 
                {
                    let mut next = idx;

                    // collapse consecutive recursive patterns
                    while (next + 1) < self.dir_patterns.len() && self.dir_patterns[next + 1].is_recursive
                    {
                        next += 1;
                    }

                    if path.is_directory 
                    {
                        fill_todo
                        (
                            &mut self.todo,
                            &self.dir_patterns,
                            next,
                            &path,
                            self.options,
                        );

                        if next == self.dir_patterns.len() - 1 
                        {
                            return Some(Ok(path.into_path()));
                        } 
                        else 
                        {
                            idx = next + 1;
                        }
                    } 
                    
                    else if next == self.dir_patterns.len() - 1 
                    {
                        continue;
                    } 
                    else 
                    {
                        idx = next + 1;
                    }
                }

                // not recursive, so match normally
                if self.dir_patterns[idx].matches_with
                (
                    {
                        match path.file_name().and_then(|s| s.to_str()) 
                        {
                            None => continue,
                            Some(x) => x,
                        }
                    },
                    self.options,
                )
                {
                    if idx == self.dir_patterns.len() - 1 
                    {
                        if !self.require_dir || path.is_directory 
                        { return Some(Ok(path.into_path())); }
                    } 
                    else
                    {
                        fill_todo
                        (
                            &mut self.todo,
                            &self.dir_patterns,
                            idx + 1,
                            &path,
                            self.options,
                        );
                    }
                }
            }
        }
    }

    /// A pattern parsing error.
    #[derive(Debug)]
    pub struct PatternError 
    {
        /// The approximate character index of where the error occurred.
        pub pos: usize,

        /// A message describing the error.
        pub msg: &'static str,
    }

    impl Error for PatternError 
    {
        fn description(&self) -> &str 
        {
            self.msg
        }
    }

    impl fmt::Display for PatternError 
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
        {
            write!
            (
                f,
                "Pattern syntax error near position {}: {}",
                self.pos, self.msg
            )
        }
    }
    /**
    A compiled Unix shell style pattern. */
    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Debug)]
    pub struct Pattern 
    {
        original: String,
        tokens: Vec<PatternToken>,
        is_recursive: bool,
    }

    /// Show the original glob pattern.
    impl fmt::Display for Pattern 
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
        {
            self.original.fmt(f)
        }
    }

    impl FromStr for Pattern 
    {
        type Err = PatternError;

        fn from_str(s: &str) -> Result<Self, PatternError> 
        {
            Self::new(s)
        }
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    enum PatternToken 
    {
        Char(char),
        AnyChar,
        AnySequence,
        AnyRecursiveSequence,
        AnyWithin(Vec<CharSpecifier>),
        AnyExcept(Vec<CharSpecifier>),
    }

    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    enum CharSpecifier 
    {
        SingleChar(char),
        CharRange(char, char),
    }

    #[derive(Copy, Clone, PartialEq)]
    enum MatchResult 
    {
        Match,
        SubPatternDoesntMatch,
        EntirePatternDoesntMatch,
    }
    
    impl Pattern 
    {
        /**
        This function compiles Unix shell style patterns. */
        pub fn new(pattern: &str) -> Result<Self, PatternError> 
        {
            let chars = pattern.chars().collect::<Vec<_>>();
            let mut tokens = Vec::new();
            let mut is_recursive = false;
            let mut i = 0;
            while i < chars.len() 
            {
                match chars[i] 
                {
                    '?' => 
                    {
                        tokens.push(AnyChar);
                        i += 1;
                    }
                    '*' => 
                    {
                        let old = i;
                        while i < chars.len() && chars[i] == '*' 
                        { i += 1; }

                        let count = i - old;
                        match count.cmp(&2) 
                        {
                            Ordering::Greater => 
                            {
                                return Err
                                (
                                    PatternError 
                                    {
                                        pos: old + 2,
                                        msg: ERROR_WILDCARDS,
                                    }
                                )
                            }

                            Ordering::Equal => 
                            {
                                // ** can only be an entire path component
                                let is_valid = if i == 2 || path::is_separator(chars[i - count - 1])
                                {
                                    // it ends in a '/'
                                    if i < chars.len() && path::is_separator(chars[i])
                                    {
                                        i += 1;
                                        true
                                    } 
                                    else if i == chars.len(){ true } 
                                    else 
                                    {
                                        return Err
                                        (
                                            PatternError 
                                            {
                                                pos: i,
                                                msg: ERROR_RECURSIVE_WILDCARDS,
                                            }
                                        );
                                    }
                                }
                                else 
                                {
                                    return Err
                                    (
                                        PatternError 
                                        {
                                        pos: old - 1,
                                        msg: ERROR_RECURSIVE_WILDCARDS,
                                        }
                                    );
                                };

                                if is_valid
                                {
                                    let tokens_len = tokens.len();

                                    if !(tokens_len > 1 && tokens[tokens_len - 1] == AnyRecursiveSequence)
                                    {
                                        is_recursive = true;
                                        tokens.push(AnyRecursiveSequence);
                                    }
                                }
                            }

                            Ordering::Less => tokens.push(AnySequence),
                        }
                    }

                    '[' => 
                    {
                        if i + 4 <= chars.len() && chars[i + 1] == '!' 
                        {
                            match chars[i + 3..].iter().position(|x| *x == ']')
                            {
                                None => (),
                                Some(j) =>
                                {
                                    let chars = &chars[i + 2..i + 3 + j];
                                    let cs = parse_char_specifiers(chars);
                                    tokens.push(AnyExcept(cs));
                                    i += j + 4;
                                    continue;
                                }
                            }
                        }
                        else if i + 3 <= chars.len() && chars[i + 1] != '!'
                        {
                            match chars[i + 2..].iter().position(|x| *x == ']')
                            {
                                None => (),
                                Some(j) =>
                                {
                                    let cs = parse_char_specifiers(&chars[i + 1..i + 2 + j]);
                                    tokens.push(AnyWithin(cs));
                                    i += j + 3;
                                    continue;
                                }
                            }
                        }

                        // if we get here then this is not a valid range pattern
                        return Err(PatternError {
                            pos: i,
                            msg: ERROR_INVALID_RANGE,
                        });
                    }
                    c => 
                    {
                        tokens.push(Char(c));
                        i += 1;
                    }
                }
            }

            Ok
            (
                Self 
                {
                    tokens,
                    original: pattern.to_string(),
                    is_recursive,
                }
            )
        }

        /// Escape metacharacters within the given string by surrounding them in brackets.
        pub fn escape(s: &str) -> String
        {
            let mut escaped = String::new();
            for c in s.chars()
            {
                match c 
                {
                    '?' | '*' | '[' | ']' =>
                    {
                        escaped.push('[');
                        escaped.push(c);
                        escaped.push(']');
                    }
                    
                    c => 
                    {
                        escaped.push(c);
                    }
                }
            }

            escaped
        }

        /// Return if the given `str` matches this `Pattern` using the default match options.
        pub fn matches(&self, str: &str) -> bool
        {
            self.matches_with(str, MatchOptions::new())
        }

        /// Return if the given `Path`, when converted to a `str`, matches this
        /// `Pattern` using the default match options.
        pub fn matches_path(&self, path: &Path) -> bool 
        {
            path.to_str().map_or(false, |s| self.matches(s))
        }

        /// Return if the given `str` matches this `Pattern` using the specified match options.
        pub fn matches_with(&self, str: &str, options: MatchOptions) -> bool
        {
            self.matches_from(true, str.chars(), 0, options) == Match
        }

        /// Return if the given `Path`, when converted to a `str`, matches this 
        /// `Pattern` using the specified match options.
        pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool 
        {
            path.to_str().map_or(false, |s| self.matches_with(s, options))
        }

        /// Access the original glob pattern.
        pub fn as_str(&self) -> &str
        { &self.original }

        fn matches_from
        (
            &self,
            mut follows_separator: bool,
            mut file: std::str::Chars,
            i: usize,
            options: MatchOptions,
        ) -> MatchResult 
        {
            for (ti, token) in self.tokens[i..].iter().enumerate() 
            {
                match *token
                {
                    AnySequence | AnyRecursiveSequence =>
                    {
                        debug_assert!
                        (
                            match *token
                            {
                                AnyRecursiveSequence => follows_separator,
                                _ => true,
                            }
                        );
                        
                        match self.matches_from(follows_separator, file.clone(), i + ti + 1, options)
                        {
                            SubPatternDoesntMatch => (),
                            m => return m,
                        };

                        while let Some(c) = file.next()
                        {
                            if follows_separator && options.require_literal_leading_dot && c == '.'
                            {
                                return SubPatternDoesntMatch;
                            }
                            
                            follows_separator = path::is_separator(c);
                            match *token
                            {
                                AnyRecursiveSequence if !follows_separator => continue,
                                AnySequence
                                    if options.require_literal_separator && follows_separator =>
                                {
                                    return SubPatternDoesntMatch
                                }
                                _ => (),
                            }

                            match self.matches_from
                            (
                                follows_separator,
                                file.clone(),
                                i + ti + 1,
                                options,
                            )
                            {
                                SubPatternDoesntMatch => (), // keep trying
                                m => return m,
                            }
                        }
                    }

                    _ =>
                    {
                        let c = match file.next()
                        {
                            Some(c) => c,
                            None => return EntirePatternDoesntMatch,
                        };

                        let is_sep = path::is_separator(c);

                        if !match *token
                        {
                              AnyChar 
                            | AnyWithin(..) 
                            | AnyExcept(..) if (options.require_literal_separator && is_sep) || (follows_separator && options.require_literal_leading_dot && c == '.') =>
                            {
                                false
                            }
                            AnyChar => true,
                            AnyWithin(ref specifiers) => in_char_specifiers(specifiers, c, options),
                            AnyExcept(ref specifiers) => !in_char_specifiers(specifiers, c, options),
                            Char(c2) => chars_eq(c, c2, options.case_sensitive),
                            AnySequence | AnyRecursiveSequence => unreachable!(),
                        }
                        { return SubPatternDoesntMatch; }
                        follows_separator = is_sep;
                    }
                }
            }
            
            if file.next().is_none() { Match } 
            else { SubPatternDoesntMatch }
        }
    }
    /**
    Fills `todo` with paths under `path` to be matched by `patterns[idx]`, 
    special-casing patterns to match `.` and `..`, and avoiding `readdir()` 
    calls when there are no metacharacters in the pattern. */
    fn fill_todo
    (
        todo: &mut Vec<Result<(PathWrapper, usize), GlobError>>,
        patterns: &[Pattern],
        idx: usize,
        path: &PathWrapper,
        options: MatchOptions,
    )
    {
        fn pattern_as_str(pattern: &Pattern) -> Option<String>
        {
            let mut s = String::new();
            for token in &pattern.tokens
            {
                match *token
                {
                    Char(c) => s.push(c),
                    _ => return None,
                }
            }

            Some(s)
        }

        let add = |todo: &mut Vec<_>, next_path: PathWrapper| 
        {
            if idx + 1 == patterns.len()
            { todo.push(Ok((next_path, ::usize::MAX ) ) ); }
            else 
            { fill_todo(todo, patterns, idx + 1, &next_path, options); }
        };

        let pattern = &patterns[idx];
        let is_dir = path.is_directory;
        let curdir = path.as_ref() == Path::new(".");
        match pattern_as_str(pattern)
        {
            Some(s) => 
            {
                let special = "." == s || ".." == s;
                let next_path = if curdir 
                { PathBuf::from(s) }
                else { path.join(&s) };

                let next_path = PathWrapper::from_path(next_path);
                if (special && is_dir) 
                || (!special && (fs::metadata(&next_path).is_ok()|| fs::symlink_metadata(&next_path).is_ok()))
                {
                    add(todo, next_path);
                }
            }

            None if is_dir => 
            {
                let dirs = fs::read_dir(path).and_then(|d| {
                    d.map(|e| {
                        e.map(|e| {
                            let path = if curdir {
                                PathBuf::from(e.path().file_name().unwrap())
                            } else {
                                e.path()
                            };
                            PathWrapper::from_dir_entry(path, e)
                        })
                    })
                    .collect::<Result<Vec<_>, _>>()
                });
                match dirs {
                    Ok(mut children) => {
                        if options.require_literal_leading_dot {
                            children
                                .retain(|x| !x.file_name().unwrap().to_str().unwrap().starts_with('.'));
                        }
                        children.sort_by(|p1, p2| p2.file_name().cmp(&p1.file_name()));
                        todo.extend(children.into_iter().map(|x| Ok((x, idx))));

                        // Matching the special directory entries . and .. that
                        // refer to the current and parent directory respectively
                        // requires that the pattern has a leading dot, even if the
                        // `MatchOptions` field `require_literal_leading_dot` is not
                        // set.
                        if !pattern.tokens.is_empty() && pattern.tokens[0] == Char('.') {
                            for &special in &[".", ".."] {
                                if pattern.matches_with(special, options) {
                                    add(todo, PathWrapper::from_path(path.join(special)));
                                }
                            }
                        }
                    }
                    Err(e) => {
                        todo.push(Err(GlobError {
                            path: path.to_path_buf(),
                            error: e,
                        }));
                    }
                }
            }
            None => 
            {
                // not a directory, nothing more to find
            }
        }
    }

    fn parse_char_specifiers(s: &[char]) -> Vec<CharSpecifier> 
    {
        let mut cs = Vec::new();
        let mut i = 0;
        while i < s.len() 
        {
            if i + 3 <= s.len() && s[i + 1] == '-' 
            {
                cs.push(CharRange(s[i], s[i + 2]));
                i += 3;
            } 

            else 
            {
                cs.push(SingleChar(s[i]));
                i += 1;
            }
        }
        cs
    }

    fn in_char_specifiers(specifiers: &[CharSpecifier], c: char, options: MatchOptions) -> bool 
    {
        for &specifier in specifiers.iter()
        {
            match specifier
            {
                SingleChar(sc) => 
                {
                    if chars_eq(c, sc, options.case_sensitive) {
                        return true;
                    }
                }

                CharRange(start, end) => 
                {
                    if !options.case_sensitive && c.is_ascii() && start.is_ascii() && end.is_ascii()
                    {
                        let start = start.to_ascii_lowercase();
                        let end = end.to_ascii_lowercase();

                        let start_up = start.to_uppercase().next().unwrap();
                        let end_up = end.to_uppercase().next().unwrap();
                        
                        if start != start_up && end != end_up 
                        {
                            let c = c.to_ascii_lowercase();
                            if c >= start && c <= end 
                            { return true; }
                        }
                    }

                    if c >= start && c <= end 
                    { return true; }
                }
            }
        }

        false
    }

    /// A helper function to determine if two chars are (possibly case-insensitively) equal.
    fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool 
    {
        if !case_sensitive && a.is_ascii() && b.is_ascii()  { a.eq_ignore_ascii_case(&b) } 
        else { a == b }
    }

    /// Configuration options to modify the behaviour of `Pattern::matches_with(..)`.
    #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    pub struct MatchOptions 
    {
        /*
        Whether or not patterns should be matched in a case-sensitive manner. */
        pub case_sensitive: bool,
        /**
        Whether or not path-component separator characters. */
        pub require_literal_separator: bool,
        /**
        Whether or not paths that contain components that start with a `.` will require that 
        `.` appears literally in the pattern; `*`, `?`, `**`, or `[...]` will not match. */
        pub require_literal_leading_dot: bool,
    }

    impl MatchOptions 
    {
        /**
        Constructs a new `MatchOptions` with default field values. */
        pub fn new() -> Self 
        {
            Self 
            {
                case_sensitive: true,
                require_literal_separator: false,
                require_literal_leading_dot: false,
            }
        }
    }

}
/*
Extends Option with additional methods. */
pub mod option
{
    pub use std::option::{ * };
    
    pub mod implementation
    {
        use super::OptionExt;

        impl<T> OptionExt<T> for Option<T> 
        {
            fn contains<U>(&self, x: &U) -> bool where U: PartialEq<T> 
            {
                match *self 
                {
                    Some(ref y) => x == y,
                    None => false,
                }
            }

            #[inline]
            fn map_or2<U, F: FnOnce(T) -> U>(self, f: F, default: U) -> U 
            {
                self.map_or(default, f)
            }

            #[inline]
            fn map_or_else2<U, F: FnOnce(T) -> U, D: FnOnce() -> U>(self, f: F, default: D) -> U 
            {
                self.map_or_else(default, f)
            }
        } 
    }

    /// Extension trait providing additional methods for `Option`.
    pub trait OptionExt<T> 
    {
        /// Returns `true` if the option is a [`Some`] value containing the given value.
        #[must_use]
        fn contains<U>(&self, x: &U) -> bool where U: PartialEq<T>;

        /// Returns the result from applying the function `f` to the contained value 
        /// if the option is [`Some`], or returns provided `default` value 
        /// if the option is [`None`].
        #[must_use]
        fn map_or2<U, F: FnOnce(T) -> U>(self, f: F, default: U) -> U;

        /// Returns the result from applying the function `f` to the contained value 
        /// if the option is [`Some`], or returns the result from evaluating the 
        /// provided function `default` if the option is [`None`].
        #[must_use]
        fn map_or_else2<U, F: FnOnce(T) -> U, D: FnOnce() -> U>(self, f: F, default: D) -> U;
    }
}
/*
Provides platform-specific standard locations of directories for config, cache and other data.*/
pub mod dirs
{
    use ::
    {
        path::{PathBuf},
    };
    /*
    System-level helper functions*/
    pub mod sys
    {
        use ::
        {
            collections::{ HashMap },
            ffi::{CStr, OsString},
            os::unix::ffi::{ OsStringExt },
            path::{ Path, PathBuf },
            env, mem, option, ptr
        };

        pub fn is_absolute_path(path: OsString) -> Option<PathBuf> 
        {
            let path = PathBuf::from(path);
            if path.is_absolute() {
                Some(path)
            } else {
                None
            }
        }
        
        pub mod user
        {
            use ::
            {
                collections::{ HashMap },
                ffi::{ OsString },
                io::{self, Read},
                os::unix::ffi::{ OsStringExt },
                path::{ Path, PathBuf },
                fs, str,
            };
            
            use super::
            {
                option::{ OptionExt },
            };

            /// Returns all XDG user directories obtained from $(XDG_CONFIG_HOME)/user-dirs.dirs.
            pub fn all(home_dir_path: &Path, user_dir_file_path: &Path) -> HashMap<String, PathBuf> 
            {
                let bytes = read_all(user_dir_file_path).unwrap_or(Vec::new());
                parse_user_dirs(home_dir_path, None, &bytes)
            }

            /// Returns a single XDG user directory obtained from $(XDG_CONFIG_HOME)/user-dirs.dirs.
            pub fn single(home_dir_path: &Path, user_dir_file_path: &Path, user_dir_name: &str) -> HashMap<String, PathBuf> 
            {
                let bytes = read_all(user_dir_file_path).unwrap_or(Vec::new());
                parse_user_dirs(home_dir_path, Some(user_dir_name), &bytes)
            }

            fn parse_user_dirs(home_dir: &Path, user_dir: Option<&str>, bytes: &[u8]) -> HashMap<String, PathBuf> 
            {
                let mut user_dirs = HashMap::new();

                for line in bytes.split(|b| *b == b'\n') 
                {
                    let mut single_dir_found = false;
                    let (key, value) = match split_once(line, b'=') 
                    {
                        Some(kv) => kv,
                        None => continue,
                    };

                    let key = trim_blank(key);
                    let key = if key.starts_with(b"XDG_") && key.ends_with(b"_DIR")
                    {
                        match str::from_utf8(&key[4..key.len()-4])
                        {
                            Ok(key) =>
                            { 
                                if user_dir.contains(&key)
                                {
                                    single_dir_found = true;
                                    key
                                }
                                else if user_dir.is_none() 
                                { key }
                                else 
                                { continue }
                            }
                            Err(_)  => continue,
                        }
                    }
                    else { continue };

                    // xdg-user-dirs-update uses double quotes and we don't support anything else.
                    let value = trim_blank(value);
                    let mut value = if value.starts_with(b"\"") && value.ends_with(b"\"") 
                    { &value[1..value.len()-1] } 
                    else { continue };

                    // Path should be either relative to the home directory or absolute.
                    let is_relative = if value == b"$HOME/" 
                    { continue }

                    else if value.starts_with(b"$HOME/") 
                    {
                        value = &value[b"$HOME/".len()..];
                        true
                    } 

                    else if value.starts_with(b"/")
                    {
                        false
                    } 

                    else 
                    { continue };

                    let value = OsString::from_vec(shell_unescape(value));

                    let path = if is_relative 
                    {
                        let mut path = PathBuf::from(&home_dir);
                        path.push(value);
                        path
                    }
                    
                    else 
                    { PathBuf::from(value) };

                    user_dirs.insert(key.to_owned(), path);

                    if single_dir_found 
                    { break; }
                }

                user_dirs
            }

            /// Reads the entire contents of a file into a byte vector.
            fn read_all(path: &Path) -> io::Result<Vec<u8>>
            {
                let mut file = fs::File::open(path)?;
                let mut bytes = Vec::with_capacity(1024);
                file.read_to_end(&mut bytes)?;
                Ok(bytes)
            }

            /// Returns bytes before and after first occurrence of separator.
            fn split_once(bytes: &[u8], separator: u8) -> Option<(&[u8], &[u8])>
            {
                bytes.iter().position(|b| *b == separator).map(|i|
                {
                    (&bytes[..i], &bytes[i+1..])
                })
            }

            /// Returns a slice with leading and trailing <blank> characters removed.
            fn trim_blank(bytes: &[u8]) -> &[u8] 
            {
                // Trim leading <blank> characters.
                let i = bytes.iter().cloned().take_while(|b| *b == b' ' || *b == b'\t').count();
                let bytes = &bytes[i..];

                // Trim trailing <blank> characters.
                let i = bytes.iter().cloned().rev().take_while(|b| *b == b' ' || *b == b'\t').count();
                &bytes[..bytes.len()-i]
            }

            /// Unescape bytes escaped with POSIX shell double-quotes rules.
            fn shell_unescape(escaped: &[u8]) -> Vec<u8>
            {
                let mut unescaped: Vec<u8> = Vec::with_capacity(escaped.len());
                let mut i = escaped.iter().cloned();

                while let Some(b) = i.next() 
                {
                    if b == b'\\' 
                    {
                        if let Some(b) = i.next() 
                        {
                            unescaped.push(b);
                        }
                    } 
                    else { unescaped.push(b); }
                }

                unescaped
            }
        }
        
        pub fn home_dir() -> Option<PathBuf> 
        {
            return env::var_os("HOME")
            .and_then(|h| if h.is_empty() { None } else { Some(h) })
            .or_else(|| unsafe { fallback() })
            .map(PathBuf::from);
            
            unsafe fn fallback() -> Option<OsString> 
            {
                let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX)
                {
                    n if n < 0 => 512 as usize,
                    n => n as usize,
                };

                let mut buf = Vec::with_capacity(amt);
                let mut passwd: libc::passwd = mem::zeroed();
                let mut result = ptr::null_mut();
                match libc::getpwuid_r
                (
                    libc::getuid(),
                    &mut passwd,
                    buf.as_mut_ptr(),
                    buf.capacity(),
                    &mut result,
                )
                {
                    0 if !result.is_null() => 
                    {
                        let ptr = passwd.pw_dir as *const _;
                        let bytes = CStr::from_ptr(ptr).to_bytes();
                        if bytes.is_empty()
                        {
                            None
                        }
                        
                        else 
                        {
                            Some( OsStringExt::from_vec( bytes.to_vec() ) )
                        }
                    }
                    _ => None,
                }
            }
        }
        
        pub fn user_dir_file(home_dir: &Path) -> PathBuf 
        {
            use crate::dirs::sys::is_absolute_path;
            env::var_os("XDG_CONFIG_HOME").and_then(is_absolute_path).unwrap_or_else(|| home_dir.join(".config")).join("user-dirs.dirs")
        }

        // this could be optimized further to not create a map and instead retrieve the requested path only
        pub fn user_dir(user_dir_name: &str) -> Option<PathBuf> 
        {
            if let Some(home_dir) = home_dir() 
            {
                user::single(&home_dir, &user_dir_file(&home_dir), user_dir_name).remove(user_dir_name)
            } 
            else { None }
        }

        pub fn user_dirs(home_dir_path: &Path) -> HashMap<String, PathBuf>
        {
            user::all(home_dir_path, &user_dir_file(home_dir_path))
        }

        pub fn cache_dir()        -> Option<PathBuf> { env::var_os("XDG_CACHE_HOME") .and_then(is_absolute_path).or_else(|| home_dir().map(|h| h.join(".cache"))) }
        pub fn config_dir()       -> Option<PathBuf> { env::var_os("XDG_CONFIG_HOME").and_then(is_absolute_path).or_else(|| home_dir().map(|h| h.join(".config"))) }
        pub fn config_local_dir() -> Option<PathBuf> { config_dir() }
        pub fn data_dir()         -> Option<PathBuf> { env::var_os("XDG_DATA_HOME")  .and_then(is_absolute_path).or_else(|| home_dir().map(|h| h.join(".local/share"))) }
        pub fn data_local_dir()   -> Option<PathBuf> { data_dir() }
        pub fn preference_dir()   -> Option<PathBuf> { config_dir() }
        pub fn runtime_dir()      -> Option<PathBuf> { env::var_os("XDG_RUNTIME_DIR").and_then(is_absolute_path) }
        pub fn state_dir()        -> Option<PathBuf> { env::var_os("XDG_STATE_HOME") .and_then(is_absolute_path).or_else(|| home_dir().map(|h| h.join(".local/state"))) }
        pub fn executable_dir()   -> Option<PathBuf> { env::var_os("XDG_BIN_HOME")   .and_then(is_absolute_path).or_else(|| home_dir().map(|h| h.join(".local/bin"))) }
        
        pub fn audio_dir()        -> Option<PathBuf> { user_dir("MUSIC") }
        pub fn desktop_dir()      -> Option<PathBuf> { user_dir("DESKTOP") }
        pub fn document_dir()     -> Option<PathBuf> { user_dir("DOCUMENTS") }
        pub fn download_dir()     -> Option<PathBuf> { user_dir("DOWNLOAD") }
        pub fn font_dir()         -> Option<PathBuf> { data_dir().map(|d| d.join("fonts")) }
        pub fn picture_dir()      -> Option<PathBuf> { user_dir("PICTURES") }
        pub fn public_dir()       -> Option<PathBuf> { user_dir("PUBLICSHARE") }
        pub fn template_dir()     -> Option<PathBuf> { user_dir("TEMPLATES") }
        pub fn video_dir()        -> Option<PathBuf> { user_dir("VIDEOS") }
 
    }
    /// Returns the path to the user's home directory.
    pub fn home_dir() -> Option<PathBuf> 
    {
        sys::home_dir()
    }
    /// Returns the path to the user's cache directory.
    pub fn cache_dir() -> Option<PathBuf> 
    {
        sys::cache_dir()
    }
    /// Returns the path to the user's config directory.
    pub fn config_dir() -> Option<PathBuf> 
    {
        sys::config_dir()
    }
    /// Returns the path to the user's local config directory.
    pub fn config_local_dir() -> Option<PathBuf> 
    {
        sys::config_local_dir()
    }
    /// Returns the path to the user's data directory.
    pub fn data_dir() -> Option<PathBuf> 
    {
        sys::data_dir()
    }
    /// Returns the path to the user's local data directory.
    pub fn data_local_dir() -> Option<PathBuf> 
    {
        sys::data_local_dir()
    }
    /// Returns the path to the user's executable directory.
    pub fn executable_dir() -> Option<PathBuf> 
    {
        sys::executable_dir()
    }
    /// Returns the path to the user's preference directory.
    pub fn preference_dir() -> Option<PathBuf> 
    {
        sys::preference_dir()
    }
    /// Returns the path to the user's runtime directory.
    pub fn runtime_dir() -> Option<PathBuf> 
    {
        sys::runtime_dir()
    }
    /// Returns the path to the user's state directory.
    pub fn state_dir() -> Option<PathBuf> 
    {
        sys::state_dir()
    }
    /// Returns the path to the user's audio directory.
    pub fn audio_dir() -> Option<PathBuf> 
    {
        sys::audio_dir()
    }
    /// Returns the path to the user's desktop directory.
    pub fn desktop_dir() -> Option<PathBuf> 
    {
        sys::desktop_dir()
    }
    /// Returns the path to the user's document directory.
    pub fn document_dir() -> Option<PathBuf> 
    {
        sys::document_dir()
    }
    /// Returns the path to the user's download directory.
    pub fn download_dir() -> Option<PathBuf> 
    {
        sys::download_dir()
    }
    /// Returns the path to the user's font directory.
    pub fn font_dir() -> Option<PathBuf> 
    {
        sys::font_dir()
    }
    /// Returns the path to the user's picture directory.
    pub fn picture_dir() -> Option<PathBuf> 
    {
        sys::picture_dir()
    }
    /// Returns the path to the user's public directory.
    pub fn public_dir() -> Option<PathBuf> 
    {
        sys::public_dir()
    }
    /// Returns the path to the user's template directory.
    pub fn template_dir() -> Option<PathBuf> 
    {
        sys::template_dir()
    }
    /// Returns the path to the user's video directory.
    pub fn video_dir() -> Option<PathBuf> 
    {
        sys::video_dir()
    }
}
/*
Fast float parsing conversion routines. */
pub mod lexical
{
    //! Fast, minimal float-parsing algorithm.
    pub mod bellerophon
    {
        //! An implementation of Clinger's Bellerophon algorithm.
        use super::extended_float::ExtendedFloat;
        use super::mask::{lower_n_halfway, lower_n_mask};
        use super::num::Float;
        use super::number::Number;
        use super::rounding::{round, round_nearest_tie_even};
        use super::table::BASE10_POWERS;
        
        pub fn bellerophon<F: Float>(num: &Number) -> ExtendedFloat 
        {
            let fp_zero = ExtendedFloat 
            {
                mant: 0,
                exp: 0,
            };
            
            let fp_inf = ExtendedFloat 
            {
                mant: 0,
                exp: F::INFINITE_POWER,
            };

            // Early short-circuit, in case of literal 0 or infinity.
            if num.mantissa == 0 || num.exponent <= -0x1000 {
                return fp_zero;
            } else if num.exponent >= 0x1000 {
                return fp_inf;
            }

            // Calculate our indexes for our extended-precision multiplication.
            let exponent = num.exponent as i32 + BASE10_POWERS.bias;
            let small_index = exponent % BASE10_POWERS.step;
            let large_index = exponent / BASE10_POWERS.step;

            if exponent < 0 {
                // Guaranteed underflow (assign 0).
                return fp_zero;
            }
            if large_index as usize >= BASE10_POWERS.large.len() {
                // Overflow (assign infinity)
                return fp_inf;
            }

            // Within the valid exponent range, multiply by the large and small
            // exponents and return the resulting value.

            // Track errors to as a factor of unit in last-precision.
            let mut errors: u32 = 0;
            if num.many_digits {
                errors += error_halfscale();
            }

            // Multiply by the small power.
            // Check if we can directly multiply by an integer, if not,
            // use extended-precision multiplication.
            let mut fp = ExtendedFloat {
                mant: num.mantissa,
                exp: 0,
            };
            match fp.mant.overflowing_mul(BASE10_POWERS.get_small_int(small_index as usize)) {
                // Overflow, multiplication unsuccessful, go slow path.
                (_, true) => {
                    normalize(&mut fp);
                    fp = mul(&fp, &BASE10_POWERS.get_small(small_index as usize));
                    errors += error_halfscale();
                },
                // No overflow, multiplication successful.
                (mant, false) => {
                    fp.mant = mant;
                    normalize(&mut fp);
                },
            }

            // Multiply by the large power.
            fp = mul(&fp, &BASE10_POWERS.get_large(large_index as usize));
            if errors > 0 {
                errors += 1;
            }
            errors += error_halfscale();

            // Normalize the floating point (and the errors).
            let shift = normalize(&mut fp);
            errors <<= shift;
            fp.exp += F::EXPONENT_BIAS;

            // Check for literal overflow, even with halfway cases.
            if -fp.exp + 1 > 65 {
                return fp_zero;
            }

            // Too many errors accumulated, return an error.
            if !error_is_accurate::<F>(errors, &fp) {
                // Bias the exponent so we know it's invalid.
                fp.exp += F::INVALID_FP;
                return fp;
            }

            // Check if we have a literal 0 or overflow here.
            // If we have an exponent of -63, we can still have a valid shift,
            // giving a case where we have too many errors and need to round-up.
            if -fp.exp + 1 == 65 {
                // Have more than 64 bits below the minimum exponent, must be 0.
                return fp_zero;
            }

            round::<F, _>(&mut fp, |f, s| {
                round_nearest_tie_even(f, s, |is_odd, is_halfway, is_above| {
                    is_above || (is_odd && is_halfway)
                });
            });
            fp
        }
        
        #[inline(always)]
        const fn error_scale() -> u32 {
            8
        }

        /// Get the half error scale.
        #[inline(always)]
        const fn error_halfscale() -> u32 {
            error_scale() / 2
        }

        /// Determine if the number of errors is tolerable for float precision.
        fn error_is_accurate<F: Float>(errors: u32, fp: &ExtendedFloat) -> bool {
            // Check we can't have a literal 0 denormal float.
            debug_assert!(fp.exp >= -64);

            // Determine if extended-precision float is a good approximation.
            // This is always a valid u32, since `fp.exp >= -64`
            // will always be positive and the significand size is {23, 52}.
            let mantissa_shift = 64 - F::MANTISSA_SIZE - 1;

            // The unbiased exponent checks is `unbiased_exp <= F::MANTISSA_SIZE
            // - F::EXPONENT_BIAS -64 + 1`, or `biased_exp <= F::MANTISSA_SIZE - 63`,
            // or `biased_exp <= mantissa_shift`.
            let extrabits = match fp.exp <= -mantissa_shift {
                // Denormal, since shifting to the hidden bit still has a negative exponent.
                // The unbiased check calculation for bits is `1 - F::EXPONENT_BIAS - unbiased_exp`,
                // or `1 - biased_exp`.
                true => 1 - fp.exp,
                false => 64 - F::MANTISSA_SIZE - 1,
            };

            // Our logic is as follows: we want to determine if the actual
            // mantissa and the errors during calculation differ significantly
            // from the rounding point.
            let maskbits = extrabits as u64;
            let errors = errors as u64;

            // Round-to-nearest, need to use the halfway point.
            if extrabits > 64 {
                // Underflow, we have a shift larger than the mantissa.
                // Representation is valid **only** if the value is close enough
                // overflow to the next bit within errors. If it overflows,
                // the representation is **not** valid.
                !fp.mant.overflowing_add(errors).1
            } else {
                let mask = lower_n_mask(maskbits);
                let extra = fp.mant & mask;

                // Round-to-nearest, need to check if we're close to halfway.
                // IE, b10100 | 100000, where `|` signifies the truncation point.
                let halfway = lower_n_halfway(maskbits);
                let cmp1 = halfway.wrapping_sub(errors) < extra;
                let cmp2 = extra < halfway.wrapping_add(errors);

                // If both comparisons are true, we have significant rounding error,
                // and the value cannot be exactly represented. Otherwise, the
                // representation is valid.
                !(cmp1 && cmp2)
            }
        }
        
        /// Get the number of bytes shifted.
        pub fn normalize(fp: &mut ExtendedFloat) -> i32 
        {
            if fp.mant != 0 {
                let shift = fp.mant.leading_zeros() as i32;
                fp.mant <<= shift;
                fp.exp -= shift;
                shift
            } else {
                0
            }
        }

        /// Multiply two normalized extended-precision floats, as if by `a*b`.
        pub fn mul(x: &ExtendedFloat, y: &ExtendedFloat) -> ExtendedFloat {
            // Logic check, values must be decently normalized prior to multiplication.
            debug_assert!(x.mant >> 32 != 0);
            debug_assert!(y.mant >> 32 != 0);

            // Extract high-and-low masks.
            // Mask is u32::MAX for older Rustc versions.
            const LOMASK: u64 = 0xffff_ffff;
            let x1 = x.mant >> 32;
            let x0 = x.mant & LOMASK;
            let y1 = y.mant >> 32;
            let y0 = y.mant & LOMASK;

            // Get our products
            let x1_y0 = x1 * y0;
            let x0_y1 = x0 * y1;
            let x0_y0 = x0 * y0;
            let x1_y1 = x1 * y1;

            let mut tmp = (x1_y0 & LOMASK) + (x0_y1 & LOMASK) + (x0_y0 >> 32);
            // round up
            tmp += 1 << (32 - 1);

            ExtendedFloat {
                mant: x1_y1 + (x1_y0 >> 32) + (x0_y1 >> 32) + (tmp >> 32),
                exp: x.exp + y.exp + 64,
            }
        }

        /// Precalculated powers of base N for the Bellerophon algorithm.
        pub struct BellerophonPowers {
            // Pre-calculated small powers.
            pub small: &'static [u64],
            // Pre-calculated large powers.
            pub large: &'static [u64],
            /// Pre-calculated small powers as 64-bit integers
            pub small_int: &'static [u64],
            // Step between large powers and number of small powers.
            pub step: i32,
            // Exponent bias for the large powers.
            pub bias: i32,
            /// ceil(log2(radix)) scaled as a multiplier.
            pub log2: i64,
            /// Bitshift for the log2 multiplier.
            pub log2_shift: i32,
        }

        /// Allow indexing of values without bounds checking
        impl BellerophonPowers {
            #[inline]
            pub fn get_small(&self, index: usize) -> ExtendedFloat {
                let mant = self.small[index];
                let exp = (1 - 64) + ((self.log2 * index as i64) >> self.log2_shift);
                ExtendedFloat {
                    mant,
                    exp: exp as i32,
                }
            }

            #[inline]
            pub fn get_large(&self, index: usize) -> ExtendedFloat {
                let mant = self.large[index];
                let biased_e = index as i64 * self.step as i64 - self.bias as i64;
                let exp = (1 - 64) + ((self.log2 * biased_e) >> self.log2_shift);
                ExtendedFloat {
                    mant,
                    exp: exp as i32,
                }
            }

            #[inline]
            pub fn get_small_int(&self, index: usize) -> u64 {
                self.small_int[index]
            }
        }
    }

    pub mod bigint
    {
        //! A simple big-integer type for slow path algorithms.
        //!
        //! This includes minimal stackvector for use in big-integer arithmetic.
        use super::heapvec::HeapVec;
        use super::num::{int_pow_fast_path, FastPathRadix};
        use std::{cmp, ops, ptr};

        /// Number of bits in a Bigint.
        pub const BIGINT_BITS: usize = 4000;

        /// The number of limbs for the bigint.
        pub const BIGINT_LIMBS: usize = BIGINT_BITS / LIMB_BITS;
        
        pub type VecType = HeapVec;        

        /// Storage for a big integer type.
        #[derive(Clone, PartialEq, Eq)]
        pub struct Bigint {
            /// Significant digits for the float, stored in a big integer in LE order.
            pub data: VecType,
        }
        
        impl Bigint {
            /// Construct a bigint representing 0.
            #[inline(always)]
            pub fn new() -> Self {
                Self {
                    data: VecType::new(),
                }
            }

            /// Construct a bigint from an integer.
            #[inline(always)]
            pub fn from_u64(value: u64) -> Self {
                Self {
                    data: VecType::from_u64(value),
                }
            }

            #[inline(always)]
            pub fn hi64(&self) -> (u64, bool) {
                self.data.hi64()
            }

            /// Multiply and assign as if by exponentiation by a power.
            #[inline]
            pub fn pow(&mut self, base: u32, exp: u32) -> Option<()> {
                debug_assert!(base == 2 || base == 5 || base == 10);
                if base % 5 == 0 {
                    pow(&mut self.data, exp)?;
                }
                if base % 2 == 0 {
                    shl(&mut self.data, exp as usize)?;
                }
                Some(())
            }

            /// Calculate the bit-length of the big-integer.
            #[inline]
            pub fn bit_length(&self) -> u32 {
                bit_length(&self.data)
            }
        }

        impl ops::MulAssign<&Bigint> for Bigint {
            fn mul_assign(&mut self, rhs: &Bigint) {
                self.data *= &rhs.data;
            }
        }

        /// Reverse, immutable view of a sequence.
        pub struct ReverseView<'a, T: 'a> {
            inner: &'a [T],
        }

        impl<'a, T> ops::Index<usize> for ReverseView<'a, T> {
            type Output = T;

            #[inline]
            fn index(&self, index: usize) -> &T {
                let len = self.inner.len();
                &(*self.inner)[len - index - 1]
            }
        }

        /// Create a reverse view of the vector for indexing.
        #[inline]
        pub fn rview(x: &[Limb]) -> ReverseView<Limb> {
            ReverseView {
                inner: x,
            }
        }

        /// Compare `x` to `y`, in little-endian order.
        #[inline]
        pub fn compare(x: &[Limb], y: &[Limb]) -> cmp::Ordering {
            match x.len().cmp(&y.len()) {
                cmp::Ordering::Equal => {
                    let iter = x.iter().rev().zip(y.iter().rev());
                    for (&xi, yi) in iter {
                        match xi.cmp(yi) {
                            cmp::Ordering::Equal => (),
                            ord => return ord,
                        }
                    }
                    // Equal case.
                    cmp::Ordering::Equal
                },
                ord => ord,
            }
        }

        /// Normalize the integer, so any leading zero values are removed.
        #[inline]
        pub fn normalize(x: &mut VecType) {
            // We don't care if this wraps: the index is bounds-checked.
            while let Some(&value) = x.get(x.len().wrapping_sub(1)) {
                if value == 0 {
                    unsafe { x.set_len(x.len() - 1) };
                } else {
                    break;
                }
            }
        }

        /// Get if the big integer is normalized.
        #[inline]
        pub fn is_normalized(x: &[Limb]) -> bool {
            // We don't care if this wraps: the index is bounds-checked.
            match x.get(x.len().wrapping_sub(1)) {
                Some(&0) => false,
                _ => true,
            }
        }

        /// Create StackVec from u64 value.
        #[inline(always)]
        pub fn from_u64(x: u64) -> VecType {
            let mut vec = VecType::new();
            debug_assert!(vec.capacity() >= 2);
            if LIMB_BITS == 32 {
                vec.try_push(x as Limb).unwrap();
                vec.try_push((x >> 32) as Limb).unwrap();
            } else {
                vec.try_push(x as Limb).unwrap();
            }
            vec.normalize();
            vec
        }

        /// Check if any of the remaining bits are non-zero.
        #[inline]
        pub fn nonzero(x: &[Limb], rindex: usize) -> bool {
            debug_assert!(rindex <= x.len());

            let len = x.len();
            let slc = &x[..len - rindex];
            slc.iter().rev().any(|&x| x != 0)
        }

        /// Shift 32-bit integer to high 64-bits.
        #[inline]
        pub fn u32_to_hi64_1(r0: u32) -> (u64, bool) {
            u64_to_hi64_1(r0 as u64)
        }

        /// Shift 2 32-bit integers to high 64-bits.
        #[inline]
        pub fn u32_to_hi64_2(r0: u32, r1: u32) -> (u64, bool) {
            let r0 = (r0 as u64) << 32;
            let r1 = r1 as u64;
            u64_to_hi64_1(r0 | r1)
        }

        /// Shift 3 32-bit integers to high 64-bits.
        #[inline]
        pub fn u32_to_hi64_3(r0: u32, r1: u32, r2: u32) -> (u64, bool) {
            let r0 = r0 as u64;
            let r1 = (r1 as u64) << 32;
            let r2 = r2 as u64;
            u64_to_hi64_2(r0, r1 | r2)
        }

        /// Shift 64-bit integer to high 64-bits.
        #[inline]
        pub fn u64_to_hi64_1(r0: u64) -> (u64, bool) {
            let ls = r0.leading_zeros();
            (r0 << ls, false)
        }

        /// Shift 2 64-bit integers to high 64-bits.
        #[inline]
        pub fn u64_to_hi64_2(r0: u64, r1: u64) -> (u64, bool) {
            let ls = r0.leading_zeros();
            let rs = 64 - ls;
            let v = match ls {
                0 => r0,
                _ => (r0 << ls) | (r1 >> rs),
            };
            let n = r1 << ls != 0;
            (v, n)
        }

        /// Extract the hi bits from the buffer.
        macro_rules! hi {
            (@1 $self:ident, $rview:ident, $t:ident, $fn:ident) => {{
                $fn($rview[0] as $t)
            }};

            (@2 $self:ident, $rview:ident, $t:ident, $fn:ident) => {{
                let r0 = $rview[0] as $t;
                let r1 = $rview[1] as $t;
                $fn(r0, r1)
            }};
            
            (@nonzero2 $self:ident, $rview:ident, $t:ident, $fn:ident) => {{
                let (v, n) = hi!(@2 $self, $rview, $t, $fn);
                (v, n || nonzero($self, 2 ))
            }};
            
            (@3 $self:ident, $rview:ident, $t:ident, $fn:ident) => {{
                let r0 = $rview[0] as $t;
                let r1 = $rview[1] as $t;
                let r2 = $rview[2] as $t;
                $fn(r0, r1, r2)
            }};
            
            (@nonzero3 $self:ident, $rview:ident, $t:ident, $fn:ident) => {{
                let (v, n) = hi!(@3 $self, $rview, $t, $fn);
                (v, n || nonzero($self, 3))
            }};
        }

        /// Get the high 64 bits from the vector.
        #[inline(always)]
        pub fn hi64(x: &[Limb]) -> (u64, bool) {
            let rslc = rview(x);
            
            match x.len() {
                0 => (0, false),
                1 if LIMB_BITS == 32 => hi!(@1 x, rslc, u32, u32_to_hi64_1),
                1 => hi!(@1 x, rslc, u64, u64_to_hi64_1),
                2 if LIMB_BITS == 32 => hi!(@2 x, rslc, u32, u32_to_hi64_2),
                2 => hi!(@2 x, rslc, u64, u64_to_hi64_2),
                _ if LIMB_BITS == 32 => hi!(@nonzero3 x, rslc, u32, u32_to_hi64_3),
                _ => hi!(@nonzero2 x, rslc, u64, u64_to_hi64_2),
            }
        }

        /// MulAssign by a power of 5.
        pub fn pow(x: &mut VecType, mut exp: u32) -> Option<()> 
        {
            let small_step = if LIMB_BITS == 32 {
                13
            } else {
                27
            };
            let max_native = (5 as Limb).pow(small_step);
            while exp >= small_step {
                small_mul(x, max_native)?;
                exp -= small_step;
            }
            if exp != 0 {
                let small_power = unsafe { int_pow_fast_path(exp as usize, FastPathRadix::Five) };
                small_mul(x, small_power as Limb)?;
            }
            Some(())
        }
        /// Add two small integers and return the resulting value and if overflow happens.
        #[inline(always)]
        pub fn scalar_add(x: Limb, y: Limb) -> (Limb, bool) {
            x.overflowing_add(y)
        }

        /// Multiply two small integers (with carry) (and return the overflow contribution).
        #[inline(always)]
        pub fn scalar_mul(x: Limb, y: Limb, carry: Limb) -> (Limb, Limb) 
        {
            let z: Wide = (x as Wide) * (y as Wide) + (carry as Wide);
            (z as Limb, (z >> LIMB_BITS) as Limb)
        }

        /// Add small integer to bigint starting from offset.
        #[inline]
        pub fn small_add_from(x: &mut VecType, y: Limb, start: usize) -> Option<()> {
            let mut index = start;
            let mut carry = y;
            while carry != 0 && index < x.len() {
                let result = scalar_add(x[index], carry);
                x[index] = result.0;
                carry = result.1 as Limb;
                index += 1;
            }
            // If we carried past all the elements, add to the end of the buffer.
            if carry != 0 {
                x.try_push(carry)?;
            }
            Some(())
        }

        /// Add small integer to bigint.
        #[inline(always)]
        pub fn small_add(x: &mut VecType, y: Limb) -> Option<()> {
            small_add_from(x, y, 0)
        }

        /// Multiply bigint by small integer.
        #[inline]
        pub fn small_mul(x: &mut VecType, y: Limb) -> Option<()> {
            let mut carry = 0;
            for xi in x.iter_mut() {
                let result = scalar_mul(*xi, y, carry);
                *xi = result.0;
                carry = result.1;
            }
            
            if carry != 0 {
                x.try_push(carry)?;
            }
            Some(())
        }

        /// Add bigint to bigint starting from offset.
        pub fn large_add_from(x: &mut VecType, y: &[Limb], start: usize) -> Option<()> {
            if y.len() > x.len().saturating_sub(start) {
                // Ensure we panic if we can't extend the buffer.
                // This avoids any unsafe behavior afterwards.
                x.try_resize(y.len() + start, 0)?;
            }

            // Iteratively add elements from y to x.
            let mut carry = false;
            for (index, &yi) in y.iter().enumerate() {
                // We panicked in `try_resize` if this wasn't true.
                let xi = x.get_mut(start + index).unwrap();
                
                let result = scalar_add(*xi, yi);
                *xi = result.0;
                let mut tmp = result.1;
                if carry {
                    let result = scalar_add(*xi, 1);
                    *xi = result.0;
                    tmp |= result.1;
                }
                carry = tmp;
            }

            // Handle overflow.
            if carry {
                small_add_from(x, 1, y.len() + start)?;
            }
            Some(())
        }

        /// Add bigint to bigint.
        #[inline(always)]
        pub fn large_add(x: &mut VecType, y: &[Limb]) -> Option<()> {
            large_add_from(x, y, 0)
        }

        /// Grade-school multiplication algorithm.
        pub fn long_mul(x: &[Limb], y: &[Limb]) -> Option<VecType> {
            let mut z = VecType::try_from(x)?;
            if !y.is_empty() {
                let y0 = y[0];
                small_mul(&mut z, y0)?;

                for (index, &yi) in y.iter().enumerate().skip(1) {
                    if yi != 0 {
                        let mut zi = VecType::try_from(x)?;
                        small_mul(&mut zi, yi)?;
                        large_add_from(&mut z, &zi, index)?;
                    }
                }
            }

            z.normalize();
            Some(z)
        }

        /// Multiply bigint by bigint using grade-school multiplication algorithm.
        #[inline(always)]
        pub fn large_mul(x: &mut VecType, y: &[Limb]) -> Option<()> {
            if y.len() == 1 {
                small_mul(x, y[0])?;
            } else {
                *x = long_mul(y, x)?;
            }
            Some(())
        }

        /// Shift-left `n` bits inside a buffer.
        #[inline]
        pub fn shl_bits(x: &mut VecType, n: usize) -> Option<()> {
            debug_assert!(n != 0);
            
            debug_assert!(n < LIMB_BITS);
            let rshift = LIMB_BITS - n;
            let lshift = n;
            let mut prev: Limb = 0;
            for xi in x.iter_mut() {
                let tmp = *xi;
                *xi <<= lshift;
                *xi |= prev >> rshift;
                prev = tmp;
            }

            // Always push the carry, even if it creates a non-normal result.
            let carry = prev >> rshift;
            if carry != 0 {
                x.try_push(carry)?;
            }

            Some(())
        }

        /// Shift-left `n` limbs inside a buffer.
        #[inline]
        pub fn shl_limbs(x: &mut VecType, n: usize) -> Option<()> {
            debug_assert!(n != 0);
            if n + x.len() > x.capacity() {
                None
            } else if !x.is_empty() {
                let len = n + x.len();
                
                unsafe {
                    // Move the elements.
                    let src = x.as_ptr();
                    let dst = x.as_mut_ptr().add(n);
                    ptr::copy(src, dst, x.len());
                    // Write our 0s.
                    ptr::write_bytes(x.as_mut_ptr(), 0, n);
                    x.set_len(len);
                }
                Some(())
            } else {
                Some(())
            }
        }

        /// Shift-left buffer by n bits.
        #[inline]
        pub fn shl(x: &mut VecType, n: usize) -> Option<()> {
            let rem = n % LIMB_BITS;
            let div = n / LIMB_BITS;
            if rem != 0 {
                shl_bits(x, rem)?;
            }
            if div != 0 {
                shl_limbs(x, div)?;
            }
            Some(())
        }

        /// Get number of leading zero bits in the storage.
        #[inline]
        pub fn leading_zeros(x: &[Limb]) -> u32 {
            let length = x.len();
            // wrapping_sub is fine, since it'll just return None.
            if let Some(&value) = x.get(length.wrapping_sub(1)) {
                value.leading_zeros()
            } else {
                0
            }
        }

        /// Calculate the bit-length of the big-integer.
        #[inline]
        pub fn bit_length(x: &[Limb]) -> u32 {
            let nlz = leading_zeros(x);
            LIMB_BITS as u32 * x.len() as u32 - nlz
        }

        //  Type for a single limb of the big integer.
        pub type Limb = u32;
        pub type Wide = u64;
        pub const LIMB_BITS: usize = 32;
    }

    pub mod extended_float
    {
        // FLOAT TYPE

        use super::num::Float;

        /// Extended precision floating-point type.
        ///
        /// Private implementation, exposed only for testing purposes.
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub struct ExtendedFloat 
        {
            /// Mantissa for the extended-precision float.
            pub mant: u64,
            /// Binary exponent for the extended-precision float.
            pub exp: i32,
        }

        impl ExtendedFloat
        {
            pub const fn new() -> Self
            {
                Self
                {
                    mant:0,
                    exp:0,
                }
            }

            
            pub fn extended_to_float<F: Float>( self ) -> F 
            {
                let mut word = self.mant;
                word |= (self.exp as u64) << F::MANTISSA_SIZE;
                F::from_bits(word)
            }
        }

        /// Converts an `ExtendedFloat` to the closest machine float type.
        #[inline(always)]
        pub fn extended_to_float<F: Float>(x: ExtendedFloat) -> F 
        {
            let mut word = x.mant;
            word |= (x.exp as u64) << F::MANTISSA_SIZE;
            F::from_bits(word)
        }
    }

    pub mod fpu
    {
        //! Platform-specific, assembly instructions to avoid intermediate rounding on architectures with FPUs.
        use std::mem::size_of;

        /// A structure used to preserve the original value of the FPU control word, 
        /// so that it can be restored when the structure is dropped.
        pub struct FPUControlWord(u16);

        fn set_cw(cw: u16) 
        {
            unsafe 
            {
                use ::arch::asm;
                asm!
                (
                    "fldcw word ptr [{}]",
                    in(reg) &cw,
                    options(nostack),
                )
            }
        }

        /// Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.
        pub fn set_precision<T>() -> FPUControlWord 
        {
            // Get the original value of the control word to restore it later, when the `FPUControlWord` structure is dropped
            unsafe 
            {
                use ::arch::asm;

                let mut cw = 0_u16;

                // Compute the value for the Precision Control field that is appropriate for `T`.
                let cw_precision = match size_of::<T>() 
                {
                    4 => 0x0000, // 32 bits
                    8 => 0x0200, // 64 bits
                    _ => 0x0300, // default, 80 bits
                };

                asm!
                (
                    "fnstcw word ptr [{}]",
                    in(reg) &mut cw,
                    options(nostack),
                )
            }

            // Set the control word to the desired precision. This is achieved by masking away the old
            // precision (bits 8 and 9, 0x300) and replacing it with the precision flag computed above.
            set_cw((cw & 0xFCFF) | cw_precision);

            FPUControlWord(cw)
        }

        impl Drop for FPUControlWord
        {
            fn drop(&mut self) 
            {
                set_cw(self.0)
            }
        }
    }

    pub mod heapvec
    {
        //! Simple heap-allocated vector.
        use ::
        {
            lexical::{ bigint },
            vec::{ Vec },
            cmp, ops
        };

        /// Simple heap vector implementation.
        #[derive(Clone)]
        pub struct HeapVec 
        {
            /// The heap-allocated buffer for the elements.
            data: Vec<bigint::Limb>,
        }
        
        impl HeapVec 
        {
            /// Construct an empty vector.
            #[inline] pub fn new() -> Self 
            {
                Self { data:Vec::with_capacity(bigint::BIGINT_LIMBS), }
            }

            /// Construct a vector from an existing slice.
            #[inline] pub fn try_from(x: &[bigint::Limb]) -> Option<Self>
            {
                let mut vec = Self::new();
                vec.try_extend(x)?;
                Some(vec)
            }

            /// Sets the length of a vector.
            #[inline] pub unsafe fn set_len(&mut self, len: usize)
            {
                debug_assert!(len <= bigint::BIGINT_LIMBS);
                unsafe { self.data.set_len(len) };
            }

            /// The number of elements stored in the vector.
            #[inline] pub fn len(&self) -> usize
            { self.data.len() }

            /// If the vector is empty.
            #[inline]
            pub fn is_empty(&self) -> bool 
            { self.len() == 0 }

            /// The number of items the vector can hold.
            #[inline] pub fn capacity(&self) -> usize 
            { self.data.capacity() }

            /// Append an item to the vector.
            #[inline] pub fn try_push(&mut self, value: bigint::Limb) -> Option<()>
            {
                self.data.push(value);
                Some(())
            }

            /// Remove an item from the end of the vector and return it, or None if empty.
            #[inline] pub fn pop(&mut self) -> Option<bigint::Limb> 
            {
                self.data.pop()
            }

            /// Copy elements from a slice and append them to the vector.
            #[inline] pub fn try_extend(&mut self, slc: &[bigint::Limb]) -> Option<()>
            {
                self.data.extend_from_slice(slc);
                Some(())
            }

            /// Try to resize the buffer.
            #[inline] pub fn try_resize(&mut self, len: usize, value: bigint::Limb) -> Option<()>
            {
                self.data.resize(len, value);
                Some(())
            }

            // HI
            /// Get the high 64 bits from the vector.
            #[inline(always)] pub fn hi64(&self) -> (u64, bool) 
            { bigint::hi64(&self.data) }

            // FROM
            /// Create StackVec from u64 value.
            #[inline(always)] pub fn from_u64(x: u64) -> Self 
            { bigint::from_u64(x) }

            /// Normalize the integer, so any leading zero values are removed.
            #[inline] pub fn normalize(&mut self) 
            { bigint::normalize(self) }

            /// Get if the big integer is normalized.
            #[inline] pub fn is_normalized(&self) -> bool
            { bigint::is_normalized(self) }

            /// AddAssign small integer.
            #[inline] pub fn add_small(&mut self, y: bigint::Limb) -> Option<()>
            { bigint::small_add(self, y) }

            /// MulAssign small integer.
            #[inline] pub fn mul_small(&mut self, y: bigint::Limb) -> Option<()> 
            { bigint::small_mul(self, y) }
        }

        impl PartialEq for HeapVec
        {
            #[inline] fn eq(&self, other: &Self) -> bool
            {
                use ::ops::Deref;
                self.len() == other.len() && self.deref() == other.deref()
            }
        }

        impl Eq for HeapVec {}

        impl cmp::PartialOrd for HeapVec
        {
            #[inline] fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> 
            {
                Some(bigint::compare(self, other))
            }
        }

        impl cmp::Ord for HeapVec
        {
            #[inline] fn cmp(&self, other: &Self) -> cmp::Ordering
            {
                bigint::compare(self, other)
            }
        }

        impl ops::Deref for HeapVec
        {
            type Target = [bigint::Limb];

            #[inline] fn deref(&self) -> &[bigint::Limb] 
            { &self.data }
        }

        impl ops::DerefMut for HeapVec
        {
            #[inline] fn deref_mut(&mut self) -> &mut [bigint::Limb]
            {
                &mut self.data
            }
        }

        impl ops::MulAssign<&[bigint::Limb]> for HeapVec
        {
            #[inline] fn mul_assign(&mut self, rhs: &[bigint::Limb])
            {
                bigint::large_mul(self, rhs).unwrap();
            }
        }
    }
    
    pub mod libm
    {
        //! A small number of math routines for floats and doubles.
        macro_rules! i 
        {
            ($array:ident, $index:expr) => { unsafe { *$array.get_unchecked( $index ) } };
        }

        pub fn powf(x: f32, y: f32) -> f32 
        {
            const BP: [f32; 2] = [1.0, 1.5];
            const DP_H: [f32; 2] = [0.0, 5.84960938e-01];
            const DP_L: [f32; 2] = [0.0, 1.56322085e-06];
            const TWO24: f32 = 16777216.0;
            const HUGE: f32 = 1.0e30;
            const TINY: f32 = 1.0e-30;
            const L1: f32 = 6.0000002384e-01;
            const L2: f32 = 4.2857143283e-01;
            const L3: f32 = 3.3333334327e-01;
            const L4: f32 = 2.7272811532e-01;
            const L5: f32 = 2.3066075146e-01;
            const L6: f32 = 2.0697501302e-01;
            const P1: f32 = 1.6666667163e-01;
            const P2: f32 = -2.7777778450e-03;
            const P3: f32 = 6.6137559770e-05;
            const P4: f32 = -1.6533901999e-06;
            const P5: f32 = 4.1381369442e-08;
            const LG2: f32 = 6.9314718246e-01;
            const LG2_H: f32 = 6.93145752e-01;
            const LG2_L: f32 = 1.42860654e-06;
            const OVT: f32 = 4.2995665694e-08;
            const CP: f32 = 9.6179670095e-01;
            const CP_H: f32 = 9.6191406250e-01;
            const CP_L: f32 = -1.1736857402e-04;
            const IVLN2: f32 = 1.4426950216e+00;
            const IVLN2_H: f32 = 1.4426879883e+00;
            const IVLN2_L: f32 = 7.0526075433e-06;

            let mut z: f32;
            let mut ax: f32;
            let z_h: f32;
            let z_l: f32;
            let mut p_h: f32;
            let mut p_l: f32;
            let y1: f32;
            let mut t1: f32;
            let t2: f32;
            let mut r: f32;
            let s: f32;
            let mut sn: f32;
            let mut t: f32;
            let mut u: f32;
            let mut v: f32;
            let mut w: f32;
            let i: i32;
            let mut j: i32;
            let mut k: i32;
            let mut yisint: i32;
            let mut n: i32;
            let hx: i32;
            let hy: i32;
            let mut ix: i32;
            let iy: i32;
            let mut is: i32;

            hx = x.to_bits() as i32;
            hy = y.to_bits() as i32;

            ix = hx & 0x7fffffff;
            iy = hy & 0x7fffffff;
            
            if iy == 0 { return 1.0; }
            
            if hx == 0x3f800000 { return 1.0; }
            
            if ix > 0x7f800000 || iy > 0x7f800000 { return x + y; }
            
            yisint = 0;
            if hx < 0 
            {
                if iy >= 0x4b800000 
                { yisint = 2; } 
                
                else if iy >= 0x3f800000 
                {
                    k = (iy >> 23) - 0x7f;
                    j = iy >> (23 - k);
                    if (j << (23 - k)) == iy 
                    { yisint = 2 - (j & 1); }
                }
            }
            
            if iy == 0x7f800000 
            {
                if ix == 0x3f800000 
                {
                    return 1.0;
                } 
                else if ix > 0x3f800000 
                {
                    return if hy >= 0 
                    {
                        y
                    } 
                    else 
                    {
                        0.0
                    };
                } 
                else 
                {
                    return if hy >= 0 
                    { 0.0 }
                    
                    else 
                    { -y };
                }
            }

            if iy == 0x3f800000
            {
                return if hy >= 0 
                { x }
                
                else 
                { 1.0 / x };
            }

            if hy == 0x40000000 
            { return x * x; }

            if hy == 0x3f000000
            
            && hx >= 0
            {
                return sqrtf(x);
            }

            ax = fabsf(x);

            if ix == 0x7f800000 || ix == 0 || ix == 0x3f800000
            {
                z = ax;
                if hy < 0 
                { z = 1.0 / z; }

                if hx < 0 
                {
                    if ((ix - 0x3f800000) | yisint) == 0 
                    { z = (z - z) / (z - z); } 

                    else if yisint == 1 
                    { z = -z; }
                }
                return z;
            }

            sn = 1.0;
            if hx < 0 
            {
                if yisint == 0 
                { return (x - x) / (x - x); }

                if yisint == 1 
                { sn = -1.0; }
            }
            
            if iy > 0x4d000000 
            {
                if ix < 0x3f7ffff8 
                {
                    return if hy < 0 
                    { sn * HUGE * HUGE } 
                    else 
                    { sn * TINY * TINY };
                }

                if ix > 0x3f800007 
                {
                    return if hy > 0 
                    { sn * HUGE * HUGE } 
                    else 
                    { sn * TINY * TINY };
                }

                t = ax - 1.;
                w = (t * t) * (0.5 - t * (0.333333333333 - t * 0.25));
                u = IVLN2_H * t;
                v = t * IVLN2_L - w * IVLN2;
                t1 = u + v;
                is = t1.to_bits() as i32;
                t1 = f32::from_bits(is as u32 & 0xfffff000);
                t2 = v - (t1 - u);
            } 
            else 
            {
                let mut s2: f32;
                let mut s_h: f32;
                let s_l: f32;
                let mut t_h: f32;
                let mut t_l: f32;

                n = 0;
                if ix < 0x00800000 
                {
                    ax *= TWO24;
                    n -= 24;
                    ix = ax.to_bits() as i32;
                }

                n += ((ix) >> 23) - 0x7f;
                j = ix & 0x007fffff;
                ix = j | 0x3f800000;
                if j <= 0x1cc471 
                {
                    k = 0;
                } 
                else if j < 0x5db3d7
                {
                    k = 1;
                } 
                else 
                {
                    k = 0;
                    n += 1;
                    ix -= 0x00800000;
                }
                ax = f32::from_bits(ix as u32);
                u = ax - i!(BP, k as usize);
                v = 1.0 / (ax + i!(BP, k as usize));
                s = u * v;
                s_h = s;
                is = s_h.to_bits() as i32;
                s_h = f32::from_bits(is as u32 & 0xfffff000);
                is = (((ix as u32 >> 1) & 0xfffff000) | 0x20000000) as i32;
                t_h = f32::from_bits(is as u32 + 0x00400000 + ((k as u32) << 21));
                t_l = ax - (t_h - i!(BP, k as usize));
                s_l = v * ((u - s_h * t_h) - s_h * t_l);
                s2 = s * s;
                r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));
                r += s_l * (s_h + s);
                s2 = s_h * s_h;
                t_h = 3.0 + s2 + r;
                is = t_h.to_bits() as i32;
                t_h = f32::from_bits(is as u32 & 0xfffff000);
                t_l = r - ((t_h - 3.0) - s2);
                u = s_h * t_h;
                v = s_l * t_h + t_l * s;
                p_h = u + v;
                is = p_h.to_bits() as i32;
                p_h = f32::from_bits(is as u32 & 0xfffff000);
                p_l = v - (p_h - u);
                z_h = CP_H * p_h;
                z_l = CP_L * p_h + p_l * CP + i!(DP_L, k as usize);
                t = n as f32;
                t1 = ((z_h + z_l) + i!(DP_H, k as usize)) + t;
                is = t1.to_bits() as i32;
                t1 = f32::from_bits(is as u32 & 0xfffff000);
                t2 = z_l - (((t1 - t) - i!(DP_H, k as usize)) - z_h);
            };
            
            is = y.to_bits() as i32;
            y1 = f32::from_bits(is as u32 & 0xfffff000);
            p_l = (y - y1) * t1 + y * t2;
            p_h = y1 * t1;
            z = p_l + p_h;
            j = z.to_bits() as i32;
            
            if j > 0x43000000 
            {
                return sn * HUGE * HUGE;
            }
            
            else if j == 0x43000000 
            {
                if p_l + OVT > z - p_h 
                { return sn * HUGE * HUGE; }
            } 
            
            else if (j & 0x7fffffff) > 0x43160000 
            { return sn * TINY * TINY; } 

            else if j as u32 == 0xc3160000 && p_l <= z - p_h
            {
                return sn * TINY * TINY;
            }
            
            i = j & 0x7fffffff;
            k = (i >> 23) - 0x7f;
            n = 0;

            if i > 0x3f000000 
            {
                n = j + (0x00800000 >> (k + 1));
                k = ((n & 0x7fffffff) >> 23) - 0x7f;
                t = f32::from_bits(n as u32 & !(0x007fffff >> k));
                n = ((n & 0x007fffff) | 0x00800000) >> (23 - k);
                if j < 0 {
                    n = -n;
                }
                p_h -= t;
            }

            t = p_l + p_h;
            is = t.to_bits() as i32;
            t = f32::from_bits(is as u32 & 0xffff8000);
            u = t * LG2_H;
            v = (p_l - (t - p_h)) * LG2 + t * LG2_L;
            z = u + v;
            w = v - (z - u);
            t = z * z;
            t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));
            r = (z * t1) / (t1 - 2.0) - (w + z * w);
            z = 1.0 - (r - z);
            j = z.to_bits() as i32;
            j += n << 23;
            
            if (j >> 23) <= 0 
            { z = scalbnf(z, n); } 
            
            else 
            { z = f32::from_bits(j as u32); }
            
            sn * z
        }

        pub fn sqrtf(x: f32) -> f32 
        {
            unsafe 
            {
                use ::arch::x86_64::*;
                let m = _mm_set_ss(x);
                let m_sqrt = _mm_sqrt_ss(m);
                _mm_cvtss_f32(m_sqrt)
            }
        }

        /// Absolute value (magnitude) (f32).
        pub fn fabsf(x: f32) -> f32 
        { f32::from_bits(x.to_bits() & 0x7fffffff) }

        pub fn scalbnf(mut x: f32, mut n: i32) -> f32 
        {
            let x1p127 = f32::from_bits(0x7f000000);
            let x1p_126 = f32::from_bits(0x800000);
            let x1p24 = f32::from_bits(0x4b800000);

            if n > 127 
            {
                x *= x1p127;
                n -= 127;
                if n > 127 
                {
                    x *= x1p127;
                    n -= 127;
                    if n > 127
                    { n = 127; }
                }
            }
            
            else if n < -126
            {
                x *= x1p_126 * x1p24;
                n += 126 - 24;
                if n < -126
                {
                    x *= x1p_126 * x1p24;
                    n += 126 - 24;
                    if n < -126
                    {
                        n = -126;
                    }
                }
            }

            x * f32::from_bits(((0x7f + n) as u32) << 23)
        }

        pub fn powd(x: f64, y: f64) -> f64 
        {
            const BP: [f64; 2] = [1.0, 1.5];
            const DP_H: [f64; 2] = [0.0, 5.84962487220764160156e-01];
            const DP_L: [f64; 2] = [0.0, 1.35003920212974897128e-08];
            const TWO53: f64 = 9007199254740992.0;
            const HUGE: f64 = 1.0e300;
            const TINY: f64 = 1.0e-300;
            
            const L1: f64 = 5.99999999999994648725e-01;
            const L2: f64 = 4.28571428578550184252e-01;
            const L3: f64 = 3.33333329818377432918e-01;
            const L4: f64 = 2.72728123808534006489e-01;
            const L5: f64 = 2.30660745775561754067e-01;
            const L6: f64 = 2.06975017800338417784e-01;
            const P1: f64 = 1.66666666666666019037e-01;
            const P2: f64 = -2.77777777770155933842e-03;
            const P3: f64 = 6.61375632143793436117e-05;
            const P4: f64 = -1.65339022054652515390e-06;
            const P5: f64 = 4.13813679705723846039e-08;
            const LG2: f64 = 6.93147180559945286227e-01;
            const LG2_H: f64 = 6.93147182464599609375e-01;
            const LG2_L: f64 = -1.90465429995776804525e-09;
            const OVT: f64 = 8.0085662595372944372e-017;
            const CP: f64 = 9.61796693925975554329e-01;
            const CP_H: f64 = 9.61796700954437255859e-01;
            const CP_L: f64 = -7.02846165095275826516e-09;
            const IVLN2: f64 = 1.44269504088896338700e+00;
            const IVLN2_H: f64 = 1.44269502162933349609e+00;
            const IVLN2_L: f64 = 1.92596299112661746887e-08;

            let t1: f64;
            let t2: f64;

            let (hx, lx): (i32, u32) = ((x.to_bits() >> 32) as i32, x.to_bits() as u32);
            let (hy, ly): (i32, u32) = ((y.to_bits() >> 32) as i32, y.to_bits() as u32);

            let mut ix: i32 = (hx & 0x7fffffff) as i32;
            let iy: i32 = (hy & 0x7fffffff) as i32;
            
            if ((iy as u32) | ly) == 0 
            { return 1.0; }
            
            if hx == 0x3ff00000 && lx == 0 
            { return 1.0; }
            
            if ix > 0x7ff00000
            || (ix == 0x7ff00000 && lx != 0)
            || iy > 0x7ff00000
            || (iy == 0x7ff00000 && ly != 0)
            { return x + y; }
            
            let mut yisint: i32 = 0;
            let mut k: i32;
            let mut j: i32;
            if hx < 0
            {
                if iy >= 0x43400000
                { yisint = 2; } 
                else if iy >= 0x3ff00000 
                {
                    k = (iy >> 20) - 0x3ff;

                    if k > 20 
                    {
                        j = (ly >> (52 - k)) as i32;

                        if (j << (52 - k)) == (ly as i32)
                        { yisint = 2 - (j & 1); }
                    } 
                    else if ly == 0 
                    {
                        j = iy >> (20 - k);

                        if (j << (20 - k)) == iy
                        {
                            yisint = 2 - (j & 1);
                        }
                    }
                }
            }

            if ly == 0 
            {
                if iy == 0x7ff00000 
                {
                    return if ((ix - 0x3ff00000) | (lx as i32)) == 0 
                    {
                        1.0
                    } 
                    else if ix >= 0x3ff00000 
                    {
                        if hy >= 0 
                        { y } 
                        
                        else 
                        { 0.0 }
                    } 
                    else 
                    {
                        if hy >= 0 
                        { 0.0 } 
                        
                        else 
                        { -y }
                    };
                }

                if iy == 0x3ff00000 
                {
                    return if hy >= 0
                    { x }

                    else 
                    { 1.0 / x };
                }

                if hy == 0x40000000 
                { return x * x; }

                if hy == 0x3fe00000
                {
                    if hx >= 0 
                    {
                        return sqrtd(x);
                    }
                }
            }

            let mut ax: f64 = fabsd(x);
            if lx == 0 
            {
                if ix == 0x7ff00000 || ix == 0 || ix == 0x3ff00000
                {
                    let mut z: f64 = ax;

                    if hy < 0 
                    {
                        z = 1.0 / z;
                    }

                    if hx < 0 
                    {
                        if ((ix - 0x3ff00000) | yisint) == 0 
                        { z = (z - z) / (z - z); } 
                        
                        else if yisint == 1 
                        { z = -z; }
                    }

                    return z;
                }
            }

            let mut s: f64 = 1.0;
            if hx < 0 
            {
                if yisint == 0 
                { return (x - x) / (x - x); }

                if yisint == 1 
                { s = -1.0; }
            }
            
            if iy > 0x41e00000 
            {
                if iy > 0x43f00000 
                {
                    if ix <= 0x3fefffff 
                    {
                        return if hy < 0 
                        { HUGE * HUGE } 
                        
                        else 
                        { TINY * TINY };
                    }

                    if ix >= 0x3ff00000 
                    {
                        return if hy > 0 
                        { HUGE * HUGE }

                        else { TINY * TINY };
                    }
                }

                /* over/underflow if x is not close to one */
                if ix < 0x3fefffff {
                    return if hy < 0 {
                        s * HUGE * HUGE
                    } else {
                        s * TINY * TINY
                    };
                }
                if ix > 0x3ff00000 {
                    return if hy > 0 {
                        s * HUGE * HUGE
                    } else {
                        s * TINY * TINY
                    };
                }

                /* now |1-x| is TINY <= 2**-20, suffice to compute
                log(x) by x-x^2/2+x^3/3-x^4/4 */
                let t: f64 = ax - 1.0; /* t has 20 trailing zeros */
                let w: f64 = (t * t) * (0.5 - t * (0.3333333333333333333333 - t * 0.25));
                let u: f64 = IVLN2_H * t; /* ivln2_h has 21 sig. bits */
                let v: f64 = t * IVLN2_L - w * IVLN2;
                t1 = with_set_low_word(u + v, 0);
                t2 = v - (t1 - u);
            } 
            
            else 
            {
                let mut n: i32 = 0;
                if ix < 0x00100000 
                {
                    ax *= TWO53;
                    n -= 53;
                    ix = get_high_word(ax) as i32;
                }

                n += (ix >> 20) - 0x3ff;
                j = ix & 0x000fffff;
                
                let k: i32;
                ix = j | 0x3ff00000;
                if j <= 0x3988E 
                {
                    k = 0;
                }

                else if j < 0xBB67A
                {
                    k = 1;
                } 
                
                else 
                {
                    k = 0;
                    n += 1;
                    ix -= 0x00100000;
                }
                ax = with_set_high_word(ax, ix as u32);
                
                let u: f64 = ax - i!(BP, k as usize);
                let v: f64 = 1.0 / (ax + i!(BP, k as usize));
                let ss: f64 = u * v;
                let s_h = with_set_low_word(ss, 0);
                
                let t_h: f64 = with_set_high_word
                (
                    0.0,
                    ((ix as u32 >> 1) | 0x20000000) + 0x00080000 + ((k as u32) << 18),
                );
                
                let t_l: f64 = ax - (t_h - i!(BP, k as usize));
                let s_l: f64 = v * ((u - s_h * t_h) - s_h * t_l);
                
                let s2: f64 = ss * ss;
                let mut r: f64 = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));
                r += s_l * (s_h + ss);
                let s2: f64 = s_h * s_h;
                let t_h: f64 = with_set_low_word(3.0 + s2 + r, 0);
                let t_l: f64 = r - ((t_h - 3.0) - s2);
                
                let u: f64 = s_h * t_h;
                let v: f64 = s_l * t_h + t_l * ss;
                
                let p_h: f64 = with_set_low_word(u + v, 0);
                let p_l = v - (p_h - u);
                let z_h: f64 = CP_H * p_h;
                let z_l: f64 = CP_L * p_h + p_l * CP + i!(DP_L, k as usize);
                
                let t: f64 = n as f64;
                t1 = with_set_low_word(((z_h + z_l) + i!(DP_H, k as usize)) + t, 0);
                t2 = z_l - (((t1 - t) - i!(DP_H, k as usize)) - z_h);
            }
            
            let y1: f64 = with_set_low_word(y, 0);
            let p_l: f64 = (y - y1) * t1 + y * t2;
            let mut p_h: f64 = y1 * t1;
            let z: f64 = p_l + p_h;
            let mut j: i32 = (z.to_bits() >> 32) as i32;
            let i: i32 = z.to_bits() as i32;            

            if j >= 0x40900000 
            {   
                if (j - 0x40900000) | i != 0 
                { return s * HUGE * HUGE; }

                if p_l + OVT > z - p_h 
                { return s * HUGE * HUGE; }

            }

            else if (j & 0x7fffffff) >= 0x4090cc00 
            {
                if (((j as u32) - 0xc090cc00) | (i as u32)) != 0 
                { return s * TINY * TINY; }

                if p_l <= z - p_h 
                { return s * TINY * TINY; }
            }
            
            let i: i32 = j & (0x7fffffff as i32);
            k = (i >> 20) - 0x3ff;
            let mut n: i32 = 0;

            if i > 0x3fe00000 
            {
                n = j + (0x00100000 >> (k + 1));
                k = ((n & 0x7fffffff) >> 20) - 0x3ff;
                let t: f64 = with_set_high_word(0.0, (n & !(0x000fffff >> k)) as u32);
                n = ((n & 0x000fffff) | 0x00100000) >> (20 - k);
                if j < 0 
                {
                    n = -n;
                }
                p_h -= t;
            }

            let t: f64 = with_set_low_word(p_l + p_h, 0);
            let u: f64 = t * LG2_H;
            let v: f64 = (p_l - (t - p_h)) * LG2 + t * LG2_L;
            let mut z: f64 = u + v;
            let w: f64 = v - (z - u);
            let t: f64 = z * z;
            let t1: f64 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));
            let r: f64 = (z * t1) / (t1 - 2.0) - (w + z * w);
            z = 1.0 - (r - z);
            j = get_high_word(z) as i32;
            j += n << 20;

            if (j >> 20) <= 0 
            {
                z = scalbnd(z, n);
            }
            
            else 
            { z = with_set_high_word(z, j as u32); }

            s * z
        }

        /// Absolute value (magnitude) (f64).
        pub fn fabsd(x: f64) -> f64 
        {
            f64::from_bits(x.to_bits() & (u64::MAX / 2))
        }

        pub fn scalbnd(x: f64, mut n: i32) -> f64 
        {
            let x1p1023 = f64::from_bits(0x7fe0000000000000);
            let x1p53 = f64::from_bits(0x4340000000000000);
            let x1p_1022 = f64::from_bits(0x0010000000000000);

            let mut y = x;
            if n > 1023 
            {
                y *= x1p1023;
                n -= 1023;
                if n > 1023
                {
                    y *= x1p1023;
                    n -= 1023;
                    if n > 1023
                    {
                        n = 1023;
                    }
                }
            }
            else if n < -1022 
            {
                y *= x1p_1022 * x1p53;
                n += 1022 - 53;
                if n < -1022 
                {
                    y *= x1p_1022 * x1p53;
                    n += 1022 - 53;
                    if n < -1022 
                    { n = -1022; }
                }
            }
            y * f64::from_bits(((0x3ff + n) as u64) << 52)
        }
        
        pub fn sqrtd(x: f64) -> f64 
        {
            unsafe 
            {
                use ::arch::x86_64::*;
                let m = _mm_set_sd(x);
                let m_sqrt = _mm_sqrt_pd(m);
                _mm_cvtsd_f64(m_sqrt)
            }
        }

        #[inline] fn get_high_word(x: f64) -> u32 
        {
            (x.to_bits() >> 32) as u32
        }

        #[inline] fn with_set_high_word(f: f64, hi: u32) -> f64
        {
            let mut tmp = f.to_bits();
            tmp &= 0x00000000_ffffffff;
            tmp |= (hi as u64) << 32;
            f64::from_bits(tmp)
        }

        #[inline] fn with_set_low_word(f: f64, lo: u32) -> f64 
        {
            let mut tmp = f.to_bits();
            tmp &= 0xffffffff_00000000;
            tmp |= lo as u64;
            f64::from_bits(tmp)
        }
    }

    pub mod mask
    {
        //! Utilities to generate bitmasks.
        #[inline] pub fn lower_n_mask(n: u64) -> u64 
        {
            debug_assert!(n <= 64, "lower_n_mask() overflow in shl.");

            match n == 64 
            {
                true => 0xffff_ffff_ffff_ffff,
                false => (1 << n) - 1,
            }
        }

        /// Calculate the halfway point for the lower `n` bits.
        #[inline] pub fn lower_n_halfway(n: u64) -> u64 
        {
            debug_assert!(n <= 64, "lower_n_halfway() overflow in shl.");

            match n == 0 
            {
                true => 0,
                false => nth_bit(n - 1),
            }
        }

        /// Calculate a scalar factor of 2 above the halfway point.
        #[inline] pub fn nth_bit(n: u64) -> u64 
        {
            debug_assert!(n < 64, "nth_bit() overflow in shl.");
            1 << n
        }
    }

    pub mod num
    {
        //! Utilities for Rust numbers.
        use ::ops;

        /// Generic floating-point type, to be used in generic code for parsing.
        pub trait Float:
        Sized
        + Copy
        + PartialEq
        + PartialOrd
        + Send
        + Sync
        + ops::Add<Output = Self>
        + ops::AddAssign
        + ops::Div<Output = Self>
        + ops::DivAssign
        + ops::Mul<Output = Self>
        + ops::MulAssign
        + ops::Rem<Output = Self>
        + ops::RemAssign
        + ops::Sub<Output = Self>
        + ops::SubAssign
        + ops::Neg<Output = Self>
        {
            /// Maximum number of digits that can contribute in the mantissa.
            const MAX_DIGITS: usize;

            // MASKS
            /// Bitmask for the sign bit.
            const SIGN_MASK: u64;
            /// Bitmask for the exponent, including the hidden bit.
            const EXPONENT_MASK: u64;
            /// Bitmask for the hidden bit in exponent, which is an implicit 1 in the fraction.
            const HIDDEN_BIT_MASK: u64;
            /// Bitmask for the mantissa (fraction), excluding the hidden bit.
            const MANTISSA_MASK: u64;

            // PROPERTIES
            /// Size of the significand (mantissa) without hidden bit.
            const MANTISSA_SIZE: i32;
            /// Bias of the exponet
            const EXPONENT_BIAS: i32;
            /// Exponent portion of a denormal float.
            const DENORMAL_EXPONENT: i32;
            /// Maximum exponent value in float.
            const MAX_EXPONENT: i32;

            // ROUNDING
            /// Mask to determine if a full-carry occurred (1 in bit above hidden bit).
            const CARRY_MASK: u64;

            /// Bias for marking an invalid extended float.
            const INVALID_FP: i32 = -0x8000;

            // Maximum mantissa for the fast-path (`1 << 53` for f64).
            const MAX_MANTISSA_FAST_PATH: u64 = 2_u64 << Self::MANTISSA_SIZE;

            // Largest exponent value `(1 << EXP_BITS) - 1`.
            const INFINITE_POWER: i32 = Self::MAX_EXPONENT + Self::EXPONENT_BIAS;

            // Round-to-even only happens for negative values of q when q ≥ −4 in the 64-bit case 
            // and when q ≥ −17 in the 32-bitcase.
            const MIN_EXPONENT_ROUND_TO_EVEN: i32;
            const MAX_EXPONENT_ROUND_TO_EVEN: i32;

            /// Minimum normal exponent value `-(1 << (EXPONENT_SIZE - 1)) + 1`.
            const MINIMUM_EXPONENT: i32;

            /// Smallest decimal exponent for a non-zero value.
            const SMALLEST_POWER_OF_TEN: i32;

            /// Largest decimal exponent for a non-infinite value.
            const LARGEST_POWER_OF_TEN: i32;

            /// Minimum exponent that for a fast path case, or `-⌊(MANTISSA_SIZE+1)/log2(10)⌋`
            const MIN_EXPONENT_FAST_PATH: i32;

            /// Maximum exponent that for a fast path case, or `⌊(MANTISSA_SIZE+1)/log2(5)⌋`
            const MAX_EXPONENT_FAST_PATH: i32;

            /// Maximum exponent that can be represented for a disguised-fast path case.
            const MAX_EXPONENT_DISGUISED_FAST_PATH: i32;

            /// Convert 64-bit integer to float.
            fn from_u64(u: u64) -> Self;

            // Re-exported methods from std.
            fn from_bits(u: u64) -> Self;
            fn to_bits(self) -> u64;

            /// Get a small power-of-radix for fast-path multiplication.
            unsafe fn pow_fast_path(exponent: usize) -> Self;

            /// Returns true if the float is a denormal.
            #[inline] fn is_denormal(self) -> bool 
            {
                self.to_bits() & Self::EXPONENT_MASK == 0
            }

            /// Get exponent component from the float.
            #[inline] fn exponent(self) -> i32 
            {
                if self.is_denormal() 
                { return Self::DENORMAL_EXPONENT; }

                let bits = self.to_bits();
                let biased_e: i32 = ((bits & Self::EXPONENT_MASK) >> Self::MANTISSA_SIZE) as i32;
                biased_e - Self::EXPONENT_BIAS
            }

            /// Get mantissa (significand) component from float.
            #[inline] fn mantissa(self) -> u64
            {
                let bits = self.to_bits();
                let s = bits & Self::MANTISSA_MASK;
                
                if !self.is_denormal() 
                { s + Self::HIDDEN_BIT_MASK } 

                else { s }
            }
        }

        impl Float for f32 
        {
            const MAX_DIGITS: usize = 114;
            const SIGN_MASK: u64 = 0x80000000;
            const EXPONENT_MASK: u64 = 0x7F800000;
            const HIDDEN_BIT_MASK: u64 = 0x00800000;
            const MANTISSA_MASK: u64 = 0x007FFFFF;
            const MANTISSA_SIZE: i32 = 23;
            const EXPONENT_BIAS: i32 = 127 + Self::MANTISSA_SIZE;
            const DENORMAL_EXPONENT: i32 = 1 - Self::EXPONENT_BIAS;
            const MAX_EXPONENT: i32 = 0xFF - Self::EXPONENT_BIAS;
            const CARRY_MASK: u64 = 0x1000000;
            const MIN_EXPONENT_ROUND_TO_EVEN: i32 = -17;
            const MAX_EXPONENT_ROUND_TO_EVEN: i32 = 10;
            const MINIMUM_EXPONENT: i32 = -127;
            const SMALLEST_POWER_OF_TEN: i32 = -65;
            const LARGEST_POWER_OF_TEN: i32 = 38;
            const MIN_EXPONENT_FAST_PATH: i32 = -10;
            const MAX_EXPONENT_FAST_PATH: i32 = 10;
            const MAX_EXPONENT_DISGUISED_FAST_PATH: i32 = 17;

            #[inline(always)] unsafe fn pow_fast_path(exponent: usize) -> Self 
            {
                return powf(10.0f32, exponent as f32);
            }

            #[inline] fn from_u64(u: u64) -> f32
            {
                u as _
            }

            #[inline] fn from_bits(u: u64) -> f32
            {
                debug_assert!(u <= 0xffff_ffff);
                f32::from_bits(u as u32)
            }

            #[inline] fn to_bits(self) -> u64
            {
                f32::to_bits(self) as u64
            }
        }

        impl Float for f64 
        {
            const MAX_DIGITS: usize = 769;
            const SIGN_MASK: u64 = 0x8000000000000000;
            const EXPONENT_MASK: u64 = 0x7FF0000000000000;
            const HIDDEN_BIT_MASK: u64 = 0x0010000000000000;
            const MANTISSA_MASK: u64 = 0x000FFFFFFFFFFFFF;
            const MANTISSA_SIZE: i32 = 52;
            const EXPONENT_BIAS: i32 = 1023 + Self::MANTISSA_SIZE;
            const DENORMAL_EXPONENT: i32 = 1 - Self::EXPONENT_BIAS;
            const MAX_EXPONENT: i32 = 0x7FF - Self::EXPONENT_BIAS;
            const CARRY_MASK: u64 = 0x20000000000000;
            const MIN_EXPONENT_ROUND_TO_EVEN: i32 = -4;
            const MAX_EXPONENT_ROUND_TO_EVEN: i32 = 23;
            const MINIMUM_EXPONENT: i32 = -1023;
            const SMALLEST_POWER_OF_TEN: i32 = -342;
            const LARGEST_POWER_OF_TEN: i32 = 308;
            const MIN_EXPONENT_FAST_PATH: i32 = -22;
            const MAX_EXPONENT_FAST_PATH: i32 = 22;
            const MAX_EXPONENT_DISGUISED_FAST_PATH: i32 = 37;

            #[inline(always)] unsafe fn pow_fast_path(exponent: usize) -> Self 
            { return powd(10.0f64, exponent as f64); }

            #[inline] fn from_u64(u: u64) -> f64 
            { u as _ }

            #[inline] fn from_bits(u: u64) -> f64 
            { f64::from_bits(u) }

            #[inline] fn to_bits(self) -> u64 
            { f64::to_bits(self) }
        }

        #[inline(always)] pub fn powf(x: f32, y: f32) -> f32 
        { x.powf(y) }

        #[inline(always)] pub fn powd(x: f64, y: f64) -> f64 
        { x.powf(y) }

        pub(crate) enum FastPathRadix 
        {
            Five,
            Ten,
        }

        impl From<FastPathRadix> for u64 
        {
            fn from(radix: FastPathRadix) -> u64 
            {
                match radix 
                {
                    FastPathRadix::Five => 5,
                    FastPathRadix::Ten => 10,
                }
            }
        }

        /// Get a small, integral power-of-radix for fast-path multiplication.
        #[inline(always)] pub unsafe fn int_pow_fast_path(exponent: usize, radix: FastPathRadix) 
        -> u64 
        { return u64::from(radix).pow(exponent as u32); }
    }

    pub mod number
    {
        //! Representation of a float as the significant digits and exponent.        
        use super::
        {
            fpu::{ set_precision },
            num::{int_pow_fast_path, FastPathRadix, Float},
        };

        /// Representation of a number as the significant digits and exponent.
        #[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
        pub struct Number 
        {
            /// The exponent of the float, scaled to the mantissa.
            pub exponent: i32,
            /// The significant digits of the float.
            pub mantissa: u64,
            /// If the significant digits were truncated.
            pub many_digits: bool,
        }

        impl Number 
        {
            /// Detect if the float can be accurately reconstructed from native floats.
            #[inline] pub fn is_fast_path<F: Float>(&self) -> bool 
            {
                F::MIN_EXPONENT_FAST_PATH <= self.exponent
                && self.exponent <= F::MAX_EXPONENT_DISGUISED_FAST_PATH
                && self.mantissa <= F::MAX_MANTISSA_FAST_PATH
                && !self.many_digits
            }

            /// The fast path algorithmn using machine-sized integers and floats.
            pub fn try_fast_path<F: Float>(&self) -> Option<F> 
            {
                let _cw = set_precision::<F>();

                if self.is_fast_path::<F>() 
                {
                    let max_exponent = F::MAX_EXPONENT_FAST_PATH;
                    Some(if self.exponent <= max_exponent 
                    {
                        let value = F::from_u64(self.mantissa);
                        
                        if self.exponent < 0 
                        { value / unsafe { F::pow_fast_path((-self.exponent) as _) } }

                        else 
                        { value * unsafe { F::pow_fast_path(self.exponent as _) } }
                    }
                    
                    else 
                    {
                        let shift = self.exponent - max_exponent;
                        
                        let int_power = unsafe { int_pow_fast_path(shift as usize, FastPathRadix::Ten) };
                        let mantissa = self.mantissa.checked_mul(int_power)?;
                        if mantissa > F::MAX_MANTISSA_FAST_PATH 
                        { return None; }
                        
                        F::from_u64(mantissa) * unsafe { F::pow_fast_path(max_exponent as _) }
                    })
                }
                else 
                {
                    None
                }
            }
        }
    }

    pub mod parse
    {
        //! Parse byte iterators to float.
        use super::
        {
            bellerophon::{ bellerophon },
            extended_float::{ExtendedFloat},
            num::{Float},
            number::{Number},
            slow::{slow},
        };

        /// Try to parse the significant digits quickly.
        #[inline] fn parse_number_fast<'a, Iter1, Iter2>
        (
            integer: Iter1,
            fraction: Iter2,
            exponent: i32,
        ) -> Option<Number> where
        Iter1: Iterator<Item = &'a u8>,
        Iter2: Iterator<Item = &'a u8>,
        {
            let mut num = Number::default();
            let mut integer_count: usize = 0;
            let mut fraction_count: usize = 0;
            for &c in integer 
            {
                integer_count += 1;
                let digit = c - b'0';
                num.mantissa = num.mantissa.wrapping_mul(10).wrapping_add(digit as u64);
            }
            
            for &c in fraction 
            {
                fraction_count += 1;
                let digit = c - b'0';
                num.mantissa = num.mantissa.wrapping_mul(10).wrapping_add(digit as u64);
            }

            if integer_count + fraction_count <= 19 
            {
                num.exponent = exponent.saturating_sub(fraction_count as i32);
                Some(num)
            }

            else { None }
        }

        /// Parse the significant digits of the float and adjust the exponent.
        #[inline] fn parse_number<'a, Iter1, Iter2>(mut integer: Iter1, mut fraction: Iter2, exponent: i32) -> Number where
        Iter1: Iterator<Item = &'a u8> + Clone,
        Iter2: Iterator<Item = &'a u8> + Clone,
        {
            if let Some(num) = parse_number_fast(integer.clone(), fraction.clone(), exponent) 
            { return num; }
            
            let mut num = Number::default();
            let mut count = 0;
            while let Some(&c) = integer.next()
            {
                count += 1;
                if count == 20
                {
                    num.many_digits = true;
                    num.exponent = exponent.saturating_add(into_i32(1 + integer.count()));
                    return num;
                }
                
                else
                {
                    let digit = c - b'0';
                    num.mantissa = num.mantissa * 10 + digit as u64;
                }
            }

            // Skip leading fraction zeros.
            let mut fraction_count: usize = 0;
            if count == 0 {
                for &c in &mut fraction {
                    fraction_count += 1;
                    if c != b'0' {
                        count += 1;
                        let digit = c - b'0';
                        num.mantissa = num.mantissa * 10 + digit as u64;
                        break;
                    }
                }
            }
            for c in fraction {
                fraction_count += 1;
                count += 1;
                if count == 20 {
                    num.many_digits = true;
                    // This can't wrap, since we have at most 20 digits.
                    num.exponent = exponent.saturating_sub(fraction_count as i32 - 1);
                    return num;
                } else {
                    let digit = c - b'0';
                    num.mantissa = num.mantissa * 10 + digit as u64;
                }
            }

            // No truncated digits: easy.
            // Cannot overflow: <= 20 digits.
            num.exponent = exponent.saturating_sub(fraction_count as i32);
            num
        }

        /// Parse float from extracted float components.
        pub fn parse_float<'a, F, Iter1, Iter2>(integer: Iter1, fraction: Iter2, exponent: i32) -> F where
        F: Float,
        Iter1: Iterator<Item = &'a u8> + Clone,
        Iter2: Iterator<Item = &'a u8> + Clone,
        {
            let num = parse_number(integer.clone(), fraction.clone(), exponent);
            if let Some(value) = num.try_fast_path() 
            { return value; }
            
            let mut fp = moderate_path::<F>(&num);
            if fp.exp < 0 
            {
                fp.exp -= F::INVALID_FP;
                fp = slow::<F, _, _>(num, fp, integer, fraction);
            }

            fp.extended_to_float::<F>()
        }

        /// Wrapper for different moderate-path algorithms.
        #[inline] pub fn moderate_path<F: Float>(num: &Number) -> ExtendedFloat 
        {
            return bellerophon::<F>(num);
        }

        /// Convert usize into i32 without overflow.
        #[inline] fn into_i32(value: usize) -> i32 
        {
            if value > i32::max_value() as usize 
            { i32::max_value() }
            
            else 
            { value as i32 }
        }

        // Add digit to mantissa.
        #[inline] pub fn add_digit(value: u64, digit: u8) -> Option<u64>
        { value.checked_mul(10)?.checked_add(digit as u64) }
    }

    pub mod rounding
    {
        //! Defines rounding schemes for floating-point numbers.

        #![doc(hidden)]
        use super::
        {
            extended_float::{ExtendedFloat},
            mask::{lower_n_halfway, lower_n_mask},
            num::{Float},
        };

        // ROUNDING
        // --------
        /// Round an extended-precision float to the nearest machine float.
        pub fn round<F, Cb>(fp: &mut ExtendedFloat, cb: Cb) where
        F: Float,
        Cb: Fn(&mut ExtendedFloat, i32),
        {
            let fp_inf = ExtendedFloat 
            {
                mant: 0,
                exp: F::INFINITE_POWER,
            };
            
            let mantissa_shift = 64 - F::MANTISSA_SIZE - 1;
            if -fp.exp >= mantissa_shift 
            {
                let shift = -fp.exp + 1;
                debug_assert!(shift <= 65);
                cb(fp, shift.min(64));
                fp.exp = (fp.mant >= F::HIDDEN_BIT_MASK) as i32;
                return;
            }

            cb(fp, mantissa_shift);
            
            let carry_mask = F::CARRY_MASK;
            if fp.mant & carry_mask == carry_mask 
            {
                fp.mant >>= 1;
                fp.exp += 1;
            }
            
            if fp.exp >= F::INFINITE_POWER 
            {
                *fp = fp_inf;
                return;
            }

            fp.mant &= F::MANTISSA_MASK;
        }

        /// Shift right N-bytes and round towards a direction.
        pub fn round_nearest_tie_even<Cb>(fp: &mut ExtendedFloat, shift: i32, cb: Cb) where
        Cb: Fn(bool, bool, bool) -> bool,
        {
            debug_assert!(shift <= 64);
            
            let mask = lower_n_mask(shift as u64);
            let halfway = lower_n_halfway(shift as u64);
            let truncated_bits = fp.mant & mask;
            let is_above = truncated_bits > halfway;
            let is_halfway = truncated_bits == halfway;
            
            fp.mant = match shift == 64 
            {
                true => 0,
                false => fp.mant >> shift,
            };
            fp.exp += shift;
            
            let is_odd = fp.mant & 1 == 1;
            
            fp.mant += cb(is_odd, is_halfway, is_above) as u64;
        }

        /// Round our significant digits into place, truncating them.
        pub fn round_down(fp: &mut ExtendedFloat, shift: i32) 
        {
            fp.mant = match shift == 64
            {
                true => 0,
                false => fp.mant >> shift,
            };
            fp.exp += shift;
        }
    }

    pub mod slow
    {
        //! Slow, fallback cases where we cannot unambiguously round a float.

        use super::bigint::{Bigint, Limb, LIMB_BITS};
        use super::extended_float::{ExtendedFloat};
        use super::num::{int_pow_fast_path, FastPathRadix, Float};
        use super::number::Number;
        use super::rounding::{round, round_down, round_nearest_tie_even};
        use ::cmp;        

        /// Add a digit to the temporary value.
        macro_rules! add_digit 
        {
            ($c:ident, $value:ident, $counter:ident, $count:ident) => 
            {{
                let digit = $c - b'0';
                $value *= 10 as Limb;
                $value += digit as Limb;
                $counter += 1;
                $count += 1;
            }};
        }

        /// Add a temporary value to our mantissa.
        macro_rules! add_temporary
        {
            (@mul $result:ident, $power:expr, $value:expr) => 
            {
                $result.data.mul_small($power).unwrap();
                $result.data.add_small($value).unwrap();
            };
            
            ($format:ident, $result:ident, $counter:ident, $value:ident) => 
            {
                if $counter != 0 
                {
                    let small_power = unsafe { int_pow_fast_path($counter, FastPathRadix::Ten) };
                    add_temporary!(@mul $result, small_power as Limb, $value);
                    $counter = 0;
                    $value = 0;
                }
            };
            
            (@end $format:ident, $result:ident, $counter:ident, $value:ident) => 
            {
                if $counter != 0 
                {
                    let small_power = unsafe { int_pow_fast_path($counter, FastPathRadix::Ten) };
                    add_temporary!(@mul $result, small_power as Limb, $value);
                }
            };
            
            (@max $format:ident, $result:ident, $counter:ident, $value:ident, $max:ident) => 
            {
                add_temporary!(@mul $result, $max, $value);
                $counter = 0;
                $value = 0;
            };
        }

        /// Round-up a truncated value.
        macro_rules! round_up_truncated 
        {
            ($format:ident, $result:ident, $count:ident) => 
            {{
                add_temporary!(@mul $result, 10, 1);
                $count += 1;
            }};
        }

        /// Check and round-up the fraction if any non-zero digits exist.
        macro_rules! round_up_nonzero
        {
            ($format:ident, $iter:expr, $result:ident, $count:ident) => 
            {{
                for &digit in $iter 
                {
                    if digit != b'0' 
                    {
                        round_up_truncated!($format, $result, $count);
                        return ($result, $count);
                    }
                }
            }};
        }

        // ALGORITHM
        // ---------
        /// Parse the significant digits and biased, binary exponent of a float.
        #[inline] pub fn slow<'a, F, Iter1, Iter2>
        (
            num: Number,
            fp: ExtendedFloat,
            integer: Iter1,
            fraction: Iter2,
        ) -> ExtendedFloat where
        F: Float,
        Iter1: Iterator<Item = &'a u8> + Clone,
        Iter2: Iterator<Item = &'a u8> + Clone,
        {
            debug_assert!(fp.mant & (1 << 63) != 0);
            
            let sci_exp = scientific_exponent(&num);
            
            let (bigmant, digits) = parse_mantissa(integer, fraction, F::MAX_DIGITS);
            let exponent = sci_exp + 1 - digits as i32;
            if exponent >= 0 
            { positive_digit_comp::<F>(bigmant, exponent) }
            
            else 
            { negative_digit_comp::<F>(bigmant, fp, exponent) }
        }

        /// Generate the significant digits with a positive exponent relative to mantissa.
        pub fn positive_digit_comp<F: Float>(mut bigmant: Bigint, exponent: i32) -> ExtendedFloat 
        {
            bigmant.pow(10, exponent as u32).unwrap();

            let (mant, is_truncated) = bigmant.hi64();
            let exp = bigmant.bit_length() as i32 - 64 + F::EXPONENT_BIAS;
            let mut fp = ExtendedFloat
            {
                mant,
                exp,
            };
            
            round::<F, _>
            (
                &mut fp, 
                |f, 
                s| 
                {
                    round_nearest_tie_even
                    (
                        f, 
                        s, 
                        |is_odd, 
                        is_halfway, 
                        is_above| 
                        {
                            is_above || (is_halfway && is_truncated) || (is_odd && is_halfway)
                        }
                    );
                }
            );

            fp
        }

        /// Generate the significant digits with a negative exponent relative to mantissa.
        pub fn negative_digit_comp<F: Float>
        (
            bigmant: Bigint,
            mut fp: ExtendedFloat,
            exponent: i32,
        ) -> ExtendedFloat 
        {
            debug_assert!(fp.mant & (1 << 63) != 0);
            
            let mut real_digits = bigmant;
            let real_exp = exponent;
            debug_assert!(real_exp < 0);
            
            let mut b = fp;
            round::<F, _>(&mut b, round_down);
            let b = b.extended_to_float::<F>();
            
            let theor = bh(b);
            let mut theor_digits = Bigint::from_u64(theor.mant);
            let theor_exp = theor.exp;
            
            let binary_exp = theor_exp - real_exp;
            let halfradix_exp = -real_exp;
            if halfradix_exp != 0 
            { theor_digits.pow(5, halfradix_exp as u32).unwrap(); }
            
            if binary_exp > 0 
            { theor_digits.pow(2, binary_exp as u32).unwrap(); } 
            
            else if binary_exp < 0 
            { real_digits.pow(2, (-binary_exp) as u32).unwrap(); }
            
            let ord = real_digits.data.cmp(&theor_digits.data);
            round::<F, _>
            (
                &mut fp, 
                |f, 
                s| 
                {
                    round_nearest_tie_even
                    (
                        f, 
                        s, 
                        |is_odd, 
                        _, 
                        _| 
                        {
                            match ord
                            {
                                cmp::Ordering::Greater => true,
                                cmp::Ordering::Less => false,
                                cmp::Ordering::Equal if is_odd => true,
                                cmp::Ordering::Equal => false,
                            }
                        }
                    );
                }
            );

            fp
        }

        /// Parse the full mantissa into a big integer.
        pub fn parse_mantissa<'a, Iter1, Iter2>
        (
            mut integer: Iter1,
            mut fraction: Iter2,
            max_digits: usize,
        ) -> (Bigint, usize) where
        Iter1: Iterator<Item = &'a u8> + Clone,
        Iter2: Iterator<Item = &'a u8> + Clone,
        {
            let mut counter: usize = 0;
            let mut count: usize = 0;
            let mut value: Limb = 0;
            let mut result = Bigint::new();
            
            let step: usize = if LIMB_BITS == 32 
            { 9 }
            else { 19 };

            let max_native = (10 as Limb).pow(step as u32);
            
            'integer: loop 
            {
                while counter < step && count < max_digits 
                {
                    if let Some(&c) = integer.next()
                    {
                        add_digit!(c, value, counter, count);
                    }
                    else 
                    {
                        break 'integer;
                    }
                }
                
                if count == max_digits 
                {
                    add_temporary!(@end format, result, counter, value);
                    round_up_nonzero!(format, integer, result, count);
                    round_up_nonzero!(format, fraction, result, count);
                    return (result, count);
                }
                else
                { add_temporary!(@max format, result, counter, value, max_native); }
            }
            
            if count == 0 
            {
                for &c in &mut fraction
                {
                    if c != b'0'
                    {
                        add_digit!(c, value, counter, count);
                        break;
                    }
                }
            }
            
            'fraction: loop 
            {
                while counter < step && count < max_digits
                {
                    if let Some(&c) = fraction.next()
                    {
                        add_digit!(c, value, counter, count);
                    } 
                    else { break 'fraction; }
                }
                
                if count == max_digits 
                {
                    add_temporary!(@end format, result, counter, value);
                    round_up_nonzero!(format, fraction, result, count);
                    return (result, count);
                }
                
                else 
                {
                    add_temporary!(@max format, result, counter, value, max_native);
                }
            }

            add_temporary!(@end format, result, counter, value);
            (result, count)
        }

        /// Calculate the scientific exponent from a `Number` value.
        #[inline] pub fn scientific_exponent(num: &Number) -> i32
        {
            let mut mantissa = num.mantissa;
            let mut exponent = num.exponent;
            while mantissa >= 10000
            {
                mantissa /= 10000;
                exponent += 4;
            }
            
            while mantissa >= 100
            {
                mantissa /= 100;
                exponent += 2;
            }
            
            while mantissa >= 10
            {
                mantissa /= 10;
                exponent += 1;
            }
            
            exponent as i32
        }

        /// Calculate `b` from a a representation of `b` as a float.
        #[inline] pub fn b<F: Float>(float: F) -> ExtendedFloat
        {
            ExtendedFloat
            {
                mant: float.mantissa(),
                exp: float.exponent(),
            }
        }

        /// Calculate `b+h` from a a representation of `b` as a float.
        #[inline] pub fn bh<F: Float>(float: F) -> ExtendedFloat
        {
            let fp = b(float);
            ExtendedFloat
            {
                mant: (fp.mant << 1) + 1,
                exp: fp.exp - 1,
            }
        }
    }

    pub mod table
    {
        //! Cached exponents for basen values with 80-bit extended floats.
        use super::bellerophon::BellerophonPowers;

        // HIGH LEVEL
        // ----------
        pub const BASE10_POWERS: BellerophonPowers = BellerophonPowers 
        {
            small: &BASE10_SMALL_MANTISSA,
            large: &BASE10_LARGE_MANTISSA,
            small_int: &BASE10_SMALL_INT_POWERS,
            step: BASE10_STEP,
            bias: BASE10_BIAS,
            log2: BASE10_LOG2_MULT,
            log2_shift: BASE10_LOG2_SHIFT,
        };

        // LOW-LEVEL
        // ---------
        const BASE10_SMALL_MANTISSA: [u64; 10] = 
        [
            9223372036854775808,
            11529215046068469760,
            14411518807585587200,
            18014398509481984000,
            11258999068426240000,
            14073748835532800000,
            17592186044416000000,
            10995116277760000000,
            13743895347200000000,
            17179869184000000000,
        ];

        const BASE10_LARGE_MANTISSA: [u64; 66] = 
        [
            11555125961253852697,
            13451937075301367670,
            15660115838168849784,
            18230774251475056848,
            10611707258198326947,
            12353653155963782858,
            14381545078898527261,
            16742321987285426889,
            9745314011399999080, 
            11345038669416679861,
            13207363278391631158,
            15375394465392026070,
            17899314949046850752,
            10418772551374772303,
            12129047596099288555,
            14120069793541087484,
            16437924692338667210,
            9568131466127621947, 
            11138771039116687545,
            12967236152753102995,
            15095849699286165408,
            17573882009934360870,
            10229345649675443343,
            11908525658859223294,
            13863348470604074297,
            16139061738043178685,
            9394170331095332911, 
            10936253623915059621,
            12731474852090538039,
            14821387422376473014,
            17254365866976409468,
            10043362776618689222,
            11692013098647223345,
            13611294676837538538,
            15845632502852867518,
            9223372036854775808, 
            10737418240000000000,
            12500000000000000000,
            14551915228366851806,
            16940658945086006781,
            9860761315262647567, 
            11479437019748901445,
            13363823550460978230,
            15557538194652854267,
            18111358157653424735,
            10542197943230523224,
            12272733663244316382,
            14287342391028437277,
            16632655625031838749,
            9681479787123295682, 
            11270725851789228247,
            13120851772591970218,
            15274681817498023410,
            17782069995880619867,
            10350527006597618960,
            12049599325514420588,
            14027579833653779454,
            16330252207878254650,
            9505457831475799117, 
            11065809325636130661,
            12882297539194266616,
            14996968138956309548,
            17458768723248864463,
            10162340898095201970,
            11830521861667747109,
            13772540099066387756,
        ];

        const BASE10_SMALL_INT_POWERS: [u64; 10] =
        [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];

        const BASE10_STEP: i32 = 10;
        const BASE10_BIAS: i32 = 350;
        const BASE10_LOG2_MULT: i64 = 217706;
        const BASE10_LOG2_SHIFT: i32 = 16;
    }
    
    pub use self::num::Float;
    pub use self::parse::parse_float;
}
/*
A byte-oriented, zero-copy, parser combinators library*/
pub mod nom
{
    //! # nom, eating data byte by byte
    // Reexports
    pub use self::bits::*;
    pub use self::internal::*;
    pub use self::traits::*;
    //pub use self::str::*;

    #[macro_use]
    pub mod macros
    {
        macro_rules! succ 
        (
        (0, $submac:ident ! ($($rest:tt)*)) => ($submac!(1, $($rest)*));
        (1, $submac:ident ! ($($rest:tt)*)) => ($submac!(2, $($rest)*));
        (2, $submac:ident ! ($($rest:tt)*)) => ($submac!(3, $($rest)*));
        (3, $submac:ident ! ($($rest:tt)*)) => ($submac!(4, $($rest)*));
        (4, $submac:ident ! ($($rest:tt)*)) => ($submac!(5, $($rest)*));
        (5, $submac:ident ! ($($rest:tt)*)) => ($submac!(6, $($rest)*));
        (6, $submac:ident ! ($($rest:tt)*)) => ($submac!(7, $($rest)*));
        (7, $submac:ident ! ($($rest:tt)*)) => ($submac!(8, $($rest)*));
        (8, $submac:ident ! ($($rest:tt)*)) => ($submac!(9, $($rest)*));
        (9, $submac:ident ! ($($rest:tt)*)) => ($submac!(10, $($rest)*));
        (10, $submac:ident ! ($($rest:tt)*)) => ($submac!(11, $($rest)*));
        (11, $submac:ident ! ($($rest:tt)*)) => ($submac!(12, $($rest)*));
        (12, $submac:ident ! ($($rest:tt)*)) => ($submac!(13, $($rest)*));
        (13, $submac:ident ! ($($rest:tt)*)) => ($submac!(14, $($rest)*));
        (14, $submac:ident ! ($($rest:tt)*)) => ($submac!(15, $($rest)*));
        (15, $submac:ident ! ($($rest:tt)*)) => ($submac!(16, $($rest)*));
        (16, $submac:ident ! ($($rest:tt)*)) => ($submac!(17, $($rest)*));
        (17, $submac:ident ! ($($rest:tt)*)) => ($submac!(18, $($rest)*));
        (18, $submac:ident ! ($($rest:tt)*)) => ($submac!(19, $($rest)*));
        (19, $submac:ident ! ($($rest:tt)*)) => ($submac!(20, $($rest)*));
        (20, $submac:ident ! ($($rest:tt)*)) => ($submac!(21, $($rest)*));
        );
    }
    #[macro_use]
    pub mod error
    {
        //! Error management
        use super::internal::Parser;
        use ::fmt;

        /// Creates a parse error from a `nom::ErrorKind` and the position in the input 
        #[macro_export(local_inner_macros)]
        macro_rules! error_position
        (
            ($input:expr, $code:expr) => 
            ({
                $crate::nom::error::make_error($input, $code)
            });
        );

        /// Creates a parse error from a `nom::ErrorKind`, the position in the input 
        ///and the next error in the parsing tree.
        #[macro_export(local_inner_macros)]
        macro_rules! error_node_position
        (
            ($input:expr, $code:expr, $next:expr) => 
            ({
                $crate::nom::error::append_error($input, $code, $next)
            });
        );

        /// This trait must be implemented by the error type of a nom parser.
        pub trait ParseError<I>: Sized 
        {
            /// Creates an error from the input position and an [ErrorKind]
            fn from_error_kind(input: I, kind: ErrorKind) -> Self;

            /// Combines an existing error with a new one created from the input position and an [ErrorKind].
            fn append(input: I, kind: ErrorKind, other: Self) -> Self;

            /// Creates an error from an input position and an expected character
            fn from_char(input: I, _: char) -> Self 
            { Self::from_error_kind(input, ErrorKind::Char) }

            /// Combines two existing errors.
            fn or(self, other: Self) -> Self
            { other }
        }

        /// This trait is required by the `context` combinator to add a static string to an existing error
        pub trait ContextError<I>: Sized 
        {
            /// Creates a new error from an input position, a static string and an existing error.
            fn add_context(_input: I, _ctx: &'static str, other: Self) -> Self 
            {
                other
            }
        }

        /// Required by the `map_res` combinator to integrate error types from external functions.
        pub trait FromExternalError<I, E> 
        {
            /// Creates a new error from an input position, an [ErrorKind] indicating the wrapping parser, 
            /// and an external error.
            fn from_external_error(input: I, kind: ErrorKind, e: E) -> Self;
        }

        /// default error type, only contains the error' location and code
        #[derive(Debug, PartialEq)]
        pub struct Error<I> 
        {
            /// position of the error in the input data
            pub input: I,
            /// nom error code
            pub code: ErrorKind,
        }

        impl<I> Error<I> 
        {
            /// creates a new basic error
            pub fn new(input: I, code: ErrorKind) -> Error<I> 
            { Error { input, code } }
        }

        impl<I> ParseError<I> for Error<I> 
        {
            fn from_error_kind(input: I, kind: ErrorKind) -> Self
            { Error { input, code: kind } }

            fn append(_: I, _: ErrorKind, other: Self) -> Self 
            { other }
        }

        impl<I> ContextError<I> for Error<I> {}

        impl<I, E> FromExternalError<I, E> for Error<I>
        {
            /// Create a new error from an input position and an external error
            fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self
            { Error { input, code: kind } }
        }

        /// The Display implementation allows the std::error::Error implementation
        impl<I: fmt::Display> fmt::Display for Error<I> 
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
            { write!(f, "error {:?} at: {}", self.code, self.input) }
        }
        
        impl<I: fmt::Debug + fmt::Display> std::error::Error for Error<I> {}

        // Backward compatibility, keep those trait impls for the previously used error type
        impl<I> ParseError<I> for (I, ErrorKind)
        {
            fn from_error_kind(input: I, kind: ErrorKind) -> Self
            { (input, kind) }

            fn append(_: I, _: ErrorKind, other: Self) -> Self
            { other }
        }

        impl<I> ContextError<I> for (I, ErrorKind) {}

        impl<I, E> FromExternalError<I, E> for (I, ErrorKind) 
        {
            fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self
            { (input, kind) }
        }

        impl<I> ParseError<I> for () 
        {
            fn from_error_kind(_: I, _: ErrorKind) -> Self {}

            fn append(_: I, _: ErrorKind, _: Self) -> Self {}
        }

        impl<I> ContextError<I> for () {}

        impl<I, E> FromExternalError<I, E> for () 
        {
            fn from_external_error(_input: I, _kind: ErrorKind, _e: E) -> Self {}
        }

        /// Creates an error from the input position and an [ErrorKind]
        pub fn make_error<I, E: ParseError<I>>(input: I, kind: ErrorKind) -> E 
        {
            E::from_error_kind(input, kind)
        }

        /// Combines an existing error with a new one created from the input position and an [ErrorKind].
        pub fn append_error<I, E: ParseError<I>>(input: I, kind: ErrorKind, other: E) -> E 
        {
            E::append(input, kind, other)
        }

        /// This error type accumulates errors and their position when backtracking through a parse tree.
        #[derive(Clone, Debug, PartialEq)]
        pub struct VerboseError<I> 
        {
            /// List of errors accumulated by `VerboseError`, containing the affected
            /// part of input data, and some context
            pub errors: super::lib::std::vec::Vec<(I, VerboseErrorKind)>,
        }
        
        #[derive(Clone, Debug, PartialEq)]
        /// Error context for `VerboseError`
        pub enum VerboseErrorKind 
        {
            /// Static string added by the `context` function
            Context(&'static str),
            /// Indicates which character was expected by the `char` function
            Char(char),
            /// Error kind given by various nom parsers
            Nom(ErrorKind),
        }
        
        impl<I> ParseError<I> for VerboseError<I> 
        {
            fn from_error_kind(input: I, kind: ErrorKind) -> Self
            {
                VerboseError 
                {
                    errors: vec![(input, VerboseErrorKind::Nom(kind))],
                }
            }

            fn append(input: I, kind: ErrorKind, mut other: Self) -> Self
             {
                other.errors.push((input, VerboseErrorKind::Nom(kind)));
                other
            }

            fn from_char(input: I, c: char) -> Self
            {
                VerboseError
                {
                    errors: vec![(input, VerboseErrorKind::Char(c))],
                }
            }
        }
        
        impl<I> ContextError<I> for VerboseError<I> 
        {
            fn add_context(input: I, ctx: &'static str, mut other: Self) -> Self
            {
                other.errors.push((input, VerboseErrorKind::Context(ctx)));
                other
            }
        }
        
        impl<I, E> FromExternalError<I, E> for VerboseError<I> 
        {
            /// Create a new error from an input position and an external error
            fn from_external_error(input: I, kind: ErrorKind, _e: E) -> Self
            {
                Self::from_error_kind(input, kind)
            }
        }
        
        impl<I: fmt::Display> fmt::Display for VerboseError<I>
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
            {
                writeln!(f, "Parse error:")?;
                for (input, error) in &self.errors 
                {
                    match error
                    {
                        VerboseErrorKind::Nom(e) => writeln!(f, "{:?} at: {}", e, input)?,
                        VerboseErrorKind::Char(c) => writeln!(f, "expected '{}' at: {}", c, input)?,
                        VerboseErrorKind::Context(s) => writeln!(f, "in section '{}', at: {}", s, input)?,
                    }
                }

                Ok(())
            }
        }
        
        impl<I: fmt::Debug + fmt::Display> std::error::Error for VerboseError<I> {}

        use super::internal::{Err, IResult};

        /// Create a new error from an input position, a static string and an existing error.
        pub fn context<I: Clone, E: ContextError<I>, F, O>
        ( 
            context: &'static str, 
            mut f: F, 
        ) -> impl FnMut(I) -> IResult<I, O, E> where
        F: Parser<I, O, E>,
        {
            move |i: I| match f.parse(i.clone()) 
            {
                Ok(o) => Ok(o),
                Err(Err::Incomplete(i)) => Err(Err::Incomplete(i)),
                Err(Err::Error(e)) => Err(Err::Error(E::add_context(i, context, e))),
                Err(Err::Failure(e)) => Err(Err::Failure(E::add_context(i, context, e))),
            }
        }

        /// Transforms a `VerboseError` into a trace with input position information.
        pub fn convert_error<I: core::ops::Deref<Target = str>>
        (
            input: I,
            e: VerboseError<I>,
        ) -> ::String 
        {
            use ::fmt::Write;
            use super::traits::Offset;

            let mut result = String::new();

            for (i, (substring, kind)) in e.errors.iter().enumerate() 
            {
                let offset = input.offset(substring);

                if input.is_empty() 
                {
                    match kind
                    {
                        VerboseErrorKind::Char(c) => 
                        {
                            write!(&mut result, "{}: expected '{}', got empty input\n\n", i, c)
                        }
                        VerboseErrorKind::Context(s) => write!(&mut result, "{}: in {}, got empty input\n\n", i, s),
                        VerboseErrorKind::Nom(e) => write!(&mut result, "{}: in {:?}, got empty input\n\n", i, e),
                    }
                }

                else 
                {
                    let prefix = &input.as_bytes()[..offset];
                    
                    let line_number = prefix.iter().filter(|&&b| b == b'\n').count() + 1;
                    
                    let line_begin = prefix
                    .iter()
                    .rev()
                    .position(|&b| b == b'\n')
                    .map(|pos| offset - pos)
                    .unwrap_or(0);
                    
                    let line = input[line_begin..]
                    .lines()
                    .next()
                    .unwrap_or(&input[line_begin..])
                    .trim_end();
                    
                    let column_number = line.offset(substring) + 1;
                    
                    match kind 
                    {
                        VerboseErrorKind::Char(c) =>
                        {
                            if let Some(actual) = substring.chars().next()
                            {
                                write!
                                (
                                    &mut result,
                                    "{i}: at line {line_number}:\n\
                                    {line}\n\
                                    {caret:>column$}\n\
                                    expected '{expected}', found {actual}\n\n",
                                    i = i,
                                    line_number = line_number,
                                    line = line,
                                    caret = '^',
                                    column = column_number,
                                    expected = c,
                                    actual = actual,
                                )
                            } 
                            
                            else 
                            {
                                write!
                                (
                                    &mut result,
                                    "{i}: at line {line_number}:\n\
                                    {line}\n\
                                    {caret:>column$}\n\
                                    expected '{expected}', got end of input\n\n",
                                    i = i,
                                    line_number = line_number,
                                    line = line,
                                    caret = '^',
                                    column = column_number,
                                    expected = c,
                                )
                            }
                        }
                        
                        VerboseErrorKind::Context(s) => 
                        write!
                        (
                            &mut result,
                            "{i}: at line {line_number}, in {context}:\n\
                                {line}\n\
                                {caret:>column$}\n\n",
                            i = i,
                            line_number = line_number,
                            context = s,
                            line = line,
                            caret = '^',
                            column = column_number,
                        ),

                        VerboseErrorKind::Nom(e) => write!
                        (
                            &mut result,
                            "{i}: at line {line_number}, in {nom_err:?}:\n\
                                {line}\n\
                                {caret:>column$}\n\n",
                            i = i,
                            line_number = line_number,
                            nom_err = e,
                            line = line,
                            caret = '^',
                            column = column_number,
                        ),
                    }
                }
                .unwrap();
            }

            result
        }

        /// Indicates which parser returned an error
        #[derive(Debug,PartialEq,Eq,Hash,Clone,Copy)]
        pub enum ErrorKind 
        {
            Tag,
            MapRes,
            MapOpt,
            Alt,
            IsNot,
            IsA,
            SeparatedList,
            SeparatedNonEmptyList,
            Many0,
            Many1,
            ManyTill,
            Count,
            TakeUntil,
            LengthValue,
            TagClosure,
            Alpha,
            Digit,
            HexDigit,
            OctDigit,
            AlphaNumeric,
            Space,
            MultiSpace,
            LengthValueFn,
            Eof,
            Switch,
            TagBits,
            OneOf,
            NoneOf,
            Char,
            CrLf,
            RegexpMatch,
            RegexpMatches,
            RegexpFind,
            RegexpCapture,
            RegexpCaptures,
            TakeWhile1,
            Complete,
            Fix,
            Escaped,
            EscapedTransform,
            NonEmpty,
            ManyMN,
            Not,
            Permutation,
            Verify,
            TakeTill1,
            TakeWhileMN,
            TooLarge,
            Many0Count,
            Many1Count,
            Float,
            Satisfy,
            Fail,
        }
        
        /// Converts an ErrorKind to a number
        pub fn error_to_u32(e: &ErrorKind) -> u32 
        {
            match *e
            {
                ErrorKind::Tag                       => 1,
                ErrorKind::MapRes                    => 2,
                ErrorKind::MapOpt                    => 3,
                ErrorKind::Alt                       => 4,
                ErrorKind::IsNot                     => 5,
                ErrorKind::IsA                       => 6,
                ErrorKind::SeparatedList             => 7,
                ErrorKind::SeparatedNonEmptyList     => 8,
                ErrorKind::Many1                     => 9,
                ErrorKind::Count                     => 10,
                ErrorKind::TakeUntil                 => 12,
                ErrorKind::LengthValue               => 15,
                ErrorKind::TagClosure                => 16,
                ErrorKind::Alpha                     => 17,
                ErrorKind::Digit                     => 18,
                ErrorKind::AlphaNumeric              => 19,
                ErrorKind::Space                     => 20,
                ErrorKind::MultiSpace                => 21,
                ErrorKind::LengthValueFn             => 22,
                ErrorKind::Eof                       => 23,
                ErrorKind::Switch                    => 27,
                ErrorKind::TagBits                   => 28,
                ErrorKind::OneOf                     => 29,
                ErrorKind::NoneOf                    => 30,
                ErrorKind::Char                      => 40,
                ErrorKind::CrLf                      => 41,
                ErrorKind::RegexpMatch               => 42,
                ErrorKind::RegexpMatches             => 43,
                ErrorKind::RegexpFind                => 44,
                ErrorKind::RegexpCapture             => 45,
                ErrorKind::RegexpCaptures            => 46,
                ErrorKind::TakeWhile1                => 47,
                ErrorKind::Complete                  => 48,
                ErrorKind::Fix                       => 49,
                ErrorKind::Escaped                   => 50,
                ErrorKind::EscapedTransform          => 51,
                ErrorKind::NonEmpty                  => 56,
                ErrorKind::ManyMN                    => 57,
                ErrorKind::HexDigit                  => 59,
                ErrorKind::OctDigit                  => 61,
                ErrorKind::Many0                     => 62,
                ErrorKind::Not                       => 63,
                ErrorKind::Permutation               => 64,
                ErrorKind::ManyTill                  => 65,
                ErrorKind::Verify                    => 66,
                ErrorKind::TakeTill1                 => 67,
                ErrorKind::TakeWhileMN               => 69,
                ErrorKind::TooLarge                  => 70,
                ErrorKind::Many0Count                => 71,
                ErrorKind::Many1Count                => 72,
                ErrorKind::Float                     => 73,
                ErrorKind::Satisfy                   => 74,
                ErrorKind::Fail                      => 75,
            }
        }

        impl ErrorKind 
        { 
            /// Converts an ErrorKind to a text description
            pub fn description(&self) -> &str 
            {
                match *self
                {
                    ErrorKind::Tag                       => "Tag",
                    ErrorKind::MapRes                    => "Map on Result",
                    ErrorKind::MapOpt                    => "Map on Option",
                    ErrorKind::Alt                       => "Alternative",
                    ErrorKind::IsNot                     => "IsNot",
                    ErrorKind::IsA                       => "IsA",
                    ErrorKind::SeparatedList             => "Separated list",
                    ErrorKind::SeparatedNonEmptyList     => "Separated non empty list",
                    ErrorKind::Many0                     => "Many0",
                    ErrorKind::Many1                     => "Many1",
                    ErrorKind::Count                     => "Count",
                    ErrorKind::TakeUntil                 => "Take until",
                    ErrorKind::LengthValue               => "Length followed by value",
                    ErrorKind::TagClosure                => "Tag closure",
                    ErrorKind::Alpha                     => "Alphabetic",
                    ErrorKind::Digit                     => "Digit",
                    ErrorKind::AlphaNumeric              => "AlphaNumeric",
                    ErrorKind::Space                     => "Space",
                    ErrorKind::MultiSpace                => "Multiple spaces",
                    ErrorKind::LengthValueFn             => "LengthValueFn",
                    ErrorKind::Eof                       => "End of file",
                    ErrorKind::Switch                    => "Switch",
                    ErrorKind::TagBits                   => "Tag on bitstream",
                    ErrorKind::OneOf                     => "OneOf",
                    ErrorKind::NoneOf                    => "NoneOf",
                    ErrorKind::Char                      => "Char",
                    ErrorKind::CrLf                      => "CrLf",
                    ErrorKind::RegexpMatch               => "RegexpMatch",
                    ErrorKind::RegexpMatches             => "RegexpMatches",
                    ErrorKind::RegexpFind                => "RegexpFind",
                    ErrorKind::RegexpCapture             => "RegexpCapture",
                    ErrorKind::RegexpCaptures            => "RegexpCaptures",
                    ErrorKind::TakeWhile1                => "TakeWhile1",
                    ErrorKind::Complete                  => "Complete",
                    ErrorKind::Fix                       => "Fix",
                    ErrorKind::Escaped                   => "Escaped",
                    ErrorKind::EscapedTransform          => "EscapedTransform",
                    ErrorKind::NonEmpty                  => "NonEmpty",
                    ErrorKind::ManyMN                    => "Many(m, n)",
                    ErrorKind::HexDigit                  => "Hexadecimal Digit",
                    ErrorKind::OctDigit                  => "Octal digit",
                    ErrorKind::Not                       => "Negation",
                    ErrorKind::Permutation               => "Permutation",
                    ErrorKind::ManyTill                  => "ManyTill",
                    ErrorKind::Verify                    => "predicate verification",
                    ErrorKind::TakeTill1                 => "TakeTill1",
                    ErrorKind::TakeWhileMN               => "TakeWhileMN",
                    ErrorKind::TooLarge                  => "Needed data size is too large",
                    ErrorKind::Many0Count                => "Count occurrence of >=0 patterns",
                    ErrorKind::Many1Count                => "Count occurrence of >=1 patterns",
                    ErrorKind::Float                     => "Float",
                    ErrorKind::Satisfy                   => "Satisfy",
                    ErrorKind::Fail                      => "Fail",
                }
            }
        }

        /// Prints a message and the input if the parser fails.        
        pub fn dbg_dmp<'a, F, O, E: std::fmt::Debug>
        (
            f: F,
            context: &'static str,
        ) -> impl Fn(&'a [u8]) -> IResult<&'a [u8], O, E> where
        F: Fn(&'a [u8]) -> IResult<&'a [u8], O, E>,
        {
            use super::HexDisplay;
            move |i: &'a [u8]| match f(i) 
            {
                Err(e) => {
                println!("{}: Error({:?}) at:\n{}", context, e, i.to_hex(8));
                Err(e)
                }
                a => a,
            }
        }
    }
    /*
    */
    pub mod branch
    {
        //! Choice combinators 
        use super::error::ErrorKind;
        use super::error::ParseError;
        use super::internal::{Err, IResult, Parser};

        macro_rules! alt_trait
        (
            ($first:ident $second:ident $($id: ident)+) => 
            (
                alt_trait!(__impl $first $second; $($id)+);
            );
            
            (__impl $($current:ident)*; $head:ident $($id: ident)+) => 
            (
                alt_trait_impl!($($current)*);
                alt_trait!(__impl $($current)* $head; $($id)+);
            );

            (__impl $($current:ident)*; $head:ident) => 
            (
                alt_trait_impl!($($current)*);
                alt_trait_impl!($($current)* $head);
            );
        );

        macro_rules! alt_trait_impl
        (
            ($($id:ident)+) => 
            (
                impl<
                Input: Clone, Output, Error: ParseError<Input>,
                $($id: Parser<Input, Output, Error>),+
                > Alt<Input, Output, Error> for ( $($id),+ )
                {
                    fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>
                    {
                        match self.0.parse(input.clone())
                        {
                            Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),
                            res => res,
                        }
                    }
                }
            );
        );

        macro_rules! alt_trait_inner
        (
            ($it:tt, $self:expr, $input:expr, $err:expr, $head:ident $($id:ident)+) => 
            (
                match $self.$it.parse($input.clone())
                {
                    Err(Err::Error(e)) =>
                    {
                        let err = $err.or(e);
                        succ!($it, alt_trait_inner!($self, $input, err, $($id)+))
                    }
                    res => res,
                }
            );

            ($it:tt, $self:expr, $input:expr, $err:expr, $head:ident) =>
            (
                Err(Err::Error(Error::append($input, ErrorKind::Alt, $err)))
            );
        );

        macro_rules! permutation_trait
        (
            (
                $name1:ident $ty1:ident $item1:ident
                $name2:ident $ty2:ident $item2:ident
                $($name3:ident $ty3:ident $item3:ident)*
            ) =>
            (
                permutation_trait!(__impl $name1 $ty1 $item1, $name2 $ty2 $item2; $($name3 $ty3 $item3)*);
            );
            (
                __impl $($name:ident $ty:ident $item:ident),+;
                $name1:ident $ty1:ident $item1:ident $($name2:ident $ty2:ident $item2:ident)*
            ) => (
                permutation_trait_impl!($($name $ty $item),+);
                permutation_trait!(__impl $($name $ty $item),+ , $name1 $ty1 $item1; $($name2 $ty2 $item2)*);
            );
            (__impl $($name:ident $ty:ident $item:ident),+;) => (
                permutation_trait_impl!($($name $ty $item),+);
            );
        );

        macro_rules! permutation_trait_impl
        (
            ($($name:ident $ty:ident $item:ident),+) =>
            (
                impl<
                Input: Clone, $($ty),+ , Error: ParseError<Input>,
                $($name: Parser<Input, $ty, Error>),+
                > Permutation<Input, ( $($ty),+ ), Error> for ( $($name),+ )
                {
                    fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error> 
                    {
                        let mut res = ($(Option::<$ty>::None),+);
                        loop 
                        {
                            let mut err: Option<Error> = None;
                            permutation_trait_inner!(0, self, input, res, err, $($name)+);
                            
                            if let Some(err) = err
                            {
                                return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err)));
                            }
                            
                            match res
                            {
                                ($(Some($item)),+) => return Ok((input, ($($item),+))),
                                _ => unreachable!(),
                            }
                        }
                    }
                }
            );
        );

        macro_rules! permutation_trait_inner
        (
            ($it:tt, $self:expr, $input:ident, $res:expr, $err:expr, $head:ident $($id:ident)*) => (
                if $res.$it.is_none() {
                match $self.$it.parse($input.clone()) {
                    Ok((i, o)) => {
                    $input = i;
                    $res.$it = Some(o);
                    continue;
                    }
                    Err(Err::Error(e)) => {
                    $err = Some(match $err {
                        Some(err) => err.or(e),
                        None => e,
                    });
                    }
                    Err(e) => return Err(e),
                };
                }
                succ!($it, permutation_trait_inner!($self, $input, $res, $err, $($id)*));
            );
            ($it:tt, $self:expr, $input:ident, $res:expr, $err:expr,) => ();
        );

        /// Helper trait for the [alt()] combinator.
        pub trait Alt<I, O, E> 
        {
            /// Tests each parser in the tuple and returns the result of the first one that succeeds
            fn choice(&mut self, input: I) -> IResult<I, O, E>;
        }

        /// Tests a list of parsers one by one until one succeeds.
        pub fn alt<I: Clone, O, E: ParseError<I>, List: Alt<I, O, E>>
        (
            mut l: List,
        ) -> impl FnMut(I) -> IResult<I, O, E> 
        {
            move |i: I| l.choice(i)
        }

        /// Helper trait for the [permutation()] combinator.
        pub trait Permutation<I, O, E> 
        {
            /// Tries to apply all parsers in the tuple in various orders until all of them succeed
            fn permutation(&mut self, input: I) -> IResult<I, O, E>;
        }

        /// Applies a list of parsers in any order.
        pub fn permutation<I: Clone, O, E: ParseError<I>, List: Permutation<I, O, E>>
        (
            mut l: List,
        ) -> impl FnMut(I) -> IResult<I, O, E> 
        {
            move |i: I| l.permutation(i)
        }

        alt_trait!(A B C D E F G H I J K L M N O P Q R S T U);

        // Manually implement Alt for (A,), the 1-tuple type
        impl<Input, Output, Error: ParseError<Input>, A: Parser<Input, Output, Error>>
        Alt<Input, Output, Error> for (A,)
        {
            fn choice(&mut self, input: Input) -> IResult<Input, Output, Error> {
                self.0.parse(input)
            }
        }

        permutation_trait!
        (
            FnA A a
            FnB B b
            FnC C c
            FnD D d
            FnE E e
            FnF F f
            FnG G g
            FnH H h
            FnI I i
            FnJ J j
            FnK K k
            FnL L l
            FnM M m
            FnN N n
            FnO O o
            FnP P p
            FnQ Q q
            FnR R r
            FnS S s
            FnT T t
            FnU U u
        );
    }
    /*
    */
    pub mod combinator
    {
        //! General purpose combinators
        use super::lib::std::boxed::Box;

        use super::error::{ErrorKind, FromExternalError, ParseError};
        use super::internal::*;
        use super::lib::std::borrow::Borrow;
        use super::lib::std::convert::Into;
        use super::lib::std::fmt::Debug;
        use super::lib::std::mem::transmute;
        use super::lib::std::ops::{Range, RangeFrom, RangeTo};
        use super::traits::{AsChar, InputIter, InputLength, InputTakeAtPosition, ParseTo};
        use super::traits::{Compare, CompareResult, Offset, Slice};
        
        /// Return the remaining input.
        #[inline]
        pub fn rest<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
        T: Slice<RangeFrom<usize>>,
        T: InputLength,
        {
            Ok((input.slice(input.input_len()..), input))
        }

        /// Return the length of the remaining input.
        #[inline]
        pub fn rest_len<T, E: ParseError<T>>(input: T) -> IResult<T, usize, E> where
        T: InputLength,
        {
            let len = input.input_len();
            Ok((input, len))
        }

        /// Maps a function on the result of a parser.
        pub fn map<I, O1, O2, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: FnMut(O1) -> O2,
        {
            move |input: I| {
                let (input, o1) = parser.parse(input)?;
                Ok((input, f(o1)))
            }
        }

        /// Applies a function returning a `Result` over the result of a parser.
        pub fn map_res<I: Clone, O1, O2, E: FromExternalError<I, E2>, E2, F, G>
        (
            mut parser: F,
            mut f: G,
        ) -> impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: FnMut(O1) -> Result<O2, E2>,
        {
            move |input: I| {
                let i = input.clone();
                let (input, o1) = parser.parse(input)?;
                match f(o1) {
                Ok(o2) => Ok((input, o2)),
                Err(e) => Err(Err::Error(E::from_external_error(i, ErrorKind::MapRes, e))),
                }
            }
        }

        /// Applies a function returning an `Option` over the result of a parser.
        pub fn map_opt<I: Clone, O1, O2, E: ParseError<I>, F, G>
        (
            mut parser: F,
            mut f: G,
        ) -> impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: FnMut(O1) -> Option<O2>,
        {
            move |input: I| {
                let i = input.clone();
                let (input, o1) = parser.parse(input)?;
                match f(o1) {
                Some(o2) => Ok((input, o2)),
                None => Err(Err::Error(E::from_error_kind(i, ErrorKind::MapOpt))),
                }
            }
        }

        /// Applies a parser over the result of another one.
        pub fn map_parser<I, O1, O2, E: ParseError<I>, F, G>
        (
            mut parser: F,
            mut applied_parser: G,
        ) -> impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: Parser<O1, O2, E>,
        {
            move |input: I| {
                let (input, o1) = parser.parse(input)?;
                let (_, o2) = applied_parser.parse(o1)?;
                Ok((input, o2))
            }
        }

        /// Creates a new parser from the output of the first parser, then apply that parser over the rest of the input.
        pub fn flat_map<I, O1, O2, E: ParseError<I>, F, G, H>
        (
            mut parser: F,
            mut applied_parser: G,
        ) -> impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: FnMut(O1) -> H,
        H: Parser<I, O2, E>,
        {
            move |input: I| {
                let (input, o1) = parser.parse(input)?;
                applied_parser(o1).parse(input)
            }
        }

        /// Optional parser, will return `None` on [`Err::Error`].
        pub fn opt<I: Clone, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, Option<O>, E> where
        F: Parser<I, O, E>,
        {
            move |input: I| {
                let i = input.clone();
                match f.parse(input) {
                Ok((i, o)) => Ok((i, Some(o))),
                Err(Err::Error(_)) => Ok((i, None)),
                Err(e) => Err(e),
                }
            }
        }

        /// Calls the parser if the condition is met.
        pub fn cond<I, O, E: ParseError<I>, F>
        (
            b: bool,
            mut f: F,
        ) -> impl FnMut(I) -> IResult<I, Option<O>, E> where
        F: Parser<I, O, E>,
        {
            move |input: I| {
                if b {
                match f.parse(input) {
                    Ok((i, o)) => Ok((i, Some(o))),
                    Err(e) => Err(e),
                }
                } else {
                Ok((input, None))
                }
            }
        }

        /// Tries to apply its parser without consuming the input.
        pub fn peek<I: Clone, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, O, E> where
        F: Parser<I, O, E>,
        {
            move |input: I| {
                let i = input.clone();
                match f.parse(input) {
                Ok((_, o)) => Ok((i, o)),
                Err(e) => Err(e),
                }
            }
        }

        /// Returns its input if it is at the end of input data
        pub fn eof<I: InputLength + Clone, E: ParseError<I>>(input: I) -> IResult<I, I, E> 
        {
            if input.input_len() == 0 {
                let clone = input.clone();
                Ok((input, clone))
            } else {
                Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof)))
            }
        }

        /// Transforms Incomplete into `Error`.
        pub fn complete<I: Clone, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, O, E> where
        F: Parser<I, O, E>,
        {
            move |input: I| {
                let i = input.clone();
                match f.parse(input) {
                Err(Err::Incomplete(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Complete))),
                rest => rest,
                }
            }
        }

        /// Succeeds if all the input has been consumed by its child parser.
        pub fn all_consuming<I, O, E: ParseError<I>, F>(mut f: F) -> impl FnMut(I) -> IResult<I, O, E> where
        I: InputLength,
        F: Parser<I, O, E>,
        {
            move |input: I| {
                let (input, res) = f.parse(input)?;
                if input.input_len() == 0 {
                Ok((input, res))
                } else {
                Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof)))
                }
            }
        }

        /// Returns the result of the child parser if it satisfies a verification function.
        pub fn verify<I: Clone, O1, O2, E: ParseError<I>, F, G>
        (
            mut first: F,
            second: G,
        ) -> impl FnMut(I) -> IResult<I, O1, E> where
        F: Parser<I, O1, E>,
        G: Fn(&O2) -> bool,
        O1: Borrow<O2>,
        O2: ?Sized,
        {
            move |input: I| {
                let i = input.clone();
                let (input, o) = first.parse(input)?;

                if second(o.borrow()) {
                Ok((input, o))
                } else {
                Err(Err::Error(E::from_error_kind(i, ErrorKind::Verify)))
                }
            }
        }

        /// Returns the provided value if the child parser succeeds.
        pub fn value<I, O1: Clone, O2, E: ParseError<I>, F>
        (
            val: O1,
            mut parser: F,
        ) -> impl FnMut(I) -> IResult<I, O1, E> where
        F: Parser<I, O2, E>,
        {
            move |input: I| parser.parse(input).map(|(i, _)| (i, val.clone()))
        }

        /// Succeeds if the child parser returns an error.
        pub fn not<I: Clone, O, E: ParseError<I>, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, (), E> where
        F: Parser<I, O, E>,
        {
            move |input: I| {
                let i = input.clone();
                match parser.parse(input) {
                Ok(_) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Not))),
                Err(Err::Error(_)) => Ok((i, ())),
                Err(e) => Err(e),
                }
            }
        }

        /// If the child parser was successful, return the consumed input as produced value.
        pub fn recognize<I: Clone + Offset + Slice<RangeTo<usize>>, O, E: ParseError<I>, F>(
        mut parser: F,
        ) -> impl FnMut(I) -> IResult<I, I, E> where
        F: Parser<I, O, E>,
        {
            move |input: I| {
                let i = input.clone();
                match parser.parse(i) {
                Ok((i, _)) => {
                    let index = input.offset(&i);
                    Ok((i, input.slice(..index)))
                }
                Err(e) => Err(e),
                }
            }
        }

        /// The child parser was successful, so return the consumed input with the output as a tuple.
        pub fn consumed<I, O, F, E>(mut parser: F) -> impl FnMut(I) -> IResult<I, (I, O), E> where
        I: Clone + Offset + Slice<RangeTo<usize>>,
        E: ParseError<I>,
        F: Parser<I, O, E>,
        {
            move |input: I| {
                let i = input.clone();
                match parser.parse(i) {
                Ok((remaining, result)) => {
                    let index = input.offset(&remaining);
                    let consumed = input.slice(..index);
                    Ok((remaining, (consumed, result)))
                }
                Err(e) => Err(e),
                }
            }
        }

        /// Transforms an [`Err::Error`] (recoverable) to [`Err::Failure`] (unrecoverable)
        pub fn cut<I, O, E: ParseError<I>, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, O, E> where
        F: Parser<I, O, E>,
        {
            move |input: I| match parser.parse(input) {
                Err(Err::Error(e)) => Err(Err::Failure(e)),
                rest => rest,
            }
        }

        /// Automatically converts the child parser's result to another type.
        pub fn into<I, O1, O2, E1, E2, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, O2, E2> where
        O1: Into<O2>,
        E1: Into<E2>,
        E1: ParseError<I>,
        E2: ParseError<I>,
        F: Parser<I, O1, E1>,
        {
            move |input: I| match parser.parse(input) {
                Ok((i, o)) => Ok((i, o.into())),
                Err(Err::Error(e)) => Err(Err::Error(e.into())),
                Err(Err::Failure(e)) => Err(Err::Failure(e.into())),
                Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),
            }
        }

        /// Creates an iterator from input data and a parser.
        pub fn iterator<Input, Output, Error, F>(input: Input, f: F) -> ParserIterator<Input, Error, F> where
        F: Parser<Input, Output, Error>,
        Error: ParseError<Input>,
        {
            ParserIterator {
                iterator: f,
                input,
                state: Some(State::Running),
            }
        }

        /// Main structure associated to the [iterator] function.
        pub struct ParserIterator<I, E, F> 
        {
            iterator: F,
            input: I,
            state: Option<State<E>>,
        }

        impl<I: Clone, E, F> ParserIterator<I, E, F> 
        {
            /// Returns the remaining input if parsing was successful, or the error if we encountered an error.
            pub fn finish(mut self) -> IResult<I, (), E> {
                match self.state.take().unwrap() {
                State::Running | State::Done => Ok((self.input, ())),
                State::Failure(e) => Err(Err::Failure(e)),
                State::Incomplete(i) => Err(Err::Incomplete(i)),
                }
            }
        }

        impl<'a, Input, Output, Error, F> core::iter::Iterator for &'a mut ParserIterator<Input, Error, F> where
        F: FnMut(Input) -> IResult<Input, Output, Error>,
        Input: Clone,
        {
            type Item = Output;

            fn next(&mut self) -> Option<Self::Item> {
                if let State::Running = self.state.take().unwrap() {
                let input = self.input.clone();

                match (self.iterator)(input) {
                    Ok((i, o)) => {
                    self.input = i;
                    self.state = Some(State::Running);
                    Some(o)
                    }
                    Err(Err::Error(_)) => {
                    self.state = Some(State::Done);
                    None
                    }
                    Err(Err::Failure(e)) => {
                    self.state = Some(State::Failure(e));
                    None
                    }
                    Err(Err::Incomplete(i)) => {
                    self.state = Some(State::Incomplete(i));
                    None
                    }
                }
                } else {
                None
                }
            }
        }

        enum State<E> 
        {
            Running,
            Done,
            Failure(E),
            Incomplete(Needed),
        }

        /// A parser which always succeeds with given value without consuming any input.
        pub fn success<I, O: Clone, E: ParseError<I>>(val: O) -> impl Fn(I) -> IResult<I, O, E> 
        {
            move |input: I| Ok((input, val.clone()))
        }

        /// A parser which always fails.
        pub fn fail<I, O, E: ParseError<I>>(i: I) -> IResult<I, O, E> 
        {
            Err(Err::Error(E::from_error_kind(i, ErrorKind::Fail)))
        }
    }
    /*
    */
    pub mod internal
    {
        //! Basic types to build the parsers
        use self::Needed::*;
        use super::error::{self, ErrorKind};
        use super::lib::std::fmt;
        use std::num::NonZeroUsize;

        /// Holds the result of parsing functions.
        pub type IResult<I, O, E = error::Error<I>> = Result<(I, O), Err<E>>;

        /// Helper trait to convert a parser's result to a more manageable type
        pub trait Finish<I, O, E> 
        {
            /// Converts the parser's result to a type that is more consumable by error management libraries.
            fn finish(self) -> Result<(I, O), E>;
        }

        impl<I, O, E> Finish<I, O, E> for IResult<I, O, E> 
        {
            fn finish(self) -> Result<(I, O), E> 
            {
                match self 
                {
                    Ok(res) => Ok(res),
                    Err(Err::Error(e)) | Err(Err::Failure(e)) => Err(e),
                    Err(Err::Incomplete(_)) => {
                        panic!("Cannot call `finish()` on `Err(Err::Incomplete(_))`: this result means that the parser does not have enough data to decide, you should gather more data and try to reapply  the parser instead")
                    }
                }
            }
        }

        /// Contains information on needed data if a parser returned `Incomplete`
        #[derive(Debug, PartialEq, Eq, Clone, Copy)] 
        pub enum Needed 
        {
            /// Needs more data, but we do not know how much
            Unknown,
            /// Contains the required data size in bytes
            Size(NonZeroUsize),
        }

        impl Needed 
        {
            /// Creates `Needed` instance, returns `Needed::Unknown` if the argument is zero
            pub fn new(s: usize) -> Self {
                match NonZeroUsize::new(s) {
                Some(sz) => Needed::Size(sz),
                None => Needed::Unknown,
                }
            }

            /// Indicates if we know how many bytes we need
            pub fn is_known(&self) -> bool {
                *self != Unknown
            }

            /// Maps a `Needed` to `Needed` by applying a function to a contained `Size` value.
            #[inline]
            pub fn map<F: Fn(NonZeroUsize) -> usize>(self, f: F) -> Needed {
                match self {
                Unknown => Unknown,
                Size(n) => Needed::new(f(n)),
                }
            }
        }

        /// The `Err` enum indicates the parser was not successful.
        #[derive(Debug, Clone, PartialEq)] 
        pub enum Err<E> 
        {
            /// There was not enough data
            Incomplete(Needed),
            /// The parser had an error (recoverable)
            Error(E),
            /// The parser had an unrecoverable error
            Failure(E),
        }

        impl<E> Err<E> 
        {
            /// Tests if the result is Incomplete
            pub fn is_incomplete(&self) -> bool {
                if let Err::Incomplete(_) = self {
                true
                } else {
                false
                }
            }

            /// Applies the given function to the inner error
            pub fn map<E2, F>(self, f: F) -> Err<E2>
            where
                F: FnOnce(E) -> E2,
            {
                match self {
                Err::Incomplete(n) => Err::Incomplete(n),
                Err::Failure(t) => Err::Failure(f(t)),
                Err::Error(t) => Err::Error(f(t)),
                }
            }

            /// Automatically converts between errors if the underlying type supports it
            pub fn convert<F>(e: Err<F>) -> Self where
            E: From<F>,
            {
                e.map( super::lib::std::convert::Into::into)
            }
        }

        impl<T> Err<(T, ErrorKind)> 
        {
            /// Maps `Err<(T, ErrorKind)>` to `Err<(U, ErrorKind)>` with the given `F: T -> U`
            pub fn map_input<U, F>(self, f: F) -> Err<(U, ErrorKind)>
            where
                F: FnOnce(T) -> U,
            {
                match self {
                Err::Incomplete(n) => Err::Incomplete(n),
                Err::Failure((input, k)) => Err::Failure((f(input), k)),
                Err::Error((input, k)) => Err::Error((f(input), k)),
                }
            }
        }

        impl<T> Err<error::Error<T>> 
        {
            /// Maps `Err<error::Error<T>>` to `Err<error::Error<U>>` with the given `F: T -> U`
            pub fn map_input<U, F>(self, f: F) -> Err<error::Error<U>>
            where
                F: FnOnce(T) -> U,
            {
                match self {
                Err::Incomplete(n) => Err::Incomplete(n),
                Err::Failure(error::Error { input, code }) => Err::Failure(error::Error {
                    input: f(input),
                    code,
                }),
                Err::Error(error::Error { input, code }) => Err::Error(error::Error {
                    input: f(input),
                    code,
                }),
                }
            }
        }
        
        use super::lib::std::{borrow::ToOwned, string::String, vec::Vec};
        
        impl Err<(&[u8], ErrorKind)> 
        {
            /// Obtaining ownership
            pub fn to_owned(self) -> Err<(Vec<u8>, ErrorKind)> {
                self.map_input(ToOwned::to_owned)
            }
        }
        
        impl Err<(&str, ErrorKind)>
        {
            /// Obtaining ownership 
            pub fn to_owned(self) -> Err<(String, ErrorKind)> {
                self.map_input(ToOwned::to_owned)
            }
        }
        
        impl Err<error::Error<&[u8]>> 
        {
            /// Obtaining ownership 
            pub fn to_owned(self) -> Err<error::Error<Vec<u8>>> {
                self.map_input(ToOwned::to_owned)
            }
        }
        
        impl Err<error::Error<&str>> 
        {
            /// Obtaining ownership
            pub fn to_owned(self) -> Err<error::Error<String>> {
                self.map_input(ToOwned::to_owned)
            }
        }

        impl<E: Eq> Eq for Err<E> {}

        impl<E> fmt::Display for Err<E> where
        E: fmt::Debug,
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                Err::Incomplete(Needed::Size(u)) => write!(f, "Parsing requires {} bytes/chars", u),
                Err::Incomplete(Needed::Unknown) => write!(f, "Parsing requires more data"),
                Err::Failure(c) => write!(f, "Parsing Failure: {:?}", c),
                Err::Error(c) => write!(f, "Parsing Error: {:?}", c),
                }
            }
        }
        
        use std::error::Error;
        
        impl<E> Error for Err<E> where
        E: fmt::Debug,
        {
            fn source(&self) -> Option<&(dyn Error + 'static)> {
                None // no underlying error
            }
        }

        /// All nom parsers implement this trait
        pub trait Parser<I, O, E> 
        {
            /// A parser takes in input type, and returns a `Result` containing either the remaining input and the output value, or an error.
            fn parse(&mut self, input: I) -> IResult<I, O, E>;

            /// Maps a function over the result of a parser
            fn map<G, O2>(self, g: G) -> Map<Self, G, O> where
            G: Fn(O) -> O2,
            Self: std::marker::Sized,
            {
                Map {
                f: self,
                g,
                phantom: core::marker::PhantomData,
                }
            }

            /// Creates a second parser from the output of the first one, then apply over the rest of the input
            fn flat_map<G, H, O2>(self, g: G) -> FlatMap<Self, G, O> where
            G: FnMut(O) -> H,
            H: Parser<I, O2, E>,
            Self: std::marker::Sized,
            {
                FlatMap 
                {
                    f: self,
                    g,
                    phantom: std::marker::PhantomData,
                }
            }

            /// Applies a second parser over the output of the first one
            fn and_then<G, O2>(self, g: G) -> AndThen<Self, G, O> where
            G: Parser<O, O2, E>,
            Self: std::marker::Sized,
            {
                AndThen 
                {
                    f: self,
                    g,
                    phantom: std::marker::PhantomData,
                }
            }

            /// Applies a second parser after the first one, return their results as a tuple
            fn and<G, O2>(self, g: G) -> And<Self, G> where
            G: Parser<I, O2, E>,
            Self: std::marker::Sized,
            {
                And { f: self, g }
            }

            /// Applies a second parser over the input if the first one failed
            fn or<G>(self, g: G) -> Or<Self, G> where
            G: Parser<I, O, E>,
            Self: std::marker::Sized,
            {
                Or { f: self, g }
            }

            /// automatically converts the parser's output and error values to another type, as long as they implement the `From` trait
            fn into<O2: From<O>, E2: From<E>>(self) -> Into<Self, O, O2, E, E2> where
            Self: std::marker::Sized,
            {
                Into 
                {
                    f: self,
                    phantom_out1: std::marker::PhantomData,
                    phantom_err1: std::marker::PhantomData,
                    phantom_out2: std::marker::PhantomData,
                    phantom_err2: std::marker::PhantomData,
                }
            }
        }

        impl<'a, I, O, E, F> Parser<I, O, E> for F where
        F: FnMut(I) -> IResult<I, O, E> + 'a,
        {
            fn parse(&mut self, i: I) -> IResult<I, O, E> {
                self(i)
            }
        }
        
        use std::boxed::Box;
        
        impl<'a, I, O, E> Parser<I, O, E> for Box<dyn Parser<I, O, E> + 'a> 
        {
            fn parse(&mut self, input: I) -> IResult<I, O, E> {
                (**self).parse(input)
            }
        }

        /// Implementation of `Parser::map` 
        pub struct Map<F, G, O1> 
        {
            f: F,
            g: G,
            phantom: std::marker::PhantomData<O1>,
        }

        impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Fn(O1) -> O2> Parser<I, O2, E> for Map<F, G, O1> 
        {
            fn parse(&mut self, i: I) -> IResult<I, O2, E> 
            {
                match self.f.parse(i) {
                Err(e) => Err(e),
                Ok((i, o)) => Ok((i, (self.g)(o))),
                }
            }
        }

        /// Implementation of `Parser::flat_map` 
        pub struct FlatMap<F, G, O1> 
        {
            f: F,
            g: G,
            phantom: std::marker::PhantomData<O1>,
        }

        impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Fn(O1) -> H, H: Parser<I, O2, E>> Parser<I, O2, E>
        for FlatMap<F, G, O1>
        {
            fn parse(&mut self, i: I) -> IResult<I, O2, E> {
                let (i, o1) = self.f.parse(i)?;
                (self.g)(o1).parse(i)
            }
        }

        /// Implementation of `Parser::and_then` 
        pub struct AndThen<F, G, O1> 
        {
            f: F,
            g: G,
            phantom: std::marker::PhantomData<O1>,
        }

        impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Parser<O1, O2, E>> Parser<I, O2, E>
        for AndThen<F, G, O1>
        {
            fn parse(&mut self, i: I) -> IResult<I, O2, E> {
                let (i, o1) = self.f.parse(i)?;
                let (_, o2) = self.g.parse(o1)?;
                Ok((i, o2))
            }
        }

        /// Implementation of `Parser::and` 
        pub struct And<F, G> 
        {
            f: F,
            g: G,
        }

        impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Parser<I, O2, E>> Parser<I, (O1, O2), E>
        for And<F, G>
        {
            fn parse(&mut self, i: I) -> IResult<I, (O1, O2), E> {
                let (i, o1) = self.f.parse(i)?;
                let (i, o2) = self.g.parse(i)?;
                Ok((i, (o1, o2)))
            }
        }

        /// Implementation of `Parser::or` 
        pub struct Or<F, G> 
        {
            f: F,
            g: G,
        }

        impl<'a, I: Clone, O, E: super::error::ParseError<I>, F: Parser<I, O, E>, G: Parser<I, O, E>>
        Parser<I, O, E> for Or<F, G>
        {
            fn parse(&mut self, i: I) -> IResult<I, O, E> 
            {
                match self.f.parse(i.clone()) {
                Err(Err::Error(e1)) => match self.g.parse(i) {
                    Err(Err::Error(e2)) => Err(Err::Error(e1.or(e2))),
                    res => res,
                },
                res => res,
                }
            }
        }

        /// Implementation of `Parser::into` 
        pub struct Into<F, O1, O2: From<O1>, E1, E2: From<E1>> 
        {
            f: F,
            phantom_out1: std::marker::PhantomData<O1>,
            phantom_err1: std::marker::PhantomData<E1>,
            phantom_out2: std::marker::PhantomData<O2>,
            phantom_err2: std::marker::PhantomData<E2>,
        }

        impl
        <
        'a,
        I: Clone,
        O1,
        O2: From<O1>,
        E1,
        E2: super::error::ParseError<I> + From<E1>,
        F: Parser<I, O1, E1>,
        > Parser<I, O2, E2> for Into<F, O1, O2, E1, E2>
        {
            fn parse(&mut self, i: I) -> IResult<I, O2, E2> 
            {
                match self.f.parse(i) 
                {
                    Ok((i, o)) => Ok((i, o.into())),
                    Err(Err::Error(e)) => Err(Err::Error(e.into())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.into())),
                    Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),
                }
            }
        }
    }
    /*
    */
    pub mod multi
    {
        //! Combinators applying their child parser multiple times
        use super::error::ErrorKind;
        use super::error::ParseError;
        use super::internal::{Err, IResult, Needed, Parser};
        use super::lib::std::vec::Vec;
        use super::traits::{InputLength, InputTake, ToUsize};
        use std::num::NonZeroUsize;

        /// Don't pre-allocate more than 64KiB when calling `Vec::with_capacity`.
        const MAX_INITIAL_CAPACITY_BYTES: usize = 65536;

        /// Repeats the embedded parser, gathering the results in a `Vec`.
        pub fn many0<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        E: ParseError<I>,
        {
            move |mut i: I| {
                let mut acc = super::lib::std::vec::Vec::with_capacity(4);
                loop {
                let len = i.input_len();
                match f.parse(i.clone()) {
                    Err(Err::Error(_)) => return Ok((i, acc)),
                    Err(e) => return Err(e),
                    Ok((i1, o)) => {
                    // infinite loop check: the parser must always consume
                    if i1.input_len() == len {
                        return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many0)));
                    }

                    i = i1;
                    acc.push(o);
                    }
                }
                }
            }
        }

        /// Runs the embedded parser, gathering the results in a `Vec`.
        pub fn many1<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        E: ParseError<I>,
        {
            move |mut i: I| match f.parse(i.clone()) {
                Err(Err::Error(err)) => Err(Err::Error(E::append(i, ErrorKind::Many1, err))),
                Err(e) => Err(e),
                Ok((i1, o)) => {
                let mut acc = super::lib::std::vec::Vec::with_capacity(4);
                acc.push(o);
                i = i1;

                loop {
                    let len = i.input_len();
                    match f.parse(i.clone()) {
                    Err(Err::Error(_)) => return Ok((i, acc)),
                    Err(e) => return Err(e),
                    Ok((i1, o)) => {
                        // infinite loop check: the parser must always consume
                        if i1.input_len() == len {
                        return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1)));
                        }

                        i = i1;
                        acc.push(o);
                    }
                    }
                }
                }
            }
        }

        /// Applies the parser `f` until the parser `g` produces a result.
        pub fn many_till<I, O, P, E, F, G>(
        mut f: F,
        mut g: G,
        ) -> impl FnMut(I) -> IResult<I, (Vec<O>, P), E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: Parser<I, P, E>,
        E: ParseError<I>,
        {
            move |mut i: I| {
                let mut res = super::lib::std::vec::Vec::new();
                loop {
                let len = i.input_len();
                match g.parse(i.clone()) {
                    Ok((i1, o)) => return Ok((i1, (res, o))),
                    Err(Err::Error(_)) => {
                    match f.parse(i.clone()) {
                        Err(Err::Error(err)) => return Err(Err::Error(E::append(i, ErrorKind::ManyTill, err))),
                        Err(e) => return Err(e),
                        Ok((i1, o)) => {
                        // infinite loop check: the parser must always consume
                        if i1.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(i1, ErrorKind::ManyTill)));
                        }

                        res.push(o);
                        i = i1;
                        }
                    }
                    }
                    Err(e) => return Err(e),
                }
                }
            }
        }

        /// Alternates between two parsers to produce a list of elements.
        pub fn separated_list0<I, O, O2, E, F, G>(
        mut sep: G,
        mut f: F,
        ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: Parser<I, O2, E>,
        E: ParseError<I>,
        {
            move |mut i: I| 
            {
                let mut res = Vec::new();

                match f.parse(i.clone()) {
                Err(Err::Error(_)) => return Ok((i, res)),
                Err(e) => return Err(e),
                Ok((i1, o)) => {
                    res.push(o);
                    i = i1;
                }
                }

                loop {
                let len = i.input_len();
                match sep.parse(i.clone()) {
                    Err(Err::Error(_)) => return Ok((i, res)),
                    Err(e) => return Err(e),
                    Ok((i1, _)) => {
                    // infinite loop check: the parser must always consume
                    if i1.input_len() == len {
                        return Err(Err::Error(E::from_error_kind(i1, ErrorKind::SeparatedList)));
                    }

                    match f.parse(i1.clone()) {
                        Err(Err::Error(_)) => return Ok((i, res)),
                        Err(e) => return Err(e),
                        Ok((i2, o)) => {
                        res.push(o);
                        i = i2;
                        }
                    }
                    }
                }
                }
            }
        }

        /// Alternates between two parsers to produce a list of elements until [`Err::Error`].
        pub fn separated_list1<I, O, O2, E, F, G>
        (
            mut sep: G,
            mut f: F,
        ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: Parser<I, O2, E>,
        E: ParseError<I>,
        {
            move |mut i: I| 
            {
                let mut res = Vec::new();

                // Parse the first element
                match f.parse(i.clone()) {
                Err(e) => return Err(e),
                Ok((i1, o)) => {
                    res.push(o);
                    i = i1;
                }
                }

                loop {
                let len = i.input_len();
                match sep.parse(i.clone()) {
                    Err(Err::Error(_)) => return Ok((i, res)),
                    Err(e) => return Err(e),
                    Ok((i1, _)) => {
                    // infinite loop check: the parser must always consume
                    if i1.input_len() == len {
                        return Err(Err::Error(E::from_error_kind(i1, ErrorKind::SeparatedList)));
                    }

                    match f.parse(i1.clone()) {
                        Err(Err::Error(_)) => return Ok((i, res)),
                        Err(e) => return Err(e),
                        Ok((i2, o)) => {
                        res.push(o);
                        i = i2;
                        }
                    }
                    }
                }
                }
            }
        }

        /// Repeats the embedded parser `m..=n` times.
        pub fn many_m_n<I, O, E, F>
        (
            min: usize,
            max: usize,
            mut parse: F,
        ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        E: ParseError<I>,
        {
            move |mut input: I| 
            {
                if min > max {
                return Err(Err::Failure(E::from_error_kind(input, ErrorKind::ManyMN)));
                }

                let max_initial_capacity =
                MAX_INITIAL_CAPACITY_BYTES / super::lib::std::mem::size_of::<O>().max(1);
                let mut res = super::lib::std::vec::Vec::with_capacity(min.min(max_initial_capacity));
                for count in 0..max {
                let len = input.input_len();
                match parse.parse(input.clone()) {
                    Ok((tail, value)) => {
                    // infinite loop check: the parser must always consume
                    if tail.input_len() == len {
                        return Err(Err::Error(E::from_error_kind(input, ErrorKind::ManyMN)));
                    }

                    res.push(value);
                    input = tail;
                    }
                    Err(Err::Error(e)) => {
                    if count < min {
                        return Err(Err::Error(E::append(input, ErrorKind::ManyMN, e)));
                    } else {
                        return Ok((input, res));
                    }
                    }
                    Err(e) => {
                    return Err(e);
                    }
                }
                }

                Ok((input, res))
            }
        }

        /// Repeats the embedded parser, counting the results.
        pub fn many0_count<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, usize, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        E: ParseError<I>,
        {
            move |i: I| {
                let mut input = i;
                let mut count = 0;

                loop {
                let input_ = input.clone();
                let len = input.input_len();
                match f.parse(input_) {
                    Ok((i, _)) => {
                    // infinite loop check: the parser must always consume
                    if i.input_len() == len {
                        return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many0Count)));
                    }

                    input = i;
                    count += 1;
                    }

                    Err(Err::Error(_)) => return Ok((input, count)),

                    Err(e) => return Err(e),
                }
                }
            }
        }

        /// Runs the embedded parser, counting the results.
        pub fn many1_count<I, O, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, usize, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        E: ParseError<I>,
        {
            move |i: I| 
            {
                let i_ = i.clone();
                match f.parse(i_) {
                Err(Err::Error(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1Count))),
                Err(i) => Err(i),
                Ok((i1, _)) => {
                    let mut count = 1;
                    let mut input = i1;

                    loop {
                    let len = input.input_len();
                    let input_ = input.clone();
                    match f.parse(input_) {
                        Err(Err::Error(_)) => return Ok((input, count)),
                        Err(e) => return Err(e),
                        Ok((i, _)) => {
                        // infinite loop check: the parser must always consume
                        if i.input_len() == len {
                            return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1Count)));
                        }

                        count += 1;
                        input = i;
                        }
                    }
                    }
                }
                }
            }
        }

        /// Runs the embedded parser `count` times, gathering the results in a `Vec`.
        pub fn count<I, O, E, F>(mut f: F, count: usize) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + PartialEq,
        F: Parser<I, O, E>,
        E: ParseError<I>,
        {
            move |i: I| 
            {
                let mut input = i.clone();
                let max_initial_capacity =
                MAX_INITIAL_CAPACITY_BYTES / super::lib::std::mem::size_of::<O>().max(1);
                let mut res = super::lib::std::vec::Vec::with_capacity(count.min(max_initial_capacity));

                for _ in 0..count {
                let input_ = input.clone();
                match f.parse(input_) {
                    Ok((i, o)) => {
                    res.push(o);
                    input = i;
                    }
                    Err(Err::Error(e)) => {
                    return Err(Err::Error(E::append(i, ErrorKind::Count, e)));
                    }
                    Err(e) => {
                    return Err(e);
                    }
                }
                }

                Ok((input, res))
            }
        }

        /// Runs the embedded parser repeatedly, filling the given slice with results.
        pub fn fill<'a, I, O, E, F>(f: F, buf: &'a mut [O]) -> impl FnMut(I) -> IResult<I, (), E> + 'a where
        I: Clone + PartialEq,
        F: Fn(I) -> IResult<I, O, E> + 'a,
        E: ParseError<I>,
        {
            move |i: I| 
            {
                let mut input = i.clone();

                for elem in buf.iter_mut() {
                let input_ = input.clone();
                match f(input_) {
                    Ok((i, o)) => {
                    *elem = o;
                    input = i;
                    }
                    Err(Err::Error(e)) => {
                    return Err(Err::Error(E::append(i, ErrorKind::Count, e)));
                    }
                    Err(e) => {
                    return Err(e);
                    }
                }
                }

                Ok((input, ()))
            }
        }

        /// Repeats the embedded parser, calling `g` to gather the results.
        pub fn fold_many0<I, O, E, F, G, H, R>
        (
            mut f: F,
            mut init: H,
            mut g: G,
        ) -> impl FnMut(I) -> IResult<I, R, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: FnMut(R, O) -> R,
        H: FnMut() -> R,
        E: ParseError<I>,
        {
            move |i: I| 
            {
                let mut res = init();
                let mut input = i;

                loop {
                let i_ = input.clone();
                let len = input.input_len();
                match f.parse(i_) {
                    Ok((i, o)) => {
                    // infinite loop check: the parser must always consume
                    if i.input_len() == len {
                        return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many0)));
                    }

                    res = g(res, o);
                    input = i;
                    }
                    Err(Err::Error(_)) => {
                    return Ok((input, res));
                    }
                    Err(e) => {
                    return Err(e);
                    }
                }
                }
            }
        }

        /// Repeats the embedded parser, calling `g` to gather the results.
        pub fn fold_many1<I, O, E, F, G, H, R>
        (
            mut f: F,
            mut init: H,
            mut g: G,
        ) -> impl FnMut(I) -> IResult<I, R, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: FnMut(R, O) -> R,
        H: FnMut() -> R,
        E: ParseError<I>,
        {
            move |i: I| 
            {
                let _i = i.clone();
                let init = init();
                match f.parse(_i) {
                Err(Err::Error(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1))),
                Err(e) => Err(e),
                Ok((i1, o1)) => {
                    let mut acc = g(init, o1);
                    let mut input = i1;

                    loop {
                    let _input = input.clone();
                    let len = input.input_len();
                    match f.parse(_input) {
                        Err(Err::Error(_)) => {
                        break;
                        }
                        Err(e) => return Err(e),
                        Ok((i, o)) => {
                        // infinite loop check: the parser must always consume
                        if i.input_len() == len {
                            return Err(Err::Failure(E::from_error_kind(i, ErrorKind::Many1)));
                        }

                        acc = g(acc, o);
                        input = i;
                        }
                    }
                    }

                    Ok((input, acc))
                }
                }
            }
        }

        /// Repeats the embedded parser `m..=n` times, calling `g` to gather the results.
        pub fn fold_many_m_n<I, O, E, F, G, H, R>
        (
            min: usize,
            max: usize,
            mut parse: F,
            mut init: H,
            mut fold: G,
        ) -> impl FnMut(I) -> IResult<I, R, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: FnMut(R, O) -> R,
        H: FnMut() -> R,
        E: ParseError<I>,
        {
            move |mut input: I| {
                if min > max {
                return Err(Err::Failure(E::from_error_kind(input, ErrorKind::ManyMN)));
                }

                let mut acc = init();
                for count in 0..max {
                let len = input.input_len();
                match parse.parse(input.clone()) {
                    Ok((tail, value)) => {
                    // infinite loop check: the parser must always consume
                    if tail.input_len() == len {
                        return Err(Err::Error(E::from_error_kind(tail, ErrorKind::ManyMN)));
                    }

                    acc = fold(acc, value);
                    input = tail;
                    }
                    //FInputXMError: handle failure properly
                    Err(Err::Error(err)) => {
                    if count < min {
                        return Err(Err::Error(E::append(input, ErrorKind::ManyMN, err)));
                    } else {
                        break;
                    }
                    }
                    Err(e) => return Err(e),
                }
                }

                Ok((input, acc))
            }
        }

        /// Gets a number from the parser and returns a subslice of the input of that size.
        pub fn length_data<I, N, E, F>(mut f: F) -> impl FnMut(I) -> IResult<I, I, E> where
        I: InputLength + InputTake,
        N: ToUsize,
        F: Parser<I, N, E>,
        E: ParseError<I>,
        {
            move |i: I| {
                let (i, length) = f.parse(i)?;

                let length: usize = length.to_usize();

                if let Some(needed) = length
                .checked_sub(i.input_len())
                .and_then(NonZeroUsize::new)
                {
                Err(Err::Incomplete(Needed::Size(needed)))
                } else {
                Ok(i.take_split(length))
                }
            }
        }

        /// Gets a number from the first parser, takes a subslice of the input of that size, then applies the second parser on that subslice.
        pub fn length_value<I, O, N, E, F, G>(mut f: F, mut g: G) -> impl FnMut(I) -> IResult<I, O, E> where
        I: Clone + InputLength + InputTake,
        N: ToUsize,
        F: Parser<I, N, E>,
        G: Parser<I, O, E>,
        E: ParseError<I>,
        {
            move |i: I| {
                let (i, length) = f.parse(i)?;

                let length: usize = length.to_usize();

                if let Some(needed) = length
                .checked_sub(i.input_len())
                .and_then(NonZeroUsize::new)
                {
                Err(Err::Incomplete(Needed::Size(needed)))
                } else {
                let (rest, i) = i.take_split(length);
                match g.parse(i.clone()) {
                    Err(Err::Incomplete(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Complete))),
                    Err(e) => Err(e),
                    Ok((_, o)) => Ok((rest, o)),
                }
                }
            }
        }

        /// Gets a number from the first parser, then applies the second parser that many times.
        pub fn length_count<I, O, N, E, F, G>(mut f: F, mut g: G) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone,
        N: ToUsize,
        F: Parser<I, N, E>,
        G: Parser<I, O, E>,
        E: ParseError<I>,
        {
            move |i: I| {
                let (i, count) = f.parse(i)?;
                let mut input = i.clone();
                let mut res = Vec::new();

                for _ in 0..count.to_usize() {
                let input_ = input.clone();
                match g.parse(input_) {
                    Ok((i, o)) => {
                    res.push(o);
                    input = i;
                    }
                    Err(Err::Error(e)) => {
                    return Err(Err::Error(E::append(i, ErrorKind::Count, e)));
                    }
                    Err(e) => {
                    return Err(e);
                    }
                }
                }

                Ok((input, res))
            }
        }
    }
    /*
    */
    pub mod sequence
    {
        //! Combinators applying parsers in sequence
        use super::error::ParseError;
        use super::internal::{IResult, Parser};
        
        macro_rules! tuple_trait
        (
            ($name1:ident $ty1:ident, $name2: ident $ty2:ident, $($name:ident $ty:ident),*) => (
                tuple_trait!(__impl $name1 $ty1, $name2 $ty2; $($name $ty),*);
            );
            (__impl $($name:ident $ty: ident),+; $name1:ident $ty1:ident, $($name2:ident $ty2:ident),*) => (
                tuple_trait_impl!($($name $ty),+);
                tuple_trait!(__impl $($name $ty),+ , $name1 $ty1; $($name2 $ty2),*);
            );
            (__impl $($name:ident $ty: ident),+; $name1:ident $ty1:ident) => (
                tuple_trait_impl!($($name $ty),+);
                tuple_trait_impl!($($name $ty),+, $name1 $ty1);
            );
        );

        macro_rules! tuple_trait_impl
        (
            ($($name:ident $ty: ident),+) => (
                impl<
                Input: Clone, $($ty),+ , Error: ParseError<Input>,
                $($name: Parser<Input, $ty, Error>),+
                > Tuple<Input, ( $($ty),+ ), Error> for ( $($name),+ ) {

                fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error> {
                    tuple_trait_inner!(0, self, input, (), $($name)+)

                }
                }
            );
        );

        macro_rules! tuple_trait_inner
        (
            ($it:tt, $self:expr, $input:expr, (), $head:ident $($id:ident)+) => ({
                let (i, o) = $self.$it.parse($input.clone())?;

                succ!($it, tuple_trait_inner!($self, i, ( o ), $($id)+))
            });
            ($it:tt, $self:expr, $input:expr, ($($parsed:tt)*), $head:ident $($id:ident)+) => ({
                let (i, o) = $self.$it.parse($input.clone())?;

                succ!($it, tuple_trait_inner!($self, i, ($($parsed)* , o), $($id)+))
            });
            ($it:tt, $self:expr, $input:expr, ($($parsed:tt)*), $head:ident) => ({
                let (i, o) = $self.$it.parse($input.clone())?;

                Ok((i, ($($parsed)* , o)))
            });
        );

        /// Gets an object from the first parser, then gets another object from the second parser.
        pub fn pair<I, O1, O2, E: ParseError<I>, F, G>
        (
            mut first: F,
            mut second: G,
        ) -> impl FnMut(I) -> IResult<I, (O1, O2), E> where
        F: Parser<I, O1, E>,
        G: Parser<I, O2, E>,
        {
            move |input: I| {
                let (input, o1) = first.parse(input)?;
                second.parse(input).map(|(i, o2)| (i, (o1, o2)))
            }
        }

        /// Matches an object from the first parser and discards it, then gets an object from the second parser.
        pub fn preceded<I, O1, O2, E: ParseError<I>, F, G>
        (
            mut first: F,
            mut second: G,
        ) -> impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: Parser<I, O2, E>,
        {
            move |input: I| {
                let (input, _) = first.parse(input)?;
                second.parse(input)
            }
        }

        /// Gets an object from the first parser, then matches an object from the second parser and discards it.
        pub fn terminated<I, O1, O2, E: ParseError<I>, F, G>
        (
            mut first: F,
            mut second: G,
        ) -> impl FnMut(I) -> IResult<I, O1, E> where
        F: Parser<I, O1, E>,
        G: Parser<I, O2, E>,
        {
            move |input: I| {
                let (input, o1) = first.parse(input)?;
                second.parse(input).map(|(i, _)| (i, o1))
            }
        }

        /// Gets an object from the first parser, then matches an object from the sep_parser 
        /// and discards it, then gets another object from the second parser.
        pub fn separated_pair<I, O1, O2, O3, E: ParseError<I>, F, G, H>
        (
            mut first: F,
            mut sep: G,
            mut second: H,
        ) -> impl FnMut(I) -> IResult<I, (O1, O3), E> where
        F: Parser<I, O1, E>,
        G: Parser<I, O2, E>,
        H: Parser<I, O3, E>,
        {
            move |input: I| {
                let (input, o1) = first.parse(input)?;
                let (input, _) = sep.parse(input)?;
                second.parse(input).map(|(i, o2)| (i, (o1, o2)))
            }
        }

        /// Matches an object from the first parser and discards it,
        /// then gets an object from the second parser,
        /// and finally matches an object from the third parser and discards it.
        pub fn delimited<I, O1, O2, O3, E: ParseError<I>, F, G, H>
        (
            mut first: F,
            mut second: G,
            mut third: H,
        ) -> impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: Parser<I, O2, E>,
        H: Parser<I, O3, E>,
        {
            move |input: I| {
                let (input, _) = first.parse(input)?;
                let (input, o2) = second.parse(input)?;
                third.parse(input).map(|(i, _)| (i, o2))
            }
        }

        /// Helper trait for the tuple combinator.
        pub trait Tuple<I, O, E> 
        {
            /// Parses the input and returns a tuple of results of each parser.
            fn parse(&mut self, input: I) -> IResult<I, O, E>;
        }

        impl<Input, Output, Error: ParseError<Input>, F: Parser<Input, Output, Error>>
        Tuple<Input, (Output,), Error> for (F,)
        {
            fn parse(&mut self, input: Input) -> IResult<Input, (Output,), Error> {
                self.0.parse(input).map(|(i, o)| (i, (o,)))
            }
        }

        tuple_trait!(FnA A, FnB B, FnC C, FnD D, FnE E, FnF F, FnG G, FnH H, FnI I, FnJ J, FnK K, FnL L,
        FnM M, FnN N, FnO O, FnP P, FnQ Q, FnR R, FnS S, FnT T, FnU U);

        // Special case: implement `Tuple` for `()`, the unit type.
        impl<I, E: ParseError<I>> Tuple<I, (), E> for () 
        {
            fn parse(&mut self, input: I) -> IResult<I, (), E> {
                Ok((input, ()))
            }
        }

        ///Applies a tuple of parsers one by one and returns their results as a tuple.
        pub fn tuple<I, O, E: ParseError<I>, List: Tuple<I, O, E>>( mut l: List, ) -> impl FnMut(I) -> IResult<I, O, E> 
        {
            move |i: I| l.parse(i)
        }
    }
    /*
    */
    pub mod traits
    {
        //! Traits input types have to implement to work with nom combinators
        use super::error::{self, ErrorKind, ParseError};
        use super::internal::{Err, IResult, Needed};
        use super::lib::std::iter::{Copied, Enumerate};
        use super::lib::std::ops::{Range, RangeFrom, RangeFull, RangeTo};
        use super::lib::std::slice::Iter;
        use super::lib::std::str::from_utf8;
        use super::lib::std::str::CharIndices;
        use super::lib::std::str::Chars;
        use super::lib::std::str::FromStr;
        use super::lib::std::string::String;
        use super::lib::std::vec::Vec; 

        static CHARS: &[u8] = b"0123456789abcdef";

        macro_rules! as_bytes_array_impls 
        {
            ($($N:expr)+) => {
                $(
                impl<'a> AsBytes for &'a [u8; $N] {
                    #[inline(always)]
                    fn as_bytes(&self) -> &[u8] {
                    *self
                    }
                }

                impl AsBytes for [u8; $N] {
                    #[inline(always)]
                    fn as_bytes(&self) -> &[u8] {
                    self
                    }
                }
                )+
            };
        }

        macro_rules! impl_fn_slice 
        {
            ( $ty:ty ) => {
                fn slice(&self, range: $ty) -> Self {
                &self[range]
                }
            };
        }

        macro_rules! slice_range_impl 
        {
            ( [ $for_type:ident ], $ty:ty ) => {
                impl<'a, $for_type> Slice<$ty> for &'a [$for_type] {
                impl_fn_slice!($ty);
                }
            };
            ( $for_type:ty, $ty:ty ) => {
                impl<'a> Slice<$ty> for &'a $for_type {
                impl_fn_slice!($ty);
                }
            };
        }

        macro_rules! slice_ranges_impl 
        {
            ( [ $for_type:ident ] ) => {
                slice_range_impl! {[$for_type], Range<usize>}
                slice_range_impl! {[$for_type], RangeTo<usize>}
                slice_range_impl! {[$for_type], RangeFrom<usize>}
                slice_range_impl! {[$for_type], RangeFull}
            };
            ( $for_type:ty ) => {
                slice_range_impl! {$for_type, Range<usize>}
                slice_range_impl! {$for_type, RangeTo<usize>}
                slice_range_impl! {$for_type, RangeFrom<usize>}
                slice_range_impl! {$for_type, RangeFull}
            };
        }

        macro_rules! array_impls 
        {
            ($($N:expr)+) => {
                $(
                impl InputLength for [u8; $N] {
                    #[inline]
                    fn input_len(&self) -> usize {
                    self.len()
                    }
                }

                impl<'a> InputLength for &'a [u8; $N] {
                    #[inline]
                    fn input_len(&self) -> usize {
                    self.len()
                    }
                }

                impl<'a> InputIter for &'a [u8; $N] {
                    type Item = u8;
                    type Iter = Enumerate<Self::IterElem>;
                    type IterElem = Copied<Iter<'a, u8>>;

                    fn iter_indices(&self) -> Self::Iter {
                    (&self[..]).iter_indices()
                    }

                    fn iter_elements(&self) -> Self::IterElem {
                    (&self[..]).iter_elements()
                    }

                    fn position<P>(&self, predicate: P) -> Option<usize>
                    where P: Fn(Self::Item) -> bool {
                    (&self[..]).position(predicate)
                    }

                    fn slice_index(&self, count: usize) -> Result<usize, Needed> {
                    (&self[..]).slice_index(count)
                    }
                }

                impl<'a> Compare<[u8; $N]> for &'a [u8] {
                    #[inline(always)]
                    fn compare(&self, t: [u8; $N]) -> CompareResult {
                    self.compare(&t[..])
                    }

                    #[inline(always)]
                    fn compare_no_case(&self, t: [u8;$N]) -> CompareResult {
                    self.compare_no_case(&t[..])
                    }
                }

                impl<'a,'b> Compare<&'b [u8; $N]> for &'a [u8] {
                    #[inline(always)]
                    fn compare(&self, t: &'b [u8; $N]) -> CompareResult {
                    self.compare(&t[..])
                    }

                    #[inline(always)]
                    fn compare_no_case(&self, t: &'b [u8;$N]) -> CompareResult {
                    self.compare_no_case(&t[..])
                    }
                }

                impl FindToken<u8> for [u8; $N] {
                    fn find_token(&self, token: u8) -> bool {
                    memchr::memchr(token, &self[..]).is_some()
                    }
                }

                impl<'a> FindToken<&'a u8> for [u8; $N] {
                    fn find_token(&self, token: &u8) -> bool {
                    self.find_token(*token)
                    }
                }
                )+
            };
        }

        /// Abstract method to calculate the input length
        pub trait InputLength 
        {
            /// Calculates the input length, as indicated by its name,
            /// and the name of the trait itself
            fn input_len(&self) -> usize;
        }

        impl<'a, T> InputLength for &'a [T] 
        {
            #[inline]
            fn input_len(&self) -> usize {
                self.len()
            }
        }

        impl<'a> InputLength for &'a str 
        {
            #[inline]
            fn input_len(&self) -> usize {
                self.len()
            }
        }

        impl<'a> InputLength for (&'a [u8], usize) 
        {
            #[inline]
            fn input_len(&self) -> usize {
                //println!("bit input length for ({:?}, {}):", self.0, self.1);
                //println!("-> {}", self.0.len() * 8 - self.1);
                self.0.len() * 8 - self.1
            }
        }

        /// Useful functions to calculate the offset between slices and show a hexdump of a slice
        pub trait Offset 
        {
            /// Offset between the first byte of self and the first byte of the argument
            fn offset(&self, second: &Self) -> usize;
        }

        impl Offset for [u8] 
        {
            fn offset(&self, second: &Self) -> usize {
                let fst = self.as_ptr();
                let snd = second.as_ptr();

                snd as usize - fst as usize
            }
        }

        impl<'a> Offset for &'a [u8] 
        {
            fn offset(&self, second: &Self) -> usize {
                let fst = self.as_ptr();
                let snd = second.as_ptr();

                snd as usize - fst as usize
            }
        }

        impl Offset for str 
        {
            fn offset(&self, second: &Self) -> usize {
                let fst = self.as_ptr();
                let snd = second.as_ptr();

                snd as usize - fst as usize
            }
        }

        impl<'a> Offset for &'a str 
        {
            fn offset(&self, second: &Self) -> usize {
                let fst = self.as_ptr();
                let snd = second.as_ptr();

                snd as usize - fst as usize
            }
        }

        /// Helper trait for types that can be viewed as a byte slice
        pub trait AsBytes 
        {
            /// Casts the input type to a byte slice
            fn as_bytes(&self) -> &[u8];
        }

        impl<'a> AsBytes for &'a str 
        {
            #[inline(always)]
            fn as_bytes(&self) -> &[u8] {
                (*self).as_bytes()
            }
        }

        impl AsBytes for str 
        {
            #[inline(always)]
            fn as_bytes(&self) -> &[u8] {
                self.as_ref()
            }
        }

        impl<'a> AsBytes for &'a [u8] 
        {
            #[inline(always)]
            fn as_bytes(&self) -> &[u8] {
                *self
            }
        }

        impl AsBytes for [u8] 
        {
            #[inline(always)]
            fn as_bytes(&self) -> &[u8] {
                self
            }
        }

        as_bytes_array_impls! 
        {
            0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 
            17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
        }

        /// Transforms common types to a char for basic token parsing
        pub trait AsChar 
        {
            /// makes a char from self
            fn as_char(self) -> char;

            /// Tests that self is an alphabetic character.
            fn is_alpha(self) -> bool;

            /// Tests that self is an alphabetic character or a decimal digit.
            fn is_alphanum(self) -> bool;
            /// Tests that self is a decimal digit
            fn is_dec_digit(self) -> bool;
            /// Tests that self is an hex digit
            fn is_hex_digit(self) -> bool;
            /// Tests that self is an octal digit
            fn is_oct_digit(self) -> bool;
            /// Gets the len in bytes for self
            fn len(self) -> usize;
        }

        impl AsChar for u8 
        {
            #[inline]
            fn as_char(self) -> char {
                self as char
            }
            #[inline]
            fn is_alpha(self) -> bool {
                (self >= 0x41 && self <= 0x5A) || (self >= 0x61 && self <= 0x7A)
            }
            #[inline]
            fn is_alphanum(self) -> bool {
                self.is_alpha() || self.is_dec_digit()
            }
            #[inline]
            fn is_dec_digit(self) -> bool {
                self >= 0x30 && self <= 0x39
            }
            #[inline]
            fn is_hex_digit(self) -> bool {
                (self >= 0x30 && self <= 0x39)
                || (self >= 0x41 && self <= 0x46)
                || (self >= 0x61 && self <= 0x66)
            }
            #[inline]
            fn is_oct_digit(self) -> bool {
                self >= 0x30 && self <= 0x37
            }
            #[inline]
            fn len(self) -> usize {
                1
            }
        }

        impl<'a> AsChar for &'a u8 
        {
            #[inline] fn as_char(self) -> char 
            {
                *self as char
            }
            
            #[inline] fn is_alpha(self) -> bool 
            {
                (*self >= 0x41 && *self <= 0x5A) || (*self >= 0x61 && *self <= 0x7A)
            }
            
            #[inline] fn is_alphanum(self) -> bool
            {
                self.is_alpha() || self.is_dec_digit()
            }
            
            #[inline] fn is_dec_digit(self) -> bool
            {
                *self >= 0x30 && *self <= 0x39
            }
            
            #[inline] fn is_hex_digit(self) -> bool
            {
                (*self >= 0x30 && *self <= 0x39)
                || (*self >= 0x41 && *self <= 0x46)
                || (*self >= 0x61 && *self <= 0x66)
            }

            #[inline] fn is_oct_digit(self) -> bool
            {
                *self >= 0x30 && *self <= 0x37
            }

            #[inline] fn len(self) -> usize
            {
                1
            }
        }

        impl AsChar for char 
        {
            #[inline] fn as_char(self) -> char
            {
                self
            }
            
            #[inline] fn is_alpha(self) -> bool
            {
                self.is_ascii_alphabetic()
            }
            
            #[inline] fn is_alphanum(self) -> bool
            {
                self.is_alpha() || self.is_dec_digit()
            }
            
            #[inline] fn is_dec_digit(self) -> bool
            {
                self.is_ascii_digit()
            }
            
            #[inline] fn is_hex_digit(self) -> bool
            {
                self.is_ascii_hexdigit()
            }
            
            #[inline] fn is_oct_digit(self) -> bool
            {
                self.is_digit(8)
            }

            #[inline] fn len(self) -> usize
            {
                self.len_utf8()
            }
        }

        impl<'a> AsChar for &'a char 
        {
            #[inline] fn as_char(self) -> char
            {
                *self
            }
            
            #[inline] fn is_alpha(self) -> bool
            {
                self.is_ascii_alphabetic()
            }
            
            #[inline] fn is_alphanum(self) -> bool
            {
                self.is_alpha() || self.is_dec_digit()
            }
            
            #[inline] fn is_dec_digit(self) -> bool
            {
                self.is_ascii_digit()
            }

            #[inline] fn is_hex_digit(self) -> bool
            {
                self.is_ascii_hexdigit()
            }

            #[inline] fn is_oct_digit(self) -> bool
            {
                self.is_digit(8)
            }

            #[inline] fn len(self) -> usize 
            {
                self.len_utf8()
            }
        }

        /// Abstracts common iteration operations on the input type
        pub trait InputIter
        {
            /// The current input type is a sequence of that `Item` type.
            type Item;
            /// An iterator over the input type, producing the item and its position for use with [Slice].
            type Iter: Iterator<Item = (usize, Self::Item)>;

            /// An iterator over the input type, producing the item
            type IterElem: Iterator<Item = Self::Item>;

            /// Returns an iterator over the elements and their byte offsets
            fn iter_indices(&self) -> Self::Iter;
            
            /// Returns an iterator over the elements
            fn iter_elements(&self) -> Self::IterElem;
            
            /// Finds the byte position of the element
            fn position<P>(&self, predicate: P) -> Option<usize> where P: Fn(Self::Item) -> bool;

            /// Get the byte offset from the element's position in the stream
            fn slice_index(&self, count: usize) -> Result<usize, Needed>;
        }

        /// Abstracts slicing operations
        pub trait InputTake: Sized 
        {
            /// Returns a slice of `count` bytes. panics if count > length
            fn take(&self, count: usize) -> Self;

            /// Split the stream at the `count` byte offset. panics if count > length
            fn take_split(&self, count: usize) -> (Self, Self);
        }

        impl<'a> InputIter for &'a [u8] 
        {
            type Item = u8;
            type Iter = Enumerate<Self::IterElem>;
            type IterElem = Copied<Iter<'a, u8>>;

            #[inline] fn iter_indices(&self) -> Self::Iter
            {
                self.iter_elements().enumerate()
            }

            #[inline] fn iter_elements(&self) -> Self::IterElem 
            {
                self.iter().copied()
            }
            
            #[inline] fn position<P>(&self, predicate: P) -> Option<usize> where
            P: Fn(Self::Item) -> bool,
            {
                self.iter().position(|b| predicate(*b))
            }

            #[inline] fn slice_index(&self, count: usize) -> Result<usize, Needed>
            {
                if self.len() >= count
                { Ok(count) }
                
                else { Err(Needed::new(count - self.len())) }
            }
        }

        impl<'a> InputTake for &'a [u8] 
        {
            #[inline]
            fn take(&self, count: usize) -> Self 
            {
                &self[0..count]
            }

            #[inline] fn take_split(&self, count: usize) -> (Self, Self)
            {
                let (prefix, suffix) = self.split_at(count);
                (suffix, prefix)
            }
        }

        impl<'a> InputIter for &'a str 
        {
            type Item = char;
            type Iter = CharIndices<'a>;
            type IterElem = Chars<'a>;

            #[inline] fn iter_indices(&self) -> Self::Iter { self.char_indices() }

            #[inline] fn iter_elements(&self) -> Self::IterElem { self.chars() }

            fn position<P>(&self, predicate: P) -> Option<usize> where
            P: Fn(Self::Item) -> bool,
            {
                for (o, c) in self.char_indices()
                {
                    if predicate(c) { return Some(o); }
                }

                None
            }

            #[inline] fn slice_index(&self, count: usize) -> Result<usize, Needed>
            {
                let mut cnt = 0;
                for (index, _) in self.char_indices()
                {
                    if cnt == count { return Ok(index); }
                    cnt += 1;
                }

                if cnt == count { return Ok(self.len()); }

                Err(Needed::Unknown)
            }
        }

        impl<'a> InputTake for &'a str 
        {
            #[inline]
            fn take(&self, count: usize) -> Self
            {
                &self[..count]
            }

            // return byte index
            #[inline] fn take_split(&self, count: usize) -> (Self, Self)
            {
                let (prefix, suffix) = self.split_at(count);
                (suffix, prefix)
            }
        }

        /// Dummy trait used for default implementations
        pub trait UnspecializedInput {}

        /// Methods to take as much input as possible until the provided function returns true for the current element.
        pub trait InputTakeAtPosition: Sized 
        {
            /// The current input type is a sequence of that `Item` type.
            type Item;

            /// Looks for the first element of the input type for which the condition returns true, and returns the input up to this position.
            fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool;

            /// Looks for the first element of the input type for which the condition returns true and returns the input up to this position.
            fn split_at_position1<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
                e: ErrorKind,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool;

            /// Looks for the first element of the input type for which the condition returns true, and returns the input up to this position.
            fn split_at_position_complete<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool;

            /// Looks for the first element of the input type for which the condition returns true and returns the input up to this position.
            fn split_at_position1_complete<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
                e: ErrorKind,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool;
        }

        impl<T: InputLength + InputIter + InputTake + Clone + UnspecializedInput> InputTakeAtPosition
        for T
        {
            type Item = <T as InputIter>::Item;

            fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.position(predicate)
                {
                    Some(n) => Ok(self.take_split(n)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position1<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
                e: ErrorKind,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.position(predicate)
                {
                    Some(0) => Err(Err::Error(E::from_error_kind(self.clone(), e))),
                    Some(n) => Ok(self.take_split(n)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position_complete<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.split_at_position(predicate)
                {
                    Err(Err::Incomplete(_)) => Ok(self.take_split(self.input_len())),
                    res => res,
                }
            }

            fn split_at_position1_complete<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
                e: ErrorKind,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.split_at_position1(predicate, e)
                {
                    Err(Err::Incomplete(_)) => 
                    {
                        if self.input_len() == 0 
                        { Err(Err::Error(E::from_error_kind(self.clone(), e))) }
                        
                        else { Ok(self.take_split(self.input_len())) }
                    }
                    res => res,
                }
            }
        }

        impl<'a> InputTakeAtPosition for &'a [u8] 
        {
            type Item = u8;

            fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.iter().position(|c| predicate(*c))
                {
                    Some(i) => Ok(self.take_split(i)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position1<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
                e: ErrorKind,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.iter().position(|c| predicate(*c)) 
                {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => Ok(self.take_split(i)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position_complete<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.iter().position(|c| predicate(*c)) 
                {
                    Some(i) => Ok(self.take_split(i)),
                    None => Ok(self.take_split(self.input_len())),
                }
            }

            fn split_at_position1_complete<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
                e: ErrorKind,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.iter().position(|c| predicate(*c))
                {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => Ok(self.take_split(i)),
                    None => 
                    {
                        if self.is_empty()
                        { Err(Err::Error(E::from_error_kind(self, e))) }
                        
                        else { Ok(self.take_split(self.input_len())) }
                    }
                }
            }
        }

        impl<'a> InputTakeAtPosition for &'a str 
        {
            type Item = char;

            fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.find(predicate)
                {
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position1<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
                e: ErrorKind,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.find(predicate)
                {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position_complete<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.find(predicate) 
                {
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => unsafe
                    {
                        Ok
                        ((
                            self.get_unchecked(self.len()..),
                            self.get_unchecked(..self.len()),
                        ))
                    },
                }
            }

            fn split_at_position1_complete<P, E: ParseError<Self>>
            (
                &self,
                predicate: P,
                e: ErrorKind,
            ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.find(predicate) 
                {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => 
                    {
                        if self.is_empty() 
                        {
                        Err(Err::Error(E::from_error_kind(self, e)))
                        } 
                        else 
                        {
                            unsafe 
                            {
                                Ok
                                ((
                                    self.get_unchecked(self.len()..),
                                    self.get_unchecked(..self.len()),
                                ))
                            }
                        }
                    }
                }
            }
        }

        /// Indicates whether a comparison was successful, an error, or if more data was needed.
        #[derive(Debug, PartialEq)]
        pub enum CompareResult 
        {
            /// Comparison was successful
            Ok,
            /// We need more data to be sure
            Incomplete,
            /// Comparison failed
            Error,
        }

        /// Abstracts comparison operations
        pub trait Compare<T> 
        {
            /// Compares self to another value for equality
            fn compare(&self, t: T) -> CompareResult;
            /// Compares self to another value for equality independently of the case.
            fn compare_no_case(&self, t: T) -> CompareResult;
        }

        fn lowercase_byte(c: u8) -> u8 
        {
            match c 
            {
                b'A'..=b'Z' => c - b'A' + b'a',
                _ => c,
            }
        }

        impl<'a, 'b> Compare<&'b [u8]> for &'a [u8] 
        {
            #[inline(always)] fn compare(&self, t: &'b [u8]) -> CompareResult 
            {
                let pos = self.iter().zip(t.iter()).position(|(a, b)| a != b);
                match pos 
                {
                    Some(_) => CompareResult::Error,
                    None => 
                    {
                        if self.len() >= t.len() 
                        { CompareResult::Ok } 
                        else { CompareResult::Incomplete }
                    }
                }
            }

            #[inline(always)] fn compare_no_case(&self, t: &'b [u8]) -> CompareResult 
            {
                if self
                .iter()
                .zip(t)
                .any(|(a, b)| lowercase_byte(*a) != lowercase_byte(*b)){ CompareResult::Error } 
                else if self.len() < t.len() { CompareResult::Incomplete } 
                else { CompareResult::Ok }
            }
        }

        impl
        <
            T: InputLength + InputIter<Item = u8> + InputTake + UnspecializedInput,
            O: InputLength + InputIter<Item = u8> + InputTake,
        > Compare<O> for T
        {
            #[inline(always)] fn compare(&self, t: O) -> CompareResult 
            {
                let pos = self
                .iter_elements()
                .zip(t.iter_elements())
                .position(|(a, b)| a != b);

                match pos
                {
                    Some(_) => CompareResult::Error,
                    None => 
                    {
                        if self.input_len() >= t.input_len()
                        { CompareResult::Ok } 
                        else 
                        { CompareResult::Incomplete }
                    }
                }
            }

            #[inline(always)] fn compare_no_case(&self, t: O) -> CompareResult 
            {
                if self
                .iter_elements()
                .zip(t.iter_elements())
                .any(|(a, b)| lowercase_byte(a) != lowercase_byte(b))
                { CompareResult::Error } 
                
                else if self.input_len() < t.input_len() 
                { CompareResult::Incomplete }

                else 
                { CompareResult::Ok }
            }
        }

        impl<'a, 'b> Compare<&'b str> for &'a [u8] 
        {
            #[inline(always)] fn compare(&self, t: &'b str) -> CompareResult 
            {
                self.compare(AsBytes::as_bytes(t))
            }

            #[inline(always)] fn compare_no_case(&self, t: &'b str) -> CompareResult 
            {
                self.compare_no_case(AsBytes::as_bytes(t))
            }
        }

        impl<'a, 'b> Compare<&'b str> for &'a str 
        {
            #[inline(always)]
            fn compare(&self, t: &'b str) -> CompareResult 
            {
                self.as_bytes().compare(t.as_bytes())
            }

            //FIXME: this version is too simple and does not use the current locale
            #[inline(always)]
            fn compare_no_case(&self, t: &'b str) -> CompareResult 
            {
                let pos = self
                .chars()
                .zip(t.chars())
                .position(|(a, b)| a.to_lowercase().ne(b.to_lowercase()));

                match pos 
                {
                    Some(_) => CompareResult::Error,
                    None => 
                    {
                        if self.len() >= t.len() 
                        { CompareResult::Ok } 

                        else { CompareResult::Incomplete }
                    }
                }
            }
        }

        impl<'a, 'b> Compare<&'b [u8]> for &'a str 
        {
            #[inline(always)] fn compare(&self, t: &'b [u8]) -> CompareResult
            {
                AsBytes::as_bytes(self).compare(t)
            }

            #[inline(always)] fn compare_no_case(&self, t: &'b [u8]) -> CompareResult
            {
                AsBytes::as_bytes(self).compare_no_case(t)
            }
        }

        /// Look for a token in self
        pub trait FindToken<T> 
        {
            fn find_token(&self, token: T) -> bool;
        }

        impl<'a> FindToken<u8> for &'a [u8] 
        {
            fn find_token(&self, token: u8) -> bool
            {
                memchr::memchr(token, self).is_some()
            }
        }

        impl<'a> FindToken<u8> for &'a str 
        {
            fn find_token(&self, token: u8) -> bool
            {
                self.as_bytes().find_token(token)
            }
        }

        impl<'a, 'b> FindToken<&'a u8> for &'b [u8] 
        {
            fn find_token(&self, token: &u8) -> bool
            {
                self.find_token(*token)
            }
        }

        impl<'a, 'b> FindToken<&'a u8> for &'b str 
        {
            fn find_token(&self, token: &u8) -> bool
            {
                self.as_bytes().find_token(token)
            }
        }

        impl<'a> FindToken<char> for &'a [u8] 
        {
            fn find_token(&self, token: char) -> bool
            {
                self.iter().any(|i| *i == token as u8)
            }
        }

        impl<'a> FindToken<char> for &'a str 
        {
            fn find_token(&self, token: char) -> bool
            {
                self.chars().any(|i| i == token)
            }
        }

        impl<'a> FindToken<char> for &'a [char] 
        {
            fn find_token(&self, token: char) -> bool
            {
                self.iter().any(|i| *i == token)
            }
        }

        impl<'a, 'b> FindToken<&'a char> for &'b [char] 
        {
            fn find_token(&self, token: &char) -> bool
            { self.find_token(*token) }
        }

        /// Look for a substring in self
        pub trait FindSubstring<T> 
        {
            /// Returns the byte position of the substring if it is found
            fn find_substring(&self, substr: T) -> Option<usize>;
        }

        impl<'a, 'b> FindSubstring<&'b [u8]> for &'a [u8]
        {
            fn find_substring(&self, substr: &'b [u8]) -> Option<usize> 
            {
                if substr.len() > self.len() 
                { return None; }

                let (&substr_first, substr_rest) = 
                match substr.split_first()
                {
                    Some(split) => split,
                    None => return Some(0),
                };

                if substr_rest.is_empty() 
                { return memchr::memchr(substr_first, self); }

                let mut offset = 0;
                let haystack = &self[..self.len() - substr_rest.len()];

                while let Some(position) = memchr::memchr(substr_first, &haystack[offset..]) {
                offset += position;
                let next_offset = offset + 1;
                if &self[next_offset..][..substr_rest.len()] == substr_rest {
                    return Some(offset);
                }

                offset = next_offset;
                }

                None
            }
        }

        impl<'a, 'b> FindSubstring<&'b str> for &'a [u8]
        {
            fn find_substring(&self, substr: &'b str) -> Option<usize>
            {
                self.find_substring(AsBytes::as_bytes(substr))
            }
        }

        impl<'a, 'b> FindSubstring<&'b str> for &'a str
        {
            //returns byte index
            fn find_substring(&self, substr: &'b str) -> Option<usize>
            {
                self.find(substr)
            }
        }

        /// Used to integrate `str`'s `parse()` method
        pub trait ParseTo<R> 
        {
            /// Succeeds if `parse()` succeeded.
            fn parse_to(&self) -> Option<R>;
        }

        impl<'a, R: FromStr> ParseTo<R> for &'a [u8] 
        {
            fn parse_to(&self) -> Option<R>
            {
                from_utf8(self).ok().and_then(|s| s.parse().ok())
            }
        }

        impl<'a, R: FromStr> ParseTo<R> for &'a str 
        {
            fn parse_to(&self) -> Option<R>
            {
                self.parse().ok()
            }
        }

        /// Slicing operations using ranges.
        pub trait Slice<R> 
        {
            /// Slices self according to the range argument
            fn slice(&self, range: R) -> Self;
        }

        slice_ranges_impl! {str}
        slice_ranges_impl! {[T]}

        array_impls! 
        {
            0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 
            17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
        }

        /// Abstracts something which can extend an `Extend`.
        pub trait ExtendInto 
        {
            /// The current input type is a sequence of that `Item` type.
            type Item;

            /// The type that will be produced
            type Extender;

            /// Create a new `Extend` of the correct type
            fn new_builder(&self) -> Self::Extender;
            /// Accumulate the input into an accumulator
            fn extend_into(&self, acc: &mut Self::Extender);
        }
        
        impl ExtendInto for [u8] 
        {
            type Item = u8;
            type Extender = Vec<u8>;

            #[inline]
            fn new_builder(&self) -> Vec<u8> {
                Vec::new()
            }
            #[inline]
            fn extend_into(&self, acc: &mut Vec<u8>) {
                acc.extend(self.iter().cloned());
            }
        }
        
        impl ExtendInto for &[u8] 
        {
            type Item = u8;
            type Extender = Vec<u8>;

            #[inline] fn new_builder(&self) -> Vec<u8>
            {
                Vec::new()
            }

            #[inline] fn extend_into(&self, acc: &mut Vec<u8>)
            {
                acc.extend_from_slice(self);
            }
        }
        
        impl ExtendInto for str 
        {
            type Item = char;
            type Extender = String;

            #[inline] fn new_builder(&self) -> String
            {
                String::new()
            }

            #[inline] fn extend_into(&self, acc: &mut String)
            {
                acc.push_str(self);
            }
        }
        
        impl ExtendInto for &str 
        {
            type Item = char;
            type Extender = String;

            #[inline] fn new_builder(&self) -> String
            {
                String::new()
            }

            #[inline] fn extend_into(&self, acc: &mut String)
            {
                acc.push_str(self);
            }
        }
        
        impl ExtendInto for char 
        {
            type Item = char;
            type Extender = String;

            #[inline] fn new_builder(&self) -> String 
            {
                String::new()
            }

            #[inline] fn extend_into(&self, acc: &mut String) 
            {
                acc.push(*self);
            }
        }

        /// Helper trait to convert numbers to usize.
        pub trait ToUsize 
        {
            fn to_usize(&self) -> usize;
        }

        impl ToUsize for u8 
        {
            #[inline] fn to_usize(&self) -> usize 
            {
                *self as usize
            }
        }

        impl ToUsize for u16
        {
            #[inline]
            fn to_usize(&self) -> usize {
                *self as usize
            }
        }

        impl ToUsize for usize 
        {
            #[inline]
            fn to_usize(&self) -> usize {
                *self
            }
        }
        
        impl ToUsize for u32 
        {
            #[inline]
            fn to_usize(&self) -> usize {
                *self as usize
            }
        }
        
        impl ToUsize for u64 
        {
            #[inline]
            fn to_usize(&self) -> usize {
                *self as usize
            }
        }

        /// Equivalent From implementation to avoid orphan rules in bits parsers
        pub trait ErrorConvert<E> 
        {
            /// Transform to another error type
            fn convert(self) -> E;
        }

        impl<I> ErrorConvert<(I, ErrorKind)> for ((I, usize), ErrorKind) 
        {
            fn convert(self) -> (I, ErrorKind) {
                ((self.0).0, self.1)
            }
        }

        impl<I> ErrorConvert<((I, usize), ErrorKind)> for (I, ErrorKind)
        {
            fn convert(self) -> ((I, usize), ErrorKind) {
                ((self.0, 0), self.1)
            }
        }

        impl<I> ErrorConvert<error::Error<I>> for error::Error<(I, usize)> 
        {
            fn convert(self) -> error::Error<I> {
                error::Error {
                input: self.input.0,
                code: self.code,
                }
            }
        }

        impl<I> ErrorConvert<error::Error<(I, usize)>> for error::Error<I>
        {
            fn convert(self) -> error::Error<(I, usize)> 
            {
                error::Error {
                input: (self.input, 0),
                code: self.code,
                }
            }
        }
        
        impl<I> ErrorConvert<error::VerboseError<I>> for error::VerboseError<(I, usize)> 
        {
            fn convert(self) -> error::VerboseError<I> {
                error::VerboseError {
                errors: self.errors.into_iter().map(|(i, e)| (i.0, e)).collect(),
                }
            }
        }
        
        impl<I> ErrorConvert<error::VerboseError<(I, usize)>> for error::VerboseError<I> 
        {
            fn convert(self) -> error::VerboseError<(I, usize)> {
                error::VerboseError {
                errors: self.errors.into_iter().map(|(i, e)| ((i, 0), e)).collect(),
                }
            }
        }

        impl ErrorConvert<()> for () 
        {
            fn convert(self) {}
        }
        
        /// Helper trait to show a byte slice as a hex dump
        pub trait HexDisplay 
        {
            /// Converts the value of `self` to a hex dump, returning the owned
            /// `String`.
            fn to_hex(&self, chunk_size: usize) -> String;

            /// Converts the value of `self` to a hex dump beginning at `from` address, returning the owned
            /// `String`.
            fn to_hex_from(&self, chunk_size: usize, from: usize) -> String;
        }
        
        impl HexDisplay for [u8] 
        {
            #[allow(unused_variables)]
            fn to_hex(&self, chunk_size: usize) -> String {
                self.to_hex_from(chunk_size, 0)
            }

            #[allow(unused_variables)]
            fn to_hex_from(&self, chunk_size: usize, from: usize) -> String {
                let mut v = Vec::with_capacity(self.len() * 3);
                let mut i = from;
                for chunk in self.chunks(chunk_size) {
                let s = format!("{:08x}", i);
                for &ch in s.as_bytes().iter() {
                    v.push(ch);
                }
                v.push(b'\t');

                i += chunk_size;

                for &byte in chunk {
                    v.push(CHARS[(byte >> 4) as usize]);
                    v.push(CHARS[(byte & 0xf) as usize]);
                    v.push(b' ');
                }
                if chunk_size > chunk.len() {
                    for j in 0..(chunk_size - chunk.len()) {
                    v.push(b' ');
                    v.push(b' ');
                    v.push(b' ');
                    }
                }
                v.push(b'\t');

                for &byte in chunk {
                    if (byte >= 32 && byte <= 126) || byte >= 128 {
                    v.push(byte);
                    } else {
                    v.push(b'.');
                    }
                }
                v.push(b'\n');
                }

                String::from_utf8_lossy(&v[..]).into_owned()
            }
        }
        
        impl HexDisplay for str 
        {
            #[allow(unused_variables)]
            fn to_hex(&self, chunk_size: usize) -> String 
            {
                self.to_hex_from(chunk_size, 0)
            }

            #[allow(unused_variables)]
            fn to_hex_from(&self, chunk_size: usize, from: usize) -> String {
                self.as_bytes().to_hex_from(chunk_size, from)
            }
        }
    }
    /*
    */
    pub mod bits
    {
        //! Bit level parsers
        pub mod complete
        {
            //! Bit level parsers.
            use super::super::error::{ErrorKind, ParseError};
            use super::super::internal::{Err, IResult};
            use super::super::lib::std::ops::{AddAssign, Div, RangeFrom, Shl, Shr};
            use super::super::traits::{InputIter, InputLength, Slice, ToUsize};

            /// Generates a parser taking `count` bits.
            pub fn take<I, O, C, E: ParseError<(I, usize)>>( count: C, ) 
            -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            C: ToUsize,
            O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O>,
            {
                let count = count.to_usize();
                move |(input, bit_offset): (I, usize)| {
                    if count == 0 {
                    Ok(((input, bit_offset), 0u8.into()))
                    } else {
                    let cnt = (count + bit_offset).div(8);
                    if input.input_len() * 8 < count + bit_offset {
                        Err(Err::Error(E::from_error_kind(
                        (input, bit_offset),
                        ErrorKind::Eof,
                        )))
                    } else {
                        let mut acc: O = 0_u8.into();
                        let mut offset: usize = bit_offset;
                        let mut remaining: usize = count;
                        let mut end_offset: usize = 0;

                        for byte in input.iter_elements().take(cnt + 1) {
                        if remaining == 0 {
                            break;
                        }
                        let val: O = if offset == 0 {
                            byte.into()
                        } else {
                            ((byte << offset) as u8 >> offset).into()
                        };

                        if remaining < 8 - offset {
                            acc += val >> (8 - offset - remaining);
                            end_offset = remaining + offset;
                            break;
                        } else {
                            acc += val << (remaining - (8 - offset));
                            remaining -= 8 - offset;
                            offset = 0;
                        }
                        }
                        Ok(((input.slice(cnt..), end_offset), acc))
                    }
                    }
                }
            }

            /// Generates a parser taking `count` bits and comparing them to `pattern`
            pub fn tag<I, O, C, E: ParseError<(I, usize)>>( pattern: O, count: C, ) 
            -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength + Clone,
            C: ToUsize,
            O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O> + PartialEq,
            {
                let count = count.to_usize();
                move |input: (I, usize)| {
                    let inp = input.clone();

                    take(count)(input).and_then(|(i, o)| {
                    if pattern == o {
                        Ok((i, o))
                    } else {
                        Err(Err::Error(error_position!(inp, ErrorKind::TagBits)))
                    }
                    })
                }
            }

            /// Parses one specific bit as a bool.
            pub fn bool<I, E: ParseError<(I, usize)>>(input: (I, usize)) -> IResult<(I, usize), bool, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let (res, bit): (_, u32) = take(1usize)(input)?;
                Ok((res, bit != 0))
            }
        }

        pub mod streaming
        {
            //! Bit level parsers.
            use super::super::error::{ErrorKind, ParseError};
            use super::super::internal::{Err, IResult, Needed};
            use super::super::lib::std::ops::{AddAssign, Div, RangeFrom, Shl, Shr};
            use super::super::traits::{InputIter, InputLength, Slice, ToUsize};

            /// Generates a parser taking `count` bits
            pub fn take<I, O, C, E: ParseError<(I, usize)>> ( count: C, ) 
            -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            C: ToUsize,
            O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O>,
            {
                let count = count.to_usize();
                move |(input, bit_offset): (I, usize)| {
                    if count == 0 {
                    Ok(((input, bit_offset), 0u8.into()))
                    } else {
                    let cnt = (count + bit_offset).div(8);
                    if input.input_len() * 8 < count + bit_offset {
                        Err(Err::Incomplete(Needed::new(count as usize)))
                    } else {
                        let mut acc: O = 0_u8.into();
                        let mut offset: usize = bit_offset;
                        let mut remaining: usize = count;
                        let mut end_offset: usize = 0;

                        for byte in input.iter_elements().take(cnt + 1) {
                        if remaining == 0 {
                            break;
                        }
                        let val: O = if offset == 0 {
                            byte.into()
                        } else {
                            ((byte << offset) as u8 >> offset).into()
                        };

                        if remaining < 8 - offset {
                            acc += val >> (8 - offset - remaining);
                            end_offset = remaining + offset;
                            break;
                        } else {
                            acc += val << (remaining - (8 - offset));
                            remaining -= 8 - offset;
                            offset = 0;
                        }
                        }
                        Ok(((input.slice(cnt..), end_offset), acc))
                    }
                    }
                }
            }

            /// Generates a parser taking `count` bits and comparing them to `pattern`
            pub fn tag<I, O, C, E: ParseError<(I, usize)>>
            (
                pattern: O,
                count: C,
            ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength + Clone,
            C: ToUsize,
            O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O> + PartialEq,
            {
                let count = count.to_usize();
                move |input: (I, usize)| {
                    let inp = input.clone();

                    take(count)(input).and_then(|(i, o)| {
                    if pattern == o {
                        Ok((i, o))
                    } else {
                        Err(Err::Error(error_position!(inp, ErrorKind::TagBits)))
                    }
                    })
                }
            }

            /// Parses one specific bit as a bool.
            pub fn bool<I, E: ParseError<(I, usize)>>(input: (I, usize)) -> IResult<(I, usize), bool, E>
            where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let (res, bit): (_, u32) = take(1usize)(input)?;
                Ok((res, bit != 0))
            }
        }

        use super::error::{ErrorKind, ParseError};
        use super::internal::{Err, IResult, Needed, Parser};
        use super::lib::std::ops::RangeFrom;
        use super::traits::{ErrorConvert, Slice};

        /// Converts a byte-level input to a bit-level input, for consumption by a parser that uses bits.
        pub fn bits<I, O, E1, E2, P>(mut parser: P) -> impl FnMut(I) -> IResult<I, O, E2> where
        E1: ParseError<(I, usize)> + ErrorConvert<E2>,
        E2: ParseError<I>,
        I: Slice<RangeFrom<usize>>,
        P: Parser<(I, usize), O, E1>,
        {
            move |input: I| match parser.parse((input, 0)) {
                Ok(((rest, offset), result)) => {
                // If the next byte has been partially read, it will be sliced away as well.
                let remaining_bytes_index = offset / 8 + if offset % 8 == 0 { 0 } else { 1 };
                Ok((rest.slice(remaining_bytes_index..), result))
                }
                Err(Err::Incomplete(n)) => Err(Err::Incomplete(n.map(|u| u.get() / 8 + 1))),
                Err(Err::Error(e)) => Err(Err::Error(e.convert())),
                Err(Err::Failure(e)) => Err(Err::Failure(e.convert())),
            }
        }

        /// Counterpart to `bits`, `bytes` transforms its bit stream input into a byte slice 
        /// for the underlying parser, allowing byte-slice parsers to work on bit streams.
        pub fn bytes<I, O, E1, E2, P>(mut parser: P) -> impl FnMut((I, usize)) -> IResult<(I, usize), O, E2> where
        E1: ParseError<I> + ErrorConvert<E2>,
        E2: ParseError<(I, usize)>,
        I: Slice<RangeFrom<usize>> + Clone,
        P: Parser<I, O, E1>,
        {
            move |(input, offset): (I, usize)| {
                let inner = if offset % 8 != 0 {
                input.slice((1 + offset / 8)..)
                } else {
                input.slice((offset / 8)..)
                };
                let i = (input, offset);
                match parser.parse(inner) {
                Ok((rest, res)) => Ok(((rest, 0), res)),
                Err(Err::Incomplete(Needed::Unknown)) => Err(Err::Incomplete(Needed::Unknown)),
                Err(Err::Incomplete(Needed::Size(sz))) => Err(match sz.get().checked_mul(8) {
                    Some(v) => Err::Incomplete(Needed::new(v)),
                    None => Err::Failure(E2::from_error_kind(i, ErrorKind::TooLarge)),
                }),
                Err(Err::Error(e)) => Err(Err::Error(e.convert())),
                Err(Err::Failure(e)) => Err(Err::Failure(e.convert())),
                }
            }
        }
    }
    /*
    */
    pub mod bytes
    {
        //! Parsers recognizing bytes streams
        pub mod complete
        {
            //! Parsers recognizing bytes streams, complete input version.
            use super::super::error::ErrorKind;
            use super::super::error::ParseError;
            use super::super::internal::{Err, IResult, Parser};
            use super::super::lib::std::ops::RangeFrom;
            use super::super::lib::std::result::Result::*;
            use super::super::traits::
            {
                Compare, CompareResult, FindSubstring, FindToken, InputIter, InputLength, 
                InputTake, InputTakeAtPosition, Slice, ToUsize,
            };

            /// Recognizes a pattern.
            pub fn tag<T, Input, Error: ParseError<Input>>
            (
                tag: T,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + Compare<T>,
            T: InputLength + Clone,
            {
                move |i: Input| {
                    let tag_len = tag.input_len();
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match i.compare(t) {
                    CompareResult::Ok => Ok(i.take_split(tag_len)),
                    _ => {
                        let e: ErrorKind = ErrorKind::Tag;
                        Err(Err::Error(Error::from_error_kind(i, e)))
                    }
                    };
                    res
                }
            }

            /// Recognizes a case insensitive pattern.
            pub fn tag_no_case<T, Input, Error: ParseError<Input>>
            (
                tag: T,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + Compare<T>,
            T: InputLength + Clone,
            {
                move |i: Input| {
                    let tag_len = tag.input_len();
                    let t = tag.clone();

                    let res: IResult<_, _, Error> = match (i).compare_no_case(t) {
                    CompareResult::Ok => Ok(i.take_split(tag_len)),
                    _ => {
                        let e: ErrorKind = ErrorKind::Tag;
                        Err(Err::Error(Error::from_error_kind(i, e)))
                    }
                    };
                    res
                }
            }

            /// Parse till certain characters are met.
            pub fn is_not<T, Input, Error: ParseError<Input>>
            (
                arr: T,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            T: FindToken<<Input as InputTakeAtPosition>::Item>,
            {
                move |i: Input| {
                    let e: ErrorKind = ErrorKind::IsNot;
                    i.split_at_position1_complete(|c| arr.find_token(c), e)
                }
            }

            /// Returns the longest slice of the matches the pattern.
            pub fn is_a<T, Input, Error: ParseError<Input>>
            (
                arr: T,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            T: FindToken<<Input as InputTakeAtPosition>::Item>,
            {
                move |i: Input| {
                    let e: ErrorKind = ErrorKind::IsA;
                    i.split_at_position1_complete(|c| !arr.find_token(c), e)
                }
            }

            /// Returns the longest input slice (if any) that matches the predicate.
            pub fn take_while<F, Input, Error: ParseError<Input>>( cond: F, ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
            {
                move |i: Input| i.split_at_position_complete(|c| !cond(c))
            }

            /// Returns the longest (at least 1) input slice that matches the predicate.
            pub fn take_while1<F, Input, Error: ParseError<Input>>( cond: F, ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
            {
                move |i: Input| {
                    let e: ErrorKind = ErrorKind::TakeWhile1;
                    i.split_at_position1_complete(|c| !cond(c), e)
                }
            }

            /// Returns the longest (m <= len <= n) input slice  that matches the predicate.
            pub fn take_while_m_n<F, Input, Error: ParseError<Input>>
            (
            m: usize,
            n: usize,
            cond: F,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputIter + InputLength + Slice<RangeFrom<usize>>,
            F: Fn(<Input as InputIter>::Item) -> bool,
            {
                move |i: Input| {
                    let input = i;

                    match input.position(|c| !cond(c)) {
                    Some(idx) => {
                        if idx >= m {
                        if idx <= n {
                            let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(idx) {
                            Ok(input.take_split(index))
                            } else {
                            Err(Err::Error(Error::from_error_kind(
                                input,
                                ErrorKind::TakeWhileMN,
                            )))
                            };
                            res
                        } else {
                            let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(n) {
                            Ok(input.take_split(index))
                            } else {
                            Err(Err::Error(Error::from_error_kind(
                                input,
                                ErrorKind::TakeWhileMN,
                            )))
                            };
                            res
                        }
                        } else {
                        let e = ErrorKind::TakeWhileMN;
                        Err(Err::Error(Error::from_error_kind(input, e)))
                        }
                    }
                    None => {
                        let len = input.input_len();
                        if len >= n {
                        match input.slice_index(n) {
                            Ok(index) => Ok(input.take_split(index)),
                            Err(_needed) => Err(Err::Error(Error::from_error_kind(
                            input,
                            ErrorKind::TakeWhileMN,
                            ))),
                        }
                        } else if len >= m && len <= n {
                        let res: IResult<_, _, Error> = Ok((input.slice(len..), input));
                        res
                        } else {
                        let e = ErrorKind::TakeWhileMN;
                        Err(Err::Error(Error::from_error_kind(input, e)))
                        }
                    }
                    }
                }
            }

            /// Returns the longest input slice (if any) till a predicate is met.
            pub fn take_till<F, Input, Error: ParseError<Input>>
            (
                cond: F,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
            {
                move |i: Input| i.split_at_position_complete(|c| cond(c))
            }

            /// Returns the longest (at least 1) input slice till a predicate is met.
            pub fn take_till1<F, Input, Error: ParseError<Input>>
            (
                cond: F,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
            {
                move |i: Input| {
                    let e: ErrorKind = ErrorKind::TakeTill1;
                    i.split_at_position1_complete(|c| cond(c), e)
                }
            }

            /// Returns an input slice containing the first N input elements (Input[..N]).
            pub fn take<C, Input, Error: ParseError<Input>>
            (
                count: C,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputIter + InputTake,
            C: ToUsize,
            {
                let c = count.to_usize();
                move |i: Input| match i.slice_index(c) {
                    Err(_needed) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Eof))),
                    Ok(index) => Ok(i.take_split(index)),
                }
            }

            /// Returns the input slice up to the first occurrence of the pattern.
            pub fn take_until<T, Input, Error: ParseError<Input>>
            (
                tag: T,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + FindSubstring<T>,
            T: InputLength + Clone,
            {
                move |i: Input| {
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match i.find_substring(t) {
                    None => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                    Some(index) => Ok(i.take_split(index)),
                    };
                    res
                }
            }

            /// Returns the non empty input slice up to the first occurrence of the pattern.
            pub fn take_until1<T, Input, Error: ParseError<Input>>
            (
                tag: T,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + FindSubstring<T>,
            T: InputLength + Clone,
            {
                move |i: Input| {
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match i.find_substring(t) {
                    None => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                    Some(0) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                    Some(index) => Ok(i.take_split(index)),
                    };
                    res
                }
            }

            /// Matches a byte string with escaped characters.
            pub fn escaped<'a, Input: 'a, Error, F, G, O1, O2>
            (
                mut normal: F,
                control_char: char,
                mut escapable: G,
            ) -> impl FnMut(Input) -> IResult<Input, Input, Error> where
            Input: Clone
            + super::super::traits::Offset
            + InputLength
            + InputTake
            + InputTakeAtPosition
            + Slice<RangeFrom<usize>>
            + InputIter,
            <Input as InputIter>::Item: super::super::traits::AsChar,
            F: Parser<Input, O1, Error>,
            G: Parser<Input, O2, Error>,
            Error: ParseError<Input>,
            {
                use super::super::traits::AsChar;

                move |input: Input| {
                    let mut i = input.clone();

                    while i.input_len() > 0 {
                    let current_len = i.input_len();

                    match normal.parse(i.clone()) {
                        Ok((i2, _)) => {
                        // return if we consumed everything or if the normal parser
                        // does not consume anything
                        if i2.input_len() == 0 {
                            return Ok((input.slice(input.input_len()..), input));
                        } else if i2.input_len() == current_len {
                            let index = input.offset(&i2);
                            return Ok(input.take_split(index));
                        } else {
                            i = i2;
                        }
                        }
                        Err(Err::Error(_)) => {
                        // unwrap() should be safe here since index < $i.input_len()
                        if i.iter_elements().next().unwrap().as_char() == control_char {
                            let next = control_char.len_utf8();
                            if next >= i.input_len() {
                            return Err(Err::Error(Error::from_error_kind(
                                input,
                                ErrorKind::Escaped,
                            )));
                            } else {
                            match escapable.parse(i.slice(next..)) {
                                Ok((i2, _)) => {
                                if i2.input_len() == 0 {
                                    return Ok((input.slice(input.input_len()..), input));
                                } else {
                                    i = i2;
                                }
                                }
                                Err(e) => return Err(e),
                            }
                            }
                        } else {
                            let index = input.offset(&i);
                            if index == 0 {
                            return Err(Err::Error(Error::from_error_kind(
                                input,
                                ErrorKind::Escaped,
                            )));
                            }
                            return Ok(input.take_split(index));
                        }
                        }
                        Err(e) => {
                        return Err(e);
                        }
                    }
                    }

                    Ok((input.slice(input.input_len()..), input))
                }
            }

            /// Matches a byte string with escaped characters.
            pub fn escaped_transform<Input, Error, F, G, O1, O2, ExtendItem, Output>
            (
                mut normal: F,
                control_char: char,
                mut transform: G,
            ) -> impl FnMut(Input) -> IResult<Input, Output, Error> where
            Input: Clone
            + super::super::traits::Offset
            + InputLength
            + InputTake
            + InputTakeAtPosition
            + Slice<RangeFrom<usize>>
            + InputIter,
            Input: super::super::traits::ExtendInto<Item = ExtendItem, Extender = Output>,
            O1: super::super::traits::ExtendInto<Item = ExtendItem, Extender = Output>,
            O2: super::super::traits::ExtendInto<Item = ExtendItem, Extender = Output>,
            <Input as InputIter>::Item: super::super::traits::AsChar,
            F: Parser<Input, O1, Error>,
            G: Parser<Input, O2, Error>,
            Error: ParseError<Input>,
            {
                use super::super::traits::AsChar;

                move |input: Input| {
                    let mut index = 0;
                    let mut res = input.new_builder();

                    let i = input.clone();

                    while index < i.input_len() {
                    let current_len = i.input_len();
                    let remainder = i.slice(index..);
                    match normal.parse(remainder.clone()) {
                        Ok((i2, o)) => {
                        o.extend_into(&mut res);
                        if i2.input_len() == 0 {
                            return Ok((i.slice(i.input_len()..), res));
                        } else if i2.input_len() == current_len {
                            return Ok((remainder, res));
                        } else {
                            index = input.offset(&i2);
                        }
                        }
                        Err(Err::Error(_)) => {
                        // unwrap() should be safe here since index < $i.input_len()
                        if remainder.iter_elements().next().unwrap().as_char() == control_char {
                            let next = index + control_char.len_utf8();
                            let input_len = input.input_len();

                            if next >= input_len {
                            return Err(Err::Error(Error::from_error_kind(
                                remainder,
                                ErrorKind::EscapedTransform,
                            )));
                            } else {
                            match transform.parse(i.slice(next..)) {
                                Ok((i2, o)) => {
                                o.extend_into(&mut res);
                                if i2.input_len() == 0 {
                                    return Ok((i.slice(i.input_len()..), res));
                                } else {
                                    index = input.offset(&i2);
                                }
                                }
                                Err(e) => return Err(e),
                            }
                            }
                        } else {
                            if index == 0 {
                            return Err(Err::Error(Error::from_error_kind(
                                remainder,
                                ErrorKind::EscapedTransform,
                            )));
                            }
                            return Ok((remainder, res));
                        }
                        }
                        Err(e) => return Err(e),
                    }
                    }
                    Ok((input.slice(index..), res))
                }
            }
        }

        pub mod streaming
        {
            //! Parsers recognizing bytes streams, streaming version
            use super::super::error::ErrorKind;
            use super::super::error::ParseError;
            use super::super::internal::{Err, IResult, Needed, Parser};
            use super::super::lib::std::ops::RangeFrom;
            use super::super::lib::std::result::Result::*;
            use super::super::traits::
            {
                Compare, CompareResult, FindSubstring, FindToken, InputIter, InputLength, 
                InputTake, InputTakeAtPosition, Slice, ToUsize,
            };

            /// Recognizes a pattern.
            pub fn tag<T, Input, Error: ParseError<Input>>( tag: T ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputLength + Compare<T>,
            T: InputLength + Clone,
            {
                move |i: Input| 
                {
                    let tag_len = tag.input_len();
                    let t = tag.clone();

                    let res: IResult<_, _, Error> = match i.compare(t) {
                    CompareResult::Ok => Ok(i.take_split(tag_len)),
                    CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(tag_len - i.input_len()))),
                    CompareResult::Error => {
                        let e: ErrorKind = ErrorKind::Tag;
                        Err(Err::Error(Error::from_error_kind(i, e)))
                    }
                    };
                    res
                }
            }

            /// Recognizes a case insensitive pattern.
            pub fn tag_no_case<T, Input, Error: ParseError<Input>>( tag: T ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputLength + Compare<T>,
            T: InputLength + Clone,
            {
                move |i: Input| 
                {
                    let tag_len = tag.input_len();
                    let t = tag.clone();

                    let res: IResult<_, _, Error> = match (i).compare_no_case(t)
                    {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(tag_len - i.input_len()))),
                        CompareResult::Error => {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                    };
                    res
                }
            }

            /// Parse till certain characters are met.
            pub fn is_not<T, Input, Error: ParseError<Input>>( arr: T ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            T: FindToken<<Input as InputTakeAtPosition>::Item>,
            {
                move |i: Input| 
                {
                    let e: ErrorKind = ErrorKind::IsNot;
                    i.split_at_position1(|c| arr.find_token(c), e)
                }
            }

            /// Returns the longest slice of the matches the pattern.
            pub fn is_a<T, Input, Error: ParseError<Input>>( arr: T ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            T: FindToken<<Input as InputTakeAtPosition>::Item>,
            {
                move |i: Input| 
                {
                    let e: ErrorKind = ErrorKind::IsA;
                    i.split_at_position1(|c| !arr.find_token(c), e)
                }
            }

            /// Returns the longest input slice (if any) that matches the predicate.
            pub fn take_while<F, Input, Error: ParseError<Input>>( cond: F ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
            {
                move |i: Input| i.split_at_position(|c| !cond(c))
            }

            /// Returns the longest (at least 1) input slice that matches the predicate.
            pub fn take_while1<F, Input, Error: ParseError<Input>>( cond: F ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
            {
                move |i: Input| 
                {
                    let e: ErrorKind = ErrorKind::TakeWhile1;
                    i.split_at_position1(|c| !cond(c), e)
                }
            }

            /// Returns the longest (m <= len <= n) input slice  that matches the predicate.
            pub fn take_while_m_n<F, Input, Error: ParseError<Input>>
            (
                m: usize,
                n: usize,
                cond: F,
            ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputIter + InputLength,
            F: Fn(<Input as InputIter>::Item) -> bool,
            {
                move |i: Input| 
                {
                    let input = i;

                    match input.position(|c| !cond(c)) 
                    {
                        Some(idx) => 
                        {
                            if idx >= m {
                            if idx <= n {
                                let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(idx) {
                                Ok(input.take_split(index))
                                } else {
                                Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::TakeWhileMN,
                                )))
                                };
                                res
                            } else {
                                let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(n) {
                                Ok(input.take_split(index))
                                } else {
                                Err(Err::Error(Error::from_error_kind(
                                    input,
                                    ErrorKind::TakeWhileMN,
                                )))
                                };
                                res
                            }
                            } else {
                            let e = ErrorKind::TakeWhileMN;
                            Err(Err::Error(Error::from_error_kind(input, e)))
                            }
                        }

                        None => 
                        {
                            let len = input.input_len();
                            if len >= n {
                            match input.slice_index(n) {
                                Ok(index) => Ok(input.take_split(index)),
                                Err(_needed) => Err(Err::Error(Error::from_error_kind(
                                input,
                                ErrorKind::TakeWhileMN,
                                ))),
                            }
                            } else {
                            let needed = if m > len { m - len } else { 1 };
                            Err(Err::Incomplete(Needed::new(needed)))
                            }
                        }
                    }
                }
            }

            /// Returns the longest input slice (if any) till a predicate is met.
            pub fn take_till<F, Input, Error: ParseError<Input>>( cond: F ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
            {
                move |i: Input| i.split_at_position(|c| cond(c))
            }

            /// Returns the longest (at least 1) input slice till a predicate is met.
            pub fn take_till1<F, Input, Error: ParseError<Input>>( cond: F ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool,
            {
                move |i: Input| 
                {
                    let e: ErrorKind = ErrorKind::TakeTill1;
                    i.split_at_position1(|c| cond(c), e)
                }
            }

            /// Returns an input slice containing the first N input elements (Input[..N]).
            pub fn take<C, Input, Error: ParseError<Input>>( count: C ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputIter + InputTake + InputLength,
            C: ToUsize,
            {
                let c = count.to_usize();
                move |i: Input| match i.slice_index(c)
                {
                    Err(i) => Err(Err::Incomplete(i)),
                    Ok(index) => Ok(i.take_split(index)),
                }
            }

            /// Returns the input slice up to the first occurrence of the pattern.
            pub fn take_until<T, Input, Error: ParseError<Input>>( tag: T ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputLength + FindSubstring<T>,
            T: Clone,
            {
                move |i: Input| 
                {
                    let t = tag.clone();

                    let res: IResult<_, _, Error> = match i.find_substring(t) 
                    {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some(index) => Ok(i.take_split(index)),
                    };
                    
                    res
                }
            }

            /// Returns the non empty input slice up to the first occurrence of the pattern.
            pub fn take_until1<T, Input, Error: ParseError<Input>>( tag: T ) 
            -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputLength + FindSubstring<T>,
            T: Clone,
            {
                move |i: Input| {
                    let t = tag.clone();

                    let res: IResult<_, _, Error> = match i.find_substring(t) {
                    None => Err(Err::Incomplete(Needed::Unknown)),
                    Some(0) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                    Some(index) => Ok(i.take_split(index)),
                    };
                    res
                }
            }

            /// Matches a byte string with escaped characters.
            pub fn escaped<Input, Error, F, G, O1, O2>
            (
                mut normal: F,
                control_char: char,
                mut escapable: G,
            ) -> impl FnMut(Input) -> IResult<Input, Input, Error> where
            Input: Clone
            + super::super::traits::Offset
            + InputLength
            + InputTake
            + InputTakeAtPosition
            + Slice<RangeFrom<usize>>
            + InputIter,
            <Input as InputIter>::Item: super::super::traits::AsChar,
            F: Parser<Input, O1, Error>,
            G: Parser<Input, O2, Error>,
            Error: ParseError<Input>,
            {
                use super::super::traits::AsChar;

                move |input: Input| 
                {
                    let mut i = input.clone();

                    while i.input_len() > 0 
                    {
                        let current_len = i.input_len();

                        match normal.parse(i.clone())
                        {
                            Ok((i2, _)) => 
                            {
                                if i2.input_len() == 0 
                                { return Err(Err::Incomplete(Needed::Unknown)); }

                                else if i2.input_len() == current_len 
                                {
                                    let index = input.offset(&i2);
                                    return Ok(input.take_split(index));
                                } 

                                else { i = i2; }
                            }

                            Err(Err::Error(_)) => 
                            {
                                // unwrap() should be safe here since index < $i.input_len()
                                if i.iter_elements().next().unwrap().as_char() == control_char 
                                {
                                    let next = control_char.len_utf8();
                                    if next >= i.input_len() {
                                    return Err(Err::Incomplete(Needed::new(1)));
                                    } else {
                                    match escapable.parse(i.slice(next..)) {
                                        Ok((i2, _)) => {
                                        if i2.input_len() == 0 {
                                            return Err(Err::Incomplete(Needed::Unknown));
                                        } else {
                                            i = i2;
                                        }
                                        }
                                        Err(e) => return Err(e),
                                    }
                                    }
                                } 
                                
                                else 
                                {
                                    let index = input.offset(&i);
                                    return Ok(input.take_split(index));
                                }
                            }

                            Err(e) => { return Err(e); }
                        }
                    }

                    Err(Err::Incomplete(Needed::Unknown))
                }
            }

            /// Matches a byte string with escaped characters.
            pub fn escaped_transform<Input, Error, F, G, O1, O2, ExtendItem, Output>
            (
                mut normal: F,
                control_char: char,
                mut transform: G,
            ) -> impl FnMut(Input) -> IResult<Input, Output, Error> where
            Input: Clone
            + super::super::traits::Offset
            + InputLength
            + InputTake
            + InputTakeAtPosition
            + Slice<RangeFrom<usize>>
            + InputIter,
            Input: super::super::traits::ExtendInto<Item = ExtendItem, Extender = Output>,
            O1: super::super::traits::ExtendInto<Item = ExtendItem, Extender = Output>,
            O2: super::super::traits::ExtendInto<Item = ExtendItem, Extender = Output>,
            <Input as InputIter>::Item: super::super::traits::AsChar,
            F: Parser<Input, O1, Error>,
            G: Parser<Input, O2, Error>,
            Error: ParseError<Input>,
            {
                use super::super::traits::AsChar;
                move |input: Input| 
                {
                    let mut index = 0;
                    let mut res = input.new_builder();

                    let i = input.clone();

                    while index < i.input_len() 
                    {
                        let current_len = i.input_len();
                        let remainder = i.slice(index..);
                        match normal.parse(remainder.clone()) 
                        {
                            Ok((i2, o)) => 
                            {
                                o.extend_into(&mut res);
                                if i2.input_len() == 0 {
                                    return Err(Err::Incomplete(Needed::Unknown));
                                } else if i2.input_len() == current_len {
                                    return Ok((remainder, res));
                                } else {
                                    index = input.offset(&i2);
                                }
                            }

                            Err(Err::Error(_)) => 
                            {
                                // unwrap() should be safe here since index < $i.input_len()
                                if remainder.iter_elements().next().unwrap().as_char() == control_char {
                                    let next = index + control_char.len_utf8();
                                    let input_len = input.input_len();

                                    if next >= input_len {
                                    return Err(Err::Incomplete(Needed::Unknown));
                                    } else {
                                    match transform.parse(i.slice(next..)) {
                                        Ok((i2, o)) => {
                                        o.extend_into(&mut res);
                                        if i2.input_len() == 0 {
                                            return Err(Err::Incomplete(Needed::Unknown));
                                        } else {
                                            index = input.offset(&i2);
                                        }
                                        }
                                        Err(e) => return Err(e),
                                    }
                                    }
                                } else {
                                    return Ok((remainder, res));
                                }
                            }

                            Err(e) => return Err(e),
                        }
                    }

                    Err(Err::Incomplete(Needed::Unknown))
                }
            }
        }
    }
    /*
    */
    pub mod character
    {
        //! Character specific parsers and combinators
        pub mod complete
        {
            //! Character specific parsers and combinators, complete input version.
            use crate::nom::
            {
                branch::{ alt },
                combinator::{ opt, value },
                error::{ self as err, },
                internal::{Err, IResult},
                lib::std::ops::{Range, RangeFrom, RangeTo},
                traits::
                {
                    AsChar, Compare, CompareResult, FindToken, InputIter, InputLength, InputTake, 
                    InputTakeAtPosition, Slice,
                },
            };


            #[doc(hidden)]
            macro_rules! ints 
            {
                ($($t:tt)+) => {
                    $(
                    pub fn $t<T, E: err::ParseError<T>>(input: T) -> IResult<T, $t, E>
                        where
                        T: InputIter + Slice<RangeFrom<usize>> + InputLength + InputTake + Clone,
                        <T as InputIter>::Item: AsChar,
                        T: for <'a> Compare<&'a[u8]>,
                        {
                            let (i, sign) = sign(input.clone())?;

                            if i.input_len() == 0 {
                                return Err(Err::Error(E::from_error_kind(input, $crate::nom::error::ErrorKind::Digit)));
                            }

                            let mut value: $t = 0;
                            if sign {
                                for (pos, c) in i.iter_indices() {
                                    match c.as_char().to_digit(10) {
                                        None => {
                                            if pos == 0 {
                                                return Err(Err::Error(E::from_error_kind(input, $crate::nom::error::ErrorKind::Digit)));
                                            } else {
                                                return Ok((i.slice(pos..), value));
                                            }
                                        },
                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                            None => return Err(Err::Error(E::from_error_kind(input, $crate::nom::error::ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }
                            } else {
                                for (pos, c) in i.iter_indices() {
                                    match c.as_char().to_digit(10) {
                                        None => {
                                            if pos == 0 {
                                                return Err(Err::Error(E::from_error_kind(input, $crate::nom::error::ErrorKind::Digit)));
                                            } else {
                                                return Ok((i.slice(pos..), value));
                                            }
                                        },
                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {
                                            None => return Err(Err::Error(E::from_error_kind(input, $crate::nom::error::ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }
                            }

                            Ok((i.slice(i.input_len()..), value))
                        }
                    )+
                }
            }

            #[doc(hidden)]
            macro_rules! uints 
            {
                ($($t:tt)+) => 
                {
                    $(
                        pub fn $t<T, E: err::ParseError<T>>(input: T) -> IResult<T, $t, E> where
                        T: InputIter + Slice<RangeFrom<usize>> + InputLength,
                        <T as InputIter>::Item: AsChar,
                        {
                            let i = input;

                            if i.input_len() == 0 
                            { return Err(Err::Error(E::from_error_kind(i, err::ErrorKind::Digit))); }

                            let mut value: $t = 0;
                            for (pos, c) in i.iter_indices()
                            {
                                match c.as_char().to_digit(10)
                                {
                                    None => 
                                    {
                                        if pos == 0 
                                        {
                                            return Err(Err::Error(E::from_error_kind(i, err::ErrorKind::Digit)));
                                        } 
                                        else 
                                        { return Ok((i.slice(pos..), value)); }
                                    },
                                    Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) 
                                    {
                                        None => return Err(Err::Error(E::from_error_kind(i, err::ErrorKind::Digit))),
                                        Some(v) => value = v,
                                    }
                                }
                            }

                            Ok((i.slice(i.input_len()..), value))
                        }
                    )+
                }
            }
            /// Recognizes one character.
            pub fn char<I, Error: err::ParseError<I>>(c: char) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar,
            {
                move | i:I | match (i).iter_elements().next().map
                (    | t   | 
                {
                    let b = t.as_char() == c;
                    (&c, b)
                })
                {
                    Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    _ => Err(Err::Error(Error::from_char(i, c))),
                }
            }
            /// Recognizes one character and checks that it satisfies a predicate.
            pub fn satisfy<F, I, Error: err::ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar,
            F: Fn(char) -> bool,
            {
                move |i: I| match (i).iter_elements().next().map(|t| {
                    let c = t.as_char();
                    let b = cond(c);
                    (c, b)
                }) {
                    Some((c, true)) => Ok((i.slice(c.len()..), c)),
                    _ => Err(Err::Error(Error::from_error_kind(i, err::ErrorKind::Satisfy))),
                }
            }
            /// Recognizes one of the provided characters.
            pub fn one_of<I, T, Error: err::ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar + Copy,
            T: FindToken<<I as InputIter>::Item>,
            {
                move |i: I| match (i).iter_elements().next().map(|c| (c, list.find_token(c))) 
                {
                    Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    _ => Err(Err::Error(Error::from_error_kind(i, err::ErrorKind::OneOf))),
                }
            }

            /// Recognizes a character that is not in the provided characters.
            pub fn none_of<I, T, Error: err::ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar + Copy,
            T: FindToken<<I as InputIter>::Item>,
            {
                move |i: I| match (i).iter_elements().next().map(|c| (c, !list.find_token(c))) 
                {
                    Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    _ => Err(Err::Error(Error::from_error_kind(i, err::ErrorKind::NoneOf))),
                }
            }
            /// Recognizes the string "\r\n".
            pub fn crlf<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>>,
            T: InputIter,
            T: Compare<&'static str>,
            {
                match input.compare("\r\n") 
                {
                    //FIXME: is this the right index?
                    CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                    _ => 
                    {
                        let e: err::ErrorKind = err::ErrorKind::CrLf;
                        Err( Err::Error(E::from_error_kind(input, e)) )
                    }
                }
            }

            //FIXME: there's still an incomplete
            /// Recognizes a string of any char except '\r\n' or '\n'.
            pub fn not_line_ending<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: InputIter + InputLength,
            T: Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            <T as InputIter>::Item: AsChar,
            {
                match input.position(|item| {
                    let c = item.as_char();
                    c == '\r' || c == '\n'
                }) {
                    None => Ok((input.slice(input.input_len()..), input)),
                    Some(index) => {
                    let mut it = input.slice(index..).iter_elements();
                    let nth = it.next().unwrap().as_char();
                    if nth == '\r' {
                        let sliced = input.slice(index..);
                        let comp = sliced.compare("\r\n");
                        match comp {
                        //FIXME: calculate the right index
                        CompareResult::Ok => Ok((input.slice(index..), input.slice(..index))),
                        _ => {
                            let e: err::ErrorKind = err::ErrorKind::Tag;
                            Err(Err::Error(E::from_error_kind(input, e)))
                        }
                        }
                    } else {
                        Ok((input.slice(index..), input.slice(..index)))
                    }
                    }
                }
            }
            /// Recognizes an end of line (both '\n' and '\r\n').
            pub fn line_ending<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: InputIter + InputLength,
            T: Compare<&'static str>,
            {
                match input.compare("\n") {
                    CompareResult::Ok => Ok((input.slice(1..), input.slice(0..1))),
                    CompareResult::Incomplete => Err(Err::Error(E::from_error_kind(input, err::ErrorKind::CrLf))),
                    CompareResult::Error => {
                    match input.compare("\r\n") {
                        //FIXME: is this the right index?
                        CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                        _ => Err(Err::Error(E::from_error_kind(input, err::ErrorKind::CrLf))),
                    }
                    }
                }
            }
            /// Matches a newline character '\n'.
            pub fn newline<I, Error: err::ParseError<I>>(input: I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar,
            {
                char('\n')(input)
            }
            /// Matches a tab character '\t'.
            pub fn tab<I, Error: err::ParseError<I>>(input: I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar,
            {
            char('\t')(input)
            }

            /// Matches one byte as a character.
            pub fn anychar<T, E: err::ParseError<T>>(input: T) -> IResult<T, char, E> where
            T: InputIter + InputLength + Slice<RangeFrom<usize>>,
            <T as InputIter>::Item: AsChar,
            {
                let mut it = input.iter_indices();
                match it.next() {
                    None => Err(Err::Error(E::from_error_kind(input, err::ErrorKind::Eof))),
                    Some((_, c)) => match it.next() {
                    None => Ok((input.slice(input.input_len()..), c.as_char())),
                    Some((idx, _)) => Ok((input.slice(idx..), c.as_char())),
                    },
                }
            }
            /// Recognizes zero or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z
            pub fn alpha0<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                input.split_at_position_complete(|item| !item.is_alpha())
            }

            /// Recognizes one or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z
            pub fn alpha1<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                input.split_at_position1_complete(|item| !item.is_alpha(), err::ErrorKind::Alpha)
            }
            /// Recognizes zero or more ASCII numerical characters: 0-9
            pub fn digit0<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                input.split_at_position_complete(|item| !item.is_dec_digit())
            }
            /// Recognizes one or more ASCII numerical characters: 0-9
            pub fn digit1<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                input.split_at_position1_complete(|item| !item.is_dec_digit(), err::ErrorKind::Digit)
            }

            /// Recognizes zero or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f
            pub fn hex_digit0<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                input.split_at_position_complete(|item| !item.is_hex_digit())
            }
            /// Recognizes one or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f
            pub fn hex_digit1<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                input.split_at_position1_complete(|item| !item.is_hex_digit(), err::ErrorKind::HexDigit)
            }
            /// Recognizes zero or more octal characters: 0-7
            pub fn oct_digit0<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                input.split_at_position_complete(|item| !item.is_oct_digit())
            }
            /// Recognizes one or more octal characters: 0-7
            pub fn oct_digit1<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                input.split_at_position1_complete(|item| !item.is_oct_digit(), err::ErrorKind::OctDigit)
            }
            /// Recognizes zero or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z
            pub fn alphanumeric0<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                input.split_at_position_complete(|item| !item.is_alphanum())
            }
            /// Recognizes one or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z
            pub fn alphanumeric1<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                input.split_at_position1_complete(|item| !item.is_alphanum(), err::ErrorKind::AlphaNumeric)
            }
            /// Recognizes zero or more spaces and tabs.
            pub fn space0<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone,
            {
                input.split_at_position_complete(|item| 
                {
                    let c = item.as_char();
                    !(c == ' ' || c == '\t')
                })
            }
            /// Recognizes one or more spaces and tabs.
            pub fn space1<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone,
            {
                input.split_at_position1_complete(
                    |item| {
                    let c = item.as_char();
                    !(c == ' ' || c == '\t')
                    },
                    err::ErrorKind::Space,
                )
            }
            /// Recognizes zero or more spaces, tabs, carriage returns and line feeds.
            pub fn multispace0<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone,
            {
                input.split_at_position_complete(|item| {
                    let c = item.as_char();
                    !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                })
            }
            /// Recognizes one or more spaces, tabs, carriage returns and line feeds.
            pub fn multispace1<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone,
            {
                input.split_at_position1_complete
                (
                    |item| {
                    let c = item.as_char();
                    !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                    },
                    err::ErrorKind::MultiSpace,
                )
            }

            pub(crate) fn sign<T, E: err::ParseError<T>>(input: T) -> IResult<T, bool, E> where
            T: Clone + InputTake,
            T: for<'a> Compare<&'a [u8]>,
            {
                use crate::nom::bytes::complete::tag;
                let (i, opt_sign) = opt
                (alt((
                    value(false, tag(&b"-"[..])),
                    value(true, tag(&b"+"[..])),
                )))(input)?;
                
                let sign = opt_sign.unwrap_or(true);

                Ok((i, sign))
            }

            ints! { i8 i16 i32 i64 i128 }
            uints! { u8 u16 u32 u64 u128 }
        }

        pub mod streaming
        {
            //! Character specific parsers and combinators, streaming version
            use super::super::branch::alt;
            use super::super::combinator::opt;
            use super::super::error::ErrorKind;
            use super::super::error::ParseError;
            use super::super::internal::{Err, IResult, Needed};
            use super::super::lib::std::ops::{Range, RangeFrom, RangeTo};
            use super::super::traits::{
            AsChar, FindToken, InputIter, InputLength, InputTake, InputTakeAtPosition, Slice,
            };
            use super::super::traits::{Compare, CompareResult};

            /// Recognizes one character.
            pub fn char<I, Error: ParseError<I>>(c: char) -> impl Fn(I) -> IResult<I, char, Error>
            where
            I: Slice<RangeFrom<usize>> + InputIter + InputLength,
            <I as InputIter>::Item: AsChar,
            {
            move |i: I| match (i).iter_elements().next().map(|t| {
                let b = t.as_char() == c;
                (&c, b)
            }) {
                None => Err(Err::Incomplete(Needed::new(c.len() - i.input_len()))),
                Some((_, false)) => Err(Err::Error(Error::from_char(i, c))),
                Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
            }
            }

            /// Recognizes one character and checks that it satisfies a predicate.
            pub fn satisfy<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, char, Error>
            where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar,
            F: Fn(char) -> bool,
            {
            move |i: I| match (i).iter_elements().next().map(|t| {
                let c = t.as_char();
                let b = cond(c);
                (c, b)
            }) {
                None => Err(Err::Incomplete(Needed::Unknown)),
                Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Satisfy))),
                Some((c, true)) => Ok((i.slice(c.len()..), c)),
            }
            }

            /// Recognizes one of the provided characters.
            pub fn one_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error>
            where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar + Copy,
            T: FindToken<<I as InputIter>::Item>,
            {
            move |i: I| match (i).iter_elements().next().map(|c| (c, list.find_token(c))) {
                None => Err(Err::Incomplete(Needed::new(1))),
                Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::OneOf))),
                Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
            }
            }

            /// Recognizes a character that is not in the provided characters.
            pub fn none_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error>
            where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar + Copy,
            T: FindToken<<I as InputIter>::Item>,
            {
            move |i: I| match (i).iter_elements().next().map(|c| (c, !list.find_token(c))) {
                None => Err(Err::Incomplete(Needed::new(1))),
                Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::NoneOf))),
                Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
            }
            }

            /// Recognizes the string "\r\n".
            pub fn crlf<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: InputIter,
            T: Compare<&'static str>,
            {
            match input.compare("\r\n") {
                //FIXME: is this the right index?
                CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(2))),
                CompareResult::Error => {
                let e: ErrorKind = ErrorKind::CrLf;
                Err(Err::Error(E::from_error_kind(input, e)))
                }
            }
            }

            /// Recognizes a string of any char except '\r\n' or '\n'.
            pub fn not_line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: InputIter + InputLength,
            T: Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            <T as InputIter>::Item: AsChar,
            {
            match input.position(|item| {
                let c = item.as_char();
                c == '\r' || c == '\n'
            }) {
                None => Err(Err::Incomplete(Needed::Unknown)),
                Some(index) => {
                let mut it = input.slice(index..).iter_elements();
                let nth = it.next().unwrap().as_char();
                if nth == '\r' {
                    let sliced = input.slice(index..);
                    let comp = sliced.compare("\r\n");
                    match comp {
                    //FIXME: calculate the right index
                    CompareResult::Incomplete => Err(Err::Incomplete(Needed::Unknown)),
                    CompareResult::Error => {
                        let e: ErrorKind = ErrorKind::Tag;
                        Err(Err::Error(E::from_error_kind(input, e)))
                    }
                    CompareResult::Ok => Ok((input.slice(index..), input.slice(..index))),
                    }
                } else {
                    Ok((input.slice(index..), input.slice(..index)))
                }
                }
            }
            }

            /// Recognizes an end of line (both '\n' and '\r\n').
            pub fn line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: InputIter + InputLength,
            T: Compare<&'static str>,
            {
            match input.compare("\n") {
                CompareResult::Ok => Ok((input.slice(1..), input.slice(0..1))),
                CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(1))),
                CompareResult::Error => {
                match input.compare("\r\n") {
                    //FIXME: is this the right index?
                    CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                    CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(2))),
                    CompareResult::Error => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),
                }
                }
            }
            }

            /// Matches a newline character '\\n'.
            pub fn newline<I, Error: ParseError<I>>(input: I) -> IResult<I, char, Error>
            where
            I: Slice<RangeFrom<usize>> + InputIter + InputLength,
            <I as InputIter>::Item: AsChar,
            {
            char('\n')(input)
            }

            /// Matches a tab character '\t'.
            pub fn tab<I, Error: ParseError<I>>(input: I) -> IResult<I, char, Error>
            where
            I: Slice<RangeFrom<usize>> + InputIter + InputLength,
            <I as InputIter>::Item: AsChar,
            {
            char('\t')(input)
            }

            /// Matches one byte as a character. Note that the input type will
            /// accept a `str`, but not a `&[u8]`, unlike many other nom parsers.
            pub fn anychar<T, E: ParseError<T>>(input: T) -> IResult<T, char, E>
            where
            T: InputIter + InputLength + Slice<RangeFrom<usize>>,
            <T as InputIter>::Item: AsChar,
            {
            let mut it = input.iter_indices();
            match it.next() {
                None => Err(Err::Incomplete(Needed::new(1))),
                Some((_, c)) => match it.next() {
                None => Ok((input.slice(input.input_len()..), c.as_char())),
                Some((idx, _)) => Ok((input.slice(idx..), c.as_char())),
                },
            }
            }

            /// Recognizes zero or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
            pub fn alpha0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
            input.split_at_position(|item| !item.is_alpha())
            }

            /// Recognizes one or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z
            pub fn alpha1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
            input.split_at_position1(|item| !item.is_alpha(), ErrorKind::Alpha)
            }

            /// Recognizes zero or more ASCII numerical characters: 0-9.
            pub fn digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
            input.split_at_position(|item| !item.is_dec_digit())
            }

            /// Recognizes one or more ASCII numerical characters: 0-9.
            pub fn digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
            input.split_at_position1(|item| !item.is_dec_digit(), ErrorKind::Digit)
            }

            /// Recognizes zero or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f.
            pub fn hex_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
            input.split_at_position(|item| !item.is_hex_digit())
            }

            /// Recognizes one or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f.
            pub fn hex_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
            input.split_at_position1(|item| !item.is_hex_digit(), ErrorKind::HexDigit)
            }

            /// Recognizes zero or more octal characters: 0-7.
            pub fn oct_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
            input.split_at_position(|item| !item.is_oct_digit())
            }

            /// Recognizes one or more octal characters: 0-7.
            pub fn oct_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
            input.split_at_position1(|item| !item.is_oct_digit(), ErrorKind::OctDigit)
            }

            /// Recognizes zero or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z.
            pub fn alphanumeric0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
            input.split_at_position(|item| !item.is_alphanum())
            }

            /// Recognizes one or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z.
            pub fn alphanumeric1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
            input.split_at_position1(|item| !item.is_alphanum(), ErrorKind::AlphaNumeric)
            }

            /// Recognizes zero or more spaces and tabs.
            pub fn space0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone,
            {
            input.split_at_position(|item| {
                let c = item.as_char();
                !(c == ' ' || c == '\t')
            })
            }
            /// Recognizes one or more spaces and tabs.
            pub fn space1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone,
            {
            input.split_at_position1(
                |item| {
                let c = item.as_char();
                !(c == ' ' || c == '\t')
                },
                ErrorKind::Space,
            )
            }

            /// Recognizes zero or more spaces, tabs, carriage returns and line feeds.
            pub fn multispace0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone,
            {
            input.split_at_position(|item| {
                let c = item.as_char();
                !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
            })
            }

            /// Recognizes one or more spaces, tabs, carriage returns and line feeds.
            pub fn multispace1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone,
            {
            input.split_at_position1(
                |item| {
                let c = item.as_char();
                !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                },
                ErrorKind::MultiSpace,
            )
            }

            pub(crate) fn sign<T, E: ParseError<T>>(input: T) -> IResult<T, bool, E>
            where
            T: Clone + InputTake + InputLength,
            T: for<'a> Compare<&'a [u8]>,
            {
            use super::super::bytes::streaming::tag;
            use super::super::combinator::value;

            let (i, opt_sign) = opt(alt((
                value(false, tag(&b"-"[..])),
                value(true, tag(&b"+"[..])),
            )))(input)?;
            let sign = opt_sign.unwrap_or(true);

            Ok((i, sign))
            }

            #[doc(hidden)]
            macro_rules! ints {
                ($($t:tt)+) => {
                    $(
                    pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>
                        where
                        T: InputIter + Slice<RangeFrom<usize>> + InputLength + InputTake + Clone,
                        <T as InputIter>::Item: AsChar,
                        T: for <'a> Compare<&'a[u8]>,
                        {
                        let (i, sign) = sign(input.clone())?;

                            if i.input_len() == 0 {
                                return Err(Err::Incomplete(Needed::new(1)));
                            }

                            let mut value: $t = 0;
                            if sign {
                                for (pos, c) in i.iter_indices() {
                                    match c.as_char().to_digit(10) {
                                        None => {
                                            if pos == 0 {
                                                return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                            } else {
                                                return Ok((i.slice(pos..), value));
                                            }
                                        },
                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                            None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }
                            } else {
                                for (pos, c) in i.iter_indices() {
                                    match c.as_char().to_digit(10) {
                                        None => {
                                            if pos == 0 {
                                                return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit)));
                                            } else {
                                                return Ok((i.slice(pos..), value));
                                            }
                                        },
                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t)) {
                                            None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }
                            }

                            Err(Err::Incomplete(Needed::new(1)))
                        }
                    )+
                }
            }

            ints! { i8 i16 i32 i64 i128 }

            #[doc(hidden)]
            macro_rules! uints 
            {
                ($($t:tt)+) => {
                    $(
                    pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E>
                        where
                        T: InputIter + Slice<RangeFrom<usize>> + InputLength,
                        <T as InputIter>::Item: AsChar,
                        {
                            let i = input;

                            if i.input_len() == 0 {
                                return Err(Err::Incomplete(Needed::new(1)));
                            }

                            let mut value: $t = 0;
                            for (pos, c) in i.iter_indices() {
                                match c.as_char().to_digit(10) {
                                    None => {
                                        if pos == 0 {
                                            return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit)));
                                        } else {
                                            return Ok((i.slice(pos..), value));
                                        }
                                    },
                                    Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t)) {
                                        None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),
                                        Some(v) => value = v,
                                    }
                                }
                            }

                            Err(Err::Incomplete(Needed::new(1)))
                        }
                    )+
                }
            }

            uints! { u8 u16 u32 u64 u128 }
        }

        /// Tests if byte is ASCII alphabetic: A-Z, a-z
        #[inline]
        pub fn is_alphabetic(chr: u8) -> bool {
        (chr >= 0x41 && chr <= 0x5A) || (chr >= 0x61 && chr <= 0x7A)
        }

        /// Tests if byte is ASCII digit: 0-9
        #[inline]
        pub fn is_digit(chr: u8) -> bool {
        chr >= 0x30 && chr <= 0x39
        }

        /// Tests if byte is ASCII hex digit: 0-9, A-F, a-f
        #[inline]
        pub fn is_hex_digit(chr: u8) -> bool {
        (chr >= 0x30 && chr <= 0x39) || (chr >= 0x41 && chr <= 0x46) || (chr >= 0x61 && chr <= 0x66)
        }

        /// Tests if byte is ASCII octal digit: 0-7
        #[inline]
        pub fn is_oct_digit(chr: u8) -> bool {
        chr >= 0x30 && chr <= 0x37
        }

        /// Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9
        #[inline]
        pub fn is_alphanumeric(chr: u8) -> bool {
        is_alphabetic(chr) || is_digit(chr)
        }

        /// Tests if byte is ASCII space or tab
        #[inline]
        pub fn is_space(chr: u8) -> bool {
        chr == b' ' || chr == b'\t'
        }

        /// Tests if byte is ASCII newline: \n
        #[inline]
        pub fn is_newline(chr: u8) -> bool {
        chr == b'\n'
        }   
    }
    /*
    */
    pub mod number
    {
        //! Parsers recognizing numbers
        pub mod complete
        {
            //! Parsers recognizing numbers, complete input version
            use crate::nom::
            {
                branch::{ alt },
                bytes::
                {
                    self,
                    complete::{ tag },
                },
                character::
                {
                    self,
                    complete::{char, digit1, sign},
                },
                combinator::{ self, cut, map, opt, recognize },
                error::{ self as err },
                internal::{ * },
                lib::std::ops::{ Range, RangeFrom, RangeTo },
                number::{ self },
                sequence::{pair, tuple},
                traits::
                {
                    AsBytes, AsChar, Compare, InputIter, InputLength, InputTake, InputTakeAtPosition, 
                    Offset, Slice, ParseTo
                },
            };
            /// Recognizes an unsigned 1 byte integer.
            #[inline] pub fn be_u8<I, E: err::ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 1;
                if input.input_len() < bound 
                {
                    Err(Err::Error( err::make_error(input, err::ErrorKind::Eof)))
                } 
                else 
                {
                    let res = input.iter_elements().next().unwrap();
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 2 bytes integer.
            #[inline] pub fn be_u16<I, E: err::ParseError<I>>(input: I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 2;
                if input.input_len() < bound {
                    Err(Err::Error( err::make_error(input, err::ErrorKind::Eof)))
                } else {
                    let mut res = 0u16;
                    for byte in input.iter_elements().take(bound) {
                    res = (res << 8) + byte as u16;
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a big endian unsigned 3 byte integer.
            #[inline]
            pub fn be_u24<I, E: err::ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 3;
                if input.input_len() < bound {
                    Err(Err::Error( crate::nom::error::make_error(input, crate::nom::error::ErrorKind::Eof)))
                } else {
                    let mut res = 0u32;
                    for byte in input.iter_elements().take(bound) {
                    res = (res << 8) + byte as u32;
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a big endian unsigned 4 bytes integer.
            #[inline]
            pub fn be_u32<I, E: err::ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 4;
                if input.input_len() < bound {
                    Err(Err::Error( crate::nom::error::make_error(input, crate::nom::error::ErrorKind::Eof)))
                } else {
                    let mut res = 0u32;
                    for byte in input.iter_elements().take(bound) {
                    res = (res << 8) + byte as u32;
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a big endian unsigned 8 bytes integer.
            #[inline]
            pub fn be_u64<I, E: err::ParseError<I>>(input: I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 8;
                if input.input_len() < bound {
                    Err(Err::Error( crate::nom::error::make_error(input, crate::nom::error::ErrorKind::Eof)))
                } else {
                    let mut res = 0u64;
                    for byte in input.iter_elements().take(bound) {
                    res = (res << 8) + byte as u64;
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a big endian unsigned 16 bytes integer.
            #[inline]
            pub fn be_u128<I, E: err::ParseError<I>>(input: I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 16;
                if input.input_len() < bound {
                    Err(Err::Error( crate::nom::error::make_error(input, crate::nom::error::ErrorKind::Eof)))
                } else {
                    let mut res = 0u128;
                    for byte in input.iter_elements().take(bound) {
                    res = (res << 8) + byte as u128;
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a signed 1 byte integer.
            #[inline]
            pub fn be_i8<I, E: err::ParseError<I>>(input: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                be_u8.map(|x| x as i8).parse(input)
            }

            /// Recognizes a big endian signed 2 bytes integer.
            #[inline]
            pub fn be_i16<I, E: err::ParseError<I>>(input: I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                be_u16.map(|x| x as i16).parse(input)
            }

            /// Recognizes a big endian signed 3 bytes integer.
            #[inline]
            pub fn be_i24<I, E: err::ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                // Same as the unsigned version but we need to sign-extend manually here
                be_u24
                    .map(|x| {
                    if x & 0x80_00_00 != 0 {
                        (x | 0xff_00_00_00) as i32
                    } else {
                        x as i32
                    }
                    })
                    .parse(input)
            }

            /// Recognizes a big endian signed 4 bytes integer.
            #[inline]
            pub fn be_i32<I, E: err::ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                be_u32.map(|x| x as i32).parse(input)
            }

            /// Recognizes a big endian signed 8 bytes integer.
            #[inline]
            pub fn be_i64<I, E: err::ParseError<I>>(input: I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                be_u64.map(|x| x as i64).parse(input)
            }

            /// Recognizes a big endian signed 16 bytes integer.
            #[inline]
            pub fn be_i128<I, E: err::ParseError<I>>(input: I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                be_u128.map(|x| x as i128).parse(input)
            }

            /// Recognizes an unsigned 1 byte integer.
            #[inline]
            pub fn le_u8<I, E: err::ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 1;
                if input.input_len() < bound {
                    Err(Err::Error( crate::nom::error::make_error(input, crate::nom::error::ErrorKind::Eof)))
                } else {
                    let res = input.iter_elements().next().unwrap();

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a little endian unsigned 2 bytes integer.
            #[inline]
            pub fn le_u16<I, E: err::ParseError<I>>(input: I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 2;
                if input.input_len() < bound {
                    Err(Err::Error( err::make_error(input, err::ErrorKind::Eof)))
                } else {
                    let mut res = 0u16;
                    for (index, byte) in input.iter_indices().take(bound) {
                    res += (byte as u16) << (8 * index);
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a little endian unsigned 3 byte integer.
            #[inline]
            pub fn le_u24<I, E: err::ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 3;
                if input.input_len() < bound {
                    Err(Err::Error( err::make_error(input, err::ErrorKind::Eof)))
                } else {
                    let mut res = 0u32;
                    for (index, byte) in input.iter_indices().take(bound) {
                    res += (byte as u32) << (8 * index);
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a little endian unsigned 4 bytes integer.
            #[inline]
            pub fn le_u32<I, E: err::ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 4;
                if input.input_len() < bound {
                    Err(Err::Error( err::make_error(input, err::ErrorKind::Eof)))
                } else {
                    let mut res = 0u32;
                    for (index, byte) in input.iter_indices().take(bound) {
                    res += (byte as u32) << (8 * index);
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a little endian unsigned 8 bytes integer.
            #[inline]
            pub fn le_u64<I, E: err::ParseError<I>>(input: I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 8;
                if input.input_len() < bound {
                    Err(Err::Error( err::make_error(input, err::ErrorKind::Eof)))
                } else {
                    let mut res = 0u64;
                    for (index, byte) in input.iter_indices().take(bound) {
                    res += (byte as u64) << (8 * index);
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a little endian unsigned 16 bytes integer.
            #[inline]
            pub fn le_u128<I, E: err::ParseError<I>>(input: I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 16;
                if input.input_len() < bound {
                    Err(Err::Error( err::make_error(input, err::ErrorKind::Eof)))
                } else {
                    let mut res = 0u128;
                    for (index, byte) in input.iter_indices().take(bound) {
                    res += (byte as u128) << (8 * index);
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a signed 1 byte integer.
            #[inline]
            pub fn le_i8<I, E: err::ParseError<I>>(input: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                be_u8.map(|x| x as i8).parse(input)
            }

            /// Recognizes a little endian signed 2 bytes integer.
            #[inline]
            pub fn le_i16<I, E: err::ParseError<I>>(input: I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                le_u16.map(|x| x as i16).parse(input)
            }

            /// Recognizes a little endian signed 3 bytes integer.
            #[inline]
            pub fn le_i24<I, E: err::ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                // Same as the unsigned version but we need to sign-extend manually here
                le_u24
                    .map(|x| {
                    if x & 0x80_00_00 != 0 {
                        (x | 0xff_00_00_00) as i32
                    } else {
                        x as i32
                    }
                    })
                    .parse(input)
            }

            /// Recognizes a little endian signed 4 bytes integer.
            #[inline]
            pub fn le_i32<I, E: err::ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                le_u32.map(|x| x as i32).parse(input)
            }

            /// Recognizes a little endian signed 8 bytes integer.
            #[inline]
            pub fn le_i64<I, E: err::ParseError<I>>(input: I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                le_u64.map(|x| x as i64).parse(input)
            }

            /// Recognizes a little endian signed 16 bytes integer.
            #[inline]
            pub fn le_i128<I, E: err::ParseError<I>>(input: I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                le_u128.map(|x| x as i128).parse(input)
            }

            /// Recognizes an unsigned 1 byte integer
            #[inline]
            pub fn u8<I, E: err::ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 1;
                if input.input_len() < bound {
                    Err(Err::Error( err::make_error(input, err::ErrorKind::Eof)))
                } else {
                    let res = input.iter_elements().next().unwrap();

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes an unsigned 2 bytes integer.
            #[inline] pub fn u16<I, E: err::ParseError<I>>(endian:number::Endianness) 
            -> fn(I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_u16,
                    number::Endianness::Little => le_u16,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_u16,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_u16,
                }
            }

            /// Recognizes an unsigned 3 byte integer
            #[inline] pub fn u24<I, E: err::ParseError<I>>( endian: number::Endianness ) 
            -> fn(I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_u24,
                    number::Endianness::Little => le_u24,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_u24,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_u24,
                }
            }
            /// Recognizes an unsigned 4 byte integer
            #[inline] pub fn u32<I, E: err::ParseError<I>>( endian: number::Endianness ) 
            -> fn(I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_u32,
                    number::Endianness::Little => le_u32,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_u32,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_u32,
                }
            }

            /// Recognizes an unsigned 8 byte integer
            #[inline] pub fn u64<I, E: err::ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian
                {
                    number::Endianness::Big => be_u64,
                    number::Endianness::Little => le_u64,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_u64,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_u64,
                }
            }

            /// Recognizes an unsigned 16 byte integer
            #[inline] pub fn u128<I, E: err::ParseError<I>>( endian: number::Endianness ) 
            -> fn(I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_u128,
                    number::Endianness::Little => le_u128,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_u128,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_u128,
                }
            }

            /// Recognizes a signed 1 byte integer
            #[inline]
            pub fn i8<I, E: err::ParseError<I>>(i: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                u8.map(|x| x as i8).parse(i)
            }

            /// Recognizes a signed 2 byte integer
            #[inline] pub fn i16<I, E: err::ParseError<I>>( endian: number::Endianness ) 
            -> fn(I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_i16,
                    number::Endianness::Little => le_i16,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_i16,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_i16,
                }
            }
            /// Recognizes a signed 3 byte integer
            #[inline] pub fn i24<I, E: err::ParseError<I>>( endian: number::Endianness ) 
            -> fn(I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_i24,
                    number::Endianness::Little => le_i24,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_i24,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_i24,
                }
            }
            /// Recognizes a signed 4 byte integer
            #[inline] pub fn i32<I, E: err::ParseError<I>>( endian: number::Endianness ) 
            -> fn(I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_i32,
                    number::Endianness::Little => le_i32,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_i32,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_i32,
                }
            }
            /// Recognizes a signed 8 byte integer
            #[inline] pub fn i64<I, E: err::ParseError<I>>( endian: number::Endianness ) 
            -> fn(I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_i64,
                    number::Endianness::Little => le_i64,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_i64,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_i64,
                }
            }
            /// Recognizes a signed 16 byte integer
            #[inline] pub fn i128<I, E: err::ParseError<I>>( endian: number::Endianness ) 
            -> fn(I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_i128,
                    number::Endianness::Little => le_i128,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_i128,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_i128,
                }
            }

            /// Recognizes a big endian 4 bytes floating point number.
            #[inline]
            pub fn be_f32<I, E: err::ParseError<I>>(input: I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match be_u32(input) {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f32::from_bits(o))),
                }
            }

            /// Recognizes a big endian 8 bytes floating point number.
            #[inline]
            pub fn be_f64<I, E: err::ParseError<I>>(input: I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match be_u64(input) {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f64::from_bits(o))),
                }
            }

            /// Recognizes a little endian 4 bytes floating point number.
            #[inline]
            pub fn le_f32<I, E: err::ParseError<I>>(input: I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match le_u32(input) {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f32::from_bits(o))),
                }
            }

            /// Recognizes a little endian 8 bytes floating point number.
            #[inline]
            pub fn le_f64<I, E: err::ParseError<I>>(input: I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match le_u64(input) 
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f64::from_bits(o))),
                }
            }
            /// Recognizes a 4 byte floating point number
            #[inline] pub fn f32<I, E: err::ParseError<I>>( endian: number::Endianness ) 
            -> fn(I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_f32,
                    number::Endianness::Little => le_f32,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_f32,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_f32,
                }
            }
            /// Recognizes an 8 byte floating point number
            #[inline] pub fn f64<I, E: err::ParseError<I>>( endian: number::Endianness ) 
            -> fn(I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_f64,
                    number::Endianness::Little => le_f64,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_f64,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_f64,
                }
            }
            /// Recognizes a hex-encoded integer.
            #[inline]
            pub fn hex_u32<'a, E: err::ParseError<&'a [u8]>>(input: &'a [u8]) -> IResult<&'a [u8], u32, E> 
            {
                let (i, o) = bytes::complete::is_a(&b"0123456789abcdefABCDEF"[..])(input)?;
                // Do not parse more than 8 characters for a u32
                let (parsed, remaining) = if o.len() <= 8 {
                    (o, i)
                } else {
                    (&input[..8], &input[8..])
                };

                let res = parsed
                    .iter()
                    .rev()
                    .enumerate()
                    .map(|(k, &v)| {
                    let digit = v as char;
                    digit.to_digit(16).unwrap_or(0) << (k * 4)
                    })
                    .sum();

                Ok((remaining, res))
            }

            /// Recognizes floating point number in a byte string and returns the corresponding slice.
            #[rustfmt::skip]
            pub fn recognize_float<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter,
            <T as InputIter>::Item: AsChar,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                recognize
                (
                    tuple
                    ((
                        opt(alt((char('+'), char('-')))),
                        alt
                        ((
                            map(tuple((digit1, opt(pair(char('.'), opt(digit1))))), |_| ()),
                            map(tuple((char('.'), digit1)), |_| ())
                        )),
                        opt
                        (
                            tuple
                            ((
                                alt((char('e'), char('E'))),
                                opt(alt((char('+'), char('-')))),
                                cut(digit1)
                            ))
                        )
                    ))
                )(input)
            }

            // workaround until issues with minimal-lexical are fixed
            #[doc(hidden)]
            pub fn recognize_float_or_exceptions<T, E: err::ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter + InputTake + Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                alt
                ((
                    |i: T| 
                    {
                        recognize_float::<_, E>(i.clone()).map_err(|e| match e 
                        {
                            Err::Error(_) => Err::Error(E::from_error_kind(i, err::ErrorKind::Float)),
                            Err::Failure(_) => Err::Failure(E::from_error_kind(i, err::ErrorKind::Float)),
                            Err::Incomplete(needed) => Err::Incomplete(needed),
                        })
                    },
                    |i: T| 
                    {
                        bytes::complete::tag_no_case::<_, _, E>("nan")(i.clone())
                        .map_err(|_| Err::Error(E::from_error_kind(i, err::ErrorKind::Float)))
                    },
                    |i: T| 
                    {
                        bytes::complete::tag_no_case::<_, _, E>("inf")(i.clone())
                        .map_err(|_| Err::Error(E::from_error_kind(i, err::ErrorKind::Float)))
                    },
                    |i: T| 
                    {
                        bytes::complete::tag_no_case::<_, _, E>("infinity")(i.clone())
                        .map_err(|_| Err::Error(E::from_error_kind(i, err::ErrorKind::Float)))
                    },
                ))(input)
            }
            /// Recognizes a floating point number in text format.
            pub fn recognize_float_parts<T, E: err::ParseError<T>>(input: T) -> IResult<T, (bool, T, T, i32), E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
            T: Clone + Offset,
            T: InputIter + InputTake,
            <T as InputIter>::Item: AsChar + Copy,
            T: InputTakeAtPosition + InputLength,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: for<'a> Compare<&'a [u8]>,
            T: AsBytes,
            {
                let (i, sign) = sign(input.clone())?;

                //let (i, zeroes) = take_while(|c: <T as InputTakeAtPosition>::Item| c.as_char() == '0')(i)?;
                let (i, zeroes) = match i.as_bytes().iter().position(|c| *c != b'0') {
                    Some(index) => i.take_split(index),
                    None => i.take_split(i.input_len()),
                };
                //let (i, mut integer) = digit0(i)?;
                let (i, mut integer) = match i
                    .as_bytes()
                    .iter()
                    .position(|c| !(*c >= b'0' && *c <= b'9'))
                {
                    Some(index) => i.take_split(index),
                    None => i.take_split(i.input_len()),
                };

                if integer.input_len() == 0 && zeroes.input_len() > 0 {
                    // keep the last zero if integer is empty
                    integer = zeroes.slice(zeroes.input_len() - 1..);
                }

                let (i, opt_dot) = opt(tag(&b"."[..]))(i)?;
                let (i, fraction) = if opt_dot.is_none() {
                    let i2 = i.clone();
                    (i2, i.slice(..0))
                } else {
                    // match number, trim right zeroes
                    let mut zero_count = 0usize;
                    let mut position = None;
                    for (pos, c) in i.as_bytes().iter().enumerate() {
                    if *c >= b'0' && *c <= b'9' {
                        if *c == b'0' {
                        zero_count += 1;
                        } else {
                        zero_count = 0;
                        }
                    } else {
                        position = Some(pos);
                        break;
                    }
                    }

                    let position = position.unwrap_or(i.input_len());

                    let index = if zero_count == 0 {
                    position
                    } else if zero_count == position {
                    position - zero_count + 1
                    } else {
                    position - zero_count
                    };

                    (i.slice(position..), i.slice(..index))
                };

                if integer.input_len() == 0 && fraction.input_len() == 0 {
                    return Err(Err::Error(E::from_error_kind(input, err::ErrorKind::Float)));
                }

                let i2 = i.clone();
                let (i, e) = match i.as_bytes().iter().next() {
                    Some(b'e') => (i.slice(1..), true),
                    Some(b'E') => (i.slice(1..), true),
                    _ => (i, false),
                };

                let (i, exp) = if e {
                    cut( character::complete::i32 )(i)?
                } else {
                    (i2, 0)
                };

                Ok((i, (sign, integer, fraction, exp)))
            }            
            /// Recognizes floating point number in text format and returns a f32.
            pub fn float<T, E: err::ParseError<T>>(input: T) -> IResult<T, f32, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
            T: Clone + Offset + ParseTo<f32> + Compare<&'static str>,
            T: InputIter + InputLength + InputTake,
            <T as InputIter>::Item: AsChar + Copy,
            <T as InputIter>::IterElem: Clone,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: AsBytes,
            T: for<'a> Compare<&'a [u8]>,
            {
                let (i, s) = recognize_float_or_exceptions(input)?;
                match s.parse_to() 
                {
                    Some(f) => Ok((i, f)),
                    None => Err( crate::nom::Err::Error(E::from_error_kind(
                    i,
                    err::ErrorKind::Float,
                    ))),
                }
            }
            /// Recognizes floating point number in text format and returns a f64.
            pub fn double<T, E: err::ParseError<T>>(input: T) -> IResult<T, f64, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
            T: Clone + Offset + ParseTo<f64> + Compare<&'static str>,
            T: InputIter + InputLength + InputTake,
            <T as InputIter>::Item: AsChar + Copy,
            <T as InputIter>::IterElem: Clone,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: AsBytes,
            T: for<'a> Compare<&'a [u8]>,
            {
                let (i, s) = recognize_float_or_exceptions(input)?;
                match s.parse_to() 
                {
                    Some(f) => Ok((i, f)),
                    None => Err
                    (
                        crate::nom::Err::Error
                        (
                            E::from_error_kind
                            (
                                i,
                                err::ErrorKind::Float,
                            )
                        )
                    ),
                }
            }
        }

        pub mod streaming
        {
            //! Parsers recognizing numbers, streaming version
            use crate::nom::
            {
                branch::{ alt },
                bytes::
                {
                    self,
                    streaming::{ self, tag },
                },
                character::
                { 
                    self, 
                    streaming::{ char, digit1, sign },
                },
                combinator::{ cut, map, opt, recognize },
                error::{ErrorKind, ParseError},
                internal::{ * },
                lib::{ std::ops::{ RangeFrom, RangeTo }, },
                number::{ self },
                sequence::{ pair, tuple },
                traits::
                {
                    AsBytes, AsChar, Compare, InputIter, InputLength, InputTake, 
                    InputTakeAtPosition, Offset, Slice,
                },
            };

            /// Recognizes an unsigned 1 byte integer.
            #[inline]
            pub fn be_u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 1;
                if input.input_len() < bound 
                {
                    Err(Err::Incomplete(Needed::new(1)))
                } 
                else 
                {
                    let res = input.iter_elements().next().unwrap();
                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a big endian unsigned 2 bytes integer.
            #[inline]
            pub fn be_u16<I, E: ParseError<I>>(input: I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 2;
                if input.input_len() < bound 
                {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                } 
                else
                {
                    let mut res = 0u16;
                    for byte in input.iter_elements().take(bound) 
                    {
                        res = (res << 8) + byte as u16;
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a big endian unsigned 3 byte integer.
            #[inline]
            pub fn be_u24<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 3;
                if input.input_len() < bound 
                {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                } 
                else 
                {
                    let mut res = 0u32;
                    for byte in input.iter_elements().take(bound) 
                    {
                        res = (res << 8) + byte as u32;
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a big endian unsigned 4 bytes integer.
            #[inline]
            pub fn be_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 4;
                if input.input_len() < bound {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                } else {
                    let mut res = 0u32;
                    for byte in input.iter_elements().take(bound) {
                    res = (res << 8) + byte as u32;
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a big endian unsigned 8 bytes integer.
            #[inline]
            pub fn be_u64<I, E: ParseError<I>>(input: I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 8;
                if input.input_len() < bound {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                } else {
                    let mut res = 0u64;
                    for byte in input.iter_elements().take(bound) {
                    res = (res << 8) + byte as u64;
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a big endian unsigned 16 bytes integer.
            #[inline]
            pub fn be_u128<I, E: ParseError<I>>(input: I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 16;
                if input.input_len() < bound {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                } else {
                    let mut res = 0u128;
                    for byte in input.iter_elements().take(bound) {
                    res = (res << 8) + byte as u128;
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a signed 1 byte integer.
            #[inline]
            pub fn be_i8<I, E: ParseError<I>>(input: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                be_u8.map(|x| x as i8).parse(input)
            }

            /// Recognizes a big endian signed 2 bytes integer.
            #[inline]
            pub fn be_i16<I, E: ParseError<I>>(input: I) -> IResult<I, i16, E>
            where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
            be_u16.map(|x| x as i16).parse(input)
            }

            /// Recognizes a big endian signed 3 bytes integer.
            #[inline]
            pub fn be_i24<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                // Same as the unsigned version but we need to sign-extend manually here
                be_u24
                    .map(|x| {
                    if x & 0x80_00_00 != 0 {
                        (x | 0xff_00_00_00) as i32
                    } else {
                        x as i32
                    }
                    })
                    .parse(input)
            }

            /// Recognizes a big endian signed 4 bytes integer.
            #[inline]
            pub fn be_i32<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                be_u32.map(|x| x as i32).parse(input)
            }

            /// Recognizes a big endian signed 8 bytes integer.
            #[inline]
            pub fn be_i64<I, E: ParseError<I>>(input: I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                be_u64.map(|x| x as i64).parse(input)
            }

            /// Recognizes a big endian signed 16 bytes integer.
            #[inline]
            pub fn be_i128<I, E: ParseError<I>>(input: I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                be_u128.map(|x| x as i128).parse(input)
            }

            /// Recognizes an unsigned 1 byte integer.
            #[inline]
            pub fn le_u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 1;
                if input.input_len() < bound 
                {
                    Err(Err::Incomplete(Needed::new(1)))
                } 
                else 
                {
                    let res = input.iter_elements().next().unwrap();
                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a little endian unsigned 2 bytes integer.
            #[inline]
            pub fn le_u16<I, E: ParseError<I>>(input: I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 2;
                if input.input_len() < bound 
                {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                } 
                else 
                {
                    let mut res = 0u16;
                    for (index, byte) in input.iter_indices().take(bound) 
                    {
                        res += (byte as u16) << (8 * index);
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a little endian unsigned 3 bytes integer.
            #[inline]
            pub fn le_u24<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 3;
                if input.input_len() < bound 
                {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                } 
                else 
                {
                    let mut res = 0u32;
                    for (index, byte) in input.iter_indices().take(bound) 
                    {
                        res += (byte as u32) << (8 * index);
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a little endian unsigned 4 bytes integer.
            #[inline]
            pub fn le_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 4;
                if input.input_len() < bound 
                {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                } 
                else 
                {
                    let mut res = 0u32;
                    for (index, byte) in input.iter_indices().take(bound) 
                    {
                        res += (byte as u32) << (8 * index);
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a little endian unsigned 8 bytes integer.
            #[inline]
            pub fn le_u64<I, E: ParseError<I>>(input: I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 8;
                if input.input_len() < bound 
                {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                } 
                else 
                {
                    let mut res = 0u64;
                    for (index, byte) in input.iter_indices().take(bound) 
                    {
                        res += (byte as u64) << (8 * index);
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a little endian unsigned 16 bytes integer.
            #[inline]
            pub fn le_u128<I, E: ParseError<I>>(input: I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 16;
                if input.input_len() < bound 
                {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                } 
                else 
                {
                    let mut res = 0u128;
                    for (index, byte) in input.iter_indices().take(bound) 
                    {
                        res += (byte as u128) << (8 * index);
                    }

                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes a signed 1 byte integer.
            #[inline]
            pub fn le_i8<I, E: ParseError<I>>(input: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                le_u8.map(|x| x as i8).parse(input)
            }

            /// Recognizes a little endian signed 2 bytes integer.
            #[inline]
            pub fn le_i16<I, E: ParseError<I>>(input: I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                le_u16.map(|x| x as i16).parse(input)
            }

            /// Recognizes a little endian signed 3 bytes integer.
            #[inline]
            pub fn le_i24<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                // Same as the unsigned version but we need to sign-extend manually here
                le_u24
                    .map(|x| {
                    if x & 0x80_00_00 != 0 {
                        (x | 0xff_00_00_00) as i32
                    } else {
                        x as i32
                    }
                    })
                    .parse(input)
            }

            /// Recognizes a little endian signed 4 bytes integer.
            #[inline]
            pub fn le_i32<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                le_u32.map(|x| x as i32).parse(input)
            }

            /// Recognizes a little endian signed 8 bytes integer.
            #[inline]
            pub fn le_i64<I, E: ParseError<I>>(input: I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                le_u64.map(|x| x as i64).parse(input)
            }

            /// Recognizes a little endian signed 16 bytes integer.
            #[inline]
            pub fn le_i128<I, E: ParseError<I>>(input: I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                le_u128.map(|x| x as i128).parse(input)
            }

            /// Recognizes an unsigned 1 byte integer.
            #[inline]
            pub fn u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                let bound: usize = 1;
                if input.input_len() < bound 
                {
                    Err(Err::Incomplete(Needed::new(1)))
                } 
                else 
                {
                    let res = input.iter_elements().next().unwrap();
                    Ok((input.slice(bound..), res))
                }
            }

            /// Recognizes an unsigned 2 bytes integer.
            #[inline]
            pub fn u16<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_u16,
                    number::Endianness::Little => le_u16,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_u16,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_u16,
                }
            }

            /// Recognizes an unsigned 3 byte integer.
            #[inline]
            pub fn u24<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_u24,
                    number::Endianness::Little => le_u24,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_u24,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_u24,
                }
            }

            /// Recognizes an unsigned 4 byte integer
            #[inline]
            pub fn u32<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_u32,
                    number::Endianness::Little => le_u32,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_u32,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_u32,
                }
            }

            /// Recognizes an unsigned 8 byte integer.
            #[inline]
            pub fn u64<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_u64,
                    number::Endianness::Little => le_u64,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_u64,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_u64,
                }
            }

            /// Recognizes an unsigned 16 byte integer
            #[inline]
            pub fn u128<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_u128,
                    number::Endianness::Little => le_u128,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_u128,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_u128,
                }
            }

            /// Recognizes a signed 1 byte integer.
            #[inline]
            pub fn i8<I, E: ParseError<I>>(i: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                u8.map(|x| x as i8).parse(i)
            }

            /// Recognizes a signed 2 byte integer.
            #[inline]
            pub fn i16<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_i16,
                    number::Endianness::Little => le_i16,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_i16,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_i16,
                }
            }

            /// Recognizes a signed 3 byte integer.
            #[inline]
            pub fn i24<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_i24,
                    number::Endianness::Little => le_i24,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_i24,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_i24,
                }
            }

            /// Recognizes a signed 4 byte integer.
            #[inline]
            pub fn i32<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_i32,
                    number::Endianness::Little => le_i32,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_i32,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_i32,
                }
            }

            /// Recognizes a signed 8 byte integer.
            #[inline]
            pub fn i64<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_i64,
                    number::Endianness::Little => le_i64,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_i64,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_i64,
                }
            }

            /// Recognizes a signed 16 byte integer.
            #[inline]
            pub fn i128<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_i128,
                    number::Endianness::Little => le_i128,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_i128,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_i128,
                }
            }

            /// Recognizes a big endian 4 bytes floating point number.
            #[inline]
            pub fn be_f32<I, E: ParseError<I>>(input: I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match be_u32(input) 
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f32::from_bits(o))),
                }
            }

            /// Recognizes a big endian 8 bytes floating point number.
            #[inline]
            pub fn be_f64<I, E: ParseError<I>>(input: I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match be_u64(input) 
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f64::from_bits(o))),
                }
            }

            /// Recognizes a little endian 4 bytes floating point number.
            #[inline]
            pub fn le_f32<I, E: ParseError<I>>(input: I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match le_u32(input) 
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f32::from_bits(o))),
                }
            }

            /// Recognizes a little endian 8 bytes floating point number.
            #[inline]
            pub fn le_f64<I, E: ParseError<I>>(input: I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match le_u64(input) 
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f64::from_bits(o))),
                }
            }

            /// Recognizes a 4 byte floating point number.
            #[inline]
            pub fn f32<I, E: ParseError<I>>( endian:number::Endianness ) -> fn(I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_f32,
                    number::Endianness::Little => le_f32,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_f32,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_f32,
                }
            }

            /// Recognizes an 8 byte floating point number.
            #[inline]
            pub fn f64<I, E: ParseError<I>>( endian: number::Endianness ) -> fn(I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            {
                match endian 
                {
                    number::Endianness::Big => be_f64,
                    number::Endianness::Little => le_f64,
                    #[cfg(target_endian = "big")]
                    number::Endianness::Native => be_f64,
                    #[cfg(target_endian = "little")]
                    number::Endianness::Native => le_f64,
                }
            }

            /// Recognizes a hex-encoded integer.
            #[inline]
            pub fn hex_u32<'a, E: ParseError<&'a [u8]>>(input: &'a [u8]) -> IResult<&'a [u8], u32, E> 
            {
                let (i, o) = streaming::is_a(&b"0123456789abcdefABCDEF"[..])(input)?;

                // Do not parse more than 8 characters for a u32
                let (parsed, remaining) = if o.len() <= 8 { (o, i) } 
                else { (&input[..8], &input[8..]) };

                let res = parsed
                .iter()
                .rev()
                .enumerate()
                .map(|(k, &v)| 
                {
                    let digit = v as char;
                    digit.to_digit(16).unwrap_or(0) << (k * 4)
                })
                .sum();

                Ok((remaining, res))
            }

            /// Recognizes a floating point number in text format and returns the corresponding part of the input.
            #[rustfmt::skip]
            pub fn recognize_float<T, E:ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter,
            <T as InputIter>::Item: AsChar,
            T: InputTakeAtPosition + InputLength,
            <T as InputTakeAtPosition>::Item: AsChar
            {
                recognize
                (
                    tuple
                    ((
                        opt(alt((char('+'), char('-')))),
                        alt
                        ((
                            map(tuple((digit1, opt(pair(char('.'), opt(digit1))))), |_| ()),
                            map(tuple((char('.'), digit1)), |_| ())
                        )),
                        opt
                        (
                            tuple
                            ((
                                alt((char('e'), char('E'))),
                                opt(alt((char('+'), char('-')))),
                                cut(digit1)
                            ))
                        )
                    ))
                )(input)
            }

            // workaround until issues with minimal-lexical are fixed
            #[doc(hidden)]
            pub fn recognize_float_or_exceptions<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter + InputTake + InputLength + Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            {
                alt
                ((
                    |i: T| 
                    {                            
                        recognize_float::<_, E>(i.clone()).map_err(|e| match e 
                        {
                            Err::Error(_) => Err::Error(E::from_error_kind(i, ErrorKind::Float)),
                            Err::Failure(_) => Err::Failure(E::from_error_kind(i, ErrorKind::Float)),
                            Err::Incomplete(needed) => Err::Incomplete(needed),
                        })
                    },
                    |i: T| 
                    {
                        bytes::streaming::tag_no_case::<_, _, E>("nan")(i.clone())
                        .map_err(|_| Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                    },
                    |i: T| 
                    {
                        bytes::streaming::tag_no_case::<_, _, E>("inf")(i.clone())
                        .map_err(|_| Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                    },
                    |i: T| 
                    {
                        bytes::streaming::tag_no_case::<_, _, E>("infinity")(i.clone())
                        .map_err(|_| Err::Error(E::from_error_kind(i, ErrorKind::Float)))
                    },
                ))(input)
            }

            /// Recognizes a floating point number in text format.
            pub fn recognize_float_parts<T, E: ParseError<T>>(input: T) -> IResult<T, (bool, T, T, i32), E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter + crate::nom::traits::ParseTo<i32>,
            <T as InputIter>::Item: AsChar,
            T: InputTakeAtPosition + InputTake + InputLength,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: for<'a> Compare<&'a [u8]>,
            T: AsBytes,
            {
                let (i, sign) = sign(input.clone())?;
                let (i, zeroes) = match i.as_bytes().iter().position(|c| *c != b'0') 
                {
                    Some(index) => i.take_split(index),
                    None => i.take_split(i.input_len()),
                };

                //let (i, mut integer) = digit0(i)?;
                let (i, mut integer) = match i
                .as_bytes()
                .iter()
                .position(|c| !(*c >= b'0' && *c <= b'9'))
                {
                    Some(index) => i.take_split(index),
                    None => i.take_split(i.input_len()),
                };

                if integer.input_len() == 0 && zeroes.input_len() > 0 
                { integer = zeroes.slice(zeroes.input_len() - 1..); }

                let (i, opt_dot) = opt(tag(&b"."[..]))(i)?;
                let (i, fraction) = if opt_dot.is_none() 
                {
                    let i2 = i.clone();
                    (i2, i.slice(..0))
                } 
                else 
                {
                    // match number, trim right zeroes
                    let mut zero_count = 0usize;
                    let mut position = None;
                    for (pos, c) in i.as_bytes().iter().enumerate() 
                    {
                        if *c >= b'0' && *c <= b'9' 
                        {
                            if *c == b'0' 
                            { zero_count += 1; } 
                            else
                            { zero_count = 0; }
                        } 
                        else 
                        {
                            position = Some(pos);
                            break;
                        }
                    }

                    let position = match position 
                    {
                        Some(p) => p,
                        None => return Err(Err::Incomplete(Needed::new(1))),
                    };

                    let index = if zero_count == 0 { position }
                    else if zero_count == position
                    { position - zero_count + 1 } 
                    else { position - zero_count };

                    (i.slice(position..), i.slice(..index))
                };

                if integer.input_len() == 0 && fraction.input_len() == 0 
                { return Err(Err::Error(E::from_error_kind(input, ErrorKind::Float))); }

                let i2 = i.clone();
                let (i, e) = match i.as_bytes().iter().next() 
                {
                    Some(b'e') => (i.slice(1..), true),
                    Some(b'E') => (i.slice(1..), true),
                    _ => (i, false),
                };

                let (i, exp) = if e { cut( character::streaming::i32 )(i)? } 
                
                else { (i2, 0) };

                Ok((i, (sign, integer, fraction, exp)))
            }

            /// Recognizes floating point number in text format and returns a f32.
            pub fn float<T, E: ParseError<T>>(input: T) -> IResult<T, f32, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter + InputLength + InputTake + crate::nom::traits::ParseTo<f32> + Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            <T as InputIter>::IterElem: Clone,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: AsBytes,
            T: for<'a> Compare<&'a [u8]>,
            {
                let (i, s) = recognize_float_or_exceptions(input)?;
                match s.parse_to()
                {
                    Some(f) => Ok((i, f)),
                    None => Err
                    (
                        crate::nom::Err::Error
                        (E::from_error_kind(
                    i,
                    crate::nom::error::ErrorKind::Float,
                    ))),
                }
            }

            /// Recognizes floating point number in text format and returns a f64.
            pub fn double<T, E: ParseError<T>>(input: T) -> IResult<T, f64, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter + InputLength + InputTake + crate::nom::traits::ParseTo<f64> + Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            <T as InputIter>::IterElem: Clone,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: AsBytes,
            T: for<'a> Compare<&'a [u8]>,
            {
                let (i, s) = recognize_float_or_exceptions(input)?;
                match s.parse_to() 
                {
                    Some(f) => Ok((i, f)),
                    None => Err
                    (
                        crate::nom::Err::Error
                        (
                            E::from_error_kind
                            (
                                i,
                                crate::nom::error::ErrorKind::Float,
                            )
                        )
                    ),
                }
            }
        }

        /// Configurable endianness
        #[derive(Debug, PartialEq, Eq, Clone, Copy)]
        pub enum Endianness 
        {
            /// Big endian
            Big,
            /// Little endian
            Little,
            /// Will match the host's endianness
            Native,
        }
    }
}
/*
*/
pub mod terminfo
{
    mod error
    {
        use std::error;
        use std::fmt;
        use std::io;

        #[derive(Debug)]
        pub enum Error 
        {
            /// IO error.
            Io(io::Error),

            /// Database not found.
            NotFound,

            /// Parsing error.
            Parse,

            /// Expansion error.
            Expand(Expand),
        }

        #[derive(Eq, PartialEq, Copy, Clone, Debug)]
        pub enum Expand 
        {
            /// The expansion string is invalid.
            Invalid,

            /// There was a type mismatch while expanding.
            TypeMismatch,

            /// The stack underflowed while expanding.
            StackUnderflow,
        }

        pub type Result<T> = ::std::result::Result<T, Error>;

        impl From<io::Error> for Error 
        {
            fn from(value: io::Error) -> Self {
                Error::Io(value)
            }
        }

        impl From<Expand> for Error 
        {
            fn from(value: Expand) -> Self {
                Error::Expand(value)
            }
        }

        impl fmt::Display for Error 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> ::std::result::Result<(), fmt::Error> {
                match *self {
                    Error::Io(ref err) => err.fmt(f),

                    Error::NotFound => f.write_str("Capability database not found."),

                    Error::Parse => f.write_str("Failed to parse capability database."),

                    Error::Expand(ref err) => match *err {
                        Expand::Invalid => f.write_str("The expansion string is invalid."),

                        Expand::StackUnderflow => f.write_str("Not enough elements on the stack."),

                        Expand::TypeMismatch => f.write_str("Type mismatch."),
                    },
                }
            }
        }

        impl error::Error for Error {}
    }

    pub use self::error::{Error, Result};

    /// Parsers for various formats.
    mod parser
    {
        #[macro_use]
        mod util
        {
            use crate::
            {
                nom::
                {
                    branch::{ alt },
                    character::
                    {
                        streaming::{ char, line_ending as eol },
                        is_digit,
                    },
                    combinator::{ eof },
                    IResult,
                }
            };

            use std::{ borrow::{ Cow }, str, u8 };
            
            const NONE: u8 = 0b000000;
            const PRINT: u8 = 0b000001;
            const SPACE: u8 = 0b000010;
            const CONTROL: u8 = 0b000100;
            const PIPE: u8 = 0b001000;
            const COMMA: u8 = 0b010000;
            const EOL: u8 = 0b100000;

            // Ugly table of DOOM, gotta run and gun.
            #[rustfmt::skip]
            static ASCII: [u8; 256] = [
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, SPACE, EOL, NONE, NONE, EOL, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                PRINT | SPACE, PRINT, PRINT, PRINT | CONTROL, PRINT, PRINT, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT | COMMA | CONTROL, PRINT, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT, PRINT | CONTROL, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
                PRINT, PRINT, PRINT, PRINT, PRINT | PIPE, PRINT, PRINT, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
            ];

            #[inline(always)]
            pub fn is_ws(ch: u8) -> bool {
                unsafe { ASCII.get_unchecked(ch as usize) & SPACE == SPACE }
            }

            #[inline(always)]
            pub fn is_eol(ch: u8) -> bool {
                unsafe { ASCII.get_unchecked(ch as usize) & EOL == EOL }
            }

            #[inline(always)]
            pub fn is_printable_no_pipe(ch: u8) -> bool {
                unsafe { ASCII.get_unchecked(ch as usize) & (PRINT | PIPE) == PRINT }
            }

            #[inline(always)]
            pub fn is_printable_no_comma(ch: u8) -> bool {
                unsafe { ASCII.get_unchecked(ch as usize) & (PRINT | COMMA) == PRINT }
            }

            #[inline(always)]
            pub fn is_printable_no_control(ch: u8) -> bool {
                unsafe { ASCII.get_unchecked(ch as usize) & (PRINT | CONTROL) == PRINT }
            }

            pub fn ws(input: &[u8]) -> IResult<&[u8], char> {
                alt((char(' '), char('\t')))(input)
            }

            pub fn end(input: &[u8]) -> IResult<&[u8], &[u8]> {
                alt((eof, eol))(input)
            }

            #[inline]
            pub fn number(i: &[u8]) -> i32 {
                let mut n: i32 = 0;

                for &ch in i {
                    let d = (ch as i32).wrapping_sub(b'0' as i32);

                    if d <= 9 {
                        n = n.saturating_mul(10).saturating_add(d);
                    }
                }

                n
            }

            pub fn unescape(i: &[u8]) -> Cow<[u8]> {
                fn escape<I: Iterator<Item = u8>>(output: &mut Vec<u8>, iter: &mut I) {
                    match iter.next() {
                        None => (),

                        Some(b'a') => output.push(0x07),

                        Some(b'b') => output.push(0x08),

                        Some(b'E') | Some(b'e') => output.push(0x1B),

                        Some(b'f') => output.push(0x0C),

                        Some(b'l') | Some(b'n') => output.push(b'\n'),

                        Some(b'r') => output.push(b'\r'),

                        Some(b's') => output.push(b' '),

                        Some(b't') => output.push(b'\t'),

                        Some(b'^') => output.push(b'^'),

                        Some(b'\\') => output.push(b'\\'),

                        Some(b',') => output.push(b','),

                        Some(b':') => output.push(b':'),

                        Some(b'0') => output.push(0x00),

                        Some(a) if is_digit(a) => match (iter.next(), iter.next()) {
                            (Some(b), Some(c)) if is_digit(b) && is_digit(c) => {
                                if let Ok(number) =
                                    u8::from_str_radix(unsafe { str::from_utf8_unchecked(&[a, b, c]) }, 8)
                                {
                                    output.push(number);
                                } else {
                                    output.extend(&[a, b, c]);
                                }
                            }

                            (Some(b), None) => output.extend(&[b'\\', a, b]),

                            (None, None) => output.extend(&[b'\\', a]),

                            _ => unreachable!(),
                        },

                        Some(ch) => output.extend(&[b'\\', ch]),
                    }
                }

                fn control<I: Iterator<Item = u8>>(output: &mut Vec<u8>, iter: &mut I) {
                    match iter.next() {
                        None => (),

                        Some(ch) if ch.is_ascii_uppercase() => output.push(ch - b'A' + 1),

                        Some(ch) if ch.is_ascii_lowercase() => output.push(ch - b'a' + 1),

                        Some(ch) => output.extend(&[b'^', ch]),
                    }
                }

                let mut chars = i.iter().cloned();
                let mut offset = 0;

                while let Some(ch) = chars.next() {
                    if ch == b'\\' || ch == b'^' {
                        let mut output = i[..offset].to_vec();

                        match ch {
                            b'\\' => escape(&mut output, &mut chars),

                            b'^' => control(&mut output, &mut chars),

                            _ => unreachable!(),
                        }

                        while let Some(ch) = chars.next() {
                            match ch {
                                b'\\' => escape(&mut output, &mut chars),

                                b'^' => control(&mut output, &mut chars),

                                ch => output.push(ch),
                            }
                        }

                        return Cow::Owned(output);
                    }

                    offset += 1;
                }

                Cow::Borrowed(i)
            }
        }

        pub mod compiled
        {
            use crate::
            {
                nom::
                {
                    branch::{ alt },
                    bytes::{ streaming::{ tag, take, take_until } },
                    combinator::{ complete, cond, map, map_opt, map_parser, opt },
                    multi::{ count },
                    number::{ streaming::{ le_i16, le_i32 } },
                    IResult,
                },
                str,
                terminfo::
                {
                    capability::{ Value, },
                },
            };

            #[derive(Eq, PartialEq, Clone, Debug)]
            pub struct Database//<'a> 
            {
                /*
                names: &'a [u8],
                standard: Standard<'a>,
                extended: Option<Extended<'a>>,
                */
                names:(),
                standard:(),
                extended:(),
            }
            /*
            impl<'a> From<Database<'a>> for super::super::Database 
            {
                fn from(source: Database<'a>) -> Self 
                {
                    let mut names = source
                        .names
                        .split(|&c| c == b'|')
                        .map(|s| unsafe { str::from_utf8_unchecked(s) })
                        .map(|s| s.trim())
                        .collect::<Vec<_>>();

                    let mut database = Database::new();

                    database.name(names.remove(0));
                    names.pop().map(|name| database.description(name));
                    database.aliases(names);

                    for (index, _) in source.standard.booleans.iter().enumerate().filter(|&(_, &value)| value) {
                        if let Some(&name) = names::BOOLEAN.get(&(index as u16)) {
                            database.raw(name, Value::True);
                        }
                    }

                    for (index, &value) in source.standard.numbers.iter().enumerate().filter(|&(_, &n)| n >= 0)
                    {
                        if let Some(&name) = names::NUMBER.get(&(index as u16)) {
                            database.raw(name, Value::Number(value));
                        }
                    }

                    for (index, &offset) in source.standard.strings.iter().enumerate().filter(|&(_, &n)| n >= 0)
                    {
                        if let Some(&name) = names::STRING.get(&(index as u16)) {
                            let string = &source.standard.table[offset as usize..];
                            let edge = string.iter().position(|&c| c == 0).unwrap();

                            database.raw(name, Value::String(Vec::from(&string[..edge])));
                        }
                    }

                    if let Some(extended) = source.extended {
                        let names = extended
                            .table
                            .split(|&c| c == 0)
                            .skip(extended.strings.iter().cloned().filter(|&n| n >= 0).count())
                            .map(|s| unsafe { str::from_utf8_unchecked(s) })
                            .collect::<Vec<_>>();

                        for (index, _) in extended.booleans.iter().enumerate().filter(|&(_, &value)| value) {
                            database.raw(names[index], Value::True);
                        }

                        for (index, &value) in extended.numbers.iter().enumerate().filter(|&(_, &n)| n >= 0) {
                            database.raw(names[extended.booleans.len() + index], Value::Number(value));
                        }

                        for (index, &offset) in extended.strings.iter().enumerate().filter(|&(_, &n)| n >= 0) {
                            let string = &extended.table[offset as usize..];
                            let edge = string.iter().position(|&c| c == 0).unwrap();

                            database.raw(
                                names[extended.booleans.len() + extended.numbers.len() + index],
                                Value::String(Vec::from(&string[..edge])),
                            );
                        }
                    }

                    database.build().unwrap()
                }
            }
            */

            #[derive(Eq, PartialEq, Clone, Debug)]
            pub struct Standard<'a> 
            {
                booleans: Vec<bool>,
                numbers: Vec<i32>,
                strings: Vec<i32>,
                table: &'a [u8],
            }

            #[derive(Eq, PartialEq, Clone, Debug)]
            pub struct Extended<'a> 
            {
                booleans: Vec<bool>,
                numbers: Vec<i32>,
                strings: Vec<i32>,
                names: Vec<i32>,
                table: &'a [u8],
            }

            fn bit_size(magic: &[u8]) -> usize 
            {
                match magic[1] 
                {
                    0x01 => 16,
                    0x02 => 32,
                    _ => unreachable!("unknown magic number"),
                }
            }

            pub fn parse(input: &[u8]) -> IResult<&[u8], Database> 
            {
                let (input, magic) = alt((tag([0x1A, 0x01]), tag([0x1E, 0x02])))(input)?;

                let (input, name_size) = size(input)?;
                let (input, bool_count) = size(input)?;
                let (input, num_count) = size(input)?;
                let (input, string_count) = size(input)?;
                let (input, table_size) = size(input)?;

                let (input, names) = map_parser(take(name_size), take_until("\x00"))(input)?;

                let (input, booleans) = count(boolean, bool_count)(input)?;

                let (input, _) = cond((name_size + bool_count) % 2 != 0, take(1_usize))(input)?;

                let (input, numbers) = count(|input| capability(input, bit_size(magic)), num_count)(input)?;

                let (input, strings) = count(|input| capability(input, 16), string_count)(input)?;

                let (input, table) = take(table_size)(input)?;

                let (input, extended) = opt(complete(|input| {
                    let (input, _) = cond(table_size % 2 != 0, take(1_usize))(input)?;

                    let (input, ext_bool_count) = size(input)?;
                    let (input, ext_num_count) = size(input)?;
                    let (input, ext_string_count) = size(input)?;
                    let (input, _ext_offset_count) = size(input)?;
                    let (input, ext_table_size) = size(input)?;

                    let (input, booleans) = count(boolean, ext_bool_count)(input)?;

                    let (input, _) = cond(ext_bool_count % 2 != 0, take(1_usize))(input)?;

                    let (input, numbers) =
                        count(|input| capability(input, bit_size(magic)), ext_num_count)(input)?;

                    let (input, strings) = count(|input| capability(input, 16), ext_string_count)(input)?;

                    let (input, names) = count(
                        |input| capability(input, 16),
                        ext_bool_count + ext_num_count + ext_string_count,
                    )(input)?;

                    let (input, table) = take(ext_table_size)(input)?;

                    Ok((input, Extended { booleans, numbers, strings, names, table }))
                }))(input)?;

                Ok((
                    input,
                    Database { names:(), standard:(), extended:() },
                    //Database { names, standard: Standard { booleans, numbers, strings, table }, extended },
                ))
            }

            fn boolean(input: &[u8]) -> IResult<&[u8], bool> 
            {
                alt((map(tag([0]), |_| false), map(tag([1]), |_| true)))(input)
            }

            fn size(input: &[u8]) -> IResult<&[u8], usize> 
            {
                map_opt(le_i16, |n| 
                match n 
                {
                    -1 => Some(0),
                    n if n >= 0 => Some(n as usize),
                    _ => None,
                })(input)
            }

            fn capability(input: &[u8], bits: usize) -> IResult<&[u8], i32>
            {
                alt
                ((
                    map_opt
                    (
                        cond(bits == 16, map_opt(le_i16, |n| if n >= -2 { Some(n as i32) } else { None })),
                        |o| o,
                    ),
                    map_opt
                    (
                        cond(bits == 32, map_opt(le_i32, |n| if n >= -2 { Some(n) } else { None })), 
                        |o| o
                    ),
                ))(input)
            }
        }

        pub mod expansion
        {
            use crate::
            { 
                nom::
                {
                    branch::{ alt },
                    bytes::
                    {
                        complete,
                        streaming::{tag, take, take_while},
                    },
                    character::{ is_digit, streaming::one_of },
                    combinator::{ map, opt, value },
                    error::{ make_error, ErrorKind },
                    IResult,
                },
                terminfo::parser::util::number,
            };

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Item<'a> 
            {
                String(&'a [u8]),
                Constant(Constant),
                Variable(Variable),
                Operation(Operation),
                Conditional(Conditional),
                Print(Print),
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Constant 
            {
                Character(u8),
                Integer(i32),
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Variable 
            {
                Length,
                Push(u8),
                Set(bool, u8),
                Get(bool, u8),
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Operation 
            {
                Increment,
                Unary(Unary),
                Binary(Binary),
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Unary 
            {
                Not,
                NOT,
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Binary 
            {
                Add,
                Subtract,
                Multiply,
                Divide,
                Remainder,
                AND,
                OR,
                XOR,
                And,
                Or,
                Equal,
                Greater,
                Lesser,
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Conditional 
            {
                If,
                Then,
                Else,
                End,
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub struct Print 
            {
                pub flags: Flags,
                pub format: Format,
            }

            #[derive(Eq, PartialEq, Copy, Clone, Debug)]
            pub enum Format 
            {
                Chr,
                Uni,
                Str,
                Dec,
                Oct,
                Hex,
                HEX,
            }

            #[derive(Eq, PartialEq, Copy, Clone, Default, Debug)]
            pub struct Flags 
            {
                pub width: usize,
                pub precision: usize,
                pub alternate: bool,
                pub left: bool,
                pub sign: bool,
                pub space: bool,
            }

            pub fn parse(input: &[u8]) -> IResult<&[u8], Item>
            {
                alt((expansion, string))(input)
            }

            fn string(input: &[u8]) -> IResult<&[u8], Item> 
            {
                map(complete::take_till(|b| b == b'%'), Item::String)(input)
            }

            fn expansion(input: &[u8]) -> IResult<&[u8], Item>
            {
                let (input, _) = tag("%")(input)?;
                let (input, item) = alt((percent, constant, variable, operation, conditional, print))(input)?;
                Ok((input, item))
            }

            fn percent(input: &[u8]) -> IResult<&[u8], Item>
            {
                value(Item::String(b"%"), tag("%"))(input)
            }

            fn constant(input: &[u8]) -> IResult<&[u8], Item>
            {
                alt((constant_char, constant_integer))(input)
            }

            fn constant_char(input: &[u8]) -> IResult<&[u8], Item>
            {
                let (input, _) = tag("'")(input)?;
                let (input, ch) = take(1_usize)(input)?;
                let (input, _) = tag("'")(input)?;
                Ok((input, Item::Constant(Constant::Character(ch[0]))))
            }

            fn constant_integer(input: &[u8]) -> IResult<&[u8], Item>
            {
                let (input, _) = tag("{")(input)?;
                let (input, digit) = take_while(is_digit)(input)?;
                let (input, _) = tag("}")(input)?;
                Ok((input, Item::Constant(Constant::Integer(number(digit)))))
            }

            fn variable(input: &[u8]) -> IResult<&[u8], Item> 
            {
                let (input, c) = take(1_usize)(input)?;
                match c 
                {
                    b"l" => Ok((input, Item::Variable(Variable::Length))),
                    b"p" => map(one_of("123456789"), |n| Item::Variable(Variable::Push(n as u8 - b'1')))(input),
                    b"P" => alt
                    ((
                        map(one_of("abcdefghijklmnopqrstuvwxyz"), |n| { Item::Variable(Variable::Set(true, n as u8 - b'a')) }),
                        map(one_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ"), |n| { Item::Variable(Variable::Set(false, n as u8 - b'A')) }),
                    ))(input),
                    b"g" => alt
                    ((
                        map(one_of("abcdefghijklmnopqrstuvwxyz"), |n| {
                            Item::Variable(Variable::Get(true, n as u8 - b'a'))
                        }),
                        map(one_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ"), |n| {
                            Item::Variable(Variable::Get(false, n as u8 - b'A'))
                        }),
                    ))(input),
                    _ => Err( crate::nom::Err::Error(make_error(input, ErrorKind::Switch))),
                }
            }

            fn operation(input: &[u8]) -> IResult<&[u8], Item> 
            {
                let (input, c) = take(1_usize)(input)?;
                match c 
                {
                    b"+" => Ok((input, Item::Operation(Operation::Binary(Binary::Add)))),
                    b"-" => Ok((input, Item::Operation(Operation::Binary(Binary::Subtract)))),
                    b"*" => Ok((input, Item::Operation(Operation::Binary(Binary::Multiply)))),
                    b"/" => Ok((input, Item::Operation(Operation::Binary(Binary::Divide)))),
                    b"m" => Ok((input, Item::Operation(Operation::Binary(Binary::Remainder)))),
                    b"i" => Ok((input, Item::Operation(Operation::Increment))),

                    b"&" => Ok((input, Item::Operation(Operation::Binary(Binary::AND)))),
                    b"|" => Ok((input, Item::Operation(Operation::Binary(Binary::OR)))),
                    b"^" => Ok((input, Item::Operation(Operation::Binary(Binary::XOR)))),
                    b"~" => Ok((input, Item::Operation(Operation::Unary(Unary::NOT)))),

                    b"A" => Ok((input, Item::Operation(Operation::Binary(Binary::And)))),
                    b"O" => Ok((input, Item::Operation(Operation::Binary(Binary::Or)))),
                    b"!" => Ok((input, Item::Operation(Operation::Unary(Unary::Not)))),

                    b"=" => Ok((input, Item::Operation(Operation::Binary(Binary::Equal)))),
                    b">" => Ok((input, Item::Operation(Operation::Binary(Binary::Greater)))),
                    b"<" => Ok((input, Item::Operation(Operation::Binary(Binary::Lesser)))),

                    _ => Err( crate::nom::Err::Error(make_error(input, ErrorKind::Switch))),
                }
            }

            fn conditional(input: &[u8]) -> IResult<&[u8], Item> 
            {
                let (input, c) = take(1_usize)(input)?;
                match c 
                {
                    b"?" => Ok((input, Item::Conditional(Conditional::If))),
                    b"t" => Ok((input, Item::Conditional(Conditional::Then))),
                    b"e" => Ok((input, Item::Conditional(Conditional::Else))),
                    b";" => Ok((input, Item::Conditional(Conditional::End))),
                    _ => Err( crate::nom::Err::Error(make_error(input, ErrorKind::Switch))),
                }
            }

            fn print(input: &[u8]) -> IResult<&[u8], Item> 
            {
                let (input, _) = opt(tag(":"))(input)?;
                let (input, flags) = take_while(is_flag)(input)?;
                let (input, width) = opt(take_while(is_digit))(input)?;
                let (input, precision) = opt(|input| 
                {
                    let (input, _) = tag(".")(input)?;
                    let (input, amount) = take_while(is_digit)(input)?;
                    Ok((input, amount))
                })(input)?;
                let (input, format) = one_of("doxXsc")(input)?;
                Ok
                (
                    (
                        input,
                        Item::Print
                        (
                            Print 
                            {
                                flags: Flags 
                                {
                                    width: number(width.unwrap_or(b"0")) as usize,
                                    precision: number(precision.unwrap_or(b"0")) as usize,
                                    alternate: flags.contains(&b'#'),
                                    left: flags.contains(&b'-'),
                                    sign: flags.contains(&b'+'),
                                    space: flags.contains(&b' '),
                                },
                                format: match format 
                                {
                                    'd' => Format::Dec,
                                    'o' => Format::Oct,
                                    'x' => Format::Hex,
                                    'X' => Format::HEX,
                                    's' => Format::Str,
                                    'c' => Format::Chr,
                                    'u' => Format::Uni,
                                    _ => unreachable!(),
                                },
                            }
                        ),
                    )
                )
            }

            fn is_flag(i: u8) -> bool 
            {
                i == b' ' || i == b'-' || i == b'+' || i == b'#'
            }
        }
        
        pub mod source
        {
            use crate::
            {
                borrow::{ Cow },
                nom::
                {
                    branch::{ alt },
                    bytes::{ streaming::{tag, take, take_until, take_while} },
                    character::{ is_digit, streaming::line_ending as eol },
                    combinator::{ complete, map, map_res, opt },
                    error::{ make_error, ErrorKind },
                    sequence::{ terminated },
                    IResult,
                },
                str::{ self },
                terminfo::
                {
                    parser::util::
                    {
                        unescape, end, is_eol, is_ws, ws, 
                        is_printable_no_comma, is_printable_no_control, is_printable_no_pipe,
                    },
                },
            };

            #[derive(Eq, PartialEq, Clone, Debug)]
            pub enum Item<'a> 
            {
                Comment(&'a str),
                Definition { name: &'a str, aliases: Vec<&'a str>, description: &'a str },
                True(&'a str),
                Number(&'a str, i16),
                String(&'a str, Cow<'a, [u8]>),
                Disable(&'a str),
            }

            pub fn parse(input: &[u8]) -> IResult<&[u8], Item> 
            {
                alt((comment, definition, disable, entry))(input)
            }

            fn comment(input: &[u8]) -> IResult<&[u8], Item>
            {
                let (input, _) = tag("#")(input)?;
                let (input, content) = map_res(terminated(take_until("\n"), tag("\n")), str::from_utf8)(input)?;
                let (input, _) = opt(complete(take_while(is_eol)))(input)?;
                Ok((input, Item::Comment(content.trim())))
            }

            fn definition(input: &[u8]) -> IResult<&[u8], Item> 
            {
                let (input, name) = map
                (
                    take_while(is_printable_no_pipe), 
                    |n| unsafe { str::from_utf8_unchecked(n) }
                )(input)?;
                let (input, _) = tag("|")(input)?;
                let (input, content) = map
                (
                    take_while(is_printable_no_comma), 
                    |n| unsafe { str::from_utf8_unchecked(n) }
                )(input)?;
                let (input, _) = tag(",")(input)?;
                let (input, _) = take_while(is_ws)(input)?;
                let (input, _) = eol(input)?;
                let (input, _) = opt(complete(take_while(is_eol)))(input)?;
                Ok((input, 
                {
                    let mut aliases = content.split(|c| c == '|').map(|n| n.trim()).collect::<Vec<_>>();
                    Item::Definition { name, description: aliases.pop().unwrap(), aliases }
                }))
            }

            fn disable(input: &[u8]) -> IResult<&[u8], Item> 
            {
                let (input, _) = ws(input)?;
                let (input, _) = take_while(is_ws)(input)?;
                let (input, _) = tag("@")(input)?;

                let (input, name) =
                    map(take_while(is_printable_no_control), |n| unsafe { str::from_utf8_unchecked(n) })(
                        input,
                    )?;

                let (input, _) = tag(",")(input)?;
                let (input, _) = take_while(is_ws)(input)?;
                let (input, _) = end(input)?;
                let (input, _) = opt(complete(take_while(is_eol)))(input)?;

                Ok((input, Item::Disable(name)))
            }

            fn entry(input: &[u8]) -> IResult<&[u8], Item> 
            {
                let (input, _) = ws(input)?;
                let (input, _) = take_while(is_ws)(input)?;

                let (input, name) = map
                (
                    take_while(is_printable_no_control), 
                    |n| unsafe { str::from_utf8_unchecked(n) }
                )( input )?;

                let (input, c) = take(1_usize)(input)?;
                let (input, value) = match c 
                {
                    b"," => (input, Item::True(name)),
                    b"#" => 
                    {
                        let (input, value) =
                            map(take_while(is_digit), |n| unsafe { str::from_utf8_unchecked(n) })(input)?;

                        let (input, _) = tag(",")(input)?;

                        (input, Item::Number(name, value.parse().unwrap()))
                    }

                    b"=" => {
                        let (input, value) = take_while(is_printable_no_comma)(input)?;

                        let (input, _) = tag(",")(input)?;

                        (input, Item::String(name, unescape(value)))
                    }

                    _ => Err( crate::nom::Err::Error(make_error(input, ErrorKind::Switch )) )?,
                };

                let (input, _) = take_while(is_ws)(input)?;
                let (input, _) = end(input)?;
                let (input, _) = opt(complete(take_while(is_eol)))(input)?;

                Ok((input, value))
            }
        }   
    }

    /// String capability expansion.
    #[macro_use]
    pub mod expand
    {
        use crate::
        {
            io::{ BufWriter, Write },
            char,
            terminfo::
            {
                error,
                parser::expansion::{ * }, 
            },
        };
        
        /// Expand a parametrized string.
        #[macro_export] macro_rules! expand
        {
            ($value:expr) => ( $crate::terminfo::expand!($value;) );

            ($value:expr => $context:expr) => ( $crate::terminfo::expand!($value => $context;) );

            ($value:expr; $($item:expr),*) => ( $crate::terminfo::expand!($value => &mut $crate::default::Default::default(); $($item),*) );

            ($value:expr => $context:expr; $($item:expr),*) => 
            ({
                let mut output = $crate::vec::Vec::new();
                $crate::terminfo::expand!(&mut output, $value => $context; $($item),*).map(|()| output)
            });

            ($output:expr, $value:expr) => 
            (
                $crate::terminfo::expand!($output, $value;)
            );

            ($output:expr, $value:expr => $context:expr) => 
            (
                $crate::terminfo::expand!($output, $value => $context;)
            );

            ($output:expr, $value:expr; $($item:expr),*) => 
            (
                $crate::terminfo::expand!($output, $value => &mut ::std::default::Default::default(); $($item),*)
            );

            ($output:expr, $value:expr => $context:expr; $($item:expr),*) => 
            ({
                use $crate::terminfo::Expand;
                $value.expand($output, &[$($item.into()),*], $context)
            })
        }

        macro_rules! from 
        {
            (number $ty:ty) => 
            {
                impl From<$ty> for Parameter 
                {
                    fn from(value: $ty) -> Self 
                    {
                        Parameter::Number(value as i32)
                    }
                }
            };

            (string ref $ty:ty) => 
            {
                impl<'a> From<&'a $ty> for Parameter 
                {
                    fn from(value: &'a $ty) -> Self 
                    {
                        Parameter::String(value.into())
                    }
                }
            };

            (string $ty:ty) => 
            {
                impl From<$ty> for Parameter 
                {
                    fn from(value: $ty) -> Self 
                    {
                        Parameter::String(value.into())
                    }
                }
            };
        }

        /// Trait for items that can be expanded.
        pub trait Expand 
        {
            fn expand<W: Write>( &self, output: W, parameters: &[Parameter], context: &mut Context, ) -> error::Result<()>;
        }
        /// An expansion parameter.
        #[derive(Eq, PartialEq, Clone, Debug)]
        pub enum Parameter 
        {
            /// A number.
            Number(i32),
            /// An ASCII string.
            String(Vec<u8>),
        }

        impl Default for Parameter 
        {
            fn default() -> Self 
            {
                Parameter::Number(0)
            }
        }

        from!(number bool);
        from!(number u8);
        from!(number i8);
        from!(number u16);
        from!(number i16);
        from!(number u32);
        from!(number i32);

        from!(string String);
        from!(string ref str);
        from!(string Vec<u8>);
        from!(string ref [u8]);

        /// The expansion context.
        #[derive(Eq, PartialEq, Default, Debug)]
        pub struct Context 
        {
            pub fixed: [Parameter; 26],
            pub dynamic: [Parameter; 26],
        }

        impl Expand for [u8] 
        {
            fn expand<W: Write>
            (
                &self,
                output: W,
                parameters: &[Parameter],
                context: &mut Context,
            ) -> error::Result<()> 
            {
                let mut output = BufWriter::new(output);
                let mut input = self;
                let mut params: [Parameter; 9] = Default::default();
                let mut stack = Vec::new();
                let mut conditional = false;
                let mut incremented = false;

                for (dest, source) in params.iter_mut().zip(parameters.iter())
                {
                    *dest = source.clone();
                }

                macro_rules! next 
                {
                    () => 
                    {
                        match parse(input) 
                        {
                            Ok((rest, item)) => 
                            {
                                input = rest;
                                item
                            }

                            Err(_) => return Err(error::Expand::Invalid.into()),
                        }
                    };
                }

                'main: while !input.is_empty() 
                {
                    match next!() 
                    {
                        Item::Conditional(Conditional::If) =>
                        {
                            conditional = true;
                        }

                        Item::Conditional(Conditional::End) 
                        if conditional =>
                        {
                            conditional = false;
                        }

                        Item::Conditional(Conditional::Then) if conditional => 
                        match stack.pop()
                        {
                            Some(Parameter::Number(0)) =>
                            {
                                let mut level = 0;

                                while !input.is_empty()
                                {
                                    match next!()
                                    {
                                        Item::Conditional(Conditional::End) | 
                                        Item::Conditional(Conditional::Else)
                                        if level == 0 =>
                                        {
                                            continue 'main
                                        }
                                        Item::Conditional(Conditional::If) => level += 1,
                                        Item::Conditional(Conditional::End) => level -= 1,
                                        _ => (),
                                    }
                                }

                                return Err(error::Expand::Invalid.into());
                            }

                            Some(_) => (),

                            None => return Err(error::Expand::StackUnderflow.into()),
                        },

                        Item::Conditional(Conditional::Else) if conditional => 
                        {
                            let mut level = 0;

                            while !input.is_empty()
                            {
                                match next!()
                                {
                                    Item::Conditional(Conditional::End) if level == 0 => continue 'main,
                                    Item::Conditional(Conditional::If) => level += 1,
                                    Item::Conditional(Conditional::End) => level -= 1,
                                    _ => (),
                                }
                            }

                            return Err(error::Expand::Invalid.into());
                        }

                        Item::Conditional(..) => return Err(error::Expand::Invalid.into()),

                        Item::String(value) => output.write_all(value)?,

                        Item::Constant(Constant::Character(ch)) =>
                        {
                            stack.push(Parameter::Number(ch as i32));
                        }

                        Item::Constant(Constant::Integer(value)) =>
                        {
                            stack.push(Parameter::Number(value));
                        }

                        Item::Variable(Variable::Length) => 
                        match stack.pop() 
                        {
                            Some(Parameter::String(ref value)) => 
                            {
                                stack.push(Parameter::Number(value.len() as i32));
                            }

                            Some(_) => 
                            {
                                return Err(error::Expand::TypeMismatch.into());
                            }

                            None => 
                            {
                                return Err(error::Expand::StackUnderflow.into());
                            }
                        },

                        Item::Variable(Variable::Push(index)) => 
                        {
                            stack.push(params[index as usize].clone());
                        }

                        Item::Variable(Variable::Set(dynamic, index)) => 
                        {
                            if let Some(value) = stack.pop() 
                            {
                                if dynamic { context.dynamic[index as usize] = value.clone(); } 
                                else { context.fixed[index as usize] = value.clone(); }
                            } 
                            else 
                            { return Err(error::Expand::StackUnderflow.into()); }
                        }

                        Item::Variable(Variable::Get(dynamic, index)) =>
                        {
                            if dynamic { stack.push(context.dynamic[index as usize].clone()); } 
                            else { stack.push(context.fixed[index as usize].clone()); }
                        }

                        Item::Operation(Operation::Increment) if !incremented =>
                        {
                            incremented = true;

                            if let (&Parameter::Number(x), &Parameter::Number(y)) = (&params[0], &params[1])
                            {
                                params[0] = Parameter::Number(x + 1);
                                params[1] = Parameter::Number(y + 1);
                            }
                            
                            else 
                            { return Err(error::Expand::TypeMismatch.into()); }
                        }

                        Item::Operation(Operation::Increment) => (),

                        Item::Operation(Operation::Binary(operation)) => 
                        match (stack.pop(), stack.pop()) 
                        {
                            (Some(Parameter::Number(y)), Some(Parameter::Number(x))) => 
                            {
                                stack.push
                                (
                                    Parameter::Number
                                    (
                                        match operation 
                                        {
                                            Binary::Add => x + y,
                                            Binary::Subtract => x - y,
                                            Binary::Multiply => x * y,
                                            Binary::Divide => 
                                            {
                                                if y != 0 { x / y } 
                                                else { 0 }
                                            }

                                            Binary::Remainder => 
                                            {
                                                if y != 0 { x % y } 
                                                else { 0 }
                                            }

                                            Binary::AND => x & y,
                                            Binary::OR => x | y,
                                            Binary::XOR => x ^ y,

                                            Binary::And => (x != 0 && y != 0) as i32,
                                            Binary::Or => (x != 0 || y != 0) as i32,

                                            Binary::Equal => (x == y) as i32,
                                            Binary::Greater => (x > y) as i32,
                                            Binary::Lesser => (x < y) as i32,
                                        }
                                    )
                                )
                            }

                            (Some(_), Some(_)) => return Err(error::Expand::TypeMismatch.into()),

                            _ => return Err(error::Expand::StackUnderflow.into()),
                        },

                        Item::Operation(Operation::Unary(operation)) => match stack.pop()
                        {
                            Some(Parameter::Number(x)) => 
                            stack.push
                            (
                                Parameter::Number(match operation
                                {
                                    Unary::Not => (x != 0) as i32,
                                    Unary::NOT => !x,
                                })
                            ),

                            Some(_) => return Err(error::Expand::TypeMismatch.into()),

                            _ => return Err(error::Expand::StackUnderflow.into()),
                        },

                        Item::Print(p) => 
                        {
                            /// Calculate the length of a formatted number.
                            fn length(value: i32, p: &Print) -> usize
                            {
                                let digits = match p.format
                                {
                                    Format::Dec => (value as f32).abs().log(10.0).floor() as usize + 1,

                                    Format::Oct => (value as f32).abs().log(8.0).floor() as usize + 1,

                                    Format::Hex | Format::HEX => {
                                        (value as f32).abs().log(16.0).floor() as usize + 1
                                    }

                                    _ => unreachable!(),
                                };

                                let mut length = digits;

                                // Add the minimum number of digits.
                                if p.flags.precision > digits
                                {
                                    length += p.flags.precision - digits;
                                }

                                // Add the sign if present.
                                if p.format == Format::Dec && (value < 0 || p.flags.sign)
                                {
                                    length += 1;
                                }

                                // Add the alternate representation.
                                if p.flags.alternate
                                {
                                    match p.format 
                                    {
                                        Format::Hex | Format::HEX => length += 2,

                                        Format::Oct => length += 1,

                                        _ => (),
                                    }
                                }

                                length
                            }

                            macro_rules! w 
                            {
                                ($value:expr) => (
                                    output.write_all($value)?
                                );

                                ($($item:tt)*) => (
                                    write!(output, $($item)*)?
                                );
                            }

                            macro_rules! f 
                            {
                                (by $length:expr) => (
                                    for _ in 0 .. p.flags.width - $length {
                                        output.write_all(if p.flags.space { b" " } else { b"0" })?;
                                    }
                                );

                                (before by $length:expr) => (
                                    if !p.flags.left && p.flags.width > $length {
                                        f!(by $length);
                                    }
                                );

                                (after by $length:expr) => (
                                    if p.flags.left && p.flags.width > $length {
                                        f!(by $length);
                                    }
                                );

                                (before $value:expr) => (
                                    f!(before by length($value, &p));
                                );

                                (after $value:expr) => (
                                    f!(after by length($value, &p));
                                );
                            }

                            match (p.format, stack.pop())
                            {
                                (Format::Str, Some(Parameter::String(ref value))) =>
                                {
                                    let mut value = &value[..];

                                    if p.flags.precision > 0 && p.flags.precision < value.len()
                                    {
                                        value = &value[..p.flags.precision];
                                    }

                                    f!(before by value.len());
                                    w!(value);
                                    f!(after by value.len());
                                }

                                (Format::Chr, Some(Parameter::Number(value))) => w!( "{}", value as u8 as char),

                                (Format::Uni, Some(Parameter::Number(value))) => w!( "{}", char::from_u32(value as u32).ok_or(error::Expand::TypeMismatch)? ),

                                (Format::Dec, Some(Parameter::Number(value))) => 
                                {
                                    f!(before value);

                                    if p.flags.sign && value >= 0
                                    {
                                        w!(b"+");
                                    }

                                    w!("{:.1$}", value, p.flags.precision);

                                    f!(after value);
                                }

                                (Format::Oct, Some(Parameter::Number(value))) =>
                                {
                                    f!(before value);

                                    if p.flags.alternate
                                    { w!(b"0"); }

                                    w!("{:.1$o}", value, p.flags.precision);

                                    f!(after value);
                                }

                                (Format::Hex, Some(Parameter::Number(value))) =>
                                {
                                    f!(before value);

                                    if p.flags.alternate
                                    {
                                        w!(b"0x");
                                    }

                                    w!("{:.1$x}", value, p.flags.precision);

                                    f!(after value);
                                }

                                (Format::HEX, Some(Parameter::Number(value))) =>
                                {
                                    f!(before value);

                                    if p.flags.alternate { w!(b"0X"); }

                                    w!("{:.1$X}", value, p.flags.precision);

                                    f!(after value);
                                }

                                (_, Some(_)) => return Err(error::Expand::TypeMismatch.into()),

                                (_, None) => return Err(error::Expand::StackUnderflow.into()),
                            }
                        }
                    }
                }

                Ok(())
            }
        }
    }
    pub use self::expand::Expand;

    /// Standard terminal capabilities.
    pub mod capability
    {
        use crate::
        {
            borrow::{ Cow },
            io::{ Write },
            terminfo::
            { 
                error, 
                expand::
                {
                    Context, Expand, Parameter
                },
            },
        };
        /// A trait for any object that will represent a terminal capability.
        pub trait Capability<'a>: Sized 
        {
            /// Returns the name of the capability in its long form.
            fn name() -> &'static str;

            /// Parse the capability from its raw value.
            fn from(value: Option<&'a Value>) -> Option<Self>;

            /// Convert the capability into its raw value.
            fn into(self) -> Option<Value>;
        }
        /// Possible value types for capabilities.
        #[derive(Eq, PartialEq, Clone, Debug)] pub enum Value 
        {
            /// A boolean.
            True,

            /// A number.
            Number(i32),

            /// An ASCII string requiring expansion.
            String(Vec<u8>),
        }
        /// Expansion helper struct.
        #[derive(Debug)]  pub struct Expansion<'a, T: 'a + AsRef<[u8]>> 
        {
            string: &'a T,
            params: [Parameter; 9],
            context: Option<&'a mut Context>,
        }

        impl<'a, T: AsRef<[u8]>> Expansion<'a, T> {
            /// Expand using the given context.
            pub fn with<'c: 'a>(mut self, context: &'c mut Context) -> Self {
                self.context = Some(context);
                self
            }

            /// Expand to the given output.
            pub fn to<W: Write>(self, output: W) -> error::Result<()> {
                self.string.as_ref().expand(
                    output,
                    &self.params,
                    self.context.unwrap_or(&mut Default::default()),
                )
            }

            /// Expand into a vector.
            pub fn to_vec(self) -> error::Result<Vec<u8>> {
                let mut result = Vec::with_capacity(self.string.as_ref().len());
                self.to(&mut result)?;
                Ok(result)
            }
        }

        macro_rules! from {
            (number $ty:ty) => {
                impl From<$ty> for Value {
                    fn from(value: $ty) -> Self {
                        Value::Number(value as i32)
                    }
                }
            };

            (string ref $ty:ty) => {
                impl<'a> From<&'a $ty> for Value {
                    fn from(value: &'a $ty) -> Self {
                        Value::String(value.into())
                    }
                }
            };

            (string $ty:ty) => {
                impl From<$ty> for Value {
                    fn from(value: $ty) -> Self {
                        Value::String(value.into())
                    }
                }
            };
        }

        impl From<()> for Value {
            fn from(_: ()) -> Self {
                Value::True
            }
        }

        from!(number u8);
        from!(number i8);
        from!(number u16);
        from!(number i16);
        from!(number u32);
        from!(number i32);

        from!(string String);
        from!(string ref str);
        from!(string Vec<u8>);
        from!(string ref [u8]);

        macro_rules! define {
            (boolean $ident:ident => $capability:expr) => (
                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub struct $ident(pub bool);

                impl<'a> Capability<'a> for $ident {
                    #[inline]
                    fn name() -> &'static str {
                        $capability
                    }

                    #[inline]
                    fn from(value: Option<&Value>) -> Option<Self> {
                        if let Some(&Value::True) = value {
                            Some($ident(true))
                        }
                        else {
                            Some($ident(false))
                        }
                    }

                    #[inline]
                    fn into(self) -> Option<Value> {
                        if self.0 {
                            Some(Value::True)
                        }
                        else {
                            None
                        }
                    }
                }

                impl From<$ident> for bool {
                    fn from(cap: $ident) -> Self {
                        cap.0
                    }
                }
            );

            (number $ident:ident => $capability:expr) => (
                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub struct $ident(pub i32);

                impl<'a> Capability<'a> for $ident {
                    #[inline]
                    fn name() -> &'static str {
                        $capability
                    }

                    #[inline]
                    fn from(value: Option<&Value>) -> Option<Self> {
                        if let Some(&Value::Number(value)) = value {
                            Some($ident(value))
                        }
                        else {
                            None
                        }
                    }

                    #[inline]
                    fn into(self) -> Option<Value> {
                        Some(Value::Number(self.0))
                    }
                }

                impl From<$ident> for i32 {
                    fn from(cap: $ident) -> Self {
                        cap.0
                    }
                }
            );

            (string define $ident:ident => $capability:expr) => (
                #[derive(Eq, PartialEq, Clone, Debug)]
                pub struct $ident<'a>(Cow<'a, [u8]>);

                impl<'a> Capability<'a> for $ident<'a> {
                    #[inline]
                    fn name() -> &'static str {
                        $capability
                    }

                    #[inline]
                    fn from(value: Option<&'a Value>) -> Option<$ident<'a>> {
                        if let Some(&Value::String(ref value)) = value {
                            Some($ident(Cow::Borrowed(value)))
                        }
                        else {
                            None
                        }
                    }

                    #[inline]
                    fn into(self) -> Option<Value> {
                        Some(Value::String(match self.0 {
                            Cow::Borrowed(value) =>
                                value.into(),

                            Cow::Owned(value) =>
                                value
                        }))
                    }
                }

                impl<'a, T: AsRef<&'a [u8]>> From<T> for $ident<'a> {
                    #[inline]
                    fn from(value: T) -> Self {
                        $ident(Cow::Borrowed(value.as_ref()))
                    }
                }

                impl<'a> AsRef<[u8]> for $ident<'a> {
                    #[inline]
                    fn as_ref(&self) -> &[u8] {
                        &self.0
                    }
                }

                impl<'a> $ident<'a> {
                    /// Begin expanding the capability.
                    #[inline]
                    pub fn expand(&self) -> Expansion<$ident> {
                        Expansion {
                            string:  self,
                            params:  Default::default(),
                            context: None,
                        }
                    }
                }
            );

            (string $ident:ident => $capability:expr) => (
                define!(string define $ident => $capability);
            );

            (string $ident:ident => $capability:expr; $($rest:tt)+) => (
                define!(string define $ident => $capability);
                define!(string parameters $ident; $($rest)+);
                define!(string builder $ident; 0, $($rest)+, );
            );

            (string parameters $ident:ident; $($name:ident : $ty:ty),+) => (
                impl<'a> Expansion<'a, $ident<'a>> {
                    /// Pass all expansion parameters at once.
                    #[allow(unused_assignments)]
                    #[inline]
                    // https://github.com/meh/rust-terminfo/issues/28
                    #[allow(clippy::too_many_arguments)]
                    pub fn parameters(mut self, $($name: $ty),*) -> Self {
                        let mut index = 0;

                        $({
                            self.params[index]  = $name.into();
                            index              += 1;
                        })*;

                        self
                    }
                }
            );

            (string builder $ident:ident; $index:expr, ) => ();

            (string builder $ident:ident; $index:expr, $name:ident : u8, $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : u8);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : i8, $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : i8);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : u16, $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : u16);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : i16 $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : i16);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : u32, $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : u32);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : i32, $($rest:tt)*) => (
                define!(string builder direct $ident; $index, $name : i32);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder $ident:ident; $index:expr, $name:ident : $ty:ty, $($rest:tt)*) => (
                define!(string builder into $ident; $index, $name : $ty);
                define!(string builder $ident; $index + 1, $($rest)*);
            );

            (string builder direct $ident:ident; $index:expr, $name:ident : $ty:ty) => (
                impl<'a> Expansion<'a, $ident<'a>> {
                    /// Set the given parameter.
                    #[inline]
                    pub fn $name(mut self, value: $ty) -> Self {
                        self.params[$index] = value.into();
                        self
                    }
                }
            );

            (string builder into $ident:ident; $index:expr, $name:ident : $ty:ty) => (
                impl<'a> Expansion<'a, $ident<'a>> {
                    /// Set the given parameter.
                    #[inline]
                    pub fn $name<T: Into<$ty>>(mut self, value: T) -> Self {
                        self.params[$index] = value.into().into();
                        self
                    }
                }
            );
        }

        define!(boolean AutoLeftMargin => "auto_left_margin");
        define!(boolean AutoRightMargin => "auto_right_margin");
        define!(boolean NoEscCtlc => "no_esc_ctlc");
        define!(boolean CeolStandoutGlitch => "ceol_standout_glitch");
        define!(boolean EatNewlineGlitch => "eat_newline_glitch");
        define!(boolean EraseOverstrike => "erase_overstrike");
        define!(boolean GenericType => "generic_type");
        define!(boolean HardCopy => "hard_copy");
        define!(boolean HasMetaKey => "has_meta_key");
        define!(boolean HasStatusLine => "has_status_line");
        define!(boolean InsertNullGlitch => "insert_null_glitch");
        define!(boolean MemoryAbove => "memory_above");
        define!(boolean MemoryBelow => "memory_below");
        define!(boolean MoveInsertMode => "move_insert_mode");
        define!(boolean MoveStandoutMode => "move_standout_mode");
        define!(boolean OverStrike => "over_strike");
        define!(boolean StatusLineEscOk => "status_line_esc_ok");
        define!(boolean DestTabsMagicSmso => "dest_tabs_magic_smso");
        define!(boolean TildeGlitch => "tilde_glitch");
        define!(boolean TransparentUnderline => "transparent_underline");
        define!(boolean XonXoff => "xon_xoff");
        define!(boolean NeedsXonXoff => "needs_xon_xoff");
        define!(boolean PrtrSilent => "prtr_silent");
        define!(boolean HardCursor => "hard_cursor");
        define!(boolean NonRevRmcup => "non_rev_rmcup");
        define!(boolean NoPadChar => "no_pad_char");
        define!(boolean NonDestScrollRegion => "non_dest_scroll_region");
        define!(boolean CanChange => "can_change");
        define!(boolean BackColorErase => "back_color_erase");
        define!(boolean HueLightnessSaturation => "hue_lightness_saturation");
        define!(boolean ColAddrGlitch => "col_addr_glitch");
        define!(boolean CrCancelsMicroMode => "cr_cancels_micro_mode");
        define!(boolean HasPrintWheel => "has_print_wheel");
        define!(boolean RowAddrGlitch => "row_addr_glitch");
        define!(boolean SemiAutoRightMargin => "semi_auto_right_margin");
        define!(boolean CpiChangesRes => "cpi_changes_res");
        define!(boolean LpiChangesRes => "lpi_changes_res");
        define!(boolean BackspacesWithBs => "backspaces_with_bs");
        define!(boolean CrtNoScrolling => "crt_no_scrolling");
        define!(boolean NoCorrectlyWorkingCr => "no_correctly_working_cr");
        define!(boolean GnuHasMetaKey => "gnu_has_meta_key");
        define!(boolean LinefeedIsNewline => "linefeed_is_newline");
        define!(boolean HasHardwareTabs => "has_hardware_tabs");
        define!(boolean ReturnDoesClrEol => "return_does_clr_eol");

        define!(number Columns => "columns");
        define!(number InitTabs => "init_tabs");
        define!(number Lines => "lines");
        define!(number LinesOfMemory => "lines_of_memory");
        define!(number MagicCookieGlitch => "magic_cookie_glitch");
        define!(number PaddingBaudRate => "padding_baud_rate");
        define!(number VirtualTerminal => "virtual_terminal");
        define!(number WidthStatusLine => "width_status_line");
        define!(number NumLabels => "num_labels");
        define!(number LabelHeight => "label_height");
        define!(number LabelWidth => "label_width");
        define!(number MaxAttributes => "max_attributes");
        define!(number MaximumWindows => "maximum_windows");
        define!(number MaxColors => "max_colors");
        define!(number MaxPairs => "max_pairs");
        define!(number NoColorVideo => "no_color_video");
        define!(number BufferCapacity => "buffer_capacity");
        define!(number DotVertSpacing => "dot_vert_spacing");
        define!(number DotHorzSpacing => "dot_horz_spacing");
        define!(number MaxMicroAddress => "max_micro_address");
        define!(number MaxMicroJump => "max_micro_jump");
        define!(number MicroColSize => "micro_col_size");
        define!(number MicroLineSize => "micro_line_size");
        define!(number NumberOfPins => "number_of_pins");
        define!(number OutputResChar => "output_res_char");
        define!(number OutputResLine => "output_res_line");
        define!(number OutputResHorzInch => "output_res_horz_inch");
        define!(number OutputResVertInch => "output_res_vert_inch");
        define!(number PrintRate => "print_rate");
        define!(number WideCharSize => "wide_char_size");
        define!(number Buttons => "buttons");
        define!(number BitImageEntwining => "bit_image_entwining");
        define!(number BitImageType => "bit_image_type");
        define!(number MagicCookieGlitchUl => "magic_cookie_glitch_ul");
        define!(number CarriageReturnDelay => "carriage_return_delay");
        define!(number NewLineDelay => "new_line_delay");
        define!(number BackspaceDelay => "backspace_delay");
        define!(number HorizontalTabDelay => "horizontal_tab_delay");
        define!(number NumberOfFunctionKeys => "number_of_function_keys");

        define!(string BackTab => "back_tab");
        define!(string Bell => "bell");
        define!(string CarriageReturn => "carriage_return");
        define!(string ClearAllTabs => "clear_all_tabs");
        define!(string ClearScreen => "clear_screen");
        define!(string ClrEol => "clr_eol");
        define!(string ClrEos => "clr_eos");
        define!(string CommandCharacter => "command_character");
        define!(string CursorDown => "cursor_down");
        define!(string CursorHome => "cursor_home");
        define!(string CursorInvisible => "cursor_invisible");
        define!(string CursorLeft => "cursor_left");
        define!(string CursorMemAddress => "cursor_mem_address");
        define!(string CursorNormal => "cursor_normal");
        define!(string CursorRight => "cursor_right");
        define!(string CursorToLl => "cursor_to_ll");
        define!(string CursorUp => "cursor_up");
        define!(string CursorVisible => "cursor_visible");
        define!(string DeleteCharacter => "delete_character");
        define!(string DeleteLine => "delete_line");
        define!(string DisStatusLine => "dis_status_line");
        define!(string DownHalfLine => "down_half_line");
        define!(string EnterAltCharsetMode => "enter_alt_charset_mode");
        define!(string EnterBlinkMode => "enter_blink_mode");
        define!(string EnterBoldMode => "enter_bold_mode");
        define!(string EnterCaMode => "enter_ca_mode");
        define!(string EnterDeleteMode => "enter_delete_mode");
        define!(string EnterDimMode => "enter_dim_mode");
        define!(string EnterInsertMode => "enter_insert_mode");
        define!(string EnterSecureMode => "enter_secure_mode");
        define!(string EnterProtectedMode => "enter_protected_mode");
        define!(string EnterReverseMode => "enter_reverse_mode");
        define!(string EnterStandoutMode => "enter_standout_mode");
        define!(string EnterUnderlineMode => "enter_underline_mode");
        define!(string ExitAltCharsetMode => "exit_alt_charset_mode");
        define!(string ExitAttributeMode => "exit_attribute_mode");
        define!(string ExitCaMode => "exit_ca_mode");
        define!(string ExitDeleteMode => "exit_delete_mode");
        define!(string ExitInsertMode => "exit_insert_mode");
        define!(string ExitStandoutMode => "exit_standout_mode");
        define!(string ExitUnderlineMode => "exit_underline_mode");
        define!(string FlashScreen => "flash_screen");
        define!(string FormFeed => "form_feed");
        define!(string FromStatusLine => "from_status_line");
        define!(string Init1String => "init_1string");
        define!(string Init2String => "init_2string");
        define!(string Init3String => "init_3string");
        define!(string InitFile => "init_file");
        define!(string InsertCharacter => "insert_character");
        define!(string InsertLine => "insert_line");
        define!(string InsertPadding => "insert_padding");
        define!(string KeyBackspace => "key_backspace");
        define!(string KeyCATab => "key_catab");
        define!(string KeyClear => "key_clear");
        define!(string KeyCTab => "key_ctab");
        define!(string KeyDc => "key_dc");
        define!(string KeyDl => "key_dl");
        define!(string KeyDown => "key_down");
        define!(string KeyEic => "key_eic");
        define!(string KeyEol => "key_eol");
        define!(string KeyEos => "key_eos");
        define!(string KeyF0 => "key_f0");
        define!(string KeyF1 => "key_f1");
        define!(string KeyF10 => "key_f10");
        define!(string KeyF2 => "key_f2");
        define!(string KeyF3 => "key_f3");
        define!(string KeyF4 => "key_f4");
        define!(string KeyF5 => "key_f5");
        define!(string KeyF6 => "key_f6");
        define!(string KeyF7 => "key_f7");
        define!(string KeyF8 => "key_f8");
        define!(string KeyF9 => "key_f9");
        define!(string KeyHome => "key_home");
        define!(string KeyIc => "key_ic");
        define!(string KeyIl => "key_il");
        define!(string KeyLeft => "key_left");
        define!(string KeyLl => "key_ll");
        define!(string KeyNPage => "key_npage");
        define!(string KeyPPage => "key_ppage");
        define!(string KeyRight => "key_right");
        define!(string KeySf => "key_sf");
        define!(string KeySr => "key_sr");
        define!(string KeySTab => "key_stab");
        define!(string KeyUp => "key_up");
        define!(string KeypadLocal => "keypad_local");
        define!(string KeypadXmit => "keypad_xmit");
        define!(string LabF0 => "lab_f0");
        define!(string LabF1 => "lab_f1");
        define!(string LabF10 => "lab_f10");
        define!(string LabF2 => "lab_f2");
        define!(string LabF3 => "lab_f3");
        define!(string LabF4 => "lab_f4");
        define!(string LabF5 => "lab_f5");
        define!(string LabF6 => "lab_f6");
        define!(string LabF7 => "lab_f7");
        define!(string LabF8 => "lab_f8");
        define!(string LabF9 => "lab_f9");
        define!(string MetaOff => "meta_off");
        define!(string MetaOn => "meta_on");
        define!(string Newline => "newline");
        define!(string PadChar => "pad_char");
        define!(string PKeyKey => "pkey_key");
        define!(string PKeyLocal => "pkey_local");
        define!(string PKeyXmit => "pkey_xmit");
        define!(string PrintScreen => "print_screen");
        define!(string PrtrOff => "prtr_off");
        define!(string PrtrOn => "prtr_on");
        define!(string RepeatChar => "repeat_char");
        define!(string Reset1String => "reset_1string");
        define!(string Reset2String => "reset_2string");
        define!(string Reset3String => "reset_3string");
        define!(string ResetFile => "reset_file");
        define!(string RestoreCursor => "restore_cursor");
        define!(string SaveCursor => "save_cursor");
        define!(string ScrollForward => "scroll_forward");
        define!(string ScrollReverse => "scroll_reverse");
        define!(string SetTab => "set_tab");
        define!(string SetWindow => "set_window");
        define!(string Tab => "tab");
        define!(string ToStatusLine => "to_status_line");
        define!(string UnderlineChar => "underline_char");
        define!(string UpHalfLine => "up_half_line");
        define!(string InitProg => "init_prog");
        define!(string KeyA1 => "key_a1");
        define!(string KeyA3 => "key_a3");
        define!(string KeyB2 => "key_b2");
        define!(string KeyC1 => "key_c1");
        define!(string KeyC3 => "key_c3");
        define!(string PrtrNon => "prtr_non");
        define!(string CharPadding => "char_padding");
        define!(string AcsChars => "acs_chars");
        define!(string PlabNorm => "plab_norm");
        define!(string KeyBTab => "key_btab");
        define!(string EnterXonMode => "enter_xon_mode");
        define!(string ExitXonMode => "exit_xon_mode");
        define!(string EnterAmMode => "enter_am_mode");
        define!(string ExitAmMode => "exit_am_mode");
        define!(string XonCharacter => "xon_character");
        define!(string XoffCharacter => "xoff_character");
        define!(string EnaAcs => "ena_acs");
        define!(string LabelOn => "label_on");
        define!(string LabelOff => "label_off");
        define!(string KeyBeg => "key_beg");
        define!(string KeyCancel => "key_cancel");
        define!(string KeyClose => "key_close");
        define!(string KeyCommand => "key_command");
        define!(string KeyCopy => "key_copy");
        define!(string KeyCreate => "key_create");
        define!(string KeyEnd => "key_end");
        define!(string KeyEnter => "key_enter");
        define!(string KeyExit => "key_exit");
        define!(string KeyFind => "key_find");
        define!(string KeyHelp => "key_help");
        define!(string KeyMark => "key_mark");
        define!(string KeyMessage => "key_message");
        define!(string KeyMove => "key_move");
        define!(string KeyNext => "key_next");
        define!(string KeyOpen => "key_open");
        define!(string KeyOptions => "key_options");
        define!(string KeyPrevious => "key_previous");
        define!(string KeyPrint => "key_print");
        define!(string KeyRedo => "key_redo");
        define!(string KeyReference => "key_reference");
        define!(string KeyRefresh => "key_refresh");
        define!(string KeyReplace => "key_replace");
        define!(string KeyRestart => "key_restart");
        define!(string KeyResume => "key_resume");
        define!(string KeySave => "key_save");
        define!(string KeySuspend => "key_suspend");
        define!(string KeyUndo => "key_undo");
        define!(string KeySBeg => "key_sbeg");
        define!(string KeySCancel => "key_scancel");
        define!(string KeySCommand => "key_scommand");
        define!(string KeySCopy => "key_scopy");
        define!(string KeySCreate => "key_screate");
        define!(string KeySDc => "key_sdc");
        define!(string KeySDl => "key_sdl");
        define!(string KeySelect => "key_select");
        define!(string KeySEnd => "key_send");
        define!(string KeySEol => "key_seol");
        define!(string KeySExit => "key_sexit");
        define!(string KeySFind => "key_sfind");
        define!(string KeySHelp => "key_shelp");
        define!(string KeySHome => "key_shome");
        define!(string KeySIc => "key_sic");
        define!(string KeySLeft => "key_sleft");
        define!(string KeySMessage => "key_smessage");
        define!(string KeySMove => "key_smove");
        define!(string KeySNext => "key_snext");
        define!(string KeySOptions => "key_soptions");
        define!(string KeySPrevious => "key_sprevious");
        define!(string KeySPrint => "key_sprint");
        define!(string KeySRedo => "key_sredo");
        define!(string KeySReplace => "key_sreplace");
        define!(string KeySRight => "key_sright");
        define!(string KeySRsume => "key_srsume");
        define!(string KeySSave => "key_ssave");
        define!(string KeySSuspend => "key_ssuspend");
        define!(string KeySUndo => "key_sundo");
        define!(string ReqForInput => "req_for_input");
        define!(string KeyF11 => "key_f11");
        define!(string KeyF12 => "key_f12");
        define!(string KeyF13 => "key_f13");
        define!(string KeyF14 => "key_f14");
        define!(string KeyF15 => "key_f15");
        define!(string KeyF16 => "key_f16");
        define!(string KeyF17 => "key_f17");
        define!(string KeyF18 => "key_f18");
        define!(string KeyF19 => "key_f19");
        define!(string KeyF20 => "key_f20");
        define!(string KeyF21 => "key_f21");
        define!(string KeyF22 => "key_f22");
        define!(string KeyF23 => "key_f23");
        define!(string KeyF24 => "key_f24");
        define!(string KeyF25 => "key_f25");
        define!(string KeyF26 => "key_f26");
        define!(string KeyF27 => "key_f27");
        define!(string KeyF28 => "key_f28");
        define!(string KeyF29 => "key_f29");
        define!(string KeyF30 => "key_f30");
        define!(string KeyF31 => "key_f31");
        define!(string KeyF32 => "key_f32");
        define!(string KeyF33 => "key_f33");
        define!(string KeyF34 => "key_f34");
        define!(string KeyF35 => "key_f35");
        define!(string KeyF36 => "key_f36");
        define!(string KeyF37 => "key_f37");
        define!(string KeyF38 => "key_f38");
        define!(string KeyF39 => "key_f39");
        define!(string KeyF40 => "key_f40");
        define!(string KeyF41 => "key_f41");
        define!(string KeyF42 => "key_f42");
        define!(string KeyF43 => "key_f43");
        define!(string KeyF44 => "key_f44");
        define!(string KeyF45 => "key_f45");
        define!(string KeyF46 => "key_f46");
        define!(string KeyF47 => "key_f47");
        define!(string KeyF48 => "key_f48");
        define!(string KeyF49 => "key_f49");
        define!(string KeyF50 => "key_f50");
        define!(string KeyF51 => "key_f51");
        define!(string KeyF52 => "key_f52");
        define!(string KeyF53 => "key_f53");
        define!(string KeyF54 => "key_f54");
        define!(string KeyF55 => "key_f55");
        define!(string KeyF56 => "key_f56");
        define!(string KeyF57 => "key_f57");
        define!(string KeyF58 => "key_f58");
        define!(string KeyF59 => "key_f59");
        define!(string KeyF60 => "key_f60");
        define!(string KeyF61 => "key_f61");
        define!(string KeyF62 => "key_f62");
        define!(string KeyF63 => "key_f63");
        define!(string ClrBol => "clr_bol");
        define!(string ClearMargins => "clear_margins");
        define!(string SetLeftMargin => "set_left_margin");
        define!(string SetRightMargin => "set_right_margin");
        define!(string LabelFormat => "label_format");
        define!(string SetClock => "set_clock");
        define!(string DisplayClock => "display_clock");
        define!(string RemoveClock => "remove_clock");
        define!(string CreateWindow => "create_window");
        define!(string GotoWindow => "goto_window");
        define!(string Hangup => "hangup");
        define!(string DialPhone => "dial_phone");
        define!(string QuickDial => "quick_dial");
        define!(string Tone => "tone");
        define!(string Pulse => "pulse");
        define!(string FlashHook => "flash_hook");
        define!(string FixedPause => "fixed_pause");
        define!(string WaitTone => "wait_tone");
        define!(string User0 => "user0");
        define!(string User1 => "user1");
        define!(string User2 => "user2");
        define!(string User3 => "user3");
        define!(string User4 => "user4");
        define!(string User5 => "user5");
        define!(string User6 => "user6");
        define!(string User7 => "user7");
        define!(string User8 => "user8");
        define!(string User9 => "user9");
        define!(string OrigPair => "orig_pair");
        define!(string OrigColors => "orig_colors");
        define!(string InitializeColor => "initialize_color");
        define!(string InitializePair => "initialize_pair");
        define!(string SetColorPair => "set_color_pair");
        define!(string ChangeCharPitch => "change_char_pitch");
        define!(string ChangeLinePitch => "change_line_pitch");
        define!(string ChangeResHorz => "change_res_horz");
        define!(string ChangeResVert => "change_res_vert");
        define!(string DefineChar => "define_char");
        define!(string EnterDoublewideMode => "enter_doublewide_mode");
        define!(string EnterDraftQuality => "enter_draft_quality");
        define!(string EnterItalicsMode => "enter_italics_mode");
        define!(string EnterLeftwardMode => "enter_leftward_mode");
        define!(string EnterMicroMode => "enter_micro_mode");
        define!(string EnterNearLetterQuality => "enter_near_letter_quality");
        define!(string EnterNormalQuality => "enter_normal_quality");
        define!(string EnterShadowMode => "enter_shadow_mode");
        define!(string EnterSubscriptMode => "enter_subscript_mode");
        define!(string EnterSuperscriptMode => "enter_superscript_mode");
        define!(string EnterUpwardMode => "enter_upward_mode");
        define!(string ExitDoublewideMode => "exit_doublewide_mode");
        define!(string ExitItalicsMode => "exit_italics_mode");
        define!(string ExitLeftwardMode => "exit_leftward_mode");
        define!(string ExitMicroMode => "exit_micro_mode");
        define!(string ExitShadowMode => "exit_shadow_mode");
        define!(string ExitSubscriptMode => "exit_subscript_mode");
        define!(string ExitSuperscriptMode => "exit_superscript_mode");
        define!(string ExitUpwardMode => "exit_upward_mode");
        define!(string MicroColumnAddress => "micro_column_address");
        define!(string MicroDown => "micro_down");
        define!(string MicroLeft => "micro_left");
        define!(string MicroRight => "micro_right");
        define!(string MicroRowAddress => "micro_row_address");
        define!(string MicroUp => "micro_up");
        define!(string OrderOfPins => "order_of_pins");
        define!(string SelectCharSet => "select_char_set");
        define!(string SetBottomMargin => "set_bottom_margin");
        define!(string SetBottomMarginParm => "set_bottom_margin_parm");
        define!(string SetLeftMarginParm => "set_left_margin_parm");
        define!(string SetRightMarginParm => "set_right_margin_parm");
        define!(string SetTopMargin => "set_top_margin");
        define!(string SetTopMarginParm => "set_top_margin_parm");
        define!(string StartBitImage => "start_bit_image");
        define!(string StartCharSetDef => "start_char_set_def");
        define!(string StopBitImage => "stop_bit_image");
        define!(string StopCharSetDef => "stop_char_set_def");
        define!(string SubscriptCharacters => "subscript_characters");
        define!(string SuperscriptCharacters => "superscript_characters");
        define!(string TheseCauseCr => "these_cause_cr");
        define!(string ZeroMotion => "zero_motion");
        define!(string CharSetNames => "char_set_names");
        define!(string KeyMouse => "key_mouse");
        define!(string MouseInfo => "mouse_info");
        define!(string ReqMousePos => "req_mouse_pos");
        define!(string GetMouse => "get_mouse");
        define!(string PkeyPlab => "pkey_plab");
        define!(string DeviceType => "device_type");
        define!(string CodeSetInit => "code_set_init");
        define!(string Set0DesSeq => "set0_des_seq");
        define!(string Set1DesSeq => "set1_des_seq");
        define!(string Set2DesSeq => "set2_des_seq");
        define!(string Set3DesSeq => "set3_des_seq");
        define!(string SetLrMargin => "set_lr_margin");
        define!(string SetTbMargin => "set_tb_margin");
        define!(string BitImageRepeat => "bit_image_repeat");
        define!(string BitImageNewline => "bit_image_newline");
        define!(string BitImageCarriageReturn => "bit_image_carriage_return");
        define!(string ColorNames => "color_names");
        define!(string DefineBitImageRegion => "define_bit_image_region");
        define!(string EndBitImageRegion => "end_bit_image_region");
        define!(string SetColorBand => "set_color_band");
        define!(string SetPageLength => "set_page_length");
        define!(string DisplayPcChar => "display_pc_char");
        define!(string EnterPcCharsetMode => "enter_pc_charset_mode");
        define!(string ExitPcCharsetMode => "exit_pc_charset_mode");
        define!(string EnterScancodeMode => "enter_scancode_mode");
        define!(string ExitScancodeMode => "exit_scancode_mode");
        define!(string PcTermOptions => "pc_term_options");
        define!(string ScancodeEscape => "scancode_escape");
        define!(string AltScancodeEsc => "alt_scancode_esc");
        define!(string EnterHorizontalHlMode => "enter_horizontal_hl_mode");
        define!(string EnterLeftHlMode => "enter_left_hl_mode");
        define!(string EnterLowHlMode => "enter_low_hl_mode");
        define!(string EnterRightHlMode => "enter_right_hl_mode");
        define!(string EnterTopHlMode => "enter_top_hl_mode");
        define!(string EnterVerticalHlMode => "enter_vertical_hl_mode");
        define!(string SetAAttributes => "set_a_attributes");
        define!(string SetPglenInch => "set_pglen_inch");
        define!(string TermcapInit2 => "termcap_init2");
        define!(string TermcapReset => "termcap_reset");
        define!(string LinefeedIfNotLf => "linefeed_if_not_lf");
        define!(string BackspaceIfNotBs => "backspace_if_not_bs");
        define!(string OtherNonFunctionKeys => "other_non_function_keys");
        define!(string ArrowKeyMap => "arrow_key_map");
        define!(string AcsULcorner => "acs_ulcorner");
        define!(string AcsLLcorner => "acs_llcorner");
        define!(string AcsURcorner => "acs_urcorner");
        define!(string AcsLRcorner => "acs_lrcorner");
        define!(string AcsLTee => "acs_ltee");
        define!(string AcsRTee => "acs_rtee");
        define!(string AcsBTee => "acs_btee");
        define!(string AcsTTee => "acs_ttee");
        define!(string AcsHLine => "acs_hline");
        define!(string AcsVLine => "acs_vline");
        define!(string AcsPlus => "acs_plus");
        define!(string MemoryLock => "memory_lock");
        define!(string MemoryUnlock => "memory_unlock");
        define!(string BoxChars1 => "box_chars_1");

        define!(string ChangeScrollRegion => "change_scroll_region";
            top:    u32,
            bottom: u32);

        define!(string ColumnAddress => "column_address";
            x: u32);

        define!(string CursorAddress => "cursor_address";
            y: u32,
            x: u32);

        define!(string EraseChars => "erase_chars";
            count: u32);

        define!(string ParmDch => "parm_dch";
            count: u32);

        define!(string ParmDeleteLine => "parm_delete_line";
            count: u32);

        define!(string ParmDownCursor => "parm_down_cursor";
            count: u32);

        define!(string ParmIch => "parm_ich";
            count: u32);

        define!(string ParmIndex => "parm_index";
            count: u32);

        define!(string ParmInsertLine => "parm_insert_line";
            count: u32);

        define!(string ParmLeftCursor => "parm_left_cursor";
            count: u32);

        define!(string ParmRightCursor => "parm_right_cursor";
            count: u32);

        define!(string ParmRindex => "parm_rindex";
            count: u32);

        define!(string ParmUpCursor => "parm_up_cursor";
            count: u32);

        define!(string ParmDownMicro => "parm_down_micro";
            count: u32);

        define!(string ParmLeftMicro => "parm_left_micro";
            count: u32);

        define!(string ParmRightMicro => "parm_right_micro";
            count: u32);

        define!(string ParmUpMicro => "parm_up_micro";
            count: u32);

        define!(string RowAddress => "row_address";
            y: u32);

        define!(string SetAttributes => "set_attributes";
            standout:    bool,
            underline:   bool,
            reverse:     bool,
            blink:       bool,
            dim:         bool,
            bold:        bool,
            invisible:   bool,
            protected:   bool,
            alt_charset: bool);

        define!(string SetAForeground => "set_a_foreground";
            color: u8);

        define!(string SetABackground => "set_a_background";
            color: u8);

        define!(string SetForeground => "set_foreground";
            color: u8);

        define!(string SetBackground => "set_background";
            color: u8);

        // Extended capabilities from screen.
        define!(boolean XTermTitle => "XT");
        define!(boolean BrightAttribute => "AX");
        define!(boolean XTermMouse => "XM");

        // Extended capabilities from tmux.
        define!(boolean TrueColor => "Tc");

        define!(string SetClipboard => "Ms";
            selection: String,
            content:   Vec<u8>);

        define!(string SetCursorStyle => "Ss";
            kind: u8);

        define!(string ResetCursorStyle => "Se");

        // True color extended capabilities from vim.
        define!(string SetTrueColorForeground => "8f";
            r: u8,
            g: u8,
            b: u8);

        define!(string SetTrueColorBackground => "8b";
            r: u8,
            g: u8,
            b: u8);

        define!(string ResetCursorColor => "Cr");

        define!(string SetCursorColor => "Cs";
            color: String);
    }
    pub use self::capability::{Capability, Value};

    mod database
    {
        use crate::
        {
            fnv::{ FnvHasher },
            collections::{ HashMap },
            env::{ self },
            fs::{ self, File },
            hash::{ BuildHasherDefault },
            io::{ Read },
            path::{ Path, PathBuf },
            terminfo::
            {
                capability::{ Capability, Value },
                error::{ self, Error },
                names::{ self },
                parser::{ compiled },
            },
        };

        /// A capability database.
        #[derive(Eq, PartialEq, Clone, Debug)]
        pub struct Database 
        {
            name: String,
            aliases: Vec<String>,
            description: String,
            inner: HashMap<String, Value, BuildHasherDefault<FnvHasher>>,
        }

        /// Builder for a new `Database`.
        #[derive(Default, Debug)]
        pub struct Builder 
        {
            name: Option<String>,
            aliases: Vec<String>,
            description: Option<String>,
            inner: HashMap<String, Value, BuildHasherDefault<FnvHasher>>,
        }

        impl Builder 
        {
            /// Build the database.
            pub fn build(self) -> Result<Database, ()> 
            {
                Ok(Database 
                {
                    name: self.name.ok_or(())?,
                    aliases: self.aliases,
                    description: self.description.unwrap_or_default(),
                    inner: self.inner,
                })
            }

            /// Set the terminal name.
            pub fn name<T: Into<String>>(&mut self, name: T) -> &mut Self 
            {
                self.name = Some(name.into());
                self
            }

            /// Set the terminal aliases.
            pub fn aliases<T, I>(&mut self, iter: I) -> &mut Self where
            T: Into<String>,
            I: IntoIterator<Item = T>,
            {
                self.aliases = iter.into_iter().map(|a| a.into()).collect();
                self
            }

            /// Set the terminal description.
            pub fn description<T: Into<String>>(&mut self, description: T) -> &mut Self
            {
                self.description = Some(description.into());
                self
            }

            /// Set a capability.
            pub fn set<'a, C: Capability<'a>>(&'a mut self, value: C) -> &mut Self
            {
                if !self.inner.contains_key(C::name())
                {
                    if let Some(value) = C::into(value)
                    {
                        self.inner.insert(C::name().into(), value);
                    }
                }

                self
            }

            /// Set a raw capability.
            pub fn raw<S: AsRef<str>, V: Into<Value>>(&mut self, name: S, value: V) -> &mut Self 
            {
                let name = name.as_ref();
                //let name = names::ALIASES.get(name).copied().unwrap_or(name);

                if !self.inner.contains_key(name)
                {
                    self.inner.insert(name.into(), value.into());
                }

                self
            }
        }

        impl Database 
        {
            /// Create a database builder for constucting a database.
            // Clippy is right, the naming is is unconventional, but it’s probably not worth changing
            #[allow(clippy::new_ret_no_self)]
            pub fn new() -> Builder { Builder::default() }

            /// Load a database from the current environment.
            pub fn from_env() -> error::Result<Self>
            {
                if let Ok(name) = env::var("TERM")
                { Self::from_name(name) }

                else 
                { Err(Error::NotFound) }
            }

            /// Load a database for the given name.
            pub fn from_name<N: AsRef<str>>(name: N) -> error::Result<Self>
            {
                let name = name.as_ref();
                let first = name.chars().next().ok_or(Error::NotFound)?;

                // See https://manpages.debian.org/buster/ncurses-bin/terminfo.5.en.html#Fetching_Compiled_Descriptions
                let mut search = Vec::<PathBuf>::new();

                #[allow(deprecated)] if let Some(dir) = env::var_os("TERMINFO")
                {
                    search.push(dir.into());
                }
                
                else if let Some(mut home) = std::env::home_dir()
                {
                    home.push(".terminfo");
                    search.push(home);
                }

                if let Ok(dirs) = env::var("TERMINFO_DIRS")
                {
                    for dir in dirs.split(':')
                    {
                        search.push(dir.into());
                    }
                }

                // handle non-FHS systems like Termux
                if let Ok(prefix) = env::var("PREFIX") 
                {
                    let path = Path::new(&prefix);
                    search.push(path.join("etc/terminfo"));
                    search.push(path.join("lib/terminfo"));
                    search.push(path.join("share/terminfo"));
                }

                search.push("/etc/terminfo".into());
                search.push("/lib/terminfo".into());
                search.push("/usr/share/terminfo".into());
                search.push("/usr/local/share/terminfo".into());
                search.push("/usr/local/share/site-terminfo".into());
                search.push("/boot/system/data/terminfo".into());

                for path in search 
                {
                    if fs::metadata(&path).is_err(){ continue; }

                    // Check standard location.
                    {
                        let mut path = path.clone();
                        path.push(first.to_string());
                        path.push(name);

                        if fs::metadata(&path).is_ok() { return Self::from_path(path); }
                    }

                    // Check non-standard location.
                    {
                        let mut path = path.clone();
                        path.push(format!("{:x}", first as usize));
                        path.push(name);

                        if fs::metadata(&path).is_ok()
                        { return Self::from_path(path); }
                    }
                }

                Err(Error::NotFound)
            }

            /// Load a database from the given path.
            pub fn from_path<P: AsRef<Path>>(path: P) -> error::Result<Self> 
            {
                let mut file = File::open(path)?;
                let mut buffer = Vec::new();
                file.read_to_end(&mut buffer)?;

                Self::from_buffer(buffer)
            }

            /// Load a database from a buffer.
            pub fn from_buffer<T: AsRef<[u8]>>(buffer: T) -> error::Result<Self> 
            {
                Err(Error::Parse)
                /*
                if let Ok((_, database)) = compiled::parse(buffer.as_ref()) {
                    Ok(database.into())
                } else {
                    Err(Error::Parse)
                }
                */
            }

            /// The terminal name.
            pub fn name(&self) -> &str 
            {
                &self.name
            }

            /// The terminal aliases.
            pub fn aliases(&self) -> &[String] 
            {
                &self.aliases
            }

            /// The terminal description.
            pub fn description(&self) -> &str 
            {
                &self.description
            }

            /// Get a capability.
            pub fn get<'a, C: Capability<'a>>(&'a self) -> Option<C> 
            {
                C::from(self.inner.get(C::name()))
            }

            /// Get a capability by name.
            pub fn raw<S: AsRef<str>>(&self, name: S) -> Option<&Value> 
            {
                let name = name.as_ref();
                //let name = names::ALIASES.get(name).copied().unwrap_or(name);
                self.inner.get(name)
            }
        }
    }

    pub use self::database::Database;

    /// Constants to deal with name differences across terminfo and termcap.
    pub mod names
    {
    }
}
/*
bitflag 2.0 */
pub mod bitflag
{
    //! A typesafe bitmask flag generator useful for sets of C-style flags.
    //! It can be used for creating ergonomic wrappers around C APIs.
    #[doc(inline)]
    pub use self::traits::BitFlags;

    pub mod parser
    {
        //! Parsing flags from text.
        use crate::fmt;

        /// An error encountered while parsing flags from text.
        #[derive(Debug)]
        pub struct ParseError( ParseErrorKind );

        #[derive(Debug)]
        enum ParseErrorKind 
        {
            EmptyFlag,
            InvalidNamedFlag 
            {
                got: String,
            },
            InvalidHexFlag 
            {
                got: String,
            },
        }

        impl ParseError 
        {
            /// An invalid hex flag was encountered.
            pub fn invalid_hex_flag(flag: impl fmt::Display) -> Self 
            {
                let _flag = flag;
                let got = 
                {
                    _flag.to_string()
                };

                ParseError(ParseErrorKind::InvalidHexFlag { got })
            }

            /// A named flag that doesn't correspond to any on the flags type was encountered.
            pub fn invalid_named_flag(flag: impl fmt::Display) -> Self 
            {
                let _flag = flag;

                let got = 
                {
                    _flag.to_string()
                };

                ParseError(ParseErrorKind::InvalidNamedFlag { got })
            }

            /// A hex or named flag wasn't found between separators.
            pub fn empty_flag() -> Self 
            {
                ParseError(ParseErrorKind::EmptyFlag)
            }
        }

        impl fmt::Display for ParseError
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                match &self.0 
                {
                    ParseErrorKind::InvalidNamedFlag { got } => 
                    {
                        let _got = got;
                        write!(f, "unrecognized named flag")?;
                        write!(f, " `{}`", _got)?;
                    }

                    ParseErrorKind::InvalidHexFlag { got } => 
                    {
                        let _got = got;
                        write!(f, "invalid hex flag")?;
                        write!(f, " `{}`", _got)?;
                    }

                    ParseErrorKind::EmptyFlag => 
                    {
                        write!(f, "encountered empty flag")?;
                    }
                }

                Ok(())
            }
        }
        
        impl crate::error::Error for ParseError {}
    }

    pub mod traits
    {
        use crate::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};

        /// A trait that is automatically implemented for all bitflags.
        pub trait BitFlags: ImplementedByBitFlagsMacro
        {
            /// The underlying integer type.
            type Bits: Bits;
            /// An iterator over enabled flags in an instance of the type.
            type Iter: Iterator<Item = Self>;
            /// An iterator over the raw names and bits for enabled flags in an instance of the type.
            type IterNames: Iterator<Item = (&'static str, Self)>;
            /// Returns an empty set of flags.
            fn empty() -> Self;
            /// Returns the set containing all flags.
            fn all() -> Self;
            /// Returns the raw value of the flags currently stored.
            fn bits(&self) -> Self::Bits;
            /// Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.
            fn from_bits(bits: Self::Bits) -> Option<Self> where Self: Sized;
            /// Convert from underlying bit representation, dropping any bits that do not correspond to flags.
            fn from_bits_truncate(bits: Self::Bits) -> Self;
            /// Convert from underlying bit representation, preserving all bits.
            fn from_bits_retain(bits: Self::Bits) -> Self;
            /// Get the flag for a particular name.
            fn from_name(name: &str) -> Option<Self> where Self: Sized;
            /// Iterate over enabled flag values.
            fn iter(&self) -> Self::Iter;
            /// Iterate over the raw names and bits for enabled flag values.
            fn iter_names(&self) -> Self::IterNames;
            /// Returns `true` if no flags are currently stored.
            fn is_empty(&self) -> bool;
            /// Returns `true` if all flags are currently set.
            fn is_all(&self) -> bool;
            /// Returns `true` if there are flags common to both `self` and `other`.
            fn intersects(&self, other: Self) -> bool;
            /// Returns `true` if all of the flags in `other` are contained within `self`.
            fn contains(&self, other: Self) -> bool;
            /// Inserts the specified flags in-place.
            fn insert(&mut self, other: Self);
            /// Removes the specified flags in-place.
            fn remove(&mut self, other: Self);
            /// Toggles the specified flags in-place.
            fn toggle(&mut self, other: Self);
            /// Inserts or removes the specified flags depending on the passed value.
            fn set(&mut self, other: Self, value: bool);
        }

        /// A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.
        ///
        /// There's nothing stopping an end-user from implementing this trait, but we don't guarantee their
        /// manual implementations won't break between non-breaking releases.
        #[doc(hidden)]
        pub trait ImplementedByBitFlagsMacro {}

        // Not re-exported
        pub trait Sealed {}

        // Private implementation details
        //
        // The `Bits`, `PublicFlags`, and `InternalFlags` traits are implementation details of the `bitflags!`
        // macro that we're free to change here. They work with the `bitflags!` macro to separate the generated
        // code that belongs to end-users, and the generated code that belongs to this library.

        /// A private trait that encodes the requirements of underlying bits types that can hold flags.
        ///
        /// This trait may be made public at some future point, but it presents a compatibility hazard
        /// so is left internal for now.
        #[doc(hidden)]
        pub trait Bits:
        Clone
        + Copy
        + BitAnd
        + BitAndAssign
        + BitOr
        + BitOrAssign
        + BitXor
        + BitXorAssign
        + Not
        + Sized
        + Sealed
        {
            /// The value of `Self` where no bits are set.
            const EMPTY: Self;

            /// The value of `Self` where all bits are set.
            const ALL: Self;
        }

        macro_rules! impl_bits 
        {
            ($($u:ty, $i:ty,)*) => 
            {
                $(
                    impl Bits for $u 
                    {
                        const EMPTY: $u = 0;
                        const ALL: $u = <$u>::MAX;
                    }

                    impl Bits for $i 
                    {
                        const EMPTY: $i = 0;
                        const ALL: $i = <$u>::MAX as $i;
                    }

                    impl Sealed for $u {}
                    impl Sealed for $i {}
                )*
            }
        }

        impl_bits! 
        {
            u8, i8,
            u16, i16,
            u32, i32,
            u64, i64,
            u128, i128,
        }

        /// A trait for referencing the `bitflags`-owned internal type without exposing it publicly.
        pub trait PublicFlags 
        {
            /// The type of the internal field on the generated flags type.
            type Internal;
        }
    }

    #[doc(hidden)]
    pub mod __private 
    {
        pub use super::{external::*, traits::*};
    }

    /*
    How does the bitflags crate work?

    This library generates a `struct` in the end-user's crate with a bunch of constants on it that represent flags.
    The difference between `bitflags` and a lot of other libraries is that we don't actually control the generated `struct` in the end.
    It's part of the end-user's crate, so it belongs to them. That makes it difficult to extend `bitflags` with new functionality
    because we could end up breaking valid code that was already written. */
    #[macro_export(local_inner_macros)]
    macro_rules! bitflags 
    {
        (
            $(#[$outer:meta])*
            $vis:vis struct $BitFlags:ident: $T:ty {
                $(
                    $(#[$inner:ident $($args:tt)*])*
                    const $Flag:ident = $value:expr;
                )*
            }

            $($t:tt)*
        ) => {
            // Declared in the scope of the `bitflags!` call
            // This type appears in the end-user's API
            __declare_public_bitflags! {
                $(#[$outer])*
                $vis struct $BitFlags;
            }

            #[allow(
                dead_code,
                deprecated,
                unused_doc_comments,
                unused_attributes,
                unused_mut,
                unused_imports,
                non_upper_case_globals
            )]
            const _: () = {
                // Declared in a "hidden" scope that can't be reached directly
                // These types don't appear in the end-user's API
                __declare_internal_bitflags! {
                    $vis struct InternalBitFlags: $T;
                    $vis struct Iter;
                    $vis struct IterRaw;
                }

                __impl_internal_bitflags! {
                    InternalBitFlags: $T, $BitFlags, Iter, IterRaw {
                        $(
                            $(#[$inner $($args)*])*
                            $Flag;
                        )*
                    }
                }

                // This is where new library trait implementations can be added
                __impl_external_bitflags! {
                    InternalBitFlags: $T {
                        $(
                            $(#[$inner $($args)*])*
                            $Flag;
                        )*
                    }
                }

                __impl_public_bitflags! {
                    $BitFlags: $T, InternalBitFlags, Iter, IterRaw {
                        $(
                            $(#[$inner $($args)*])*
                            $Flag = $value;
                        )*
                    }
                }
            };

            bitflags! {
                $($t)*
            }
        };
        () => {};
    }

    #[macro_use]
    mod public
    {
        //! Generate the user-facing flags type.
        #[macro_export(local_inner_macros)]
        macro_rules! __declare_public_bitflags 
        {
            (
                $(#[$outer:meta])*
                $vis:vis struct $BitFlags:ident;
            ) => 
            {
                $(#[$outer])*
                $vis struct $BitFlags(<Self as $crate::bitflags::__private::PublicFlags>::Internal);
            };
        }

        /// Implement functions on the public (user-facing) bitflags type.
        #[macro_export(local_inner_macros)]
        macro_rules! __impl_public_bitflags 
        {
            (
                $PublicBitFlags:ident: $T:ty, $InternalBitFlags:ident, $Iter:ident, $IterNames:ident 
                {
                    $(
                        $(#[$attr:ident $($args:tt)*])*
                        $Flag:ident = $value:expr;
                    )*
                }
            ) => 
            {
                impl $crate::fmt::Binary for $PublicBitFlags 
                {
                    fn fmt(&self, f: &mut $crate::fmt::Formatter) -> $crate::fmt::Result 
                    {
                        $crate::fmt::Binary::fmt(&self.0, f)
                    }
                }

                impl $crate::fmt::Octal for $PublicBitFlags 
                {
                    fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result 
                    {
                        $crate::__private::core::fmt::Octal::fmt(&self.0, f)
                    }
                }

                impl $crate::fmt::LowerHex for $PublicBitFlags 
                {
                    fn fmt(&self, f: &mut $crate::fmt::Formatter) -> $crate::fmt::Result 
                    {
                        $crate::fmt::LowerHex::fmt(&self.0, f)
                    }
                }

                impl $crate::fmt::UpperHex for $PublicBitFlags 
                {
                    fn fmt(&self, f: &mut $crate::fmt::Formatter) -> $crate::fmt::Result 
                    {
                        $crate::fmt::UpperHex::fmt(&self.0, f)
                    }
                }

                impl $PublicBitFlags 
                {
                    $(
                        $(#[$attr $($args)*])*
                        pub const $Flag: Self = Self::from_bits_retain($value);
                    )*

                    /// Returns an empty set of flags.
                    #[inline] pub const fn empty() -> Self 
                    {
                        Self($InternalBitFlags::empty())
                    }

                    /// Returns the set containing all flags.
                    #[inline] pub const fn all() -> Self 
                    {
                        Self($InternalBitFlags::all())
                    }

                    /// Returns the raw value of the flags currently stored.
                    #[inline] pub const fn bits(&self) -> $T 
                    {
                        self.0.bits()
                    }

                    /// Convert from underlying bit representation, 
                    /// unless that representation contains bits that do not correspond to a flag.
                    #[inline] pub const fn from_bits(bits: $T) -> $crate::option::Option<Self> 
                    {
                        match $InternalBitFlags::from_bits(bits) 
                        {
                            $crate::option::Option::Some(bits) => $crate::option::Option::Some(Self(bits)),
                            $crate::option::Option::None => $crate::option::Option::None,
                        }
                    }

                    /// Convert from underlying bit representation, 
                    /// dropping any bits that do not correspond to flags.
                    #[inline] pub const fn from_bits_truncate(bits: $T) -> Self 
                    {
                        Self($InternalBitFlags::from_bits_truncate(bits))
                    }

                    /// Convert from underlying bit representation, preserving all
                    /// bits (even those not corresponding to a defined flag).
                    #[inline] pub const fn from_bits_retain(bits: $T) -> Self 
                    {
                        Self($InternalBitFlags::from_bits_retain(bits))
                    }

                    /// Get the value for a flag from its stringified name.
                    #[inline] pub fn from_name(name: &str) -> $crate::option::Option<Self> 
                    {
                        match $InternalBitFlags::from_name(name) 
                        {
                            $crate::option::Option::Some(bits) => $crate::option::Option::Some(Self(bits)),
                            $crate::option::Option::None => $crate::option::Option::None,
                        }
                    }

                    /// Iterate over enabled flag values.
                    #[inline] pub const fn iter(&self) -> $Iter 
                    { self.0.iter() }

                    /// Iterate over enabled flag values with their stringified names.
                    #[inline] pub const fn iter_names(&self) -> $IterNames {
                        self.0.iter_names()
                    }

                    /// Returns `true` if no flags are currently stored.
                    #[inline] pub const fn is_empty(&self) -> bool { self.0.is_empty() }

                    /// Returns `true` if all flags are currently set.
                    #[inline] pub const fn is_all(&self) -> bool { self.0.is_all() }

                    /// Returns `true` if there are flags common to both `self` and `other`.
                    #[inline] pub const fn intersects(&self, other: Self) -> bool 
                    {
                        self.0.intersects(other.0)
                    }

                    /// Returns `true` if all of the flags in `other` are contained within `self`.
                    #[inline] pub const fn contains(&self, other: Self) -> bool { self.0.contains(other.0) }

                    /// Inserts the specified flags in-place.
                    #[inline] pub fn insert(&mut self, other: Self){ self.0.insert(other.0) }

                    /// Removes the specified flags in-place.
                    #[inline] pub fn remove(&mut self, other: Self){ self.0.remove(other.0) }

                    /// Toggles the specified flags in-place.
                    #[inline] pub fn toggle(&mut self, other: Self){ self.0.toggle(other.0) }

                    /// Inserts or removes the specified flags depending on the passed value.
                    #[inline] pub fn set(&mut self, other: Self, value: bool){ self.0.set(other.0, value) }

                    /// Returns the intersection between the flags in `self` and `other`.
                    #[inline] #[must_use] pub const fn intersection(self, other: Self) -> Self 
                    { Self(self.0.intersection(other.0)) }

                    /// Returns the union of between the flags in `self` and `other`.
                    #[inline] #[must_use]
                    pub const fn union(self, other: Self) -> Self { Self(self.0.union(other.0)) }

                    /// Returns the difference between the flags in `self` and `other`.
                    #[inline] #[must_use] pub const fn difference(self, other: Self) -> Self 
                    { Self(self.0.difference(other.0)) }

                    /// Returns the [symmetric difference][sym-diff] between the flags in `self` and `other`.
                    #[inline] #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self 
                    { Self(self.0.symmetric_difference(other.0)) }

                    /// Returns the complement of this set of flags.
                    #[inline] #[must_use] pub const fn complement(self) -> Self { Self(self.0.complement()) }
                }

                impl $crate::ops::BitOr for $PublicBitFlags 
                {
                    type Output = Self;

                    /// Returns the union of the two sets of flags.
                    #[inline] fn bitor(self, other: $PublicBitFlags) -> Self 
                    { self.union(other) }
                }

                impl $crate::ops::BitOrAssign for $PublicBitFlags 
                {
                    /// Adds the set of flags.
                    #[inline] fn bitor_assign(&mut self, other: Self)
                    { self.0 = self.0.union(other.0); }
                }

                impl $crate::__private::core::ops::BitXor for $PublicBitFlags 
                {
                    type Output = Self;

                    /// Returns the left flags, but with all the right flags toggled.
                    #[inline] fn bitxor(self, other: Self) -> Self { self.symmetric_difference(other) }
                }

                impl $crate::__private::core::ops::BitXorAssign for $PublicBitFlags
                {
                    /// Toggles the set of flags.
                    #[inline] fn bitxor_assign(&mut self, other: Self){ self.0 = self.0.symmetric_difference(other.0); }
                }

                impl $crate::__private::core::ops::BitAnd for $PublicBitFlags 
                {
                    type Output = Self;

                    /// Returns the intersection between the two sets of flags.
                    #[inline] fn bitand(self, other: Self) -> Self { self.intersection(other) }
                }

                impl $crate::__private::core::ops::BitAndAssign for $PublicBitFlags 
                {
                    /// Disables all flags disabled in the set.
                    #[inline] fn bitand_assign(&mut self, other: Self)
                    {
                        self.0 = self.0.intersection(other.0);
                    }
                }

                impl $crate::__private::core::ops::Sub for $PublicBitFlags
                {
                    type Output = Self;

                    /// Returns the set difference of the two sets of flags.
                    #[inline] fn sub(self, other: Self) -> Self { self.difference(other) }
                }

                impl $crate::__private::core::ops::SubAssign for $PublicBitFlags 
                {
                    /// Disables all flags enabled in the set.
                    #[inline] fn sub_assign(&mut self, other: Self) 
                    {
                        self.0 = self.0.difference(other.0);
                    }
                }

                impl $crate::__private::core::ops::Not for $PublicBitFlags
                {
                    type Output = Self;

                    /// Returns the complement of this set of flags.
                    #[inline] fn not(self) -> Self { self.complement() }
                }

                impl $crate::__private::core::iter::Extend<$PublicBitFlags> for $PublicBitFlags
                {
                    fn extend<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T)
                    {
                        for item in iterator
                        {
                            self.insert(item)
                        }
                    }
                }

                impl $crate::__private::core::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags
                {
                    fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self
                    {
                        use $crate::__private::core::iter::Extend;
                        let mut result = Self::empty();
                        result.extend(iterator);
                        result
                    }
                }

                impl $crate::__private::core::iter::IntoIterator for $PublicBitFlags
                {
                    type Item = Self;
                    type IntoIter = $Iter;

                    fn into_iter(self) -> Self::IntoIter {
                        self.0.iter()
                    }
                }

                impl $crate::BitFlags for $PublicBitFlags {
                    type Bits = $T;

                    type Iter = $Iter;
                    type IterNames = $IterNames;

                    fn empty() -> Self {
                        $PublicBitFlags::empty()
                    }

                    fn all() -> Self {
                        $PublicBitFlags::all()
                    }

                    fn bits(&self) -> $T {
                        $PublicBitFlags::bits(self)
                    }

                    fn from_bits(bits: $T) -> $crate::__private::core::option::Option<$PublicBitFlags> {
                        $PublicBitFlags::from_bits(bits)
                    }

                    fn from_bits_truncate(bits: $T) -> $PublicBitFlags {
                        $PublicBitFlags::from_bits_truncate(bits)
                    }

                    fn from_bits_retain(bits: $T) -> $PublicBitFlags {
                        $PublicBitFlags::from_bits_retain(bits)
                    }

                    fn from_name(name: &str) -> $crate::__private::core::option::Option<$PublicBitFlags> {
                        $PublicBitFlags::from_name(name)
                    }

                    fn iter(&self) -> Self::Iter {
                        $PublicBitFlags::iter(self)
                    }

                    fn iter_names(&self) -> Self::IterNames {
                        $PublicBitFlags::iter_names(self)
                    }

                    fn is_empty(&self) -> bool {
                        $PublicBitFlags::is_empty(self)
                    }

                    fn is_all(&self) -> bool {
                        $PublicBitFlags::is_all(self)
                    }

                    fn intersects(&self, other: $PublicBitFlags) -> bool {
                        $PublicBitFlags::intersects(self, other)
                    }

                    fn contains(&self, other: $PublicBitFlags) -> bool {
                        $PublicBitFlags::contains(self, other)
                    }

                    fn insert(&mut self, other: $PublicBitFlags) {
                        $PublicBitFlags::insert(self, other)
                    }

                    fn remove(&mut self, other: $PublicBitFlags) {
                        $PublicBitFlags::remove(self, other)
                    }

                    fn toggle(&mut self, other: $PublicBitFlags) {
                        $PublicBitFlags::toggle(self, other)
                    }

                    fn set(&mut self, other: $PublicBitFlags, value: bool) {
                        $PublicBitFlags::set(self, other, value)
                    }
                }

                impl $crate::__private::ImplementedByBitFlagsMacro for $PublicBitFlags {}
            };
        }
    }

    #[macro_use]
    mod internal
    {
        //! Generate the internal `bitflags`-facing flags type.
        #[macro_export(local_inner_macros)]
        macro_rules! __declare_internal_bitflags 
        {
            (
                $vis:vis struct $InternalBitFlags:ident: $T:ty;
                $iter_vis:vis struct $Iter:ident;
                $iter_names_vis:vis struct $IterNames:ident;
            ) => 
            {
                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
                #[repr(transparent)]
                $vis struct $InternalBitFlags {
                    bits: $T,
                }

                $iter_vis struct $Iter {
                    inner: $IterNames,
                    done: bool,
                }

                $iter_names_vis struct $IterNames {
                    idx: usize,
                    source: $InternalBitFlags,
                    state: $InternalBitFlags,
                }
            };
        }

        /// Implement functions on the private (bitflags-facing) bitflags type.
        #[macro_export(local_inner_macros)]
        macro_rules! __impl_internal_bitflags
        {
            (
                $InternalBitFlags:ident: $T:ty, $BitFlags:ident, $Iter:ident, $IterNames:ident 
                {
                    $(
                        $(#[$attr:ident $($args:tt)*])*
                        $Flag:ident;
                    )*
                }
            ) => 
            {
                impl $crate::__private::PublicFlags for $BitFlags {
                    type Internal = $InternalBitFlags;
                }

                impl $crate::__private::core::default::Default for $InternalBitFlags {
                    #[inline]
                    fn default() -> Self {
                        $InternalBitFlags::empty()
                    }
                }

                impl $crate::__private::core::fmt::Debug for $InternalBitFlags {
                    fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
                        if self.is_empty() {
                            // If no flags are set then write an empty hex flag to avoid
                            // writing an empty string. In some contexts, like serialization,
                            // an empty string is preferrable, but it may be unexpected in
                            // others for a format not to produce any output.
                            //
                            // We can remove this `0x0` and remain compatible with `FromStr`,
                            // because an empty string will still parse to an empty set of flags,
                            // just like `0x0` does.
                            $crate::__private::core::write!(f, "{:#x}", <$T as $crate::__private::Bits>::EMPTY)
                        } else {
                            $crate::__private::core::fmt::Display::fmt(self, f)
                        }
                    }
                }

                impl $crate::__private::core::fmt::Display for $InternalBitFlags {
                    fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
                        // A formatter for bitflags that produces text output like:
                        //
                        // A | B | 0xf6
                        //
                        // The names of set flags are written in a bar-separated-format,
                        // followed by a hex number of any remaining bits that are set
                        // but don't correspond to any flags.

                        // Iterate over the valid flags
                        let mut first = true;
                        for (name, _) in self.iter_names() {
                            if !first {
                                f.write_str(" | ")?;
                            }

                            first = false;
                            f.write_str(name)?;
                        }

                        // Append any extra bits that correspond to flags to the end of the format
                        let extra_bits = self.bits & !Self::all().bits;

                        if extra_bits != <$T as $crate::__private::Bits>::EMPTY {
                            if !first {
                                f.write_str(" | ")?;
                            }

                            $crate::__private::core::write!(f, "{:#x}", extra_bits)?;
                        }

                        $crate::__private::core::fmt::Result::Ok(())
                    }
                }

                // The impl for `FromStr` should parse anything produced by `Display`
                impl $crate::__private::core::str::FromStr for $InternalBitFlags {
                    type Err = $crate::parser::ParseError;

                    fn from_str(s: &str) -> $crate::__private::core::result::Result<Self, Self::Err> {
                        let s = s.trim();

                        let mut parsed_flags = Self::empty();

                        // If the input is empty then return an empty set of flags
                        if s.is_empty() {
                            return $crate::__private::core::result::Result::Ok(parsed_flags);
                        }

                        for flag in s.split('|') {
                            let flag = flag.trim();

                            // If the flag is empty then we've got missing input
                            if flag.is_empty() {
                                return $crate::__private::core::result::Result::Err($crate::parser::ParseError::empty_flag());
                            }

                            // If the flag starts with `0x` then it's a hex number
                            // Parse it directly to the underlying bits type
                            let parsed_flag = if let $crate::__private::core::option::Option::Some(flag) = flag.strip_prefix("0x") {
                                let bits = <$T>::from_str_radix(flag, 16).map_err(|_| $crate::parser::ParseError::invalid_hex_flag(flag))?;

                                Self::from_bits_retain(bits)
                            }
                            // Otherwise the flag is a name
                            // The generated flags type will determine whether
                            // or not it's a valid identifier
                            else {
                                Self::from_name(flag).ok_or_else(|| $crate::parser::ParseError::invalid_named_flag(flag))?
                            };

                            parsed_flags.insert(parsed_flag);
                        }

                        $crate::__private::core::result::Result::Ok(parsed_flags)
                    }
                }

                impl $crate::__private::core::fmt::Binary for $InternalBitFlags {
                    fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
                        $crate::__private::core::fmt::Binary::fmt(&self.bits(), f)
                    }
                }

                impl $crate::__private::core::fmt::Octal for $InternalBitFlags {
                    fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
                        $crate::__private::core::fmt::Octal::fmt(&self.bits(), f)
                    }
                }

                impl $crate::__private::core::fmt::LowerHex for $InternalBitFlags {
                    fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
                        $crate::__private::core::fmt::LowerHex::fmt(&self.bits(), f)
                    }
                }

                impl $crate::__private::core::fmt::UpperHex for $InternalBitFlags {
                    fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {
                        $crate::__private::core::fmt::UpperHex::fmt(&self.bits(), f)
                    }
                }

                impl $InternalBitFlags {
                    #[inline]
                    pub const fn empty() -> Self {
                        Self { bits: <$T as $crate::__private::Bits>::EMPTY }
                    }

                    #[inline]
                    pub const fn all() -> Self {
                        Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)
                    }

                    #[inline]
                    pub const fn bits(&self) -> $T {
                        self.bits
                    }

                    #[inline]
                    pub fn bits_mut(&mut self) -> &mut $T {
                        &mut self.bits
                    }

                    #[inline]
                    pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {
                        let truncated = Self::from_bits_truncate(bits).bits;

                        if truncated == bits {
                            $crate::__private::core::option::Option::Some(Self { bits })
                        } else {
                            $crate::__private::core::option::Option::None
                        }
                    }

                    #[inline]
                    pub const fn from_bits_truncate(bits: $T) -> Self {
                        if bits == <$T as $crate::__private::Bits>::EMPTY {
                            return Self { bits }
                        }

                        let mut truncated = <$T as $crate::__private::Bits>::EMPTY;

                        $(
                            $(#[$attr $($args)*])*
                            if bits & $BitFlags::$Flag.bits() == $BitFlags::$Flag.bits() {
                                truncated |= $BitFlags::$Flag.bits()
                            }
                        )*

                        Self { bits: truncated }
                    }

                    #[inline]
                    pub const fn from_bits_retain(bits: $T) -> Self {
                        Self { bits }
                    }

                    #[inline]
                    pub fn from_name(name: &str) -> $crate::__private::core::option::Option<Self> {
                        match name {
                            $(
                                $(#[$attr $($args)*])*
                                $crate::__private::core::stringify!($Flag) => $crate::__private::core::option::Option::Some(Self { bits: $BitFlags::$Flag.bits() }),
                            )*
                            _ => $crate::__private::core::option::Option::None,
                        }
                    }

                    #[inline]
                    pub const fn iter(&self) -> $Iter {
                        $Iter {
                            inner: self.iter_names(),
                            done: false,
                        }
                    }

                    #[inline]
                    pub const fn iter_names(&self) -> $IterNames {
                        $IterNames {
                            idx: 0,
                            source: *self,
                            state: *self,
                        }
                    }

                    #[inline]
                    pub const fn is_empty(&self) -> bool {
                        self.bits == Self::empty().bits
                    }

                    #[inline]
                    pub const fn is_all(&self) -> bool {
                        Self::all().bits | self.bits == self.bits
                    }

                    #[inline]
                    pub const fn intersects(&self, other: Self) -> bool {
                        !(Self { bits: self.bits & other.bits}).is_empty()
                    }

                    #[inline]
                    pub const fn contains(&self, other: Self) -> bool {
                        (self.bits & other.bits) == other.bits
                    }

                    #[inline]
                    pub fn insert(&mut self, other: Self) {
                        self.bits |= other.bits;
                    }

                    #[inline]
                    pub fn remove(&mut self, other: Self) {
                        self.bits &= !other.bits;
                    }

                    #[inline]
                    pub fn toggle(&mut self, other: Self) {
                        self.bits ^= other.bits;
                    }

                    #[inline]
                    pub fn set(&mut self, other: Self, value: bool) {
                        if value {
                            self.insert(other);
                        } else {
                            self.remove(other);
                        }
                    }

                    #[inline]
                    #[must_use]
                    pub const fn intersection(self, other: Self) -> Self {
                        Self { bits: self.bits & other.bits }
                    }

                    #[inline]
                    #[must_use]
                    pub const fn union(self, other: Self) -> Self {
                        Self { bits: self.bits | other.bits }
                    }

                    #[inline]
                    #[must_use]
                    pub const fn difference(self, other: Self) -> Self {
                        Self { bits: self.bits & !other.bits }
                    }

                    #[inline]
                    #[must_use]
                    pub const fn symmetric_difference(self, other: Self) -> Self {
                        Self { bits: self.bits ^ other.bits }
                    }

                    #[inline]
                    #[must_use]
                    pub const fn complement(self) -> Self {
                        Self::from_bits_truncate(!self.bits)
                    }
                }

                impl $crate::__private::core::convert::AsRef<$T> for $InternalBitFlags {
                    fn as_ref(&self) -> &$T {
                        &self.bits
                    }
                }

                impl $crate::__private::core::convert::From<$T> for $InternalBitFlags {
                    fn from(bits: $T) -> Self {
                        Self::from_bits_retain(bits)
                    }
                }

                impl $crate::__private::core::iter::Iterator for $Iter {
                    type Item = $BitFlags;

                    fn next(&mut self) -> $crate::__private::core::option::Option<Self::Item> {
                        match self.inner.next().map(|(_, value)| value) {
                            $crate::__private::core::option::Option::Some(value) => $crate::__private::core::option::Option::Some(value),
                            $crate::__private::core::option::Option::None if !self.done => {
                                self.done = true;

                                // After iterating through valid names, if there are any bits left over
                                // then return one final value that includes them. This makes `into_iter`
                                // and `from_iter` roundtrip
                                if self.inner.state != $InternalBitFlags::empty() {
                                    $crate::__private::core::option::Option::Some($BitFlags::from_bits_retain(self.inner.state.bits()))
                                } else {
                                    $crate::__private::core::option::Option::None
                                }
                            },
                            _ => $crate::__private::core::option::Option::None,
                        }
                    }
                }

                impl $crate::__private::core::iter::Iterator for $IterNames {
                    type Item = (&'static str, $BitFlags);

                    fn next(&mut self) -> $crate::__private::core::option::Option<Self::Item> {
                        const NUM_FLAGS: usize = {
                            let mut num_flags = 0;

                            $(
                                $(#[$attr $($args)*])*
                                {
                                    num_flags += 1;
                                }
                            )*

                            num_flags
                        };

                        const OPTIONS: [$T; NUM_FLAGS] = [
                            $(
                                $(#[$attr $($args)*])*
                                $BitFlags::$Flag.bits(),
                            )*
                        ];

                        const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [
                            $(
                                $(#[$attr $($args)*])*
                                $crate::__private::core::stringify!($Flag),
                            )*
                        ];

                        if self.state.is_empty() || NUM_FLAGS == 0 {
                            $crate::__private::core::option::Option::None
                        } else {
                            for (flag, flag_name) in OPTIONS[self.idx..NUM_FLAGS].iter().copied()
                                .zip(OPTIONS_NAMES[self.idx..NUM_FLAGS].iter().copied())
                            {
                                self.idx += 1;

                                // NOTE: We check whether the flag exists in self, but remove it from
                                // a different value. This ensure that overlapping flags are handled
                                // properly. Take the following example:
                                //
                                // const A: 0b00000001;
                                // const B: 0b00000101;
                                //
                                // Given the bits 0b00000101, both A and B are set. But if we removed A
                                // as we encountered it we'd be left with 0b00000100, which doesn't
                                // correspond to a valid flag on its own.
                                if self.source.contains($InternalBitFlags { bits: flag }) {
                                    self.state.remove($InternalBitFlags { bits: flag });

                                    return $crate::__private::core::option::Option::Some((flag_name, $BitFlags::from_bits_retain(flag)))
                                }
                            }

                            $crate::__private::core::option::Option::None
                        }
                    }
                }
            };
        }
    }

    #[macro_use]
    mod external
    {
        //! Conditional trait implementations for external libraries.

        /// Implements traits from external libraries for the internal bitflags type.
        #[macro_export(local_inner_macros)]
        macro_rules! __impl_external_bitflags 
        {
            (
                $InternalBitFlags:ident: $T:ty {
                    $(
                        $(#[$attr:ident $($args:tt)*])*
                        $Flag:ident;
                    )*
                }
            ) => {
                // Any new library traits impls should be added here
                // Use `serde` as an example: generate code when the feature is available,
                // and a no-op when it isn't

                __impl_external_bitflags_serde! {
                    $InternalBitFlags: $T {
                        $(
                            $(#[$attr $($args)*])*
                            $Flag;
                        )*
                    }
                }
            };
        }

        #[macro_export(local_inner_macros)]
        #[doc(hidden)]
        macro_rules! __impl_external_bitflags_serde 
        {
            (
                $InternalBitFlags:ident: $T:ty {
                    $(
                        $(#[$attr:ident $($args:tt)*])*
                        $Flag:ident;
                    )*
                }
            ) => {};
        }
    }
}
/*
smallstr 0.2*/
pub mod smallstr
{
    //! Implements `SmallString`, a `String`-like container for small strings.
    pub use self::string::*;

    mod string
    {
        use ::
        {
            borrow::{Borrow, BorrowMut, Cow},
            boxed::{ Box },
            cmp::Ordering,
            ffi::{OsStr, OsString},
            fmt,
            hash::{Hash, Hasher},
            iter::FromIterator,
            ops, ptr, slice,
            marker::{PhantomData},
            str::{self, Chars, Utf8Error},
            string::{String},
        };
        
        use smallvec::{Array, SmallVec};

        /// A `String`-like container that can store a small number of bytes inline.
        #[derive(Clone, Default)]
        pub struct SmallString<A: Array<Item = u8>> 
        {
            data: SmallVec<A>,
        }

        impl<A: Array<Item = u8>> SmallString<A> 
        {
            /// Construct an empty string.
            #[inline] pub fn new() -> SmallString<A> 
            {
                SmallString 
                {
                    data: SmallVec::new(),
                }
            }

            /// Construct an empty string with capacity to store at least `nth` bytes.
            #[inline] pub fn with_capacity(n: usize) -> SmallString<A> 
            {
                SmallString 
                {
                    data: SmallVec::with_capacity(n),
                }
            }

            /// Construct a `SmallString` by copying data from a `&str`.
            #[inline] pub fn from_str(s: &str) -> SmallString<A>
            {
                SmallString
                {
                    data: SmallVec::from_slice(s.as_bytes()),
                }
            }

            /// Construct a `SmallString` by using an existing allocation.
            #[inline] pub fn from_string(s: String) -> SmallString<A> 
            {
                SmallString 
                {
                    data: SmallVec::from_vec(s.into_bytes()),
                }
            }

            /// Constructs a new `SmallString` on the stack using UTF-8 bytes.
            #[inline] pub fn from_buf(buf: A) -> Result<SmallString<A>, FromUtf8Error<A>> 
            {
                let data = SmallVec::from_buf(buf);

                match str::from_utf8(&data) 
                {
                    Ok(_) => Ok(SmallString { data }),
                    Err(error) =>
                    {
                        let buf = data.into_inner().ok().unwrap();
                        Err(FromUtf8Error { buf, error })
                    }
                }
            }

            /// Constructs a new `SmallString` on the stack using the provided byte array
            /// without checking that the array contains valid UTF-8.
            #[inline] pub unsafe fn from_buf_unchecked(buf: A) -> SmallString<A>
            {
                SmallString
                {
                    data: SmallVec::from_buf(buf),
                }
            }

            /// The maximum number of bytes this string can hold inline.
            #[inline] pub fn inline_size(&self) -> usize
            {
                A::size()
            }

            /// Returns the length of this string, in bytes.
            #[inline] pub fn len(&self) -> usize
            {
                self.data.len()
            }

            /// Returns `true` if this string is empty.
            #[inline] pub fn is_empty(&self) -> bool
            {
                self.data.is_empty()
            }

            /// Returns the number of bytes this string can hold without reallocating.
            #[inline] pub fn capacity(&self) -> usize
            {
                self.data.capacity()
            }

            /// Returns `true` if the data has spilled into a separate heap-allocated buffer.
            #[inline] pub fn spilled(&self) -> bool
            {
                self.data.spilled()
            }

            /// Empties the string and returns an iterator over its former contents.
            pub fn drain(&mut self) -> Drain
            {
                unsafe
                {
                    let len = self.len();
                    self.data.set_len(0);
                    let ptr = self.as_ptr();
                    let slice = slice::from_raw_parts(ptr, len);
                    let s = str::from_utf8_unchecked(slice);
                    Drain { iter: s.chars() }
                }
            }

            /// Appends the given `char` to the end of this string.
            #[inline] pub fn push(&mut self, ch: char)
            {
                match ch.len_utf8()
                {
                    1 => self.data.push(ch as u8),
                    _ => self.push_str(ch.encode_utf8(&mut [0; 4])),
                }
            }
            /// Appends the given string slice to the end of this string.
            #[inline] pub fn push_str(&mut self, s: &str)
            {
                self.data.extend_from_slice(s.as_bytes());
            }

            /// Removes the last character from this string and returns it.
            #[inline] pub fn pop(&mut self) -> Option<char>
            {
                match self.chars().next_back()
                {
                    Some(ch) => unsafe
                    {
                        let new_len = self.len() - ch.len_utf8();
                        self.data.set_len(new_len);
                        Some(ch)
                    },
                    None => None,
                }
            }
            /// Reallocates to set the new capacity to `new_cap`.
            ///
            /// # Panics
            ///
            /// If `new_cap` is less than the current length.
            #[inline] pub fn grow(&mut self, new_cap: usize)
            {
                self.data.grow(new_cap);
            }

            /// Ensures that this string's capacity is at least larger than its length.
            #[inline] pub fn reserve(&mut self, additional: usize)
            {
                self.data.reserve(additional);
            }

            /// Ensures that this string's capacity is `additional` bytes larger than
            /// its length.
            #[inline] pub fn reserve_exact(&mut self, additional: usize)
            {
                self.data.reserve(additional);
            }

            /// Shrink the capacity of the string as much as possible.
            #[inline] pub fn shrink_to_fit(&mut self)
            {
                self.data.shrink_to_fit();
            }

            /// Shorten the string, keeping the first `len` bytes.
            ///
            /// # Panics
            ///
            /// If `len` does not lie on a `char` boundary.
            #[inline] pub fn truncate(&mut self, len: usize)
            {
                assert!(self.is_char_boundary(len));
                self.data.truncate(len);
            }

            /// Extracts a string slice containing the entire string.
            #[inline] pub fn as_str(&self) -> &str
            {
                self
            }

            /// Extracts a string slice containing the entire string.
            #[inline] pub fn as_mut_str(&mut self) -> &mut str
            {
                self
            }

            /// Removes all contents of the string.
            #[inline] pub fn clear(&mut self)
            {
                self.data.clear();
            }

            /// Removes a `char` from this string at a byte position and returns it.
            ///
            /// # Panics
            ///
            /// If `idx` does not lie on a `char` boundary.
            #[inline] pub fn remove(&mut self, idx: usize) -> char
            {
                let ch = match self[idx..].chars().next()
                {
                    Some(ch) => ch,
                    None => panic!("cannot remove a char from the end of a string"),
                };

                let ch_len = ch.len_utf8();
                let next = idx + ch_len;
                let len = self.len();

                unsafe
                {
                    ptr::copy
                    (
                        self.as_ptr().add(next),
                        self.as_mut_ptr().add(idx),
                        len - next,
                    );
                    self.data.set_len(len - ch_len);
                }

                ch
            }

            /// Inserts a `char` into this string at the given byte position.
            ///
            /// # Panics
            ///
            /// If `idx` does not lie on `char` boundaries.
            #[inline] pub fn insert(&mut self, idx: usize, ch: char)
            {
                assert!(self.is_char_boundary(idx));

                match ch.len_utf8()
                {
                    1 => self.data.insert(idx, ch as u8),
                    _ => self.insert_str(idx, ch.encode_utf8(&mut [0; 4])),
                }
            }

            /// Inserts a `&str` into this string at the given byte position.
            ///
            /// # Panics
            ///
            /// If `idx` does not lie on `char` boundaries.
            #[inline] pub fn insert_str(&mut self, idx: usize, s: &str)
            {
                assert!(self.is_char_boundary(idx));

                let len = self.len();
                let amt = s.len();

                self.data.reserve(amt);

                unsafe
                {
                    ptr::copy
                    (
                        self.as_ptr().add(idx),
                        self.as_mut_ptr().add(idx + amt),
                        len - idx,
                    );
                    
                    ptr::copy_nonoverlapping(s.as_ptr(), self.as_mut_ptr().add(idx), amt);
                    self.data.set_len(len + amt);
                }
            }

            /// Returns a mutable reference to the contents of the `SmallString`.
            #[inline] pub unsafe fn as_mut_vec(&mut self) -> &mut SmallVec<A>
            {
                &mut self.data
            }

            /// Converts the `SmallString` into a `String`, without reallocating if the
            /// `SmallString` has already spilled onto the heap.
            #[inline] pub fn into_string(self) -> String
            {
                unsafe { String::from_utf8_unchecked(self.data.into_vec()) }
            }

            /// Converts the `SmallString` into a `Box<str>`, without reallocating if the
            /// `SmallString` has already spilled onto the heap.
            #[inline] pub fn into_boxed_str(self) -> Box<str>
            {
                self.into_string().into_boxed_str()
            }

            /// Convert the `SmallString` into `A`, if possible. Otherwise, return `Err(self)`.
            #[inline] pub fn into_inner(self) -> Result<A, Self>
            {
                self.data.into_inner().map_err(|data| SmallString { data })
            }

            /// Retains only the characters specified by the predicate.
            #[inline] pub fn retain<F: FnMut(char) -> bool>(&mut self, mut f: F)
            {
                struct SetLenOnDrop<'a, A: Array<Item = u8>>
                {
                    s: &'a mut SmallString<A>,
                    idx: usize,
                    del_bytes: usize,
                }

                impl<'a, A: Array<Item = u8>> Drop for SetLenOnDrop<'a, A>
                {
                    fn drop(&mut self)
                    {
                        let new_len = self.idx - self.del_bytes;
                        debug_assert!(new_len <= self.s.len());
                        unsafe { self.s.data.set_len(new_len) };
                    }
                }

                let len = self.len();
                let mut guard = SetLenOnDrop
                {
                    s: self,
                    idx: 0,
                    del_bytes: 0,
                };

                while guard.idx < len
                {
                    let ch = unsafe
                    {
                        guard
                        .s
                        .get_unchecked(guard.idx..len)
                        .chars()
                        .next()
                        .unwrap()
                    };
                    
                    let ch_len = ch.len_utf8();

                    if !f(ch)
                    {
                        guard.del_bytes += ch_len;
                    } 
                    else if guard.del_bytes > 0
                    {
                        unsafe
                        {
                            ptr::copy
                            (
                                guard.s.data.as_ptr().add(guard.idx),
                                guard.s.data.as_mut_ptr().add(guard.idx - guard.del_bytes),
                                ch_len,
                            );
                        }
                    }

                    // Point idx to the next char
                    guard.idx += ch_len;
                }

                drop(guard);
            }

            fn as_mut_ptr(&mut self) -> *mut u8
            {
                self.as_ptr() as *mut u8
            }
        }

        impl<A: Array<Item = u8>> ops::Deref for SmallString<A>
        {
            type Target = str;

            #[inline] fn deref(&self) -> &str
            {
                let bytes: &[u8] = &self.data;
                unsafe { str::from_utf8_unchecked(bytes) }
            }
        }

        impl<A: Array<Item = u8>> ops::DerefMut for SmallString<A>
        {
            #[inline] fn deref_mut(&mut self) -> &mut str
            {
                let bytes: &mut [u8] = &mut self.data;
                unsafe { str::from_utf8_unchecked_mut(bytes) }
            }
        }

        impl<A: Array<Item = u8>> AsRef<str> for SmallString<A>
        {
            #[inline] fn as_ref(&self) -> &str
            {
                self
            }
        }

        impl<A: Array<Item = u8>> AsMut<str> for SmallString<A>
        {
            #[inline] fn as_mut(&mut self) -> &mut str
            {
                self
            }
        }

        impl<A: Array<Item = u8>> Borrow<str> for SmallString<A>
        {
            #[inline] fn borrow(&self) -> &str
            {
                self
            }
        }

        impl<A: Array<Item = u8>> BorrowMut<str> for SmallString<A>
        {
            #[inline] fn borrow_mut(&mut self) -> &mut str
            {
                self
            }
        }

        impl<A: Array<Item = u8>> AsRef<[u8]> for SmallString<A>
        {
            #[inline] fn as_ref(&self) -> &[u8]
            {
                self.data.as_ref()
            }
        }

        impl<A: Array<Item = u8>> fmt::Write for SmallString<A>
        {
            #[inline] fn write_str(&mut self, s: &str) -> fmt::Result
            {
                self.push_str(s);
                Ok(())
            }

            #[inline] fn write_char(&mut self, ch: char) -> fmt::Result
            {
                self.push(ch);
                Ok(())
            }
        }
        

        impl<A: Array<Item = u8>> From<char> for SmallString<A> 
        {
            #[inline] fn from(ch: char) -> SmallString<A>
            {
                SmallString::from_str(ch.encode_utf8(&mut [0; 4]))
            }
        }

        impl<'a, A: Array<Item = u8>> From<&'a str> for SmallString<A>
        {
            #[inline] fn from(s: &str) -> SmallString<A>
            {
                SmallString::from_str(s)
            }
        }

        impl<A: Array<Item = u8>> From<Box<str>> for SmallString<A>
        {
            #[inline] fn from(s: Box<str>) -> SmallString<A>
            {
                SmallString::from_string(s.into())
            }
        }

        impl<A: Array<Item = u8>> From<String> for SmallString<A>
        {
            #[inline] fn from(s: String) -> SmallString<A>
            {
                SmallString::from_string(s)
            }
        }

        impl<'a, A: Array<Item = u8>> From<Cow<'a, str>> for SmallString<A>
        {
            fn from(value: Cow<'a, str>) -> Self
            {
                match value
                {
                    Cow::Borrowed(s) => Self::from_str(s),
                    Cow::Owned(s) => Self::from_string(s),
                }
            }
        }

        macro_rules! impl_index_str
        {
            ($index_type: ty) =>
            {
                impl<A: Array<Item = u8>> ops::Index<$index_type> for SmallString<A>
                {
                    type Output = str;

                    #[inline] fn index(&self, index: $index_type) -> &str
                    {
                        &self.as_str()[index]
                    }
                }

                impl<A: Array<Item = u8>> ops::IndexMut<$index_type> for SmallString<A>
                {
                    #[inline] fn index_mut(&mut self, index: $index_type) -> &mut str
                    {
                        &mut self.as_mut_str()[index]
                    }
                }
            };
        }

        impl_index_str!(ops::Range<usize>);
        impl_index_str!(ops::RangeFrom<usize>);
        impl_index_str!(ops::RangeTo<usize>);
        impl_index_str!(ops::RangeFull);

        impl<A: Array<Item = u8>> FromIterator<char> for SmallString<A>
        {
            fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> SmallString<A>
            {
                let mut s = SmallString::new();
                s.extend(iter);
                s
            }
        }

        impl<'a, A: Array<Item = u8>> FromIterator<&'a char> for SmallString<A>
        {
            fn from_iter<I: IntoIterator<Item = &'a char>>(iter: I) -> SmallString<A>
            {
                let mut s = SmallString::new();
                s.extend(iter.into_iter().cloned());
                s
            }
        }

        impl<'a, A: Array<Item = u8>> FromIterator<Cow<'a, str>> for SmallString<A>
        {
            fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> SmallString<A>
            {
                let mut s = SmallString::new();
                s.extend(iter);
                s
            }
        }

        impl<'a, A: Array<Item = u8>> FromIterator<&'a str> for SmallString<A>
        {
            fn from_iter<I: IntoIterator<Item = &'a str>>(iter: I) -> SmallString<A>
            {
                let mut s = SmallString::new();
                s.extend(iter);
                s
            }
        }

        impl<A: Array<Item = u8>> FromIterator<String> for SmallString<A>
        {
            fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> SmallString<A>
            {
                let mut s = SmallString::new();
                s.extend(iter);
                s
            }
        }

        impl<A: Array<Item = u8>> Extend<char> for SmallString<A>
        {
            fn extend<I: IntoIterator<Item = char>>(&mut self, iter: I)
            {
                let iter = iter.into_iter();
                let (lo, _) = iter.size_hint();

                self.reserve(lo);

                for ch in iter
                {
                    self.push(ch);
                }
            }
        }

        impl<'a, A: Array<Item = u8>> Extend<&'a char> for SmallString<A>
        {
            fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I)
            {
                self.extend(iter.into_iter().cloned());
            }
        }

        impl<'a, A: Array<Item = u8>> Extend<Cow<'a, str>> for SmallString<A>
        {
            fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I)
            {
                for s in iter
                {
                    self.push_str(&s);
                }
            }
        }

        impl<'a, A: Array<Item = u8>> Extend<&'a str> for SmallString<A>
        {
            fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I)
            {
                for s in iter
                {
                    self.push_str(s);
                }
            }
        }

        impl<A: Array<Item = u8>> Extend<String> for SmallString<A>
        {
            fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I)
            {
                for s in iter
                {
                    self.push_str(&s);
                }
            }
        }

        impl<A: Array<Item = u8>> fmt::Debug for SmallString<A>
        {
            #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                fmt::Debug::fmt(&**self, f)
            }
        }

        impl<A: Array<Item = u8>> fmt::Display for SmallString<A>
        {
            #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                fmt::Display::fmt(&**self, f)
            }
        }

        macro_rules! eq_str
        {
            ( $rhs:ty ) =>
            {
                impl<'a, A: Array<Item = u8>> PartialEq<$rhs> for SmallString<A>
                {
                    #[inline] fn eq(&self, rhs: &$rhs) -> bool
                    {
                        &self[..] == &rhs[..]
                    }

                    #[inline] fn ne(&self, rhs: &$rhs) -> bool
                    {
                        &self[..] != &rhs[..]
                    }
                }
            };
        }

        eq_str!(str);
        eq_str!(&'a str);
        eq_str!(String);
        eq_str!(Cow<'a, str>);
        
        impl<A: Array<Item = u8>> PartialEq<OsStr> for SmallString<A>
        {
            #[inline] fn eq(&self, rhs: &OsStr) -> bool
            {
                &self[..] == rhs
            }

            #[inline] fn ne(&self, rhs: &OsStr) -> bool 
            {
                &self[..] != rhs
            }
        }
        
        impl<'a, A: Array<Item = u8>> PartialEq<&'a OsStr> for SmallString<A> 
        {
            #[inline] fn eq(&self, rhs: &&OsStr) -> bool 
            {
                &self[..] == *rhs
            }

            #[inline] fn ne(&self, rhs: &&OsStr) -> bool
            {
                &self[..] != *rhs
            }
        }
        
        impl<A: Array<Item = u8>> PartialEq<OsString> for SmallString<A>
        {
            #[inline] fn eq(&self, rhs: &OsString) -> bool
            {
                &self[..] == rhs
            }

            #[inline] fn ne(&self, rhs: &OsString) -> bool
            {
                &self[..] != rhs
            }
        }
        
        impl<'a, A: Array<Item = u8>> PartialEq<Cow<'a, OsStr>> for SmallString<A>
        {
            #[inline] fn eq(&self, rhs: &Cow<OsStr>) -> bool
            {
                self[..] == **rhs
            }

            #[inline] fn ne(&self, rhs: &Cow<OsStr>) -> bool
            {
                self[..] != **rhs
            }
        }

        impl<A, B> PartialEq<SmallString<B>> for SmallString<A> where
        A: Array<Item = u8>,
        B: Array<Item = u8>,
        {
            #[inline] fn eq(&self, rhs: &SmallString<B>) -> bool
            {
                &self[..] == &rhs[..]
            }

            #[inline] fn ne(&self, rhs: &SmallString<B>) -> bool
            {
                &self[..] != &rhs[..]
            }
        }

        impl<A: Array<Item = u8>> Eq for SmallString<A> {}

        impl<A: Array<Item = u8>> PartialOrd for SmallString<A>
        {
            #[inline] fn partial_cmp(&self, rhs: &SmallString<A>) -> Option<Ordering>
            {
                self[..].partial_cmp(&rhs[..])
            }
        }

        impl<A: Array<Item = u8>> Ord for SmallString<A>
        {
            #[inline] fn cmp(&self, rhs: &SmallString<A>) -> Ordering
            {
                self[..].cmp(&rhs[..])
            }
        }

        impl<A: Array<Item = u8>> Hash for SmallString<A>
        {
            #[inline] fn hash<H: Hasher>(&self, state: &mut H)
            {
                self[..].hash(state)
            }
        }

        /// A draining iterator for `SmallString`.
        pub struct Drain<'a> 
        {
            iter: Chars<'a>,
        }

        impl<'a> Iterator for Drain<'a> 
        {
            type Item = char;

            #[inline] fn next(&mut self) -> Option<char>
            {
                self.iter.next()
            }

            #[inline] fn size_hint(&self) -> (usize, Option<usize>)
            {
                self.iter.size_hint()
            }
        }

        impl<'a> DoubleEndedIterator for Drain<'a>
        {
            #[inline] fn next_back(&mut self) -> Option<char>
            {
                self.iter.next_back()
            }
        }

        /// A possible error value when creating a `SmallString` from a byte array.
        #[derive(Debug)]
        pub struct FromUtf8Error<A: Array<Item = u8>>
        {
            buf: A,
            error: Utf8Error,
        }

        impl<A: Array<Item = u8>> FromUtf8Error<A>
        {
            /// Returns the slice of `[u8]` bytes that were attempted to convert to a `SmallString`.
            #[inline] pub fn as_bytes(&self) -> &[u8]
            {
                let ptr = &self.buf as *const _ as *const u8;
                unsafe { slice::from_raw_parts(ptr, A::size()) }
            }

            /// Returns the byte array that was attempted to convert into a `SmallString`.
            #[inline] pub fn into_buf(self) -> A
            {
                self.buf
            }

            /// Returns the `Utf8Error` to get more details about the conversion failure.
            #[inline] pub fn utf8_error(&self) -> Utf8Error
            {
                self.error
            }
        }

        impl<A: Array<Item = u8>> fmt::Display for FromUtf8Error<A>
        {
            #[inline] fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                fmt::Display::fmt(&self.error, f)
            }
        }
    }
}
/*
Cross-platform terminal interface */
pub mod mortal
{
    //! Platform-independent terminal interface
    //#[macro_use] extern crate bitflags;
    //extern crate smallstr;
    extern crate unicode_normalization;
    extern crate unicode_width;

    extern crate libc;
    extern crate nix;
    //extern crate terminfo;

    pub use self::screen::{Screen, ScreenReadGuard, ScreenWriteGuard};
    pub use self::sequence::{FindResult, SequenceMap};
    pub use self::signal::{Signal, SignalSet};
    pub use self::terminal::
    {
        Color, Cursor, CursorMode, Size, Style, Theme,
        Event, Key, MouseEvent, MouseInput, MouseButton, ModifierState,
        PrepareConfig, PrepareState,
        Terminal, TerminalReadGuard, TerminalWriteGuard,
    };

    #[macro_use] mod buffer
    {
        use std::mem::swap;
        use std::ops::Range;

        use smallstr::SmallString;

        use super::priv_util::is_visible;
        use super::terminal::{Color, Cursor, Size, Style, Theme};
        use super::util::{char_width, is_combining_mark};

        const TAB_STOP: usize = 8;
        
        // Generates buffer methods forwarded to a buffer contained in self.
        macro_rules! forward_screen_buffer_methods 
        {
            ( |$slf:ident| $field:expr ) => {
                pub fn size(&self) -> crate::terminal::Size {
                    let $slf = self;
                    $field.size()
                }

                pub fn cursor(&self) -> crate::terminal::Cursor {
                    let $slf = self;
                    $field.cursor()
                }

                pub fn set_cursor(&self, pos: crate::terminal::Cursor) {
                    let $slf = self;
                    $field.set_cursor(pos);
                }

                pub fn next_line(&self, column: usize) {
                    let $slf = self;
                    $field.next_line(column);
                }

                pub fn clear_screen(&self) {
                    let $slf = self;
                    $field.clear_screen();
                }

                pub fn clear_attributes(&self) {
                    let $slf = self;
                    $field.clear_attributes();
                }

                pub fn add_style(&self, style: crate::terminal::Style) {
                    let $slf = self;
                    $field.add_style(style);
                }

                pub fn remove_style(&self, style: crate::terminal::Style) {
                    let $slf = self;
                    $field.remove_style(style);
                }

                pub fn set_style(&self, style: crate::terminal::Style) {
                    let $slf = self;
                    $field.set_style(style);
                }

                pub fn set_fg(&self, fg: Option<crate::terminal::Color>) {
                    let $slf = self;
                    $field.set_fg(fg);
                }

                pub fn set_bg(&self, bg: Option<crate::terminal::Color>) {
                    let $slf = self;
                    $field.set_bg(bg);
                }

                pub fn set_theme(&self, theme: crate::terminal::Theme) {
                    let $slf = self;
                    $field.set_theme(theme)
                }

                pub fn write_char(&self, ch: char) {
                    let $slf = self;
                    let _ = $field.write_char(ch);
                }

                pub fn write_str(&self, s: &str) {
                    let $slf = self;
                    let _ = $field.write_str(s);
                }

                pub fn write_at(&self, pos: crate::terminal::Cursor, text: &str) {
                    let $slf = self;
                    let _ = $field.write_at(pos, text);
                }

                pub fn write_styled(&self,
                        fg: Option<crate::terminal::Color>, bg: Option<crate::terminal::Color>,
                        style: crate::terminal::Style, text: &str) {
                    let $slf = self;
                    let _ = $field.write_styled(fg, bg, style, text);
                }

                pub fn write_styled_at(&self, pos: crate::terminal::Cursor,
                        fg: Option<crate::terminal::Color>, bg: Option<crate::terminal::Color>,
                        style: crate::terminal::Style, text: &str) {
                    let $slf = self;
                    let _ = $field.write_styled_at(pos, fg, bg, style, text);
                }
            }
        }

        pub struct ScreenBuffer 
        {
            buffer: Vec<Cell>,
            back_buffer: Vec<Cell>,
            size: Size,
            cursor: Cursor,

            fg: Option<Color>,
            bg: Option<Color>,
            style: Style,
        }

        impl ScreenBuffer
        {
            pub fn new(size: Size) -> ScreenBuffer {
                let area = size.area();

                ScreenBuffer{
                    buffer: vec![Cell::default(); area],
                    back_buffer: vec![Cell::default(); area],
                    size: size,
                    cursor: Cursor::default(),

                    fg: None,
                    bg: None,
                    style: Style::empty(),
                }
            }

            pub fn cursor(&self) -> Cursor {
                self.cursor
            }

            pub fn size(&self) -> Size {
                self.size
            }

            pub fn resize(&mut self, new_size: Size) {
                // Try our best to maintain the contents of the buffer;
                // though it's really best if users redraw when Resize event is read.
                resize_buffer(&mut self.buffer, self.size, new_size);
                // Totally invalidate the back buffer.
                // Screen implementations will clear the screen and redraw.
                new_buffer(&mut self.back_buffer, new_size);
                self.size = new_size;
            }

            pub fn set_cursor(&mut self, pos: Cursor) {
                self.cursor = pos;
            }

            pub fn next_line(&mut self, column: usize) {
                self.cursor.line += 1;
                self.cursor.column = column;
            }

            pub fn clear_attributes(&mut self) {
                self.fg = None;
                self.bg = None;
                self.style = Style::empty();
            }

            pub fn add_style(&mut self, style: Style) {
                self.style |= style;
            }

            pub fn remove_style(&mut self, style: Style) {
                self.style -= style;
            }

            pub fn set_style(&mut self, style: Style) {
                self.style = style;
            }

            pub fn set_fg(&mut self, fg: Option<Color>) {
                self.fg = fg;
            }

            pub fn set_bg(&mut self, bg: Option<Color>) {
                self.bg = bg;
            }

            pub fn set_theme(&mut self, theme: Theme) {
                self.set_fg(theme.fg);
                self.set_bg(theme.bg);
                self.set_style(theme.style);
            }

            pub fn clear_screen(&mut self) {
                for cell in &mut self.buffer {
                    *cell = Cell::default();
                }
            }

            pub fn indices(&self) -> Range<usize> {
                0..self.size.area()
            }

            // A wrapper type implementing Iterator would be ideal, but that would
            // interefere with Screen implementations calling `&mut self` methods.
            pub fn next_cell(&mut self, indices: &mut Range<usize>) -> Option<(Cursor, Cell)> {
                while let Some(idx) = indices.next() {
                    let first = self.buffer[idx].first_char();
                    let width = char_width(first).unwrap_or(0);

                    // Skip cells overlapped by wide characters
                    if width == 2 {
                        let _ = indices.next();
                    }

                    if self.buffer[idx] != self.back_buffer[idx] {
                        let cell = self.buffer[idx].clone();

                        let line = idx / self.size.columns;
                        let column = idx % self.size.columns;

                        self.back_buffer[idx] = cell.clone();

                        return Some((Cursor{line, column}, cell));
                    }
                }

                None
            }

            #[cfg(test)]
            fn cell(&self, pos: Cursor) -> &Cell {
                &self.buffer[pos.as_index(self.size)]
            }

            fn cell_mut(&mut self, pos: Cursor) -> &mut Cell {
                let size = self.size;
                &mut self.buffer[pos.as_index(size)]
            }

            fn set_cell(&mut self, pos: Cursor, ch: char) {
                let fg = self.fg;
                let bg = self.bg;
                let style = self.style;

                let cell = self.cell_mut(pos);

                cell.fg = fg;
                cell.bg = bg;
                cell.style = style;
                cell.text = ch.into();
            }

            pub fn write_char(&mut self, ch: char) -> Result<(), OutOfBounds> {
                if ch == '\t' {
                    self.try_cursor()?;
                    let rem = self.size.columns - self.cursor.column;
                    let n = rem.min(TAB_STOP - (self.cursor.column % TAB_STOP));

                    for _ in 0..n {
                        self.write_char(' ')?;
                    }
                } else if ch == '\r' {
                    self.cursor.column = 0;
                } else if ch == '\n' {
                    self.cursor.line += 1;
                    self.cursor.column = 0;
                } else if is_combining_mark(ch) {
                    if let Some(prev) = self.cursor.previous(self.size) {
                        self.try_cursor_at(prev)?;
                        self.cell_mut(prev).text.push(ch);
                    }
                } else if is_visible(ch) {
                    self.try_cursor()?;

                    if let Some(prev) = self.cursor.previous(self.size) {
                        let cell = self.cell_mut(prev);

                        if cell.is_wide() {
                            *cell = Cell::default();
                        }
                    }

                    let rem = self.size.columns - self.cursor.column;
                    let width = char_width(ch).unwrap_or(0);

                    // If insufficient space exists on the current line,
                    // fill it with spaces and write the char on the next line.
                    if rem < width {
                        self.try_cursor()?;
                        let mut pos = self.cursor;

                        for _ in 0..rem {
                            self.set_cell(pos, ch);
                            pos.column += 1;
                        }

                        self.cursor.column = 0;
                        self.cursor.line += 1;
                    }

                    self.try_cursor()?;

                    let mut pos = self.cursor;
                    self.set_cell(pos, ch);

                    for _ in 1..width {
                        pos.column += 1;
                        self.set_cell(pos, ' ');
                    }

                    self.cursor.column += width;

                    if self.cursor.column >= self.size.columns {
                        self.cursor.line += 1;
                        self.cursor.column = 0;
                    }
                }

                Ok(())
            }

            pub fn write_str(&mut self, s: &str) -> Result<(), OutOfBounds> {
                for ch in s.chars() {
                    self.write_char(ch)?;
                }

                Ok(())
            }

            pub fn write_at(&mut self, pos: Cursor, text: &str) -> Result<(), OutOfBounds> {
                self.try_cursor_at(pos)?;
                self.cursor = pos;

                self.write_str(text)
            }

            pub fn write_styled(&mut self,
                    fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                    -> Result<(), OutOfBounds> {
                self.fg = fg;
                self.bg = bg;
                self.style = style;

                self.write_str(text)?;
                self.clear_attributes();

                Ok(())
            }

            pub fn write_styled_at(&mut self, pos: Cursor,
                    fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                    -> Result<(), OutOfBounds> {
                self.try_cursor_at(pos)?;
                self.cursor = pos;

                self.write_styled(fg, bg, style, text)
            }

            fn try_cursor(&self) -> Result<(), OutOfBounds> {
                self.try_cursor_at(self.cursor)
            }

            fn try_cursor_at(&self, pos: Cursor) -> Result<(), OutOfBounds> {
                if pos.line >= self.size.lines || pos.column >= self.size.columns {
                    Err(OutOfBounds(()))
                } else {
                    Ok(())
                }
            }
        }

        // Same as above, but methods take `&mut self` where appropriate.
        macro_rules! forward_screen_buffer_mut_methods
        {
            ( |$slf:ident| $field:expr ) => {
                pub fn size(&self) -> crate::terminal::Size {
                    let $slf = self;
                    $field.size()
                }

                pub fn cursor(&self) -> crate::terminal::Cursor {
                    let $slf = self;
                    $field.cursor()
                }

                pub fn set_cursor(&mut self, pos: crate::terminal::Cursor) {
                    let $slf = self;
                    $field.set_cursor(pos);
                }

                pub fn next_line(&mut self, column: usize) {
                    let $slf = self;
                    $field.next_line(column);
                }

                pub fn clear_screen(&mut self) {
                    let $slf = self;
                    $field.clear_screen();
                }

                pub fn clear_attributes(&mut self) {
                    let $slf = self;
                    $field.clear_attributes();
                }

                pub fn add_style(&mut self, style: crate::terminal::Style) {
                    let $slf = self;
                    $field.add_style(style);
                }

                pub fn remove_style(&mut self, style: crate::terminal::Style) {
                    let $slf = self;
                    $field.remove_style(style);
                }

                pub fn set_style(&mut self, style: crate::terminal::Style) {
                    let $slf = self;
                    $field.set_style(style);
                }

                pub fn set_fg(&mut self, fg: Option<crate::terminal::Color>) {
                    let $slf = self;
                    $field.set_fg(fg);
                }

                pub fn set_bg(&mut self, bg: Option<crate::terminal::Color>) {
                    let $slf = self;
                    $field.set_bg(bg);
                }

                pub fn set_theme(&mut self, theme: crate::terminal::Theme) {
                    let $slf = self;
                    $field.set_theme(theme);
                }

                pub fn write_char(&mut self, ch: char) {
                    let $slf = self;
                    let _ = $field.write_char(ch);
                }

                pub fn write_str(&mut self, s: &str) {
                    let $slf = self;
                    let _ = $field.write_str(s);
                }

                pub fn write_at(&mut self, pos: crate::terminal::Cursor, text: &str) {
                    let $slf = self;
                    let _ = $field.write_at(pos, text);
                }

                pub fn write_styled(&mut self,
                        fg: Option<crate::terminal::Color>, bg: Option<crate::terminal::Color>,
                        style: crate::terminal::Style, text: &str) {
                    let $slf = self;
                    let _ = $field.write_styled(fg, bg, style, text);
                }

                pub fn write_styled_at(&mut self, pos: crate::terminal::Cursor,
                        fg: Option<crate::terminal::Color>, bg: Option<crate::terminal::Color>,
                        style: crate::terminal::Style, text: &str) {
                    let $slf = self;
                    let _ = $field.write_styled_at(pos, fg, bg, style, text);
                }
            }
        }

        #[derive(Debug)]
        pub struct OutOfBounds(());

        #[derive(Clone, Debug, Eq, PartialEq)]
        pub struct Cell 
        {
            fg: Option<Color>,
            bg: Option<Color>,
            style: Style,
            text: SmallString<[u8; 8]>,
        }

        impl Cell 
        {
            fn new(fg: Option<Color>, bg: Option<Color>, style: Style, chr: char) -> Cell {
                Cell{
                    fg,
                    bg,
                    style,
                    text: chr.into(),
                }
            }

            fn invalid() -> Cell {
                Cell{
                    fg: None,
                    bg: None,
                    style: Style::empty(),
                    text: SmallString::new(),
                }
            }

            pub fn attrs(&self) -> (Option<Color>, Option<Color>, Style) {
                (self.fg, self.bg, self.style)
            }

            pub fn text(&self) -> &str {
                &self.text
            }

            fn first_char(&self) -> char {
                self.text.chars().next().expect("empty cell text")
            }

            fn is_wide(&self) -> bool {
                self.text.chars().next()
                    .and_then(char_width).unwrap_or(0) == 2
            }
        }

        impl Default for Cell 
        {
            fn default() -> Cell 
            { Cell::new(None, None, Style::empty(), ' ') }
        }

        fn resize_buffer(buf: &mut Vec<Cell>, old: Size, new: Size)
        {
            if old != new {
                let mut new_buf = vec![Cell::default(); new.area()];

                if !buf.is_empty() {
                    let n_cols = old.columns.min(new.columns);

                    for (old, new) in buf.chunks_mut(old.columns)
                            .zip(new_buf.chunks_mut(new.columns)) {
                        for i in 0..n_cols {
                            swap(&mut new[i], &mut old[i]);
                        }
                    }
                }

                *buf = new_buf;
            }
        }

        fn new_buffer(buf: &mut Vec<Cell>, new_size: Size)
        {
            // Invalidate the buffer; all cells will be redrawn
            *buf = vec![Cell::invalid(); new_size.area()];
        }
    }
    
    #[macro_use] pub mod macros
    {
        //! Provides macros easier printing with colors and styles.

        use std::io;

        /// Writes attributes and formatted text to a `Terminal` or `Screen`.
        #[macro_export] macro_rules! term_write
        {
            // Entry rule
            ( $term:expr , $first:tt $($rest:tt)* ) => 
            {
                match $term.borrow_term_write_guard() {
                    mut term => {
                        let init = $crate::macros::Chain::init();
                        term_write!(@_INTERNAL main: term ; init ; $first $($rest)*)
                    }
                }
            };

            // Final rule
            ( @_INTERNAL main: $term:expr ; $result:expr ; ) => 
            {
                $result
            };

            // Color/style rules
            ( @_INTERNAL main: $term:expr ; $result:expr ; [ $($tt:tt)* ] $($rest:tt)* ) => 
            {
                term_write!
                (
                    @_INTERNAL main: $term;
                    term_write!(@_INTERNAL style: $term; $result; $($tt)*);
                    $($rest)*
                )
            };

            // Formatting rules
            ( @_INTERNAL main: $term:expr ; $result:expr ; ( $($tt:tt)* ) $($rest:tt)* ) =>
            {
                term_write!(
                    @_INTERNAL main: $term;
                    term_write!(@_INTERNAL format: $term; $result; $($tt)*);
                    $($rest)*
                )
            };

            ( @_INTERNAL main: $term:expr ; $result:expr ; $tt:tt $($rest:tt)* ) => 
            {
                term_write!(
                    @_INTERNAL main: $term;
                    term_write!(@_INTERNAL literal: $term; $result; $tt);
                    $($rest)*
                )
            };

            // Set foreground color
            ( @_INTERNAL style: $term:expr ; $result:expr ; black ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Black))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; blue ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Blue))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; cyan ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Cyan))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; green ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Green))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; magenta ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Magenta))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; red ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Red))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; white ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::White))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; yellow ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($crate::Color::Yellow))
            };

            // Set background color
            ( @_INTERNAL style: $term:expr ; $result:expr ; # black ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Black))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; # blue ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Blue))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; # cyan ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Cyan))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; # green ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Green))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; # magenta ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Magenta))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; # red ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Red))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; # white ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::White))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; # yellow ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($crate::Color::Yellow))
            };

            // Add style
            ( @_INTERNAL style: $term:expr ; $result:expr ; bold ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.add_style($crate::Style::BOLD))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; italic ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.add_style($crate::Style::ITALIC))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; reverse ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.add_style($crate::Style::REVERSE))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; underline ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.add_style($crate::Style::UNDERLINE))
            };

            // Remove style
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! bold ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.remove_style($crate::Style::BOLD))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; ! italic ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.remove_style($crate::Style::ITALIC))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; ! reverse ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.remove_style($crate::Style::REVERSE))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; ! underline ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.remove_style($crate::Style::UNDERLINE))
            };

            // Clear attributes
            ( @_INTERNAL style: $term:expr ; $result:expr ; reset ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.clear_attributes())
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; ! fg ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg(None))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; ! bg ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg(None))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; ! style ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_style(None))
            };

            // Color/style expressions
            ( @_INTERNAL style: $term:expr ; $result:expr ; fg = $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_fg($e))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; bg = $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_bg($e))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; style = $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_style($e))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; style += $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.add_style($e))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; style -= $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.remove_style($e))
            };

            ( @_INTERNAL style: $term:expr ; $result:expr ; theme = $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.set_theme($e))
            };

            // std::fmt formatting
            ( @_INTERNAL format: $term:expr ; $result:expr ; : $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || write!($term, "{}", $e))
            };

            ( @_INTERNAL format: $term:expr ; $result:expr ; ? $e:expr ) => {
                $crate::macros::Chain::chain(
                    $result, || write!($term, "{:?}", $e))
            };

            ( @_INTERNAL format: $term:expr ; $result:expr ; $($tt:tt)* ) => {
                $crate::macros::Chain::chain(
                    $result, || write!($term, $($tt)*))
            };

            // Literal formatting
            ( @_INTERNAL literal: $term:expr ; $result:expr ; $lit:tt ) => {
                $crate::macros::Chain::chain(
                    $result, || $term.write_str(concat!($lit)))
            };
        }

        /// Writes attributes and formatted text to a `Terminal` or `Screen`.
        #[macro_export] macro_rules! term_writeln 
        {
            ( $term:expr ) => {
                term_write!($term, "\n")
            };
            ( $term:expr , $($tt:tt)* ) => {
                term_write!($term, $($tt)* "\n")
            };
        }

        // Facilitates chaining calls from either a `Terminal` or `Screen` lock.
        #[doc(hidden)] pub trait Chain: Sized 
        {
            fn chain<F: FnOnce() -> Self>(self, f: F) -> Self;
            fn init() -> Self;
        }

        impl Chain for () 
        {
            fn chain<F: FnOnce() -> Self>(self, f: F) -> Self 
            {
                f()
            }

            fn init() -> Self { }
        }

        impl Chain for io::Result<()>
        {
            fn chain<F: FnOnce() -> Self>(self, f: F) -> Self {
                self.and_then(|_| f())
            }

            fn init() -> Self { Ok(()) }
        }
    }
    
    mod priv_util
    {
        use ::sync::{LockResult, PoisonError, TryLockError, TryLockResult};
        use ::mortal::screen::{Screen, ScreenReadGuard};
        use ::mortal::terminal::{Terminal, TerminalReadGuard};
        use ::mortal::util::char_width;

        // Private trait used to prevent external crates from implementing extension traits
        pub trait Private {}

        impl Private for Screen {}
        impl<'a> Private for ScreenReadGuard<'a> {}
        impl Private for Terminal {}
        impl<'a> Private for TerminalReadGuard<'a> {}

        pub fn is_visible(ch: char) -> bool {
            match ch {
                '\t' | '\r' | '\n' => true,
                _ => char_width(ch).unwrap_or(0) != 0
            }
        }

        pub fn map_lock_result<F, T, U>(res: LockResult<T>, f: F) -> LockResult<U>
                where F: FnOnce(T) -> U {
            match res {
                Ok(t) => Ok(f(t)),
                Err(e) => Err(PoisonError::new(f(e.into_inner()))),
            }
        }

        pub fn map_try_lock_result<F, T, U>(res: TryLockResult<T>, f: F) -> TryLockResult<U>
                where F: FnOnce(T) -> U {
            match res {
                Ok(t) => Ok(f(t)),
                Err(TryLockError::Poisoned(p)) => Err(TryLockError::Poisoned(
                    PoisonError::new(f(p.into_inner())))),
                Err(TryLockError::WouldBlock) => Err(TryLockError::WouldBlock),
            }
        }

        pub fn map2_lock_result<F, T, U, R>(res: LockResult<T>, res2: LockResult<U>, f: F)
                -> LockResult<R> where F: FnOnce(T, U) -> R {
            match (res, res2) {
                (Ok(a), Ok(b)) => Ok(f(a, b)),
                (Ok(a), Err(b)) => Err(PoisonError::new(f(a, b.into_inner()))),
                (Err(a), Ok(b)) => Err(PoisonError::new(f(a.into_inner(), b))),
                (Err(a), Err(b)) => Err(PoisonError::new(f(a.into_inner(), b.into_inner()))),
            }
        }

        pub fn map2_try_lock_result<F, T, U, R>(
                res: TryLockResult<T>, res2: TryLockResult<U>, f: F)
                -> TryLockResult<R> where F: FnOnce(T, U) -> R {
            match (res, res2) {
                (Ok(a), Ok(b)) => Ok(f(a, b)),
                (Err(TryLockError::WouldBlock), _) => Err(TryLockError::WouldBlock),
                (_, Err(TryLockError::WouldBlock)) => Err(TryLockError::WouldBlock),
                (Ok(a), Err(TryLockError::Poisoned(b))) =>
                    Err(TryLockError::Poisoned(PoisonError::new(f(a, b.into_inner())))),
                (Err(TryLockError::Poisoned(a)), Ok(b)) =>
                    Err(TryLockError::Poisoned(PoisonError::new(f(a.into_inner(), b)))),
                (Err(TryLockError::Poisoned(a)), Err(TryLockError::Poisoned(b))) =>
                    Err(TryLockError::Poisoned(PoisonError::new(
                        f(a.into_inner(), b.into_inner())))),
            }
        }
    }

    pub mod screen
    {
        //! Provides a drawable buffer on terminal devices

        use std::fmt;
        use std::io;
        use std::sync::{LockResult, TryLockResult};
        use std::time::Duration;

        use ::mortal::
        {
            priv_util::{ map_lock_result, map_try_lock_result },
            sys,
            terminal::
            {
                Color, Cursor, CursorMode, Event, PrepareConfig, Size, Style, Theme,
                Terminal,
            },
        };
        
        /// Provides operations on an underlying terminal device in screen mode.
        pub struct Screen(sys::Screen);

        /// Holds an exclusive lock for read operations on a `Screen`.
        pub struct ScreenReadGuard<'a>(sys::ScreenReadGuard<'a>);

        /// Holds an exclusive lock for write operations on a `Screen`
        pub struct ScreenWriteGuard<'a>(sys::ScreenWriteGuard<'a>);

        impl Screen 
        {
            /// Opens a new screen interface on `stdout`.
            pub fn new(config: PrepareConfig) -> io::Result<Screen> 
            {
                sys::Screen::stdout(config).map(Screen)
            }

            /// Opens a new screen interface on `stderr`.
            pub fn stderr(config: PrepareConfig) -> io::Result<Screen>
            {
                sys::Screen::stderr(config).map(Screen)
            }

            /// Begins a new screen session using the given `Terminal` instance.
            pub fn with_terminal(term: Terminal, config: PrepareConfig) -> io::Result<Screen>
            {
                sys::Screen::new(term.0, config).map(Screen)
            }

            /// Returns the name of the terminal.
            #[inline] pub fn name(&self) -> &str 
            {
                self.0.name()
            }

            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn lock_read(&self) -> LockResult<ScreenReadGuard>
            {
                map_lock_result(self.0.lock_read(), ScreenReadGuard)
            }

            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn lock_write(&self) -> LockResult<ScreenWriteGuard>
            {
                map_lock_result(self.0.lock_write(), ScreenWriteGuard)
            }

            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> 
            {
                map_try_lock_result(self.0.try_lock_read(), ScreenReadGuard)
            }

            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard>
            {
                map_try_lock_result(self.0.try_lock_write(), ScreenWriteGuard)
            }
        }

        /// # Locking
        ///
        /// The following methods internally acquire the read lock.
        impl Screen 
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> 
            {
                self.0.wait_event(timeout)
            }

            /// Reads an event from the terminal.
            pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>>  
            {
                self.0.read_event(timeout)
            }
        }

        /// # Locking
        ///
        /// The following methods internally acquire the write lock.
        impl Screen 
        {
            /// Returns the current size of the terminal screen.
            #[inline] pub fn size(&self) -> Size 
            {
                self.0.size()
            }

            /// Returns the current cursor position.
            #[inline] pub fn cursor(&self) -> Cursor
            {
                self.0.cursor()
            }

            /// Sets the cursor position.
            #[inline] pub fn set_cursor<C: Into<Cursor>>(&self, pos: C) 
            {
                self.0.set_cursor(pos.into());
            }

            /// Moves the cursor to the given column on the next line.
            #[inline] pub fn next_line(&self, column: usize)
            {
                self.0.next_line(column);
            }

            /// Set the current cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()>
            {
                self.0.set_cursor_mode(mode)
            }

            /// Clears the internal screen buffer.
            pub fn clear_screen(&self) 
            {
                self.0.clear_screen();
            }

            /// Adds a set of `Style` flags to the current style setting.
            #[inline] pub fn add_style(&self, style: Style)
            {
                self.0.add_style(style);
            }

            /// Removes a set of `Style` flags to the current style setting.
            #[inline] pub fn remove_style(&self, style: Style)
            {
                self.0.remove_style(style);
            }

            /// Sets the current style setting to the given set of flags.
            #[inline] pub fn set_style<S: Into<Option<Style>>>(&self, style: S)
            {
                self.0.set_style(style.into().unwrap_or_default());
            }

            /// Sets or removes foreground text color.
            #[inline] pub fn set_fg<C: Into<Option<Color>>>(&self, fg: C)
            {
                self.0.set_fg(fg.into());
            }

            /// Sets or removes background text color.
            #[inline] pub fn set_bg<C: Into<Option<Color>>>(&self, bg: C)
            {
                self.0.set_bg(bg.into());
            }

            /// Sets all attributes for the screen.
            #[inline] pub fn set_theme(&self, theme: Theme)
            {
                self.0.set_theme(theme)
            }

            /// Removes color and style attributes.
            #[inline] pub fn clear_attributes(&self)
            {
                self.0.clear_attributes();
            }

            /// Adds bold to the current style setting.
            #[inline] pub fn bold(&self) 
            {
                self.add_style(Style::BOLD);
            }

            /// Adds italic to the current style setting.
            #[inline] pub fn italic(&self)
            {
                self.add_style(Style::ITALIC);
            }

            /// Adds underline to the current style setting.
            #[inline] pub fn underline(&self)
            {
                self.add_style(Style::UNDERLINE);
            }

            /// Adds reverse to the current style setting.
            #[inline] pub fn reverse(&self)
            {
                self.add_style(Style::REVERSE);
            }

            /// Renders the internal buffer to the terminal screen.
            pub fn refresh(&self) -> io::Result<()>
            {
                self.0.refresh()
            }

            /// Writes text at the given position within the screen buffer.
            pub fn write_at<C>(&self, position: C, text: &str) where 
            C: Into<Cursor> 
            {
                self.0.write_at(position.into(), text);
            }

            /// Writes text with the given attributes at the current cursor position.
            pub fn write_styled<F, B, S>(&self, fg: F, bg: B, style: S, text: &str) where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            {
                self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), text);
            }

            /// Writes text with the given attributes at the given position within the screen buffer.
            pub fn write_styled_at<C, F, B, S>(&self, position: C, fg: F, bg: B, style: S, text: &str) where
            C: Into<Cursor>,
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            {
                self.0.write_styled_at(position.into(), fg.into(), bg.into(), style.into().unwrap_or_default(), text);
            }

            /// Writes a single character at the cursor position using the current style and color settings.
            pub fn write_char(&self, ch: char)
            {
                self.0.write_char(ch);
            }

            /// Writes a string at the cursor position using the current style and color settings.
            pub fn write_str(&self, s: &str)
            {
                self.0.write_str(s);
            }

            /// Writes formatted text at the cursor position using the current style and color settings.
            pub fn write_fmt(&self, args: fmt::Arguments) 
            {
                let s = args.to_string();
                self.write_str(&s)
            }

            #[doc(hidden)]
            pub fn borrow_term_write_guard(&self) -> ScreenWriteGuard 
            {
                self.lock_write().unwrap()
            }
        }

        impl<'a> ScreenReadGuard<'a> 
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> 
            {
                self.0.wait_event(timeout)
            }

            /// Reads an event from the terminal.
            pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
            {
                self.0.read_event(timeout)
            }
        }

        impl<'a> ScreenWriteGuard<'a> 
        {
            /// Returns the current size of the terminal screen.
            #[inline] pub fn size(&self) -> Size 
            {
                self.0.size()
            }

            /// Sets the cursor position.
            #[inline] pub fn cursor(&self) -> Cursor
            {
                self.0.cursor()
            }

            /// Moves the cursor to the given column on the next line.
            #[inline] pub fn set_cursor<C: Into<Cursor>>(&mut self, pos: C)
            {
                self.0.set_cursor(pos.into());
            }

            /// Set the current cursor mode.
            #[inline] pub fn next_line(&mut self, column: usize)
            {
                self.0.next_line(column);
            }

            /// Set the current cursor mode.
            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> 
            {
                self.0.set_cursor_mode(mode)
            }

            /// Adds a set of `Style` flags to the current style setting.
            pub fn clear_screen(&mut self) 
            {
                self.0.clear_screen();
            }

            /// Removes a set of `Style` flags to the current style setting.
            #[inline] pub fn add_style(&mut self, style: Style)
            {
                self.0.add_style(style)
            }

            /// Sets the current style setting to the given set of flags.
            #[inline] pub fn remove_style(&mut self, style: Style)
            {
                self.0.remove_style(style)
            }

            /// Sets or removes foreground text color.
            #[inline] pub fn set_style<S: Into<Option<Style>>>(&mut self, style: S)
            {
                self.0.set_style(style.into().unwrap_or_default())
            }

            /// Sets or removes background text color.
            #[inline] pub fn set_fg<C: Into<Option<Color>>>(&mut self, fg: C)
            {
                self.0.set_fg(fg.into())
            }

            /// Removes color and style attributes.
            #[inline] pub fn set_bg<C: Into<Option<Color>>>(&mut self, bg: C)
            {
                self.0.set_bg(bg.into())
            }

            /// Sets all attributes for the screen.
            #[inline] pub fn set_theme(&mut self, theme: Theme)
            {
                self.0.set_theme(theme)
            }

            /// Adds bold to the current style setting.
            #[inline] pub fn clear_attributes(&mut self)
            {
                self.0.clear_attributes()
            }

            /// Adds bold to the current style setting.
            #[inline] pub fn bold(&mut self) 
            {
                self.add_style(Style::BOLD)
            }

            /// Adds italic to the current style setting.
            #[inline] pub fn italic(&mut self) 
            {
                self.add_style(Style::ITALIC);
            }

            /// Adds underline to the current style setting.
            #[inline] pub fn underline(&mut self) 
            {
                self.add_style(Style::UNDERLINE)
            }

            /// Adds reverse to the current style setting.
            #[inline] pub fn reverse(&mut self)
            {
                self.add_style(Style::REVERSE)
            }

            /// Renders the internal buffer to the terminal screen.
            pub fn refresh(&mut self) -> io::Result<()> 
            {
                self.0.refresh()
            }

            /// Writes text at the given position within the screen buffer.
            pub fn write_at<C>(&mut self, position: C, text: &str) where C: Into<Cursor>
            {
                self.0.write_at(position.into(), text)
            }

            /// Writes text with the given attributes at the current cursor position.
            pub fn write_styled<F, B, S>(&mut self, fg: F, bg: B, style: S, text: &str) where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            {
                self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), text)
            }

            /// Writes text with the given attributes at the given position within the screen buffer.
            pub fn write_styled_at<C, F, B, S>(&mut self, position: C, fg: F, bg: B, style: S, text: &str) where
            C: Into<Cursor>,
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            {
                self.0.write_styled_at(position.into(), fg.into(), bg.into(), style.into().unwrap_or_default(), text)
            }

            /// Writes a single character at the cursor position using the current style and color settings.
            pub fn write_char(&mut self, ch: char) 
            {
                self.0.write_char(ch)
            }

            /// Writes a string at the cursor position using the current style and color settings.
            pub fn write_str(&mut self, s: &str) 
            {
                self.0.write_str(s)
            }

            /// Writes formatted text at the cursor position using the current style and color settings.
            pub fn write_fmt(&mut self, args: fmt::Arguments) 
            {
                let s = args.to_string();
                self.write_str(&s)
            }

            #[doc(hidden)] pub fn borrow_term_write_guard(&mut self) -> &mut Self 
            {
                self
            }
        }
        
        impl ::linefeed::unix::TerminalExt for Screen 
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
            {
                self.0.read_raw(buf, timeout)
            }
        }
        
        impl<'a> ::linefeed::unix::TerminalExt for ScreenReadGuard<'a> 
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw(buf, timeout)
            }
        }
    }

    pub mod sequence
    {
        //! Utilities for manipulating raw input sequences

        use std::fmt;
        use std::iter::FromIterator;
        use std::mem::replace;

        /// Contains a set of string sequences, mapped to a value.
        #[derive(Clone, Debug, Default)]
        pub struct SequenceMap<K, V> {
            sequences: Vec<(K, V)>,
        }

        /// Represents the result of a `SequenceMap::find` operation.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum FindResult<V> {
            /// No contained sequences begin with the provided input sequence.
            NotFound,
            /// One or more sequences begin with the provided input sequence,
            /// but the sequence does not represent a complete sequence.
            Incomplete,
            /// A sequence was found exactly matching the input sequence;
            /// additionally, one or more sequences begin with the input sequence.
            Undecided(V),
            /// A sequence was found exactly matching the input sequence;
            /// no additional partially-matching sequences exist.
            Found(V),
        }

        impl<'a, V: Clone> FindResult<&'a V> {
            /// Maps `FindResult<&V>` to `FindResult<V>` by cloning the contents
            /// of the result value.
            pub fn cloned(self) -> FindResult<V> {
                match self {
                    FindResult::NotFound => FindResult::NotFound,
                    FindResult::Incomplete => FindResult::Incomplete,
                    FindResult::Undecided(v) => FindResult::Undecided(v.clone()),
                    FindResult::Found(v) => FindResult::Found(v.clone()),
                }
            }
        }

        impl<K: AsRef<str>, V> SequenceMap<K, V> {
            /// Creates an empty `SequenceMap`.
            pub fn new() -> SequenceMap<K, V> {
                SequenceMap::with_capacity(0)
            }

            /// Creates an empty `SequenceMap` with allocated capacity for `n` elements.
            pub fn with_capacity(n: usize) -> SequenceMap<K, V> {
                SequenceMap{
                    sequences: Vec::with_capacity(n),
                }
            }

            /// Returns a slice of all contained sequences, sorted by key.
            pub fn sequences(&self) -> &[(K, V)] {
                &self.sequences
            }

            /// Returns a mutable slice of all contained sequences, sorted by key.
            ///
            /// # Note
            ///
            /// Elements must remain sorted by key for the proper functioning of
            /// `SequenceMap` operations. If keys are modified, the caller must ensure
            /// that the slice is sorted.
            pub fn sequences_mut(&mut self) -> &mut [(K, V)] {
                &mut self.sequences
            }

            /// Returns an `Entry` for the given key.
            ///
            /// This API matches the entry API for the standard `HashMap` collection.
            pub fn entry(&mut self, key: K) -> Entry<K, V> {
                match self.search(key.as_ref()) {
                    Ok(n) => Entry::Occupied(OccupiedEntry{
                        map: self,
                        index: n,
                    }),
                    Err(n) => Entry::Vacant(VacantEntry{
                        map: self,
                        key,
                        index: n,
                    })
                }
            }

            /// Performs a search for a partial or complete sequence match.
            pub fn find(&self, key: &str) -> FindResult<&V> {
                let (n, found) = match self.search(key) {
                    Ok(n) => (n, true),
                    Err(n) => (n, false)
                };

                let incomplete = self.sequences.get(n + (found as usize))
                    .map_or(false, |&(ref next, _)| next.as_ref().starts_with(key));

                match (found, incomplete) {
                    (false, false) => FindResult::NotFound,
                    (false, true) => FindResult::Incomplete,
                    (true, false) => FindResult::Found(&self.sequences[n].1),
                    (true, true) => FindResult::Undecided(&self.sequences[n].1),
                }
            }

            /// Returns the corresponding value for the given sequence.
            pub fn get(&self, key: &str) -> Option<&V> {
                match self.search(key) {
                    Ok(n) => Some(&self.sequences[n].1),
                    Err(_) => None
                }
            }

            /// Returns a mutable reference to the corresponding value for the given sequence.
            pub fn get_mut(&mut self, key: &str) -> Option<&mut V> {
                match self.search(key) {
                    Ok(n) => Some(&mut self.sequences[n].1),
                    Err(_) => None
                }
            }

            /// Inserts a key-value pair into the map.
            ///
            /// If the key already exists in the map, the new value will replace the old
            /// value and the old value will be returned.
            pub fn insert(&mut self, key: K, value: V) -> Option<V> {
                match self.search(key.as_ref()) {
                    Ok(n) => Some(replace(&mut self.sequences[n], (key, value)).1),
                    Err(n) => {
                        self.sequences.insert(n, (key, value));
                        None
                    }
                }
            }

            /// Removes a key-value pair from the map.
            pub fn remove(&mut self, key: &str) -> Option<(K, V)> {
                match self.search(key) {
                    Ok(n) => Some(self.sequences.remove(n)),
                    Err(_) => None
                }
            }

            fn search(&self, key: &str) -> Result<usize, usize> {
                self.sequences.binary_search_by_key(&key, |&(ref k, _)| &k.as_ref())
            }
        }

        impl<K: AsRef<str>, V> From<Vec<(K, V)>> for SequenceMap<K, V> {
            /// Creates a `SequenceMap` from a `Vec` of key-value pairs.
            ///
            /// The input `Vec` will be sorted and deduplicated.
            ///
            /// If two elements exist with the same key, the first element is used.
            fn from(mut sequences: Vec<(K, V)>) -> SequenceMap<K, V> {
                sequences.sort_by(|a, b| a.0.as_ref().cmp(b.0.as_ref()));
                sequences.dedup_by(|a, b| a.0.as_ref() == b.0.as_ref());

                SequenceMap{sequences}
            }
        }

        impl<K: AsRef<str>, V> FromIterator<(K, V)> for SequenceMap<K, V> {
            /// Creates a `SequenceMap` from an iterator of key-value pairs.
            ///
            /// If two elements exist with the same key, the last element is used.
            fn from_iter<I: IntoIterator<Item=(K, V)>>(iter: I) -> Self {
                let iter = iter.into_iter();
                let mut map = SequenceMap::with_capacity(iter.size_hint().0);

                for (k, v) in iter {
                    map.insert(k, v);
                }

                map
            }
        }

        /// A view into a single entry of a `SequenceMap`, which may be either occupied
        /// or vacant.
        ///
        /// This value is returned from the [`SequenceMap::entry`] method.
        ///
        /// [`SequenceMap::entry`]: struct.SequenceMap.html#method.entry
        pub enum Entry<'a, K: 'a, V: 'a> {
            /// An occupied entry
            Occupied(OccupiedEntry<'a, K, V>),
            /// A vacant entry
            Vacant(VacantEntry<'a, K, V>),
        }

        /// A view into an occupied entry in a `SequenceMap`.
        pub struct OccupiedEntry<'a, K: 'a, V: 'a> {
            map: &'a mut SequenceMap<K, V>,
            index: usize,
        }

        /// A view into a vacant entry in a `SequenceMap`.
        pub struct VacantEntry<'a, K: 'a, V: 'a> {
            map: &'a mut SequenceMap<K, V>,
            key: K,
            index: usize,
        }

        impl<'a, K, V> Entry<'a, K, V> {
            /// Provides in-place mutable access to an occupied entry before any
            /// potential inserts into the map.
            pub fn and_modify<F: FnOnce(&mut V)>(self, f: F) -> Self {
                match self {
                    Entry::Occupied(mut ent) => {
                        f(ent.get_mut());
                        Entry::Occupied(ent)
                    }
                    Entry::Vacant(ent) => Entry::Vacant(ent)
                }
            }

            /// Returns a mutable reference to the entry value,
            /// inserting the provided default if the entry is vacant.
            pub fn or_insert(self, default: V) -> &'a mut V {
                match self {
                    Entry::Occupied(ent) => ent.into_mut(),
                    Entry::Vacant(ent) => ent.insert(default)
                }
            }

            /// Returns a mutable reference to the entry value,
            /// inserting a value using the provided closure if the entry is vacant.
            pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {
                match self {
                    Entry::Occupied(ent) => ent.into_mut(),
                    Entry::Vacant(ent) => ent.insert(default())
                }
            }

            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K {
                match *self {
                    Entry::Occupied(ref ent) => ent.key(),
                    Entry::Vacant(ref ent) => ent.key(),
                }
            }
        }

        impl<'a, K, V> OccupiedEntry<'a, K, V> {
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K {
                &self.map.sequences[self.index].0
            }

            /// Returns a borrowed reference to the entry value.
            pub fn get(&self) -> &V {
                &self.map.sequences[self.index].1
            }

            /// Returns a mutable reference to the entry value.
            pub fn get_mut(&mut self) -> &mut V {
                &mut self.map.sequences[self.index].1
            }

            /// Converts the `OccupiedEntry` into a mutable reference whose lifetime
            /// is bound to the `SequenceMap`.
            pub fn into_mut(self) -> &'a mut V {
                &mut self.map.sequences[self.index].1
            }

            /// Replaces the entry value with the given value, returning the previous value.
            pub fn insert(&mut self, value: V) -> V {
                replace(self.get_mut(), value)
            }

            /// Removes the entry and returns the value.
            pub fn remove(self) -> V {
                self.map.sequences.remove(self.index).1
            }

            /// Removes the entry and returns the key-value pair.
            pub fn remove_entry(self) -> (K, V) {
                self.map.sequences.remove(self.index)
            }
        }

        impl<'a, K, V> VacantEntry<'a, K, V> {
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K {
                &self.key
            }

            /// Consumes the `VacantEntry` and returns ownership of the key.
            pub fn into_key(self) -> K {
                self.key
            }

            /// Consumes the `VacantEntry` and inserts a value, returning a mutable
            /// reference to its place in the `SequenceMap`.
            pub fn insert(self, value: V) -> &'a mut V {
                self.map.sequences.insert(self.index, (self.key, value));
                &mut self.map.sequences[self.index].1
            }
        }

        impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for Entry<'a, K, V> {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match *self {
                    Entry::Occupied(ref ent) =>
                        f.debug_tuple("Entry")
                            .field(ent)
                            .finish(),
                    Entry::Vacant(ref ent) =>
                        f.debug_tuple("Entry")
                            .field(ent)
                            .finish()
                }
            }
        }

        impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for OccupiedEntry<'a, K, V> {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.debug_struct("OccupiedEntry")
                    .field("key", self.key())
                    .field("value", self.get())
                    .finish()
            }
        }

        impl<'a, K: fmt::Debug, V> fmt::Debug for VacantEntry<'a, K, V> {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.debug_tuple("VacantEntry")
                    .field(self.key())
                    .finish()
            }
        }
    }

    pub mod signal
    {
        //! Contains types relating to operating system signals

        use std::fmt;
        use std::iter::FromIterator;
        use std::ops;

        /// Signal received through a terminal device
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Signal {
            /// Break signal (`CTRL_BREAK_EVENT`); Windows only
            Break,
            /// Continue signal (`SIGCONT`); Unix only
            Continue,
            /// Interrupt signal (`SIGINT` on Unix, `CTRL_C_EVENT` on Windows)
            Interrupt,
            /// Terminal window resize (`SIGWINCH` on Unix,
            /// `WINDOW_BUFFER_SIZE_EVENT` on Windows)
            ///
            /// When this signal is received, it will be translated into an
            /// `Event::Resize(_)` value containing the new size of the terminal.
            Resize,
            /// Suspend signal (`SIGTSTP`); Unix only
            Suspend,
            /// Quit signal (`SIGQUIT`); Unix only
            Quit,
        }

        const NUM_SIGNALS: u8 = 6;

        impl Signal {
            fn as_bit(&self) -> u8 {
                1 << (*self as u8)
            }

            fn all_bits() -> u8 {
                (1 << NUM_SIGNALS) - 1
            }
        }

        impl ops::BitOr for Signal {
            type Output = SignalSet;

            fn bitor(self, rhs: Signal) -> SignalSet {
                let mut set = SignalSet::new();

                set.insert(self);
                set.insert(rhs);
                set
            }
        }

        impl ops::Not for Signal {
            type Output = SignalSet;

            fn not(self) -> SignalSet {
                !SignalSet::from(self)
            }
        }

        /// Represents a set of `Signal` values
        #[derive(Copy, Clone, Default, Eq, PartialEq)]
        pub struct SignalSet(u8);

        impl SignalSet {
            /// Returns an empty `SignalSet`.
            pub fn new() -> SignalSet {
                SignalSet(0)
            }

            /// Returns a `SignalSet` containing all available signals.
            pub fn all() -> SignalSet {
                SignalSet(Signal::all_bits())
            }

            /// Returns whether this set contains the given `Signal`.
            pub fn contains(&self, sig: Signal) -> bool {
                self.0 & sig.as_bit() != 0
            }

            /// Returns whether this set contains all signals present in another set.
            pub fn contains_all(&self, other: SignalSet) -> bool {
                self.0 & other.0 == other.0
            }

            /// Returns whether this set contains any signals present in another set.
            pub fn intersects(&self, other: SignalSet) -> bool {
                self.0 & other.0 != 0
            }

            /// Returns whether this set contains any signals.
            pub fn is_empty(&self) -> bool {
                self.0 == 0
            }

            /// Inserts a `Signal` into this set.
            pub fn insert(&mut self, sig: Signal) {
                self.0 |= sig.as_bit();
            }

            /// Removes a `Signal` from this set.
            pub fn remove(&mut self, sig: Signal) {
                self.0 &= !sig.as_bit();
            }

            /// Sets whether this set contains the given `Signal`.
            pub fn set(&mut self, sig: Signal, set: bool) {
                if set {
                    self.insert(sig);
                } else {
                    self.remove(sig);
                }
            }

            /// Returns the difference of two sets.
            ///
            /// The result is all signals contained in `self`, except for those
            /// also contained in `other`.
            ///
            /// This is equivalent to `self - other` or `self & !other`.
            pub fn difference(&self, other: SignalSet) -> SignalSet {
                SignalSet(self.0 & !other.0)
            }

            /// Returns the symmetric difference of two sets.
            ///
            /// The result is all signals contained in either set, but not those contained
            /// in both.
            ///
            /// This is equivalent to `self ^ other`.
            pub fn symmetric_difference(&self, other: SignalSet) -> SignalSet {
                SignalSet(self.0 ^ other.0)
            }

            /// Returns the intersection of two sets.
            ///
            /// The result is all signals contained in both sets, but not those contained
            /// in either one or the other.
            ///
            /// This is equivalent to `self & other`.
            pub fn intersection(&self, other: SignalSet) -> SignalSet {
                SignalSet(self.0 & other.0)
            }

            /// Returns the union of two sets.
            ///
            /// The result is all signals contained in either or both sets.
            ///
            /// This is equivalent to `self | other`.
            pub fn union(&self, other: SignalSet) -> SignalSet {
                SignalSet(self.0 | other.0)
            }

            /// Returns the inverse of the set.
            ///
            /// The result is all valid signals not contained in this set.
            ///
            /// This is equivalent to `!self`.
            pub fn inverse(&self) -> SignalSet {
                SignalSet(!self.0 & Signal::all_bits())
            }
        }

        impl fmt::Debug for SignalSet {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                const SIGNALS: &[Signal] = &[
                    Signal::Break,
                    Signal::Continue,
                    Signal::Interrupt,
                    Signal::Resize,
                    Signal::Suspend,
                    Signal::Quit,
                ];

                let mut first = true;

                f.write_str("SignalSet(")?;

                for &sig in SIGNALS {
                    if self.contains(sig) {
                        if !first {
                            f.write_str(" | ")?;
                        }

                        write!(f, "{:?}", sig)?;
                        first = false;
                    }
                }

                f.write_str(")")
            }
        }

        impl From<Signal> for SignalSet {
            fn from(sig: Signal) -> SignalSet {
                let mut set = SignalSet::new();
                set.insert(sig);
                set
            }
        }

        impl Extend<Signal> for SignalSet {
            fn extend<I: IntoIterator<Item=Signal>>(&mut self, iter: I) {
                for sig in iter {
                    self.insert(sig);
                }
            }
        }

        impl FromIterator<Signal> for SignalSet {
            fn from_iter<I: IntoIterator<Item=Signal>>(iter: I) -> SignalSet {
                let mut set = SignalSet::new();

                set.extend(iter);
                set
            }
        }

        macro_rules! impl_op {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    type Output = SignalSet;

                    fn $tr_meth(self, rhs: SignalSet) -> SignalSet {
                        self.$method(rhs)
                    }
                }
            }
        }

        macro_rules! impl_mut_op {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    fn $tr_meth(&mut self, rhs: SignalSet) {
                        *self = self.$method(rhs);
                    }
                }
            }
        }

        macro_rules! impl_unary_op {
            ( $tr:ident , $tr_meth:ident , $method:ident ) => {
                impl ops::$tr for SignalSet {
                    type Output = SignalSet;

                    fn $tr_meth(self) -> SignalSet {
                        self.$method()
                    }
                }
            }
        }

        impl_op!{ BitAnd, bitand, intersection }
        impl_op!{ BitOr, bitor, union }
        impl_op!{ BitXor, bitxor, symmetric_difference }
        impl_op!{ Sub, sub, difference }

        impl_unary_op!{ Not, not, inverse }

        impl_mut_op!{ BitAndAssign, bitand_assign, intersection }
        impl_mut_op!{ BitOrAssign, bitor_assign, union }
        impl_mut_op!{ BitXorAssign, bitxor_assign, symmetric_difference }
        impl_mut_op!{ SubAssign, sub_assign, difference }
    }

    pub mod terminal
    {
        //! Provides an interface to terminal devices

        use std::fmt;
        use std::io;
        use std::sync::{LockResult, TryLockResult};
        use std::time::Duration;

        use crate::priv_util::{map_lock_result, map_try_lock_result};
        use crate::signal::{Signal, SignalSet};
        use crate::sys;

        /// Represents a color attribute applied to text foreground or background.
        ///
        /// # Notes
        ///
        /// Names here correspond to possible default values for some systems.
        /// Because users may reconfigure the set of colors available in their terminal,
        /// these color values may correspond to different user-configured display colors.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Color {
            /// Black
            Black,
            /// Blue
            Blue,
            /// Cyan
            Cyan,
            /// Green
            Green,
            /// Magenta
            Magenta,
            /// Red
            Red,
            /// White
            White,
            /// Yellow
            Yellow,
        }

        bitflags!{
            /// Represents a set of style attributes applied to text.
            ///
            /// Some styles may not be supported on all systems.
            #[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
            pub struct Style: u8 {
                /// Bold
                const BOLD      = 1 << 0;
                /// Italic
                const ITALIC    = 1 << 1;
                /// Reverse; foreground and background color swapped
                const REVERSE   = 1 << 2;
                /// Underline
                const UNDERLINE = 1 << 3;
            }
        }

        /// Represents a terminal output theme.
        ///
        /// A theme consists of a foreground and background color as well as a style.
        #[derive(Copy, Clone, Debug, Default)]
        pub struct Theme {
            /// Foreground color
            pub fg: Option<Color>,
            /// Background color
            pub bg: Option<Color>,
            /// Style
            pub style: Style,
        }

        impl Theme {
            /// Creates a new theme with given values.
            ///
            /// # Note
            ///
            /// In order to create a Theme using default values you might want to use
            /// `Theme::default()` instead.
            pub fn new<F,B,S>(fg: F, bg: B, style: S) -> Theme
                    where
                        F: Into<Option<Color>>,
                        B: Into<Option<Color>>,
                        S: Into<Option<Style>> {
                Theme {
                    fg: fg.into(),
                    bg: bg.into(),
                    style: style.into().unwrap_or_default(),
                }
            }

            /// Sets the foreground color on the given Theme and returns the new.
            pub fn fg<F>(mut self, fg: F) -> Theme
                    where F: Into<Option<Color>> {
                self.fg = fg.into();
                self
            }

            /// Sets the background color on the given Theme and returns the new.
            pub fn bg<B>(mut self, bg: B) -> Theme
                    where B: Into<Option<Color>> {
                self.bg = bg.into();
                self
            }

            /// Sets the style on the given Theme and returns the new.
            pub fn style<S>(mut self, style: S) -> Theme
                    where S: Into<Option<Style>> {
                self.style = style.into().unwrap_or_default();
                self
            }
        }

        /// Represents the cursor position in a terminal device
        #[derive(Copy, Clone, Debug, Default, Eq, PartialEq)]
        pub struct Cursor {
            /// Index of line in terminal, beginning at `0`.
            pub line: usize,
            /// Index of column in terminal, beginning at `0`.
            pub column: usize,
        }

        impl Cursor {
            /// Returns the position of the next cell within a terminal of the given size.
            ///
            /// Returns `None` if this cursor position represents the last cell.
            #[inline]
            pub fn next(&self, size: Size) -> Option<Cursor> {
                let mut line = self.line;
                let mut column = self.column + 1;

                if column >= size.columns {
                    column = 0;
                    line += 1;
                }

                if line >= size.lines {
                    None
                } else {
                    Some(Cursor{line, column})
                }
            }

            /// Returns the position of the previous cell within a terminal of the given size.
            ///
            /// Returns `None` if this cursor position represents the first cell.
            #[inline]
            pub fn previous(&self, size: Size) -> Option<Cursor> {
                if self.column == 0 {
                    if self.line == 0 {
                        None
                    } else {
                        Some(Cursor{line: self.line - 1, column: size.columns - 1})
                    }
                } else {
                    Some(Cursor{line: self.line, column: self.column - 1})
                }
            }

            /// Returns a `Cursor` pointing to the first cell, i.e. `(0, 0)`.
            #[inline]
            pub fn first() -> Cursor {
                Cursor{
                    line: 0,
                    column: 0,
                }
            }

            /// Returns a `Cursor` pointing to the last cell of a screen of the given size.
            #[inline]
            pub fn last(size: Size) -> Cursor {
                Cursor{
                    line: size.lines - 1,
                    column: size.columns - 1,
                }
            }

            /// Returns whether the cursor is out of bounds of the given size.
            #[inline]
            pub fn is_out_of_bounds(&self, size: Size) -> bool {
                self.line >= size.lines || self.column >= size.columns
            }

            /// Returns the index of the cursor position within a one-dimensional array
            /// of the given size.
            pub(crate) fn as_index(&self, size: Size) -> usize {
                self.line * size.columns + self.column
            }
        }

        impl From<(usize, usize)> for Cursor {
            /// Returns a `Cursor` value from a `(line, column)` or `(y, x)` tuple.
            fn from((line, column): (usize, usize)) -> Cursor {
                Cursor{line, column}
            }
        }

        /// Represents the visual appearance of the cursor in the terminal
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum CursorMode {
            /// Normal mode
            Normal,
            /// Invisible mode
            Invisible,
            /// Overwrite mode
            Overwrite,
        }

        /// Represents an event generated from a terminal interface
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Event {
            /// Keyboard event
            Key(Key),
            /// Mouse event
            Mouse(MouseEvent),
            /// Raw data read
            Raw(usize),
            /// Terminal window size changed; contained value is the new size.
            Resize(Size),
            /// Terminal signal received
            Signal(Signal),
            /// No event
            NoEvent,
        }

        /// Represents a keyboard key press event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Key {
            /// Backspace
            Backspace,
            /// Enter
            Enter,
            /// Escape
            Escape,
            /// Tab
            Tab,
            /// Up arrow
            Up,
            /// Down arrow
            Down,
            /// Left arrow
            Left,
            /// Right arrow
            Right,
            /// Delete
            Delete,
            /// Insert
            Insert,
            /// Home
            Home,
            /// End
            End,
            /// PageUp
            PageUp,
            /// PageDown
            PageDown,
            /// Character key
            Char(char),
            /// Control character
            Ctrl(char),
            /// Function `n` key; e.g. F1, F2, ...
            F(u32),
        }

        impl From<char> for Key {
            fn from(ch: char) -> Key {
                use crate::util::{is_ctrl, unctrl_lower};

                match ch {
                    '\x1b' => Key::Escape,
                    '\x7f' => Key::Backspace,
                    '\r' | '\n' => Key::Enter,
                    '\t' => Key::Tab,
                    _ if is_ctrl(ch) => Key::Ctrl(unctrl_lower(ch)),
                    _ => Key::Char(ch),
                }
            }
        }

        /// Represents a mouse event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub struct MouseEvent {
            /// The position of the mouse within the terminal when the event occurred
            pub position: Cursor,
            /// The input event that occurred
            pub input: MouseInput,
            /// Modifier keys held when the input event occurred
            pub modifiers: ModifierState,
        }

        /// Represents the type of mouse input event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum MouseInput {
            /// The mouse cursor was moved
            Motion,
            /// A mouse button was pressed
            ButtonPressed(MouseButton),
            /// A mouse button was released
            ButtonReleased(MouseButton),
            /// The mouse wheel was scrolled up
            WheelUp,
            /// The mouse wheel was scrolled down
            WheelDown,
        }

        /// Represents a button on a mouse device
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum MouseButton {
            /// Left mouse button
            Left,
            /// Right mouse button
            Right,
            /// Middle mouse button
            Middle,
            /// Other mouse button
            Other(u32),
        }

        bitflags!{
            /// Represents a set of modifier keys
            #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
            pub struct ModifierState: u8 {
                /// Alt key
                const ALT   = 1 << 0;
                /// Ctrl key
                const CTRL  = 1 << 1;
                /// Shift key
                const SHIFT = 1 << 2;
            }
        }

        /// Configures a [`Terminal`] or [`Screen`] instance to read special input.
        #[derive(Copy, Clone, Debug)]
        pub struct PrepareConfig {
            /// Whether to block signals that result from user input.
            pub block_signals: bool,
            /// Whether to enable control flow characters.
            pub enable_control_flow: bool,
            /// If `true`, the terminal will be configured to generate events from
            /// function keys.
            pub enable_keypad: bool,
            /// If `true`, the terminal will be configured to generate events for
            /// mouse input, if supported, and `read_event` may return `Event::Mouse(_)`.
            pub enable_mouse: bool,
            /// If `true`, mouse motion events will always be reported.
            /// If `false`, such events will only be reported while at least one mouse
            /// button is pressed.
            pub always_track_motion: bool,
            /// For each signal in the set, a signal handler will intercept the signal
            /// and report it by returning an `Event::Signal(_)` value.
            pub report_signals: SignalSet,
        }

        impl Default for PrepareConfig {
            fn default() -> PrepareConfig {
                PrepareConfig{
                    block_signals: true,
                    enable_control_flow: false,
                    enable_keypad: true,
                    enable_mouse: false,
                    always_track_motion: false,
                    report_signals: SignalSet::new(),
                }
            }
        }

        /// Represents a previous device state of a [`Terminal`].
        #[must_use = "the result of `terminal.prepare()` should be passed to \
            `terminal.restore()` to restore terminal to its original state"]
        pub struct PrepareState(sys::PrepareState);

        /// Represents the size of a terminal window
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub struct Size {
            /// Number of lines in the terminal
            pub lines: usize,
            /// Number of columns in the terminal
            pub columns: usize,
        }

        impl Size {
            /// Returns the total number of cells in a terminal of the given size.
            #[inline]
            pub fn area(&self) -> usize {
                self.checked_area().unwrap_or_else(
                    || panic!("overflow in Size::area {:?}", self))
            }

            /// Returns the total number of cells in a terminal of the given size.
            #[inline]
            pub fn checked_area(&self) -> Option<usize> {
                self.lines.checked_mul(self.columns)
            }
        }

        /// Provides concurrent read and write access to a terminal device
        pub struct Terminal(pub(crate) sys::Terminal);

        /// Holds an exclusive lock for read operations on a `Terminal`
        pub struct TerminalReadGuard<'a>(sys::TerminalReadGuard<'a>);

        /// Holds an exclusive lock for write operations on a `Terminal`
        pub struct TerminalWriteGuard<'a>(sys::TerminalWriteGuard<'a>);

        impl Terminal {
            /// Opens a new interface to the terminal on `stdout`.
            pub fn new() -> io::Result<Terminal> {
                Ok(Terminal(sys::Terminal::stdout()?))
            }

            /// Opens a new interface to the terminal on `stderr`.
            pub fn stderr() -> io::Result<Terminal> {
                Ok(Terminal(sys::Terminal::stderr()?))
            }

            /// Returns the name of the terminal.
            #[inline]
            pub fn name(&self) -> &str {
                self.0.name()
            }

            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline]
            pub fn lock_read(&self) -> LockResult<TerminalReadGuard> {
                map_lock_result(self.0.lock_read(), TerminalReadGuard)
            }

            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline]
            pub fn lock_write(&self) -> LockResult<TerminalWriteGuard> {
                map_lock_result(self.0.lock_write(), TerminalWriteGuard)
            }

            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline]
            pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard> {
                map_try_lock_result(self.0.try_lock_read(), TerminalReadGuard)
            }

            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline]
            pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard> {
                map_try_lock_result(self.0.try_lock_write(), TerminalWriteGuard)
            }
        }

        /// # Locking
        ///
        /// The following methods internally acquire both the read and write locks.
        impl Terminal {
            /// Prepares the terminal to read input.
            pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState> {
                self.0.prepare(config).map(PrepareState)
            }

            /// Restores the terminal to its previous state.
            pub fn restore(&self, state: PrepareState) -> io::Result<()> {
                self.0.restore(state.0)
            }
        }

        /// # Locking
        ///
        /// The following methods internally acquire the read lock.
        impl Terminal {
            /// Waits for an event from the terminal.
            pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> {
                self.0.wait_event(timeout)
            }

            /// Waits for input and reads an event from the terminal.
            pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>>  {
                self.0.read_event(timeout)
            }
        }

        /// # Locking
        ///
        /// The following methods internally acquire the write lock.
        impl Terminal {
            /// Returns the size of the terminal.
            #[inline]
            pub fn size(&self) -> io::Result<Size> {
                self.0.size()
            }

            /// Clears the terminal screen, placing the cursor at the first line and column.
            pub fn clear_screen(&self) -> io::Result<()> {
                self.0.clear_screen()
            }

            /// Clears the current line, starting at cursor position.
            pub fn clear_to_line_end(&self) -> io::Result<()> {
                self.0.clear_to_line_end()
            }

            /// Clears the screen, starting at cursor position.
            pub fn clear_to_screen_end(&self) -> io::Result<()> {
                self.0.clear_to_screen_end()
            }

            /// Moves the cursor up `n` lines.
            pub fn move_up(&self, n: usize) -> io::Result<()> {
                self.0.move_up(n)
            }

            /// Moves the cursor down `n` lines.
            pub fn move_down(&self, n: usize) -> io::Result<()> {
                self.0.move_down(n)
            }

            /// Moves the cursor left `n` columns.
            pub fn move_left(&self, n: usize) -> io::Result<()> {
                self.0.move_left(n)
            }

            /// Moves the cursor right `n` columns.
            pub fn move_right(&self, n: usize) -> io::Result<()> {
                self.0.move_right(n)
            }

            /// Moves the cursor to the first column of the current line
            pub fn move_to_first_column(&self) -> io::Result<()> {
                self.0.move_to_first_column()
            }

            /// Set the current cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> {
                self.0.set_cursor_mode(mode)
            }

            /// Adds a set of `Style` flags to the current style setting.
            pub fn add_style(&self, style: Style) -> io::Result<()> {
                self.0.add_style(style)
            }

            /// Removes a set of `Style` flags from the current style setting.
            pub fn remove_style(&self, style: Style) -> io::Result<()> {
                self.0.remove_style(style)
            }

            /// Sets the current style to the given set of flags.
            pub fn set_style<S>(&self, style: S) -> io::Result<()>
                    where S: Into<Option<Style>> {
                self.0.set_style(style.into().unwrap_or_default())
            }

            /// Sets all attributes for the terminal.
            pub fn set_theme(&self, theme: Theme) -> io::Result<()> {
                self.0.set_theme(theme)
            }

            /// Sets the foreground text color.
            pub fn set_fg<C: Into<Option<Color>>>(&self, fg: C) -> io::Result<()> {
                self.0.set_fg(fg.into())
            }

            /// Sets the background text color.
            pub fn set_bg<C: Into<Option<Color>>>(&self, bg: C) -> io::Result<()> {
                self.0.set_bg(bg.into())
            }

            /// Removes color and style attributes.
            pub fn clear_attributes(&self) -> io::Result<()> {
                self.0.clear_attributes()
            }

            /// Adds bold to the current style setting.
            pub fn bold(&self) -> io::Result<()> {
                self.add_style(Style::BOLD)
            }

            /// Adds italic to the current style setting.
            pub fn italic(&self) -> io::Result<()> {
                self.add_style(Style::ITALIC)
            }

            /// Adds underline to the current style setting.
            pub fn underline(&self) -> io::Result<()> {
                self.add_style(Style::UNDERLINE)
            }

            /// Adds reverse to the current style setting.
            pub fn reverse(&self) -> io::Result<()> {
                self.add_style(Style::REVERSE)
            }

            /// Writes output to the terminal with the given color and style.
            pub fn write_styled<F, B, S>(&self, fg: F, bg: B, style: S, s: &str) -> io::Result<()> where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            {
                self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), s)
            }

            /// Writes a single character to the terminal
            /// using the current style and color settings.
            pub fn write_char(&self, ch: char) -> io::Result<()> {
                self.0.write_char(ch)
            }

            /// Writes a string to the terminal
            /// using the current style and color settings.
            pub fn write_str(&self, s: &str) -> io::Result<()> {
                self.0.write_str(s)
            }

            /// Writes formatted text to the terminal
            /// using the current style and color settings.
            pub fn write_fmt(&self, args: fmt::Arguments) -> io::Result<()> {
                let s = args.to_string();
                self.write_str(&s)
            }

            #[doc(hidden)]
            pub fn borrow_term_write_guard(&self) -> TerminalWriteGuard {
                self.lock_write().unwrap()
            }
        }

        impl<'a> TerminalReadGuard<'a> {
            /// Prepares the terminal to read input.
            pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState> {
                self.0.prepare(config).map(PrepareState)
            }

            /// Performs terminal preparation using both [`Terminal`] locks.
            pub fn prepare_with_lock(&mut self, writer: &mut TerminalWriteGuard,
                    config: PrepareConfig) -> io::Result<PrepareState> {
                self.0.prepare_with_lock(&mut writer.0, config).map(PrepareState)
            }

            /// Restores the terminal to its previous state.
            pub fn restore(&mut self, state: PrepareState) -> io::Result<()> {
                self.0.restore(state.0)
            }

            /// Performs terminal state restoration using both [`Terminal`] locks.
            pub fn restore_with_lock(&mut self, writer: &mut TerminalWriteGuard,
                    state: PrepareState) -> io::Result<()> {
                self.0.restore_with_lock(&mut writer.0, state.0)
            }

            /// Waits for an event from the terminal.
            pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                self.0.wait_event(timeout)
            }

            /// Waits for input and reads an event from the terminal.
            pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>>  {
                self.0.read_event(timeout)
            }
        }

        impl<'a> TerminalWriteGuard<'a> {
            /// Flush all output to the terminal device.
            pub fn flush(&mut self) -> io::Result<()> {
                self.0.flush()
            }

            /// Returns the size of the terminal.
            #[inline]
            pub fn size(&self) -> io::Result<Size> {
                self.0.size()
            }

            /// Clears the terminal screen, placing the cursor at the first line and column.
            pub fn clear_screen(&mut self) -> io::Result<()> {
                self.0.clear_screen()
            }

            /// Clears the current line, starting at cursor position.
            pub fn clear_to_line_end(&mut self) -> io::Result<()> {
                self.0.clear_to_line_end()
            }

            /// Clears the screen, starting at cursor position.
            pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
                self.0.clear_to_screen_end()
            }

            /// Moves the cursor up `n` lines.
            pub fn move_up(&mut self, n: usize) -> io::Result<()> {
                self.0.move_up(n)
            }

            /// Moves the cursor down `n` lines.
            pub fn move_down(&mut self, n: usize) -> io::Result<()> {
                self.0.move_down(n)
            }

            /// Moves the cursor left `n` columns.
            pub fn move_left(&mut self, n: usize) -> io::Result<()> {
                self.0.move_left(n)
            }

            /// Moves the cursor right `n` columns.
            pub fn move_right(&mut self, n: usize) -> io::Result<()> {
                self.0.move_right(n)
            }

            /// Moves the cursor to the first column of the current line
            pub fn move_to_first_column(&mut self) -> io::Result<()> {
                self.0.move_to_first_column()
            }

            /// Set the current cursor mode.
            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                self.0.set_cursor_mode(mode)
            }

            /// Adds a set of `Style` flags to the current style setting.
            pub fn add_style(&mut self, style: Style) -> io::Result<()> {
                self.0.add_style(style)
            }

            /// Removes a set of `Style` flags from the current style setting.
            pub fn remove_style(&mut self, style: Style) -> io::Result<()> {
                self.0.remove_style(style)
            }

            /// Sets the current style to the given set of flags.
            pub fn set_style<S>(&mut self, style: S) -> io::Result<()>
                    where S: Into<Option<Style>> {
                self.0.set_style(style.into().unwrap_or_default())
            }

            /// Sets all attributes for the terminal.
            pub fn set_theme(&mut self, theme: Theme) -> io::Result<()> {
                self.0.set_theme(theme)
            }

            /// Sets the background text color.
            pub fn set_fg<C: Into<Option<Color>>>(&mut self, fg: C) -> io::Result<()> {
                self.0.set_fg(fg.into())
            }

            /// Removes color and style attributes.
            pub fn set_bg<C: Into<Option<Color>>>(&mut self, bg: C) -> io::Result<()> {
                self.0.set_bg(bg.into())
            }

            /// Adds bold to the current style setting.
            pub fn clear_attributes(&mut self) -> io::Result<()> {
                self.0.clear_attributes()
            }

            /// Adds bold to the current style setting.
            pub fn bold(&mut self) -> io::Result<()> {
                self.add_style(Style::BOLD)
            }

            /// Adds italic to the current style setting.
            pub fn italic(&mut self) -> io::Result<()> {
                self.add_style(Style::ITALIC)
            }

            /// Adds underline to the current style setting.
            pub fn underline(&mut self) -> io::Result<()> {
                self.add_style(Style::UNDERLINE)
            }

            /// Adds reverse to the current style setting.
            pub fn reverse(&mut self) -> io::Result<()> {
                self.add_style(Style::REVERSE)
            }

            /// Writes output to the terminal with the given color and style added.
            pub fn write_styled<F, B, S>(&mut self, fg: F, bg: B, style: S, s: &str)
                    -> io::Result<()> where
                    F: Into<Option<Color>>,
                    B: Into<Option<Color>>,
                    S: Into<Option<Style>>,
                    {
                self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), s)
            }

            /// Writes a single character to the terminal
            /// using the current style and color settings.
            pub fn write_char(&mut self, ch: char) -> io::Result<()> {
                self.0.write_char(ch)
            }

            /// Writes a string to the terminal
            /// using the current style and color settings.
            pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                self.0.write_str(s)
            }

            /// Writes formatted text to the terminal
            /// using the current style and color settings.
            pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> {
                let s = args.to_string();
                self.write_str(&s)
            }

            #[doc(hidden)]
            pub fn borrow_term_write_guard(&mut self) -> &mut Self {
                self
            }
        }

        #[cfg(unix)]
        use std::path::Path;

        #[cfg(unix)]
        impl crate::unix::OpenTerminalExt for Terminal {
            fn from_path<P: AsRef<Path>>(path: P) -> io::Result<Self> {
                sys::Terminal::open(path).map(Terminal)
            }
        }

        #[cfg(unix)]
        impl crate::unix::TerminalExt for Terminal {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw(buf, timeout)
            }
        }

        #[cfg(unix)]
        impl<'a> crate::unix::TerminalExt for TerminalReadGuard<'a> {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw(buf, timeout)
            }
        }

        #[cfg(windows)]
        impl crate::windows::TerminalExt for Terminal {
            fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw(buf, timeout)
            }

            fn read_raw_event(&mut self, events: &mut [::winapi::um::wincon::INPUT_RECORD],
                    timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw_event(events, timeout)
            }
        }

        #[cfg(windows)]
        impl<'a> crate::windows::TerminalExt for TerminalReadGuard<'a> {
            fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw(buf, timeout)
            }

            fn read_raw_event(&mut self, events: &mut [::winapi::um::wincon::INPUT_RECORD],
                    timeout: Option<Duration>) -> io::Result<Option<Event>> {
                self.0.read_raw_event(events, timeout)
            }
        }
    }

    pub mod util
    {
        //! Miscellaneous utility functions

        use std::str::CharIndices;

        /// Returns the width of a character in the terminal.
        #[inline]
        pub fn char_width(ch: char) -> Option<usize> {
            use unicode_width::UnicodeWidthChar;

            ch.width()
        }

        /// Returns whether the given character is a combining mark.
        #[inline]
        pub fn is_combining_mark(ch: char) -> bool {
            use unicode_normalization::char::is_combining_mark;

            is_combining_mark(ch)
        }

        const CTRL_MASK: u8 = 0x1f;
        const UNCTRL_BIT: u8 = 0x40;

        /// Returns the control character corresponding to the given character.
        #[inline]
        pub fn ctrl(ch: char) -> char {
            ((ch as u8) & CTRL_MASK) as char
        }

        /// Returns whether the given character is a control character.
        #[inline]
        pub fn is_ctrl(ch: char) -> bool {
            let ch = ch as u32;
            ch & (CTRL_MASK as u32) == ch
        }

        /// Returns the ASCII character corresponding to the given control character.
        #[inline]
        pub fn unctrl_upper(ch: char) -> char {
            ((ch as u8) | UNCTRL_BIT) as char
        }

        /// Returns the lowercase ASCII character corresponding to the given control character.
        #[inline]
        pub fn unctrl_lower(ch: char) -> char {
            unctrl_upper(ch).to_ascii_lowercase()
        }

        /// Iterator over string prefixes.
        pub struct Prefixes<'a> {
            s: &'a str,
            iter: CharIndices<'a>,
        }

        /// Returns an iterator over all non-empty prefixes of `s`, beginning with the shortest.
        #[inline] pub fn prefixes(s: &str) -> Prefixes 
        {
            Prefixes
            {
                s,
                iter: s.char_indices(),
            }
        }

        impl<'a> Iterator for Prefixes<'a> {
            type Item = &'a str;

            fn next(&mut self) -> Option<&'a str> {
                self.iter.next().map(|(idx, ch)| &self.s[..idx + ch.len_utf8()])
            }
        }
    }
    
    mod sys
    {
        pub use self::screen::
        {
            Screen, ScreenReadGuard, ScreenWriteGuard,
        };
        
        pub use self::terminal::
        {
            PrepareState,
            Terminal, TerminalReadGuard, TerminalWriteGuard,
        };

        pub mod ext
        {
            //! Unix extension trait

            use ::io;
            use ::path::Path;
            use ::time::Duration;

            use crate::mortal::priv_util::Private;
            use crate::mortal::terminal::Event;

            /// Implements Unix-only extensions for terminal interfaces.
            pub trait OpenTerminalExt: Sized + Private 
            {
                /// Opens a terminal interface on the device at the given path.
                fn from_path<P: AsRef<Path>>(path: P) -> io::Result<Self>;
            }

            /// Implements Unix-only extensions for terminal interfaces.
            pub trait TerminalExt: Private 
            {
                /// Reads raw data from the terminal.
                fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>;
            }
        }

        mod screen
        {
            use ::io;
            use ::sync::{LockResult, Mutex, MutexGuard, TryLockResult};
            use ::time::Duration;

            use self::buffer::ScreenBuffer;
            use self::priv_util::
            {
                map_lock_result, map_try_lock_result,
                map2_lock_result, map2_try_lock_result,
            };

            use self::sys::{Terminal, TerminalReadGuard, TerminalWriteGuard, PrepareState};
            use self::terminal::{Color, Cursor, CursorMode, Event, Size, Style, PrepareConfig};

            pub struct Screen 
            {
                term: Terminal,
                state: Option<PrepareState>,
                writer: Mutex<Writer>,
            }

            pub struct ScreenReadGuard<'a>
            {
                screen: &'a Screen,
                reader: TerminalReadGuard<'a>,
            }

            pub struct ScreenWriteGuard<'a>
            {
                writer: TerminalWriteGuard<'a>,
                data: MutexGuard<'a, Writer>,
            }

            struct Writer
            {
                buffer: ScreenBuffer,
                clear_screen: bool,
                real_cursor: Cursor,
            }

            impl Screen
            {
                pub fn new(term: Terminal, config: PrepareConfig) -> io::Result<Screen>
                {
                    let size = term.size()?;
                    let state = term.prepare(config)?;

                    let screen = Screen{
                        term: term,
                        state: Some(state),

                        writer: Mutex::new(Writer{
                            buffer: ScreenBuffer::new(size),
                            clear_screen: false,
                            real_cursor: Cursor::default(),
                        }),
                    };

                    screen.term.enter_screen()?;

                    Ok(screen)
                }

                pub fn stdout(config: PrepareConfig) -> io::Result<Screen>
                {
                    Screen::new(Terminal::stdout()?, config)
                }

                pub fn stderr(config: PrepareConfig) -> io::Result<Screen>
                {
                    Screen::new(Terminal::stderr()?, config)
                }

                forward_screen_buffer_methods!{ |slf| slf.lock_write_data().buffer }

                pub fn lock_read(&self) -> LockResult<ScreenReadGuard>
                {
                    map_lock_result(self.term.lock_read(),
                        |r| ScreenReadGuard::new(self, r))
                }

                pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard>
                {
                    map_try_lock_result(self.term.try_lock_read(),
                        |r| ScreenReadGuard::new(self, r))
                }

                pub fn lock_write(&self) -> LockResult<ScreenWriteGuard>
                {
                    map2_lock_result(self.term.lock_write(), self.writer.lock(),
                        |a, b| ScreenWriteGuard::new(a, b))
                }

                pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard>
                {
                    map2_try_lock_result(self.term.try_lock_write(), self.writer.try_lock(),
                        |a, b| ScreenWriteGuard::new(a, b))
                }

                fn lock_reader(&self) -> ScreenReadGuard
                {
                    self.lock_read().expect("Screen::lock_reader")
                }

                fn lock_writer(&self) -> ScreenWriteGuard
                {
                    self.lock_write().expect("Screen::lock_writer")
                }

                fn lock_write_data(&self) -> MutexGuard<Writer>
                {
                    self.writer.lock().expect("Screen::lock_write_data")
                }

                pub fn name(&self) -> &str
                {
                    self.term.name()
                }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()>
                {
                    self.term.set_cursor_mode(mode)
                }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool>
                {
                    self.lock_reader().wait_event(timeout)
                }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    self.lock_reader().read_event(timeout)
                }

                pub fn read_raw(&self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    self.lock_reader().read_raw(buf, timeout)
                }

                pub fn refresh(&self) -> io::Result<()>
                {
                    self.lock_writer().refresh()
                }
            }

            impl Drop for Screen
            {
                fn drop(&mut self)
                {
                    let res = if let Some(state) = self.state.take()
                    {
                        self.term.restore(state)
                    } 
                    
                    else 
                    {
                        Ok(())
                    };

                    if let Err(e) = res.and_then(|_| self.term.exit_screen())
                    {
                        eprintln!("failed to restore terminal: {}", e);
                    }
                }
            }

            impl<'a> ScreenReadGuard<'a>
            {
                fn new(screen: &'a Screen, reader: TerminalReadGuard<'a>) -> ScreenReadGuard<'a>
                {
                    ScreenReadGuard{screen, reader}
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool>
                {
                    self.reader.wait_event(timeout)
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let r = self.reader.read_event(timeout)?;

                    if let Some(Event::Resize(size)) = r {
                        self.screen.lock_write_data().update_size(size);
                    }

                    Ok(r)
                }

                pub fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let r = self.reader.read_raw(buf, timeout)?;

                    if let Some(Event::Resize(size)) = r {
                        self.screen.lock_write_data().update_size(size);
                    }

                    Ok(r)
                }
            }

            impl<'a> ScreenWriteGuard<'a>
            {
                fn new(writer: TerminalWriteGuard<'a>, data: MutexGuard<'a, Writer>) 
                -> ScreenWriteGuard<'a>
                {
                    ScreenWriteGuard{writer, data}
                }

                forward_screen_buffer_mut_methods!{ |slf| slf.data.buffer }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>
                {
                    self.writer.set_cursor_mode(mode)
                }

                pub fn refresh(&mut self) -> io::Result<()>
                {
                    if self.data.clear_screen
                    {
                        self.writer.clear_screen()?;
                        self.data.clear_screen = false;
                    }

                    self.writer.clear_attributes()?;

                    let mut indices = self.data.buffer.indices();

                    while let Some((pos, cell)) = self.data.buffer.next_cell(&mut indices)
                    {
                        self.move_cursor(pos)?;
                        self.apply_attrs(cell.attrs())?;
                        self.writer.write_str(cell.text())?;
                        self.data.real_cursor.column += 1;
                    }

                    self.writer.clear_attributes()?;

                    let size = self.data.buffer.size();
                    let pos = self.data.buffer.cursor();

                    if pos.is_out_of_bounds(size)
                    {
                        self.move_cursor(Cursor::last(size))?;
                    }
                    
                    else
                    {
                        self.move_cursor(pos)?;
                    }

                    self.writer.flush()
                }

                fn move_cursor(&mut self, pos: Cursor) -> io::Result<()>
                {
                    if self.data.real_cursor != pos
                    {
                        self.writer.move_cursor(pos)?;
                        self.data.real_cursor = pos;
                    }

                    Ok(())
                }

                fn apply_attrs(&mut self, (fg, bg, style): (Option<Color>, Option<Color>, Style))
                -> io::Result<()>
                {
                    self.writer.set_attrs(fg, bg, style)
                }
            }

            impl<'a> Drop for ScreenWriteGuard<'a>
            {
                fn drop(&mut self)
                {
                    if let Err(e) = self.refresh()
                    {
                        eprintln!("failed to refresh screen: {}", e);
                    }
                }
            }

            impl Writer
            {
                fn update_size(&mut self, new_size: Size)
                {
                    if self.real_cursor.is_out_of_bounds(new_size)
                    {
                        // Force cursor move on next refresh
                        self.real_cursor = (!0, !0).into();
                    }
                    
                    self.buffer.resize(new_size);
                    self.clear_screen = true;
                }
            }
        }

        mod terminal
        {
            use ::convert::TryFrom;
            use ::fs::File;
            use ::io;
            use ::mem::{replace, zeroed};
            use ::os::unix::io::{FromRawFd, IntoRawFd, RawFd};
            use ::path::Path;
            use ::str::from_utf8;
            use ::sync::atomic::{AtomicUsize, Ordering};
            use ::sync::{LockResult, Mutex, MutexGuard, TryLockResult};
            use ::time::Duration;

            use libc::
            {
                ioctl,
                c_int, c_ushort, termios,
                STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO, TIOCGWINSZ,
            };

            use nix::errno::Errno;
            use nix::sys::select::{select, FdSet};
            use nix::sys::signal::
            {
                sigaction,
                SaFlags, SigAction, SigHandler, Signal as NixSignal, SigSet,
            };
            
            use nix::sys::termios::
            {
                tcgetattr, tcsetattr,
                SetArg, InputFlags, LocalFlags,
            };
            
            use nix::sys::time::{TimeVal, TimeValLike};
            use nix::unistd::{read, write};

            use ::smallstr::SmallString;

            use ::terminfo::{self, capability as cap, Database};
            use ::terminfo::capability::Expansion;
            use ::terminfo::expand::Context;

            use crate::mortal::priv_util::{map_lock_result, map_try_lock_result};
            use crate::mortal::sequence::{FindResult, SequenceMap};
            use crate::mortal::signal::{Signal, SignalSet};
            use crate::mortal::terminal::
            {
                Color, Cursor, CursorMode, Event, Key, PrepareConfig, Size, Style, Theme,
                MouseButton, MouseEvent, MouseInput, ModifierState,
            };
            use crate::mortal::util::prefixes;

            const OUT_BUFFER_SIZE: usize = 8192;

            const XTERM_ENABLE_MOUSE: &str = "\x1b[?1006h\x1b[?1002h";
            const XTERM_DISABLE_MOUSE: &str = "\x1b[?1006l\x1b[?1002l";
            const XTERM_ENABLE_MOUSE_MOTION: &str = "\x1b[?1003h";
            const XTERM_DISABLE_MOUSE_MOTION: &str = "\x1b[?1003l";
            const XTERM_MOUSE_INTRO: &str = "\x1b[<";

            const XTERM_SHIFT_MASK: u32 = 0x04;
            const XTERM_META_MASK: u32  = 0x08;
            const XTERM_CTRL_MASK: u32  = 0x10;
            const XTERM_MODIFIER_MASK: u32 = XTERM_SHIFT_MASK | XTERM_META_MASK | XTERM_CTRL_MASK;

            type SeqMap = SequenceMap<SmallString<[u8; 8]>, SeqData>;

            static LAST_SIGNAL: AtomicUsize = AtomicUsize::new(0);

            extern "C" fn handle_signal(signum: c_int) 
            {
                LAST_SIGNAL.store(signum as usize, Ordering::Relaxed);
            }

            #[derive(Copy, Clone)]
            enum SeqData 
            {
                XTermMouse,
                Key(Key),
            }

            pub struct Terminal 
            {
                info: Database,
                out_fd: RawFd,
                in_fd: RawFd,
                owned_fd: bool,
                sequences: SeqMap,
                reader: Mutex<Reader>,
                writer: Mutex<Writer>,
            }

            pub struct TerminalReadGuard<'a>
            {
                term: &'a Terminal,
                reader: MutexGuard<'a, Reader>,
            }

            pub struct TerminalWriteGuard<'a>
            {
                term: &'a Terminal,
                writer: MutexGuard<'a, Writer>,
            }

            struct Reader
            {
                in_buffer: Vec<u8>,
                resume: Option<Resume>,
                report_signals: SignalSet,
            }

            struct Writer
            {
                context: Context,
                out_buffer: Vec<u8>,
                fg: Option<Color>,
                bg: Option<Color>,
                cur_style: Style,
            }

            impl Terminal
            {
                fn new(in_fd: RawFd, out_fd: RawFd, owned_fd: bool) -> io::Result<Terminal>
                {
                    let info = Database::from_env().map_err(ti_to_io)?;
                    let sequences = sequences(&info);
                    Ok(
                        Terminal
                        {
                            info,
                            in_fd,
                            out_fd,
                            owned_fd,
                            sequences,
                            reader: Mutex::new(Reader{
                                in_buffer: Vec::new(),
                                resume: None,
                                report_signals: SignalSet::new(),
                            }),
                            writer: Mutex::new(Writer::new()),
                        }
                    )
                }

                pub fn open<P: AsRef<Path>>(path: P) -> io::Result<Terminal>
                {
                    let fd = open_rw(path)?;
                    let r = Terminal::new(fd, fd, true);
                    if r.is_err()
                    {
                        unsafe { close_fd(fd); }
                    }

                    r
                }

                pub fn stdout() -> io::Result<Terminal>
                {
                    Terminal::new(STDIN_FILENO, STDOUT_FILENO, false)
                }

                pub fn stderr() -> io::Result<Terminal>
                {
                    Terminal::new(STDIN_FILENO, STDERR_FILENO, false)
                }

                pub fn name(&self) -> &str
                {
                    self.info.name()
                }

                fn is_xterm(&self) -> bool
                {
                    is_xterm(self.name())
                }

                pub fn size(&self) -> io::Result<Size>
                {
                    self.lock_writer().size()
                }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool>
                {
                    self.lock_reader().wait_event(timeout)
                }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    self.lock_reader().read_event(timeout)
                }

                pub fn read_raw(&self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    self.lock_reader().read_raw(buf, timeout)
                }

                pub fn enter_screen(&self) -> io::Result<()>
                {
                    self.lock_writer().enter_screen()
                }

                pub fn exit_screen(&self) -> io::Result<()>
                {
                    self.lock_writer().exit_screen()
                }

                pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState>
                {
                    self.lock_reader().prepare(config)
                }

                pub fn restore(&self, state: PrepareState) -> io::Result<()>
                {
                    self.lock_reader().restore(state)
                }

                pub fn clear_screen(&self) -> io::Result<()>
                {
                    self.lock_writer().clear_screen()
                }

                pub fn clear_to_line_end(&self) -> io::Result<()>
                {
                    self.lock_writer().clear_to_line_end()
                }

                pub fn clear_to_screen_end(&self) -> io::Result<()>
                {
                    self.lock_writer().clear_to_screen_end()
                }

                pub fn move_up(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_up(n)?; }
                    Ok(())
                }

                pub fn move_down(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_down(n)?; }
                    Ok(())
                }

                pub fn move_left(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_left(n)?; }
                    Ok(())
                }

                pub fn move_right(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_right(n)?; }
                    Ok(())
                }

                pub fn move_to_first_column(&self) -> io::Result<()>
                {
                    self.lock_writer().move_to_first_column()
                }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()>
                {
                    self.lock_writer().set_cursor_mode(mode)
                }

                pub fn write_char(&self, ch: char) -> io::Result<()>
                {
                    self.write_str(ch.encode_utf8(&mut [0; 4]))
                }

                pub fn write_str(&self, s: &str) -> io::Result<()>
                {
                    self.lock_writer().write_str(s)
                }

                pub fn write_styled
                (
                    &self,
                    fg: Option<Color>, 
                    bg: Option<Color>, 
                    style: Style, 
                    text: &str
                ) -> io::Result<()>
                {
                    self.lock_writer().write_styled(fg, bg, style, text)
                }

                pub fn clear_attributes(&self) -> io::Result<()>
                {
                    self.lock_writer().clear_attributes()
                }

                pub fn set_fg(&self, fg: Option<Color>) -> io::Result<()>
                {
                    self.lock_writer().set_fg(fg)
                }

                pub fn set_bg(&self, bg: Option<Color>) -> io::Result<()>
                {
                    self.lock_writer().set_bg(bg)
                }

                pub fn add_style(&self, style: Style) -> io::Result<()>
                {
                    self.lock_writer().add_style(style)
                }

                pub fn remove_style(&self, style: Style) -> io::Result<()>
                {
                    self.lock_writer().remove_style(style)
                }

                pub fn set_style(&self, style: Style) -> io::Result<()>
                {
                    self.lock_writer().set_style(style)
                }

                pub fn set_theme(&self, theme: Theme) -> io::Result<()>
                {
                    self.lock_writer().set_theme(theme)
                }

                pub fn lock_read(&self) -> LockResult<TerminalReadGuard>
                {
                    map_lock_result
                    (
                        self.reader.lock(), 
                        |r| TerminalReadGuard::new(self, r)
                    )
                }

                pub fn lock_write(&self) -> LockResult<TerminalWriteGuard> 
                { 
                    map_lock_result(self.writer.lock(), |w| TerminalWriteGuard::new(self, w))
                }

                pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard>
                {
                    map_try_lock_result(self.reader.try_lock(), |r| TerminalReadGuard::new(self, r))
                }

                pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard>
                {
                    map_try_lock_result(self.writer.try_lock(), |w| TerminalWriteGuard::new(self, w))
                }

                fn lock_reader(&self) -> TerminalReadGuard
                {
                    self.lock_read().expect("Terminal::lock_reader")
                }

                fn lock_writer(&self) -> TerminalWriteGuard 
                {
                    self.lock_write().expect("Terminal::lock_writer")
                }
            }

            impl Drop for Terminal 
            {
                fn drop(&mut self) 
                {
                    if let Err(e) = self.set_cursor_mode(CursorMode::Normal)
                    {
                        eprintln!("failed to restore terminal: {}", e);
                    }

                    if self.owned_fd
                    {
                        unsafe { close_fd(self.out_fd); }
                    }
                }
            }

            impl<'a> TerminalReadGuard<'a> 
            {
                fn new(term: &'a Terminal, reader: MutexGuard<'a, Reader>) -> TerminalReadGuard<'a>
                {
                    TerminalReadGuard{term, reader}
                }

                pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState>
                {
                    let mut writer = self.term.lock_writer();
                    self.prepare_with_lock(&mut writer, config)
                }

                pub fn prepare_with_lock
                (
                    &mut self, 
                    writer: &mut TerminalWriteGuard,
                    config: PrepareConfig
                ) -> io::Result<PrepareState>
                {
                    use nix::sys::termios::SpecialCharacterIndices::*;

                    let old_tio = tcgetattr(self.term.in_fd).map_err(nix_to_io)?;
                    let mut tio = old_tio.clone();

                    let mut state = PrepareState
                    {
                        old_tio: old_tio.into(),
                        old_sigcont: None,
                        old_sigint: None,
                        old_sigtstp: None,
                        old_sigquit: None,
                        old_sigwinch: None,
                        restore_keypad: false,
                        restore_mouse: false,
                        prev_resume: self.reader.resume,
                    };

                    tio.input_flags.remove
                    (
                        // Disable carriage return/line feed conversion
                        InputFlags::INLCR | InputFlags::ICRNL
                    );

                    tio.local_flags.remove
                    (
                        // Disable canonical mode;
                        LocalFlags::ICANON | LocalFlags::ECHO
                    );

                    // ISIG, when enabled, causes the process to receive signals when Ctrl-C, Ctrl-\, etc. are input
                    if config.block_signals 
                    {
                        tio.local_flags.remove(LocalFlags::ISIG);
                    } 
                    else 
                    {
                        tio.local_flags.insert(LocalFlags::ISIG);
                    }

                    // IXON, when enabled, allows Ctrl-S/Ctrl-Q to suspend and restart inputs
                    if config.enable_control_flow {
                        tio.input_flags.insert(InputFlags::IXON);
                    } else {
                        tio.input_flags.remove(InputFlags::IXON);
                    }

                    // Allow a read to return with 0 characters ready
                    tio.control_chars[VMIN as usize] = 0;
                    // Allow a read to return after 0 deciseconds
                    tio.control_chars[VTIME as usize] = 0;

                    tcsetattr(self.term.in_fd, SetArg::TCSANOW, &tio).map_err(nix_to_io)?;

                    if config.enable_mouse {
                        if writer.enable_mouse(config.always_track_motion)? {
                            state.restore_mouse = true;
                        }
                    }

                    if config.enable_keypad {
                        if writer.enable_keypad()? {
                            state.restore_keypad = true;
                        }
                    }

                    writer.flush()?;

                    let action = SigAction::new(SigHandler::Handler(handle_signal),
                        SaFlags::empty(), SigSet::all());

                    // Continue and Resize are always handled by the internals,
                    // but only reported if requested.
                    state.old_sigcont = Some(unsafe { sigaction(NixSignal::SIGCONT, &action).map_err(nix_to_io)? });
                    state.old_sigwinch = Some(unsafe { sigaction(NixSignal::SIGWINCH, &action).map_err(nix_to_io)? });

                    if config.report_signals.contains(Signal::Interrupt) {
                        state.old_sigint = Some(unsafe { sigaction(NixSignal::SIGINT, &action).map_err(nix_to_io)? });
                    }
                    if config.report_signals.contains(Signal::Suspend) {
                        state.old_sigtstp = Some(unsafe { sigaction(NixSignal::SIGTSTP, &action).map_err(nix_to_io)? });
                    }
                    if config.report_signals.contains(Signal::Quit) {
                        state.old_sigquit = Some(unsafe { sigaction(NixSignal::SIGQUIT, &action).map_err(nix_to_io)? });
                    }

                    self.reader.report_signals = config.report_signals;
                    self.reader.resume = Some(Resume{config});

                    Ok(state)
                }

                pub fn restore(&mut self, state: PrepareState) -> io::Result<()> {
                    let mut writer = self.term.lock_writer();
                    self.restore_with_lock(&mut writer, state)
                }

                pub fn restore_with_lock(&mut self, writer: &mut TerminalWriteGuard,
                        state: PrepareState) -> io::Result<()> {
                    self.reader.resume = state.prev_resume;

                    if state.restore_mouse {
                        writer.disable_mouse()?;
                    }

                    if state.restore_keypad {
                        writer.disable_keypad()?;
                    }

                    writer.flush()?;

                    tcsetattr(self.term.in_fd, SetArg::TCSANOW, &state.old_tio.into()).map_err(nix_to_io)?;

                    unsafe {
                        if let Some(ref old) = state.old_sigcont {
                            sigaction(NixSignal::SIGCONT, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigint {
                            sigaction(NixSignal::SIGINT, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigtstp {
                            sigaction(NixSignal::SIGTSTP, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigquit {
                            sigaction(NixSignal::SIGQUIT, old).map_err(nix_to_io)?;
                        }
                        if let Some(ref old) = state.old_sigwinch {
                            sigaction(NixSignal::SIGWINCH, old).map_err(nix_to_io)?;
                        }
                    }

                    Ok(())
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> {
                    if get_signal().is_some() {
                        return Ok(true);
                    }

                    if peek_event(&self.reader.in_buffer, &self.term.sequences)?.is_some() {
                        return Ok(true);
                    }

                    let mut timeout = timeout.map(to_timeval);

                    let n = loop {
                        let in_fd = self.term.in_fd;

                        let mut r_fds = FdSet::new();
                        r_fds.insert(in_fd);

                        // FIXME: FdSet does not implement Copy or Clone
                        let mut e_fds = FdSet::new();
                        e_fds.insert(in_fd);

                        match select(in_fd + 1,
                                Some(&mut r_fds), None, Some(&mut e_fds), timeout.as_mut()) {
                            Ok(n) => break n,
                            Err(Errno::EINTR) =>
                                if get_signal().is_some() {
                                    return Ok(true);
                                }
                            
                            Err(e) => return Err(nix_to_io(e))
                        }
                    };

                    Ok(n != 0)
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    if let Some(ev) = self.try_read()? {
                        return Ok(Some(ev));
                    }

                    match self.read_into_buffer(timeout)? {
                        Some(Event::Raw(_)) => self.try_read(),
                        Some(Event::Signal(sig)) => {
                            if let Some(ev) = self.handle_signal(sig)? {
                                Ok(Some(ev))
                            } else {
                                Ok(None)
                            }
                        }
                        r => Ok(r)
                    }
                }

                pub fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    if !self.reader.in_buffer.is_empty() {
                        let n = buf.len().min(self.reader.in_buffer.len());
                        buf[..n].copy_from_slice(&self.reader.in_buffer[..n]);

                        let _ = self.reader.in_buffer.drain(..n);

                        return Ok(Some(Event::Raw(n)));
                    }

                    match self.read_input(buf, timeout)? {
                        Some(Event::Signal(sig)) => {
                            if let Some(event) = self.handle_signal(sig)? {
                                Ok(Some(event))
                            } else {
                                Ok(None)
                            }
                        }
                        r => Ok(r)
                    }
                }

                fn read_into_buffer(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    // Temporarily replace the buffer to prevent borrow errors
                    let mut buf = replace(&mut self.reader.in_buffer, Vec::new());

                    buf.reserve(128);

                    let len = buf.len();
                    let cap = buf.capacity();
                    let r;

                    unsafe {
                        buf.set_len(cap);

                        r = self.read_input(&mut buf[len..], timeout);

                        match r {
                            Ok(Some(Event::Raw(n))) => buf.set_len(len + n),
                            _ => buf.set_len(len)
                        }
                    }

                    // Restore the buffer before returning
                    self.reader.in_buffer = buf;

                    r
                }

                fn read_input(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    // Check for a signal that may have already arrived.
                    if let Some(sig) = take_signal() {
                        return Ok(Some(Event::Signal(sig)));
                    }

                    if !self.wait_event(timeout)? {
                        return Ok(None);
                    }

                    // Check for a signal again after waiting
                    if let Some(sig) = take_signal() {
                        return Ok(Some(Event::Signal(sig)));
                    }

                    loop {
                        match read(self.term.in_fd, buf) {
                            Ok(n) => break Ok(Some(Event::Raw(n))),
                            Err(Errno::EINTR) => {
                                if let Some(sig) = take_signal() {
                                    return Ok(Some(Event::Signal(sig)));
                                }
                            }
                            Err(e) => return Err(nix_to_io(e))
                        }
                    }
                }

                fn try_read(&mut self) -> io::Result<Option<Event>> {
                    let in_buffer = &mut self.reader.in_buffer;

                    if in_buffer.is_empty() {
                        Ok(None)
                    } else {
                        match peek_event(&in_buffer, &self.term.sequences) {
                            Ok(Some((ev, n))) => {
                                let _ = in_buffer.drain(..n);
                                Ok(Some(ev))
                            }
                            Ok(None) => Ok(None),
                            Err(e) => Err(e)
                        }
                    }
                }

                fn handle_signal(&mut self, sig: Signal) -> io::Result<Option<Event>> {
                    match sig {
                        Signal::Continue => {
                            self.resume()?;
                        }
                        Signal::Resize => {
                            let size = self.term.size()?;
                            return Ok(Some(Event::Resize(size)));
                        }
                        _ => ()
                    }

                    if self.reader.report_signals.contains(sig) {
                        Ok(Some(Event::Signal(sig)))
                    } else {
                        Ok(None)
                    }
                }

                fn resume(&mut self) -> io::Result<()> {
                    if let Some(resume) = self.reader.resume {
                        let _ = self.prepare(resume.config)?;
                    }
                    Ok(())
                }
            }

            macro_rules! expand_opt 
            {
                ( $slf:expr , $cap:path ) => 
                { 
                    {
                        if let Some(cap) = $slf.term.info.get::<$cap>()
                        {
                            $slf.expand(cap.expand())
                        } 
                        else 
                        {
                            Ok(())
                        }
                    } 
                };

                ( $slf:expr , $cap:path , |$ex:ident| $expansion:expr ) => 
                { {
                    if let Some(cap) = $slf.term.info.get::<$cap>()
                    {
                        let $ex = cap.expand();
                        $slf.expand($expansion)
                    } 
                    else 
                    {
                        Ok(())
                    }
                } }
            }

            macro_rules! expand_req
            {
                ( $slf:expr , $cap:path , $name:expr ) => 
                {{
                    $slf.term.info.get::<$cap>()
                    .ok_or_else(|| not_supported($name))
                    .and_then(|cap| $slf.expand(cap.expand()))
                }};

                ( $slf:expr , $cap:path , $name:expr , |$ex:ident| $expansion:expr ) => 
                {{
                    $slf.term.info.get::<$cap>()
                    .ok_or_else(|| not_supported($name))
                    .and_then(|cap| 
                    {
                            let $ex = cap.expand();
                            $slf.expand($expansion)
                    })
                }}
            }

            impl<'a> TerminalWriteGuard<'a> 
            {
                fn new(term: &'a Terminal, writer: MutexGuard<'a, Writer>) -> TerminalWriteGuard<'a>
                {
                    TerminalWriteGuard{term, writer}
                }

                pub fn size(&self) -> io::Result<Size>
                {
                    get_winsize(self.term.out_fd)
                }

                fn disable_keypad(&mut self) -> io::Result<()>
                {
                    if let Some(local) = self.term.info.get::<cap::KeypadLocal>()
                    {
                        self.expand(local.expand())?;
                    }

                    Ok(())
                }

                fn enable_keypad(&mut self) -> io::Result<bool>
                {
                    if let Some(xmit) = self.term.info.get::<cap::KeypadXmit>()
                    {
                        self.expand(xmit.expand())?;
                        Ok(true)
                    }
                    
                    else 
                    { Ok(false) }
                }

                fn disable_mouse(&mut self) -> io::Result<()>
                {
                    self.write_bytes(XTERM_DISABLE_MOUSE.as_bytes())?;
                    self.write_bytes(XTERM_DISABLE_MOUSE_MOTION.as_bytes())
                }

                fn enable_mouse(&mut self, track_motion: bool) -> io::Result<bool>
                {
                    if self.term.is_xterm()
                    {
                        self.write_bytes(XTERM_ENABLE_MOUSE.as_bytes())?;
                        if track_motion
                        {
                            self.write_bytes(XTERM_ENABLE_MOUSE_MOTION.as_bytes())?;
                        }

                        Ok(true)
                    } 
                    else
                    {
                        Ok(false)
                    }
                }

                fn enter_screen(&mut self) -> io::Result<()>
                {
                    match 
                    (
                        self.term.info.get::<cap::EnterCaMode>(),
                        self.term.info.get::<cap::ChangeScrollRegion>(),
                        self.term.info.get::<cap::CursorHome>()
                    )
                    {
                        (enter, Some(scroll), Some(home)) => 
                        {
                            let size = self.size()?;

                            if let Some(enter) = enter 
                            {
                                self.expand(enter.expand())?;
                            }

                            self.expand(scroll.expand().parameters(0, to_u32(size.lines - 1)))?;
                            self.expand(home.expand())?;
                        }
                        (_, None, _) => return Err(not_supported("change_scroll_region")),
                        (_, _, None) => return Err(not_supported("cursor_home")),
                    }

                    self.clear_attributes()?;
                    self.clear_screen()?;
                    Ok(())
                }

                fn exit_screen(&mut self) -> io::Result<()>
                {
                    if let Some(exit) = self.term.info.get::<cap::ExitCaMode>()
                    {
                        self.expand(exit.expand())?;
                        self.flush()?;
                    }

                    Ok(())
                }

                pub fn clear_attributes(&mut self) -> io::Result<()>
                {
                    if self.writer.fg.is_some() || self.writer.bg.is_some() || !self.writer.cur_style.is_empty()
                    {
                        self.writer.fg = None;
                        self.writer.bg = None;
                        self.writer.cur_style = Style::empty();
                        expand_opt!(self, cap::ExitAttributeMode)?;
                    }

                    Ok(())
                }

                pub fn set_fg(&mut self, fg: Option<Color>) -> io::Result<()> 
                {
                    if self.writer.fg == fg
                    {
                        Ok(())
                    } 
                    else
                    {
                        if let Some(fg) = fg 
                        {
                            self.set_fg_color(fg)?;
                        } 
                        else
                        {
                            self.clear_fg()?;
                        }

                        self.writer.fg = fg;
                        Ok(())
                    }
                }

                pub fn set_bg(&mut self, bg: Option<Color>) -> io::Result<()>
                {
                    if self.writer.bg == bg 
                    {
                        Ok(())
                    } 
                    else
                    {
                        if let Some(bg) = bg 
                        {
                            self.set_bg_color(bg)?;
                        } 
                        else
                        {
                            self.clear_bg()?;
                        }

                        self.writer.bg = bg;
                        Ok(())
                    }
                }

                pub fn add_style(&mut self, style: Style) -> io::Result<()>
                {
                    let add = style - self.writer.cur_style;

                    if add.contains(Style::BOLD){ expand_opt!(self, cap::EnterBoldMode)?; }
                    if add.contains(Style::ITALIC){ expand_opt!(self, cap::EnterItalicsMode)?; }
                    if add.contains(Style::REVERSE){ expand_opt!(self, cap::EnterReverseMode)?; }
                    if add.contains(Style::UNDERLINE){ expand_opt!(self, cap::EnterUnderlineMode)?; }
                    self.writer.cur_style |= add;
                    Ok(())
                }

                pub fn remove_style(&mut self, style: Style) -> io::Result<()>
                {
                    let remove = style & self.writer.cur_style;
                    if remove.intersects(Style::BOLD | Style::REVERSE)
                    {
                        // terminfo does not contain entries to remove bold or reverse.
                        // Instead, we must reset all attributes.
                        let new_style = self.writer.cur_style - remove;
                        let fg = self.writer.fg;
                        let bg = self.writer.bg;
                        self.clear_attributes()?;
                        self.add_style(new_style)?;
                        self.set_fg(fg)?;
                        self.set_bg(bg)?;
                    }
                    else
                    {
                        if remove.contains( Style::ITALIC ){ expand_opt!(self, cap::ExitItalicsMode)?; }
                        if remove.contains( Style::UNDERLINE ){ expand_opt!(self, cap::ExitUnderlineMode)?; }
                        self.writer.cur_style -= remove;
                    }

                    Ok(())
                }

                pub fn set_style(&mut self, style: Style) -> io::Result<()>
                {
                    let add = style - self.writer.cur_style;
                    let remove = self.writer.cur_style - style;
                    if remove.intersects(Style::BOLD | Style::REVERSE)
                    {
                        // terminfo does not contain entries to remove bold or reverse.
                        // Instead, we must reset all attributes.
                        let fg = self.writer.fg;
                        let bg = self.writer.bg;
                        self.clear_attributes()?;
                        self.set_fg(fg)?;
                        self.set_bg(bg)?;
                        self.add_style(style)?;
                    } 
                    else
                    {
                        self.add_style(add)?;
                        self.remove_style(remove)?;
                    }

                    Ok(())
                }

                pub fn set_theme(&mut self, theme: Theme) -> io::Result<()>
                {
                    self.set_attrs(theme.fg, theme.bg, theme.style)
                }

                pub fn set_attrs(&mut self, fg: Option<Color>, bg: Option<Color>, style: Style) -> io::Result<()>
                {
                    if (self.writer.fg.is_some() && fg.is_none()) || (self.writer.bg.is_some() && bg.is_none())
                    {
                        self.clear_attributes()?;
                    }

                    self.set_style(style)?;
                    self.set_fg(fg)?;
                    self.set_bg(bg)?;

                    Ok(())
                }

                fn clear_fg(&mut self) -> io::Result<()>
                {
                    let bg = self.writer.bg;
                    let style = self.writer.cur_style;

                    self.clear_attributes()?;
                    self.set_bg(bg)?;
                    self.set_style(style)
                }

                fn clear_bg(&mut self) -> io::Result<()>
                {
                    let fg = self.writer.fg;
                    let style = self.writer.cur_style;

                    self.clear_attributes()?;
                    self.set_fg(fg)?;
                    self.set_style(style)
                }

                fn set_fg_color(&mut self, fg: Color) -> io::Result<()>
                {
                    expand_opt!(self, cap::SetAForeground,
                        |ex| ex.parameters(color_code(fg)))
                }

                fn set_bg_color(&mut self, bg: Color) -> io::Result<()>
                {
                    expand_opt!(self, cap::SetABackground,
                        |ex| ex.parameters(color_code(bg)))
                }

                pub fn clear_screen(&mut self) -> io::Result<()>
                {
                    expand_req!(self, cap::ClearScreen, "clear_screen")
                }

                pub fn clear_to_line_end(&mut self) -> io::Result<()>
                {
                    expand_req!(self, cap::ClrEol, "clr_eol")
                }

                pub fn clear_to_screen_end(&mut self) -> io::Result<()>
                {
                    expand_req!(self, cap::ClrEos, "clr_eos")
                }

                pub fn move_up(&mut self, n: usize) -> io::Result<()>
                {
                    if n == 1 
                    {
                        expand_req!(self, cap::CursorUp, "cursor_up")?;
                    } 
                    else if n != 0
                    {
                        expand_req!(self, cap::ParmUpCursor, "parm_cursor_up", |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_down(&mut self, n: usize) -> io::Result<()>
                {
                    // Always use ParmDownCursor.
                    if n != 0 
                    {
                        expand_req!(self, cap::ParmDownCursor, "parm_cursor_down",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_left(&mut self, n: usize) -> io::Result<()>
                {
                    if n == 1 {
                        expand_req!(self, cap::CursorLeft, "cursor_left")?;
                    } else if n != 0 {
                        expand_req!(self, cap::ParmLeftCursor, "parm_cursor_left",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_right(&mut self, n: usize) -> io::Result<()> 
                {
                    if n == 1 {
                        expand_req!(self, cap::CursorRight, "cursor_right")?;
                    } else if n != 0 {
                        expand_req!(self, cap::ParmRightCursor, "parm_cursor_right",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_to_first_column(&mut self) -> io::Result<()>
                {
                    self.write_bytes(b"\r")
                }

                pub fn move_cursor(&mut self, pos: Cursor) -> io::Result<()>
                {
                    match (self.term.info.get::<cap::CursorAddress>(),
                            self.term.info.get::<cap::CursorHome>()) {
                        (_, Some(ref home)) if pos == Cursor::default() => {
                            self.expand(home.expand())?;
                        }
                        (Some(addr), _) => {
                            self.expand(addr.expand()
                                .parameters(to_u32(pos.line), to_u32(pos.column)))?;
                        }
                        (None, _) => return Err(not_supported("cursor_address"))
                    }

                    Ok(())
                }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>
                {
                    match mode {
                        CursorMode::Normal | CursorMode::Overwrite => {
                            // Overwrite is not supported by Unix terminals.
                            // We set to normal in this case as it will reverse
                            // a setting of Invisible
                            expand_opt!(self, cap::CursorNormal)?;
                        }
                        CursorMode::Invisible => {
                            expand_opt!(self, cap::CursorInvisible)?;
                        }
                    }

                    Ok(())
                }

                pub fn write_char(&mut self, ch: char) -> io::Result<()>
                {
                    self.write_str(ch.encode_utf8(&mut [0; 4]))
                }

                pub fn write_str(&mut self, s: &str) -> io::Result<()>
                {
                    self.write_bytes(s.as_bytes())
                }

                pub fn write_styled(&mut self, fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                -> io::Result<()> 
                {
                    self.set_attrs(fg, bg, style)?;

                    self.write_str(text)?;
                    self.clear_attributes()
                }

                fn write_bytes(&mut self, buf: &[u8]) -> io::Result<()>
                {
                    if buf.len() + self.writer.out_buffer.len() > self.writer.out_buffer.capacity() {
                        self.flush()?;
                    }

                    if buf.len() > self.writer.out_buffer.capacity() {
                        self.write_data(buf).1
                    } else {
                        self.writer.out_buffer.extend(buf);
                        Ok(())
                    }
                }

                pub fn flush(&mut self) -> io::Result<()>
                {
                    let (n, res) = self.write_data(&self.writer.out_buffer);
                    self.writer.out_buffer.drain(..n);
                    res
                }

                fn write_data(&self, buf: &[u8]) -> (usize, io::Result<()>)
                {
                    let mut offset = 0;

                    let r = loop {
                        if offset == buf.len() {
                            break Ok(());
                        }

                        match write(self.term.out_fd, buf) {
                            Ok(0) => break Err(io::Error::from(io::ErrorKind::WriteZero)),
                            Ok(n) => offset += n,
                            Err(Errno::EINTR) => continue,
                            Err(e) => break Err(nix_to_io(e))
                        }
                    };

                    (offset, r)
                }

                fn expand<T: AsRef<[u8]>>(&mut self, exp: Expansion<T>) -> io::Result<()>
                {
                    let writer = &mut *self.writer;
                    exp
                        .with(&mut writer.context)
                        .to(&mut writer.out_buffer)
                        .map_err(ti_to_io)
                }
            }

            impl<'a> Drop for TerminalWriteGuard<'a>
            {
                fn drop(&mut self)
                {
                    if let Err(e) = self.flush() {
                        eprintln!("failed to flush terminal: {}", e);
                    }
                }
            }

            impl Writer
            {
                fn new() -> Writer
                {
                    Writer
                    {
                        context: Context::default(),
                        out_buffer: Vec::with_capacity(OUT_BUFFER_SIZE),
                        fg: None,
                        bg: None,
                        cur_style: Style::empty(),
                    }
                }
            }

            fn is_xterm(name: &str) -> bool 
            {
                // Includes such terminal names as "xterm-256color"
                name == "xterm" || name.starts_with("xterm-")
            }

            fn sequences(info: &Database) -> SeqMap
            {
                let mut sequences = SequenceMap::new();

                macro_rules! add 
                {
                    ( $seq:ty , $key:expr ) => { {
                        if let Some(seq) = info.get::<$seq>() {
                            if let Some(s) = ascii_str(seq.as_ref()) {
                                sequences.insert(s.into(), SeqData::Key($key));
                            }
                        }
                    } }
                }

                add!(cap::KeyUp,        Key::Up);
                add!(cap::KeyDown,      Key::Down);
                add!(cap::KeyLeft,      Key::Left);
                add!(cap::KeyRight,     Key::Right);
                add!(cap::KeyHome,      Key::Home);
                add!(cap::KeyEnd,       Key::End);
                add!(cap::KeyNPage,     Key::PageDown);
                add!(cap::KeyPPage,     Key::PageUp);
                add!(cap::KeyDc,        Key::Delete);
                add!(cap::KeyIc,        Key::Insert);
                add!(cap::KeyF1,        Key::F(1));
                add!(cap::KeyF2,        Key::F(2));
                add!(cap::KeyF3,        Key::F(3));
                add!(cap::KeyF4,        Key::F(4));
                add!(cap::KeyF5,        Key::F(5));
                add!(cap::KeyF6,        Key::F(6));
                add!(cap::KeyF7,        Key::F(7));
                add!(cap::KeyF8,        Key::F(8));
                add!(cap::KeyF9,        Key::F(9));
                add!(cap::KeyF10,       Key::F(10));
                add!(cap::KeyF11,       Key::F(11));
                add!(cap::KeyF12,       Key::F(12));

                if is_xterm(info.name())
                {
                    sequences.insert(XTERM_MOUSE_INTRO.into(), SeqData::XTermMouse);
                }

                sequences
            }

            pub struct PrepareState
            {
                old_tio: termios,
                old_sigcont: Option<SigAction>,
                old_sigint: Option<SigAction>,
                old_sigtstp: Option<SigAction>,
                old_sigquit: Option<SigAction>,
                old_sigwinch: Option<SigAction>,
                restore_keypad: bool,
                restore_mouse: bool,
                prev_resume: Option<Resume>,
            }

            #[derive(Copy, Clone, Debug)]
            struct Resume
            {
                config: PrepareConfig,
            }

            unsafe fn close_fd(fd: RawFd)
            {
                drop(File::from_raw_fd(fd));
            }

            fn open_rw<P: AsRef<Path>>(path: P) -> io::Result<RawFd>
            {
                use std::fs::OpenOptions;

                let file = OpenOptions::new()
                    .read(true)
                    .write(true)
                    .open(path)?;

                Ok(file.into_raw_fd())
            }

            #[repr(C)]
            struct Winsize 
            {
                ws_row: c_ushort,
                ws_col: c_ushort,
                ws_xpixel: c_ushort,
                ws_ypixel: c_ushort,
            }

            fn get_winsize(fd: c_int) -> io::Result<Size> 
            {
                let mut winsz: Winsize = unsafe { zeroed() };

                // `TIOCGWINSZ.into()` is a workaround to a bug in the libc crate:
                //  https://github.com/rust-lang/libc/pull/704
                let res = unsafe { ioctl(fd, TIOCGWINSZ.into(), &mut winsz) };

                if res == -1 {
                    Err(io::Error::last_os_error())
                } else {
                    let size = Size{
                        lines: winsz.ws_row as usize,
                        columns: winsz.ws_col as usize,
                    };

                    Ok(size)
                }
            }

            fn nix_to_io(e: nix::Error) -> io::Error 
            {
                io::Error::from_raw_os_error(e as i32)
            }

            fn ti_to_io(e: terminfo::Error) -> io::Error 
            {
                match e
                {
                    terminfo::Error::Io(e) => e,
                    terminfo::Error::NotFound => io::Error::new(
                        io::ErrorKind::NotFound, "terminfo entry not found"),
                    terminfo::Error::Parse => io::Error::new(
                        io::ErrorKind::Other, "failed to parse terminfo entry"),
                    terminfo::Error::Expand(_) => io::Error::new(
                        io::ErrorKind::Other, "failed to expand terminfo entry"),
                }
            }

            fn to_timeval(d: Duration) -> TimeVal
            {
                const MAX_SECS: i64 = i64::max_value() / 1_000;

                let secs = match d.as_secs() {
                    n if n > MAX_SECS as u64 => MAX_SECS,
                    n => n as i64,
                };

                let millis = d.subsec_millis() as i64;

                TimeVal::milliseconds(secs * 1_000 + millis)
            }

            fn peek_event(buf: &[u8], sequences: &SeqMap) 
            -> io::Result<Option<(Event, usize)>> 
            {
                let (res, n) = {
                    let s = utf8_prefix(buf)?;

                    if s.is_empty() {
                        return Ok(None);
                    }

                    let mut last_match = None;

                    for pfx in prefixes(s) {
                        match sequences.find(pfx) {
                            FindResult::NotFound => break,
                            FindResult::Found(value) => {
                                last_match = Some((pfx, *value));
                                break;
                            }
                            FindResult::Incomplete => (),
                            FindResult::Undecided(value) => {
                                last_match = Some((pfx, *value));
                            }
                        }
                    }

                    let res = last_match.and_then(|(seq, value)| {
                        match value {
                            SeqData::Key(key) => Some((Event::Key(key), seq.len())),
                            SeqData::XTermMouse => {
                                if let Some((data, len)) = parse_mouse_data(&buf[seq.len()..]) {
                                    Some((Event::Mouse(data), seq.len() + len))
                                } else {
                                    // Input sequence was incomplete
                                    None
                                }
                            }
                        }
                    });

                    if let Some(res) = res {
                        res
                    } else {
                        let ch = s.chars().next().unwrap();
                        (Event::Key(ch.into()), ch.len_utf8())
                    }
                };

                Ok(Some((res, n)))
            }

            fn parse_mouse_data(mut buf: &[u8]) -> Option<(MouseEvent, usize)>
            {
                let orig_len = buf.len();

                let (mut input, end) = parse_integer(&mut buf)?;

                if end != b';' {
                    return None;
                }

                let (column, end) = parse_integer(&mut buf)?;

                if end != b';' {
                    return None;
                }

                let (line, end) = parse_integer(&mut buf)?;

                let is_pressed = match end {
                    b'M' => true,
                    b'm' => false,
                    _ => return None
                };

                let mut mods = ModifierState::empty();

                if (input & XTERM_SHIFT_MASK) != 0 {
                    mods |= ModifierState::SHIFT;
                }
                if (input & XTERM_META_MASK) != 0 {
                    mods |= ModifierState::ALT;
                }
                if (input & XTERM_CTRL_MASK) != 0 {
                    mods |= ModifierState::CTRL;
                }

                input &= !XTERM_MODIFIER_MASK;

                let input = match input {
                    0 ..= 3 => mouse_button_event(input, is_pressed),
                    64 => MouseInput::WheelUp,
                    65 => MouseInput::WheelDown,
                    _ => MouseInput::Motion,
                };

                let position = Cursor{
                    // Parsed line and column begin at 1; we begin at 0
                    line: (line - 1) as usize,
                    column: (column - 1) as usize,
                };

                Some((MouseEvent{
                    position,
                    input,
                    modifiers: mods,
                }, orig_len - buf.len()))
            }

            fn parse_integer(buf: &mut &[u8]) -> Option<(u32, u8)>
            {
                let mut n = 0u32;
                let mut iter = buf.iter();

                while let Some(&b) = iter.next() {
                    match b {
                        b'0' ..= b'9' => {
                            n = n.checked_mul(10)?
                                .checked_add((b - b'0') as u32)?;
                        }
                        _ => {
                            *buf = iter.as_slice();
                            return Some((n, b));
                        }
                    }
                }

                None
            }

            fn mouse_button_event(input: u32, is_pressed: bool) -> MouseInput
            {
                let button = match input {
                    0 => MouseButton::Left,
                    1 => MouseButton::Middle,
                    2 => MouseButton::Right,
                    _ => MouseButton::Other(input)
                };

                if is_pressed {
                    MouseInput::ButtonPressed(button)
                } else {
                    MouseInput::ButtonReleased(button)
                }
            }

            fn utf8_prefix(buf: &[u8]) -> io::Result<&str>
            {
                match from_utf8(buf) {
                    Ok(s) => Ok(s),
                    Err(e) => {
                        if e.valid_up_to() != 0 {
                            from_utf8(&buf[..e.valid_up_to()])
                                .map_err(|_| unreachable!())
                        } else if e.error_len().is_some() {
                            Err(io::Error::new(io::ErrorKind::Other,
                                "read invalid utf-8 data from terminal"))
                        } else {
                            Ok("")
                        }
                    }
                }
            }

            fn conv_signal(sig: c_int) -> Option<Signal>
            {
                match NixSignal::try_from(sig).ok() {
                    Some(NixSignal::SIGCONT)  => Some(Signal::Continue),
                    Some(NixSignal::SIGINT)   => Some(Signal::Interrupt),
                    Some(NixSignal::SIGQUIT)  => Some(Signal::Quit),
                    Some(NixSignal::SIGTSTP)  => Some(Signal::Suspend),
                    Some(NixSignal::SIGWINCH) => Some(Signal::Resize),
                    _ => None
                }
            }

            fn get_signal() -> Option<Signal>
            {
                conv_signal(LAST_SIGNAL.load(Ordering::Relaxed) as c_int)
            }

            fn take_signal() -> Option<Signal>
            {
                conv_signal(LAST_SIGNAL.swap(0, Ordering::Relaxed) as c_int)
            }

            fn ascii_str(s: &[u8]) -> Option<&str>
            {
                use std::str::from_utf8_unchecked;

                if s.is_ascii() {
                    Some(unsafe { from_utf8_unchecked(s) })
                } else {
                    None
                }
            }

            fn color_code(color: Color) -> u8
            {
                match color {
                    Color::Black =>     0,
                    Color::Red =>       1,
                    Color::Green =>     2,
                    Color::Yellow =>    3,
                    Color::Blue =>      4,
                    Color::Magenta =>   5,
                    Color::Cyan =>      6,
                    Color::White =>     7,
                }
            }

            fn not_supported(op: &str) -> io::Error
            {
                io::Error::new(io::ErrorKind::Other,
                    format!("operation not supported: {}", op))
            }
            
            fn to_u32(u: usize) -> u32 
            {
                if u > u32::max_value() as usize 
                {
                    u32::max_value()
                } 
                else 
                {
                    u as u32
                }
            }
        }
    }
    pub use self::sys::ext as unix;
}
/*
*/
pub mod linefeed
{
    //! Provides a configurable, concurrent, extensible, interactive input reader for Unix terminals and Windows console.
    pub use self::command::Command;
    pub use self::complete::{Completer, Completion, Suffix};
    pub use self::function::Function;
    pub use self::interface::Interface;
    pub use self::prompter::Prompter;
    pub use self::reader::{Reader, ReadResult};
    pub use self::terminal::{DefaultTerminal, Signal, Terminal};
    pub use self::writer::Writer;
    /*
    */
    pub mod chars
    {
        //! Provides utilities for manipulating character values
        // This is technically configurable on Unix, but exposing that information
        // from the low-level terminal interface and storing it in Reader is a pain.
        // Does anyone even care?
        /// Character value indicating end-of-file
        pub const EOF: char = '\x04';

        /// Character value generated by the Escape key
        pub const ESCAPE: char = '\x1b';

        /// Character value generated by the Backspace key
        ///
        /// On Unix systems, this is equivalent to `RUBOUT`
        #[cfg(unix)]
        pub const DELETE: char = RUBOUT;

        /// Character value generated by the Backspace key
        ///
        /// On Windows systems, this character is Ctrl-H
        #[cfg(windows)]
        pub const DELETE: char = '\x08';

        /// Character value generated by the Backspace key on some systems
        pub const RUBOUT: char = '\x7f';

        /// Returns a character name as a key sequence, e.g. `Control-x` or `Meta-x`.
        ///
        /// Returns `None` if the name is invalid.
        pub fn parse_char_name(name: &str) -> Option<String> {
            let name_lc = name.to_lowercase();

            let is_ctrl = contains_any(&name_lc, &["c-", "ctrl-", "control-"]);
            let is_meta = contains_any(&name_lc, &["m-", "meta-"]);

            let name = match name_lc.rfind('-') {
                Some(pos) => &name_lc[pos + 1..],
                None => &name_lc[..]
            };

            let ch = match name {
                "del" | "rubout"  => DELETE,
                "esc" | "escape"  => ESCAPE,
                "lfd" | "newline" => '\n',
                "ret" | "return"  => '\r',
                "spc" | "space"   => ' ',
                "tab"             => '\t',
                s if !s.is_empty() => s.chars().next().unwrap(),
                _ => return None
            };

            let ch = match (is_ctrl, is_meta) {
                (true,  true)  => meta(ctrl(ch)),
                (true,  false) => ctrl(ch).to_string(),
                (false, true)  => meta(ch),
                (false, false) => ch.to_string(),
            };

            Some(ch)
        }

        /// Returns a character sequence escaped for user-facing display.
        ///
        /// Escape is formatted as `\e`.
        /// Control key combinations are prefixed with `\C-`.
        pub fn escape_sequence(s: &str) -> String {
            let mut res = String::with_capacity(s.len());

            for ch in s.chars() {
                match ch {
                    ESCAPE => res.push_str(r"\e"),
                    RUBOUT => res.push_str(r"\C-?"),
                    '\\' => res.push_str(r"\\"),
                    '\'' => res.push_str(r"\'"),
                    '"' => res.push_str(r#"\""#),
                    ch if is_ctrl(ch) => {
                        res.push_str(r"\C-");
                        res.push(unctrl_lower(ch));
                    }
                    ch => res.push(ch)
                }
            }

            res
        }

        /// Returns a meta sequence for the given character.
        pub fn meta(ch: char) -> String {
            let mut s = String::with_capacity(ch.len_utf8() + 1);
            s.push(ESCAPE);
            s.push(ch);
            s
        }

        fn contains_any(s: &str, strs: &[&str]) -> bool {
            strs.iter().any(|a| s.contains(a))
        }

        /// Returns whether the character is printable.
        ///
        /// That is, not NUL or a control character (other than Tab or Newline).
        pub fn is_printable(c: char) -> bool {
            c == '\t' || c == '\n' || !(c == '\0' || is_ctrl(c))
        }

        const CTRL_BIT: u8 = 0x40;
        const CTRL_MASK: u8 = 0x1f;

        /// Returns whether the given character is a control character.
        pub fn is_ctrl(c: char) -> bool {
            const CTRL_MAX: u32 = 0x1f;

            c != '\0' && c as u32 <= CTRL_MAX
        }

        /// Returns a control character for the given character.
        pub fn ctrl(c: char) -> char {
            ((c as u8) & CTRL_MASK) as char
        }

        /// Returns the printable character corresponding to the given control character.
        pub fn unctrl(c: char) -> char {
            ((c as u8) | CTRL_BIT) as char
        }

        /// Returns the lowercase character corresponding to the given control character.
        pub fn unctrl_lower(c: char) -> char {
            unctrl(c).to_ascii_lowercase()
        }
    }
    /*
    */
    pub mod command
    {
        //! Defines the set of line editing commands

        use std::borrow::Cow::{self, Borrowed, Owned};
        use std::fmt;

        use crate::chars::escape_sequence;

        macro_rules! define_commands {
            ( $( #[$meta:meta] $name:ident => $str:expr , )+ ) => {
                /// Represents a command to modify `Reader` state
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub enum Command {
                    $( #[$meta] $name , )+
                    /// Custom application-defined command
                    Custom(Cow<'static, str>),
                    /// Execute a given key sequence
                    Macro(Cow<'static, str>),
                }

                /// List of all command names
                pub static COMMANDS: &[&str] = &[ $( $str ),+ ];

                impl fmt::Display for Command {
                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                        match *self {
                            $( Command::$name => f.write_str($str) , )+
                            Command::Custom(ref s) => f.write_str(s),
                            Command::Macro(ref s) => write!(f, "\"{}\"",
                                escape_sequence(s))
                        }
                    }
                }

                impl Command {
                    /// Constructs a command from a `'static str` reference.
                    ///
                    /// If the string does not refer to a built-in command, a value
                    /// of `Command::Custom(Borrowed(name))` will be returned.
                    pub fn from_str(name: &'static str) -> Command {
                        Command::opt_from_str(name)
                            .unwrap_or_else(|| Command::Custom(Borrowed(name)))
                    }

                    /// Constructs a command from a non-`'static` string-like type.
                    ///
                    /// If the string does not refer to a built-in command, a value
                    /// of `Command::Custom(Owned(name.into()))` will be returned.
                    pub fn from_string<T>(name: T) -> Command
                            where T: AsRef<str> + Into<String> {
                        Command::opt_from_str(name.as_ref())
                            .unwrap_or_else(|| Command::Custom(Owned(name.into())))
                    }

                    fn opt_from_str(s: &str) -> Option<Command> {
                        match s {
                            $( $str => Some(Command::$name), )+
                            _ => None
                        }
                    }
                }
            }
        }

        define_commands!{
            /// Abort history search
            Abort => "abort",
            /// Accepts the current input line
            AcceptLine => "accept-line",
            /// Perform completion
            Complete => "complete",
            /// Insert all completions into the input buffer
            InsertCompletions => "insert-completions",
            /// Show possible completions
            PossibleCompletions => "possible-completions",
            /// Insert the next possible completion
            MenuComplete => "menu-complete",
            /// Insert the previous possible completion
            MenuCompleteBackward => "menu-complete-backward",
            /// Begin numeric argument input
            DigitArgument => "digit-argument",
            /// Insert character or sequence at the cursor
            SelfInsert => "self-insert",
            /// Inserts a tab character
            TabInsert => "tab-insert",
            /// Toggles insert/overwrite mode
            OverwriteMode => "overwrite-mode",
            /// Insert a comment and accept input
            InsertComment => "insert-comment",
            /// Move the cursor backward one character
            BackwardChar => "backward-char",
            /// Move the cursor forward one character
            ForwardChar => "forward-char",
            /// Search for a given character
            CharacterSearch => "character-search",
            /// Search backward for a given character
            CharacterSearchBackward => "character-search-backward",
            /// Move the cursor backward one word
            BackwardWord => "backward-word",
            /// Move the cursor forward one word
            ForwardWord => "forward-word",
            /// Kill all characters before the cursor
            BackwardKillLine => "backward-kill-line",
            /// Kill all characters after the cursor
            KillLine => "kill-line",
            /// Kill a word before the cursor
            BackwardKillWord => "backward-kill-word",
            /// Kill a word after the cursor
            KillWord => "kill-word",
            /// Kill a word before the cursor, delimited by whitespace
            UnixWordRubout => "unix-word-rubout",
            /// Clear the screen
            ClearScreen => "clear-screen",
            /// Move the cursor to the beginning of the line
            BeginningOfLine => "beginning-of-line",
            /// Move the cursor to the end of the line
            EndOfLine => "end-of-line",
            /// Delete one character before the cursor
            BackwardDeleteChar => "backward-delete-char",
            /// Delete one character after the cursor
            DeleteChar => "delete-char",
            /// Drag the character before the cursor forward
            TransposeChars => "transpose-chars",
            /// Drag the word before the cursor forward
            TransposeWords => "transpose-words",
            /// Move to the first line of history
            BeginningOfHistory => "beginning-of-history",
            /// Move to the last line of history
            EndOfHistory => "end-of-history",
            /// Select next line in history
            NextHistory => "next-history",
            /// Select previous line in history
            PreviousHistory => "previous-history",
            /// Incremental search in history
            ForwardSearchHistory => "forward-search-history",
            /// Incremental reverse search in history
            ReverseSearchHistory => "reverse-search-history",
            /// Non-incremental forward history search using input up to the cursor
            HistorySearchForward => "history-search-forward",
            /// Non-incremental backward history search using input up to the cursor
            HistorySearchBackward => "history-search-backward",
            /// Insert literal character
            QuotedInsert => "quoted-insert",
            /// Insert text into buffer from the kill ring
            Yank => "yank",
            /// Rotate the kill ring and yank the new top
            YankPop => "yank-pop",
        }

        /// Describes the category of a command
        ///
        /// A command's category determines how particular operations behave
        /// in succession.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Category {
            /// Completion command
            Complete,
            /// Kill command
            Kill,
            /// Non-incremental search command
            Search,
            /// Incremental search command
            IncrementalSearch,
            /// Yank command
            Yank,
            /// Digit argument command
            Digit,
            /// Other command
            Other,
        }

        impl Command {
            /// Returns the category of the command
            pub fn category(&self) -> Category {
                use self::Command::*;

                match *self {
                    DigitArgument => Category::Digit,
                    Complete | InsertCompletions | PossibleCompletions |
                        MenuComplete | MenuCompleteBackward => Category::Complete,
                    BackwardKillLine | KillLine | BackwardKillWord | KillWord |
                        UnixWordRubout => Category::Kill,
                    ForwardSearchHistory | ReverseSearchHistory => Category::IncrementalSearch,
                    HistorySearchForward | HistorySearchBackward => Category::Search,
                    Yank | YankPop => Category::Yank,
                    _ => Category::Other
                }
            }
        }
    }
    /*
    */
    pub mod complete
    {
        //! Provides utilities for implementing word completion
        use std::borrow::Cow::{self, Borrowed, Owned};
        use std::fs::read_dir;
        use std::path::{is_separator, MAIN_SEPARATOR};

        use crate::prompter::Prompter;
        use crate::terminal::Terminal;

        /// Represents a single possible completion
        #[derive(Clone, Debug)]
        pub struct Completion {
            /// Whole completion text
            pub completion: String,
            /// Listing display string; `None` if matches completion
            pub display: Option<String>,
            /// Completion suffix; replaces append character
            pub suffix: Suffix,
        }

        /// Specifies an optional suffix to override the default value
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Suffix {
            /// Use the default suffix
            Default,
            /// Use no suffix
            None,
            /// Use the given suffix
            Some(char),
        }

        impl Completion {
            /// Returns a simple `Completion` value, with display string matching
            /// completion and using the default completion suffix.
            pub fn simple(s: String) -> Completion {
                Completion{
                    completion: s,
                    display: None,
                    suffix: Suffix::default(),
                }
            }

            /// Returns the full completion string, including suffix, using the given
            /// default suffix if one is not assigned to this completion.
            pub fn completion(&self, def_suffix: Option<char>) -> Cow<str> {
                let mut s = Borrowed(&self.completion[..]);

                if let Some(suffix) = self.suffix.with_default(def_suffix) {
                    s.to_mut().push(suffix);
                }

                s
            }

            /// Returns the display string, including suffix
            pub fn display(&self) -> Cow<str> {
                let mut s = Borrowed(self.display_str());

                if let Suffix::Some(suffix) = self.suffix {
                    s.to_mut().push(suffix);
                }

                s
            }

            /// Returns the number of characters displayed
            pub fn display_chars(&self) -> usize {
                let n = self.display_str().chars().count();
                n + if self.suffix.is_some() { 1 } else { 0 }
            }

            fn display_str(&self) -> &str {
                match self.display {
                    Some(ref dis) => dis,
                    None => &self.completion
                }
            }
        }

        impl Suffix {
            /// Returns whether the `Suffix` value is the `Default` variant.
            pub fn is_default(&self) -> bool {
                match *self {
                    Suffix::Default => true,
                    _ => false
                }
            }

            /// Returns whether the `Suffix` value is the `Some(_)` variant.
            pub fn is_some(&self) -> bool {
                match *self {
                    Suffix::Some(_) => true,
                    _ => false
                }
            }

            /// Returns whether the `Suffix` value is the `None` variant.
            pub fn is_none(&self) -> bool {
                match *self {
                    Suffix::None => true,
                    _ => false
                }
            }

            /// Returns an `Option<char>`, using the given value in place of `Default`.
            pub fn with_default(self, default: Option<char>) -> Option<char> {
                match self {
                    Suffix::None => None,
                    Suffix::Some(ch) => Some(ch),
                    Suffix::Default => default
                }
            }
        }

        impl Default for Suffix {
            fn default() -> Suffix {
                Suffix::Default
            }
        }

        /// Performs completion for `Prompter` when triggered by a user input sequence
        pub trait Completer<Term: Terminal>: Send + Sync {
            /// Returns the set of possible completions for the prefix `word`.
            fn complete(&self, word: &str, prompter: &Prompter<Term>,
                start: usize, end: usize) -> Option<Vec<Completion>>;

            /// Returns the starting position of the word under the cursor.
            ///
            /// The default implementation uses `Prompter::word_break_chars()` to
            /// detect the start of a word.
            fn word_start(&self, line: &str, end: usize, prompter: &Prompter<Term>) -> usize {
                word_break_start(&line[..end], prompter.word_break_chars())
            }

            /// Quotes a possible completion for insertion into input.
            ///
            /// The default implementation returns the word, as is.
            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }

            /// Unquotes a piece of user input before searching for completions.
            ///
            /// The default implementation returns the word, as is.
            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
        }

        /// `Completer` type that performs no completion
        ///
        /// This is the default `Completer` for a new `Prompter` instance.
        pub struct DummyCompleter;

        impl<Term: Terminal> Completer<Term> for DummyCompleter {
            fn complete(&self, _word: &str, _reader: &Prompter<Term>,
                    _start: usize, _end: usize) -> Option<Vec<Completion>> { None }
        }

        /// Performs completion by searching for filenames matching the word prefix.
        pub struct PathCompleter;

        impl<Term: Terminal> Completer<Term> for PathCompleter {
            fn complete(&self, word: &str, _reader: &Prompter<Term>, _start: usize, _end: usize)
                    -> Option<Vec<Completion>> {
                Some(complete_path(word))
            }

            fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
                escaped_word_start(&line[..end])
            }

            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                escape(word)
            }

            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                unescape(word)
            }
        }

        /// Returns a sorted list of paths whose prefix matches the given path.
        pub fn complete_path(path: &str) -> Vec<Completion> {
            let (base_dir, fname) = split_path(path);
            let mut res = Vec::new();

            let lookup_dir = base_dir.unwrap_or(".");

            if let Ok(list) = read_dir(lookup_dir) {
                for ent in list {
                    if let Ok(ent) = ent {
                        let ent_name = ent.file_name();

                        // TODO: Deal with non-UTF8 paths in some way
                        if let Ok(path) = ent_name.into_string() {
                            if path.starts_with(fname) {
                                let (name, display) = if let Some(dir) = base_dir {
                                    (format!("{}{}{}", dir, MAIN_SEPARATOR, path),
                                        Some(path))
                                } else {
                                    (path, None)
                                };

                                let is_dir = ent.metadata().ok()
                                    .map_or(false, |m| m.is_dir());

                                let suffix = if is_dir {
                                    Suffix::Some(MAIN_SEPARATOR)
                                } else {
                                    Suffix::Default
                                };

                                res.push(Completion{
                                    completion: name,
                                    display: display,
                                    suffix: suffix,
                                });
                            }
                        }
                    }
                }
            }

            res.sort_by(|a, b| a.display_str().cmp(b.display_str()));
            res
        }

        /// Returns the start position of the word that ends at the end of the string.
        pub fn word_break_start(s: &str, word_break: &str) -> usize {
            let mut start = s.len();

            for (idx, ch) in s.char_indices().rev() {
                if word_break.contains(ch) {
                    break;
                }
                start = idx;
            }

            start
        }

        /// Returns the start position of a word with non-word characters escaped by
        /// backslash (`\\`).
        pub fn escaped_word_start(s: &str) -> usize {
            let mut chars = s.char_indices().rev();
            let mut start = s.len();

            while let Some((idx, ch)) = chars.next() {
                if needs_escape(ch) {
                    let n = {
                        let mut n = 0;

                        loop {
                            let mut clone = chars.clone();

                            let ch = match clone.next() {
                                Some((_, ch)) => ch,
                                None => break
                            };

                            if ch == '\\' {
                                chars = clone;
                                n += 1;
                            } else {
                                break;
                            }
                        }

                        n
                    };

                    if n % 2 == 0 {
                        break;
                    }
                }

                start = idx;
            }

            start
        }

        /// Escapes a word by prefixing a backslash (`\\`) to non-word characters.
        pub fn escape(s: &str) -> Cow<str> {
            let n = s.chars().filter(|&ch| needs_escape(ch)).count();

            if n == 0 {
                Borrowed(s)
            } else {
                let mut res = String::with_capacity(s.len() + n);

                for ch in s.chars() {
                    if needs_escape(ch) {
                        res.push('\\');
                    }
                    res.push(ch);
                }

                Owned(res)
            }
        }

        /// Unescapes a word by removing the backslash (`\\`) from escaped characters.
        pub fn unescape(s: &str) -> Cow<str> {
            if s.contains('\\') {
                let mut res = String::with_capacity(s.len());
                let mut chars = s.chars();

                while let Some(ch) = chars.next() {
                    if ch == '\\' {
                        if let Some(ch) = chars.next() {
                            res.push(ch);
                        }
                    } else {
                        res.push(ch);
                    }
                }

                Owned(res)
            } else {
                Borrowed(s)
            }
        }

        fn needs_escape(ch: char) -> bool {
            match ch {
                ' ' | '\t' | '\n' | '\\' => true,
                _ => false
            }
        }

        fn split_path(path: &str) -> (Option<&str>, &str) {
            match path.rfind(is_separator) {
                Some(pos) => (Some(&path[..pos]), &path[pos + 1..]),
                None => (None, path)
            }
        }
    }
    /*
    */
    pub mod function
    {
        //! Provides the `Function` trait for implementing custom `Prompter` commands

        use std::io;

        use crate::command::Category;
        use crate::prompter::Prompter;
        use crate::terminal::Terminal;

        /// Implements custom functionality for a `Prompter` command
        pub trait Function<Term: Terminal>: Send + Sync {
            /// Executes the function.
            ///
            /// `count` is the numerical argument supplied by the user; `1` by default.
            /// `prompter.explicit_arg()` may be called to determine whether this value
            /// was explicitly supplied by the user.
            ///
            /// `ch` is the final character of the sequence that triggered the command.
            /// `prompter.sequence()` may be called to determine the full sequence that
            /// triggered the command.
            fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()>;

            /// Returns the command category.
            fn category(&self) -> Category { Category::Other }
        }

        impl<F, Term: Terminal> Function<Term> for F where
                F: Send + Sync,
                F: Fn(&mut Prompter<Term>, i32, char) -> io::Result<()> {
            fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()> {
                self(prompter, count, ch)
            }
        }
    }
    /*
    */
    pub mod inputrc
    {
        //! Parses configuration files in the format of GNU Readline `inputrc`

        use std::char::from_u32;
        use std::fs::File;
        use std::io::{stderr, Read, Write};
        use std::path::Path;
        use std::str::{Chars, Lines};

        use crate::chars::{ctrl, meta, parse_char_name};
        use crate::command::Command;

        /// Parsed configuration directive
        #[derive(Clone, Debug)]
        pub enum Directive {
            /// Bind construct; `"input-sequence": command-or-macro`
            Bind(String, Command),
            /// Conditional construct;
            /// (`$if name=value` or `$if value`) *directives*
            /// (optional `$else` *directives*) `$endif`
            Conditional{
                /// Value name; if `None`, value refers to application name
                name: Option<String>,
                /// Value to compare
                value: String,
                /// Group of directives evaluated when condition is true
                then_group: Vec<Directive>,
                /// Group of directives evaluated when condition is false
                else_group: Vec<Directive>,
            },
            /// Set variable; `set name value`
            SetVariable(String, String),
        }

        /// Parses the named file and returns contained directives.
        ///
        /// If the file cannot be opened, `None` is returned and an error is printed
        /// to `stderr`. If any errors are encountered during parsing, they are printed
        /// to `stderr`.
        pub fn parse_file<P: ?Sized>(filename: &P) -> Option<Vec<Directive>>
                where P: AsRef<Path> {
            let filename = filename.as_ref();

            let mut f = match File::open(filename) {
                Ok(f) => f,
                Err(e) => {
                    let _ = writeln!(stderr(), "linefeed: {}: {}", filename.display(), e);
                    return None;
                }
            };

            let mut buf = String::new();

            if let Err(e) = f.read_to_string(&mut buf) {
                let _ = writeln!(stderr(), "{}: {}", filename.display(), e);
                return None;
            }

            Some(parse_text(filename, &buf))
        }

        /// Parses some text and returns contained directives.
        ///
        /// If any errors are encountered during parsing, they are printed to `stderr`.
        pub fn parse_text<P: ?Sized>(name: &P, line: &str) -> Vec<Directive>
                where P: AsRef<Path> {
            let mut p = Parser::new(name.as_ref(), line);
            p.parse()
        }

        struct Parser<'a> {
            lines: Lines<'a>,
            filename: &'a Path,
            line_num: usize,
        }

        enum Token<'a> {
            /// Colon; `:`
            Colon,
            /// Equal; `=`
            Equal,
            /// Conditional or other special directive; `$word`
            SpecialWord(&'a str),
            /// Double-quoted string; `"foo"`
            String(String),
            /// Bare word; `foo`
            Word(&'a str),
            /// Invalid token
            Invalid,
        }

        impl<'a> Parser<'a> {
            pub fn new(filename: &'a Path, text: &'a str) -> Parser<'a> {
                Parser{
                    lines: text.lines(),
                    filename: filename,
                    line_num: 0,
                }
            }

            fn next_line(&mut self) -> Option<&'a str> {
                self.lines.next().map(|line| {
                    self.line_num += 1;
                    line.trim()
                })
            }

            fn parse(&mut self) -> Vec<Directive> {
                let mut dirs = Vec::new();

                while let Some(line) = self.next_line() {
                    if line.starts_with('#') {
                        continue;
                    }

                    let mut tokens = Tokens::new(line);

                    if let Some(Token::SpecialWord("include")) = tokens.next() {
                        let path = tokens.line;

                        if let Some(d) = parse_file(Path::new(path)) {
                            dirs.extend(d);
                        }

                        continue;
                    }

                    if let Some(dir) = self.parse_line(line) {
                        dirs.push(dir);
                    }
                }

                dirs
            }

            fn parse_conditional(&mut self) -> (Vec<Directive>, Vec<Directive>) {
                let mut then_group = Vec::new();
                let mut else_group = Vec::new();
                let mut parse_else = false;

                loop {
                    let line = match self.next_line() {
                        Some(line) => line,
                        None => {
                            self.error("missing $endif directive");
                            break;
                        }
                    };

                    if line.starts_with('#') {
                        continue;
                    }

                    let mut tokens = Tokens::new(line);

                    let start = match tokens.next() {
                        Some(tok) => tok,
                        None => continue
                    };

                    match start {
                        Token::SpecialWord("else") => {
                            if parse_else {
                                self.error("duplicate $else directive");
                            } else {
                                parse_else = true;
                            }
                        }
                        Token::SpecialWord("endif") => {
                            break;
                        }
                        _ => {
                            if let Some(dir) = self.parse_line(line) {
                                if parse_else {
                                    else_group.push(dir);
                                } else {
                                    then_group.push(dir);
                                }
                            }
                        }
                    }
                }

                (then_group, else_group)
            }

            fn parse_line(&mut self, line: &str) -> Option<Directive> {
                let mut tokens = Tokens::new(line);

                let start = tokens.next()?;

                let dir = match start {
                    Token::SpecialWord("if") => {
                        let name = match tokens.next() {
                            Some(Token::Word(w)) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let (name, value) = match tokens.next() {
                            Some(Token::Equal) => {
                                let value = match tokens.next() {
                                    Some(Token::Word(w)) => w,
                                    None => "",
                                    _ => {
                                        self.invalid();
                                        return None;
                                    }
                                };

                                (Some(name), value)
                            }
                            None => (None, name),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let (then_group, else_group) = self.parse_conditional();

                        Directive::Conditional{
                            name: name.map(|s| s.to_owned()),
                            value: value.to_owned(),
                            then_group: then_group,
                            else_group: else_group,
                        }
                    }
                    Token::SpecialWord("else") => {
                        self.error("$else without matching $if directive");
                        return None;
                    }
                    Token::SpecialWord("endif") => {
                        self.error("$endif without matching $if directive");
                        return None;
                    }
                    Token::String(seq) => {
                        match tokens.next() {
                            Some(Token::Colon) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        match tokens.next() {
                            Some(Token::Word(value)) =>
                                Directive::Bind(seq, Command::from_string(value)),
                            Some(Token::String(out)) =>
                                Directive::Bind(seq, Command::Macro(out.to_owned().into())),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    Token::Word("set") => {
                        let name = match tokens.next() {
                            Some(Token::Word(w)) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let rest = tokens.line;

                        let value = match tokens.next() {
                            Some(Token::String(s)) => s,
                            Some(Token::Word(_)) => rest.to_owned(),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        Directive::SetVariable(name.to_owned(), value)
                    }
                    Token::Word(name) => {
                        match tokens.next() {
                            Some(Token::Colon) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        let seq = match parse_char_name(name) {
                            Some(seq) => seq,
                            None => {
                                self.invalid();
                                return None;
                            }
                        };

                        match tokens.next() {
                            Some(Token::Word(value)) =>
                                Directive::Bind(seq, Command::from_string(value)),
                            Some(Token::String(macro_seq)) =>
                                Directive::Bind(seq, Command::Macro(macro_seq.to_owned().into())),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    _ => {
                        self.invalid();
                        return None;
                    }
                };

                Some(dir)
            }

            fn error(&self, msg: &str) {
                let _ = writeln!(stderr(),
                    "linefeed: {} line {}: {}", self.filename.display(), self.line_num, msg);
            }

            fn invalid(&self) {
                self.error("invalid directive");
            }
        }

        struct Tokens<'a> {
            line: &'a str,
        }

        impl<'a> Tokens<'a> {
            fn new(line: &str) -> Tokens {
                Tokens{
                    line: line,
                }
            }
        }

        impl<'a> Iterator for Tokens<'a> {
            type Item = Token<'a>;

            fn next(&mut self) -> Option<Token<'a>> {
                let ch = self.line.chars().next()?;

                let tok = match ch {
                    ':' => {
                        self.line = self.line[1..].trim_start();
                        Token::Colon
                    }
                    '=' => {
                        self.line = self.line[1..].trim_start();
                        Token::Equal
                    }
                    '$' => {
                        let (word, rest) = parse_word(&self.line[1..]);
                        self.line = rest.trim_start();
                        Token::SpecialWord(word)
                    }
                    '"' => {
                        let (tok, rest) = parse_string(self.line);
                        self.line = rest.trim_start();
                        tok
                    }
                    _ => {
                        let (word, rest) = parse_word(self.line);
                        self.line = rest.trim_start();
                        Token::Word(word)
                    }
                };

                Some(tok)
            }
        }

        fn parse_escape(chars: &mut Chars) -> Option<String> {
            let ch = chars.next()?;

            let esc = match ch {
                'C'  => {
                    match chars.next() {
                        Some('-') => (),
                        _ => return None
                    }
                    ctrl(chars.next()?)
                }
                'M'  => {
                    match chars.next() {
                        Some('-') => (),
                        _ => return None
                    }
                    return Some(meta(chars.next()?));
                }
                'e'  => '\x1b',
                '\\' => '\\',
                '"'  => '"',
                '\'' => '\'',
                'a'  => '\x07',
                'b'  => '\x08',
                'd'  => '\x7f',
                'f'  => '\x0c',
                'n'  => '\n',
                'r'  => '\r',
                't'  => '\t',
                'u'  => {
                    match chars.next() {
                        Some('{') => (),
                        _ => return None
                    }

                    let mut n = 0;

                    for _ in 0..6 {
                        match chars.clone().next().and_then(|ch| ch.to_digit(16)) {
                            Some(digit) => {
                                chars.next();
                                n *= 16;
                                n += digit;
                            }
                            None => break
                        }
                    }

                    match chars.next() {
                        Some('}') => (),
                        _ => return None
                    }

                    from_u32(n)?
                }
                'v'  => '\x0b',
                'x'  => {
                    let mut n = 0;

                    for _ in 0..2 {
                        // Peek the next character
                        let digit = chars.clone().next()?.to_digit(16)? as u8;

                        // Consume if valid
                        chars.next();

                        n <<= 4;
                        n |= digit;
                    }

                    n as char
                }
                '0' ..= '3' => {
                    let mut n = ch as u8 - b'0';

                    for _ in 0..2 {
                        // Peek the next character
                        let digit = chars.clone().next()?.to_digit(8)? as u8;

                        // Consume if valid
                        chars.next();

                        n <<= 3;
                        n |= digit;
                    }

                    n as char
                }
                _ => return None
            };

            Some(esc.to_string())
        }

        fn parse_string(s: &str) -> (Token, &str) {
            let mut chars = s.chars();
            let mut res = String::new();

            // Skip open quote
            chars.next();

            while let Some(ch) = chars.next() {
                match ch {
                    '"' => return (Token::String(res), chars.as_str()),
                    '\\' => {
                        match parse_escape(&mut chars) {
                            Some(esc) => {
                                res.push_str(&esc);
                            }
                            None => break
                        }
                    }
                    ch => res.push(ch)
                }
            }

            (Token::Invalid, "")
        }

        fn parse_word(s: &str) -> (&str, &str) {
            let mut chars = s.char_indices();

            loop {
                let mut clone = chars.clone();

                match clone.next() {
                    Some((ind, ch)) if ch == ':' || ch == '"' || ch == '=' ||
                            ch.is_whitespace() => {
                        return (&s[..ind], &s[ind..]);
                    }
                    None => {
                        return (s, "");
                    }
                    _ => ()
                }

                chars = clone;
            }
        }
    }
    /*
    */
    pub mod interface
    {
        //! Provides the main interface to interactive input reader

        use std::borrow::Cow;
        use std::fmt;
        use std::fs::{File, OpenOptions};
        use std::io::{
            self, BufRead, BufReader, BufWriter,
            Read as _, Seek, SeekFrom, Write as _,
        };
        use std::path::Path;
        use std::sync::{Arc, Mutex, MutexGuard};
        use std::time::Duration;

        use crate::command::Command;
        use crate::complete::{Completer};
        use crate::function::Function;
        use crate::inputrc::Directive;
        use crate::reader::{Read, Reader, ReadLock, ReadResult};
        use crate::terminal::{DefaultTerminal, Signal, Terminal};
        use crate::variables::Variable;
        use crate::writer::{Write, Writer, WriteLock};

        /// The main interface to input reading and other terminal operations
        ///
        /// # Concurrency
        ///
        /// Each `Interface` contains two internal locks to allow concurrent read and write
        /// operations. The following types are used to hold a lock and to provide
        /// access to a set of operations:
        ///
        /// * [`Reader`] holds the read lock; it provides access to variables and bindings
        ///   and can initiate a [`read_line`] call. When `read_line` begins, the read
        ///   lock is acquired and it is held until the function returns. During the
        ///   `read_line` loop, the `Reader` waits for user input, reads input from the
        ///   terminal device, then acquires the write lock to process input and run
        ///   commands which may alter the prompt and the input buffer.
        /// * [`Writer`] holds the write lock; it provides an interface to write
        ///   line-by-line output to the terminal device without interfering with the
        ///   prompt when a `read_line` may be in progress.
        /// * [`Prompter`] holds both the read and write locks; it is created by the
        ///   `Reader` during the `read_line` loop and destroyed when the write lock is
        ///   released. It provides access to the current state of user input.
        ///
        /// [`Reader`]: ../reader/struct.Reader.html
        /// [`Writer`]: ../writer/struct.Writer.html
        /// [`Prompter`]: ../prompter/struct.Prompter.html
        /// [`read_line`]: #method.read_line
        pub struct Interface<Term: Terminal> {
            term: Term,
            write: Mutex<Write>,
            read: Mutex<Read<Term>>,
        }

        impl Interface<DefaultTerminal> {
            /// Creates a new `Interface` with the given application name.
            ///
            /// `application` is a string containing the name of the application.
            /// This can be used in user configurations to specify behavior for
            /// particular applications.
            ///
            /// The default terminal interface is used.
            pub fn new<T>(application: T) -> io::Result<Interface<DefaultTerminal>>
                    where T: Into<Cow<'static, str>> {
                let term = DefaultTerminal::new()?;
                Interface::with_term(application, term)
            }
        }

        impl<Term: Terminal> Interface<Term> {
            /// Creates a new `Interface` instance with a particular terminal implementation.
            ///
            /// To use the default terminal interface, call `Interface::new` instead.
            pub fn with_term<T>(application: T, term: Term) -> io::Result<Interface<Term>>
                    where T: Into<Cow<'static, str>> {
                let size = term.lock_write().size()?;
                let read = Read::new(&term, application.into());

                Ok(Interface{
                    term: term,
                    write: Mutex::new(Write::new(size)),
                    read: Mutex::new(read),
                })
            }

            /// Acquires the read lock and returns a `Reader` instance.
            ///
            /// The `Reader` instance allows exclusive access to variables, bindings,
            /// and command implementations.
            pub fn lock_reader(&self) -> Reader<Term> {
                Reader::new(self, self.lock_read())
            }

            /// Acquires the write lock and returns a `Writer` instance.
            ///
            /// If a `read_line` call is in progress, this method will move the cursor
            /// to a new line after the prompt, allowing output to be written without
            /// corrupting the prompt text. The prompt will be redrawn when the `Writer`
            /// instance is dropped.
            ///
            /// To instead erase the prompt and write text, use [`lock_writer_erase`].
            ///
            /// [`lock_writer_erase`]: #method.lock_writer_erase
            pub fn lock_writer_append(&self) -> io::Result<Writer<Term>> {
                Writer::with_lock(self.lock_write(), false)
            }

            /// Acquires the write lock and returns a `Writer` instance.
            ///
            /// If a `read_line` call is in progress, this method will erase the prompt,
            /// allowing output to be written without corrupting the prompt text.
            /// The prompt will be redrawn when the `Writer` instance is dropped.
            ///
            /// To instead write text after the prompt, use [`lock_writer_append`].
            ///
            /// [`lock_writer_append`]: #method.lock_writer_append
            pub fn lock_writer_erase(&self) -> io::Result<Writer<Term>> {
                Writer::with_lock(self.lock_write(), true)
            }

            fn lock_read(&self) -> ReadLock<Term> {
                ReadLock::new(
                    self.term.lock_read(),
                    self.read.lock().expect("Interface::lock_read"))
            }

            pub(crate) fn lock_write(&self) -> WriteLock<Term> {
                WriteLock::new(
                    self.term.lock_write(),
                    self.write.lock().expect("Interface::lock_write"))
            }

            pub(crate) fn lock_write_data(&self) -> MutexGuard<Write> {
                self.write.lock().expect("Interface::lock_write_data")
            }
        }

        /// ## Locking
        ///
        /// The following methods internally acquire the read lock.
        ///
        /// The lock is released before the method returns.
        ///
        /// If the read lock is already held, e.g. because a `read_line` call is in
        /// progress, the method will block until the lock is released.
        impl<Term: Terminal> Interface<Term> {
            /// Interactively reads a line from the terminal device.
            ///
            /// User input is collected until one of the following conditions is met:
            ///
            /// * If the user issues an end-of-file, `ReadResult::Eof` is returned.
            /// * When the user inputs a newline (`'\n'`), the resulting input
            ///   (not containing a trailing newline character) is returned as
            ///   `ReadResult::Input(_)`.
            /// * When a reported signal (see [`set_report_signal`]) is received,
            ///   it is returned as `ReadResult::Signal(_)`. The `read_line` operation may
            ///   then be either resumed with another call to `read_line` or ended by
            ///   calling [`cancel_read_line`].
            ///
            /// [`cancel_read_line`]: #method.cancel_read_line
            /// [`set_report_signal`]: #method.set_report_signal
            pub fn read_line(&self) -> io::Result<ReadResult> {
                self.lock_reader().read_line()
            }

            /// Performs one step of the interactive `read_line` loop.
            ///
            /// This method can be used to drive the `read_line` process asynchronously.
            /// It will wait for input only up to the specified duration, then process
            /// any available input from the terminal.
            ///
            /// If the user completes the input process, `Ok(Some(result))` is returned.
            /// Otherwise, `Ok(None)` is returned to indicate that the interactive loop
            /// may continue.
            ///
            /// The interactive prompt may be cancelled prematurely using the
            /// [`cancel_read_line`] method.
            ///
            /// See [`read_line`] for details on the return value.
            ///
            /// [`cancel_read_line`]: #method.cancel_read_line
            /// [`read_line`]: #method.read_line
            pub fn read_line_step(&self, timeout: Option<Duration>)
                    -> io::Result<Option<ReadResult>> {
                self.lock_reader().read_line_step(timeout)
            }

            /// Cancels an in-progress `read_line` operation.
            ///
            /// This method will reset internal data structures to their original state
            /// and move the terminal cursor to a new, empty line.
            ///
            /// This method is called to prematurely end the interactive loop when
            /// using the [`read_line_step`] method.
            ///
            /// It is not necessary to call this method if using the [`read_line`] method.
            ///
            /// [`read_line`]: #method.read_line
            /// [`read_line_step`]: #method.read_line_step
            pub fn cancel_read_line(&self) -> io::Result<()> {
                self.lock_reader().cancel_read_line()
            }

            /// Returns a clone of the current completer instance.
            pub fn completer(&self) -> Arc<dyn Completer<Term>> {
                self.lock_reader().completer().clone()
            }

            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer(&self, completer: Arc<dyn Completer<Term>>)
                    -> Arc<dyn Completer<Term>> {
                self.lock_reader().set_completer(completer)
            }

            /// Returns the value of the named variable or `None`
            /// if no such variable exists.
            pub fn get_variable(&self, name: &str) -> Option<Variable> {
                self.lock_reader().get_variable(name)
            }

            /// Sets the value of the named variable and returns the previous
            /// value.
            ///
            /// If `name` does not refer to a variable or the `value` is not
            /// a valid value for the variable, `None` is returned.
            pub fn set_variable(&self, name: &str, value: &str) -> Option<Variable> {
                self.lock_reader().set_variable(name, value)
            }

            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal(&self, signal: Signal) -> bool {
                self.lock_reader().ignore_signal(signal)
            }

            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal(&self, signal: Signal, set: bool) {
                self.lock_reader().set_ignore_signal(signal, set)
            }

            /// Returns whether the given `Signal` is reported.
            pub fn report_signal(&self, signal: Signal) -> bool {
                self.lock_reader().report_signal(signal)
            }

            /// Sets whether the given `Signal` is reported.
            pub fn set_report_signal(&self, signal: Signal, set: bool) {
                self.lock_reader().set_report_signal(signal, set)
            }

            /// Binds a sequence to a command.
            ///
            /// Returns the previously bound command.
            pub fn bind_sequence<T>(&self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.lock_reader().bind_sequence(seq, cmd)
            }

            /// Binds a sequence to a command, if and only if the given sequence
            /// is not already bound to a command.
            ///
            /// Returns `true` if a new binding was created.
            pub fn bind_sequence_if_unbound<T>(&self, seq: T, cmd: Command) -> bool
                    where T: Into<Cow<'static, str>> {
                self.lock_reader().bind_sequence_if_unbound(seq, cmd)
            }

            /// Removes a binding for the given sequence.
            ///
            /// Returns the previously bound command.
            pub fn unbind_sequence(&self, seq: &str) -> Option<Command> {
                self.lock_reader().unbind_sequence(seq)
            }

            /// Defines a named function to which sequences may be bound.
            ///
            /// The name should consist of lowercase ASCII letters and numbers,
            /// containing no spaces, with words separated by hyphens. However,
            /// this is not a requirement.
            ///
            /// Returns the function previously defined with the same name.
            pub fn define_function<T>(&self, name: T, cmd: Arc<dyn Function<Term>>)
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.lock_reader().define_function(name, cmd)
            }

            /// Removes a function defined with the given name.
            ///
            /// Returns the defined function.
            pub fn remove_function(&self, name: &str) -> Option<Arc<dyn Function<Term>>> {
                self.lock_reader().remove_function(name)
            }

            /// Evaluates a series of configuration directives.
            pub fn evaluate_directives(&self, dirs: Vec<Directive>) {
                self.lock_reader().evaluate_directives(&self.term, dirs)
            }

            /// Evaluates a single configuration directive.
            pub fn evaluate_directive(&self, dir: Directive) {
                self.lock_reader().evaluate_directive(&self.term, dir)
            }
        }

        /// ## Locking
        ///
        /// The following methods internally acquire the write lock.
        ///
        /// The lock is released before the method returns.
        ///
        /// If the write lock is already held, the method will block until it is released.
        impl<Term: Terminal> Interface<Term> {
            /// Returns the current input buffer.
            pub fn buffer(&self) -> String {
                self.lock_write().buffer.to_owned()
            }

            /// Returns the current number of history entries.
            pub fn history_len(&self) -> usize {
                self.lock_write().history_len()
            }

            /// Returns the maximum number of history entries.
            ///
            /// Not to be confused with [`history_len`], which returns the *current*
            /// number of history entries.
            ///
            /// [`history_len`]: #method.history_len
            pub fn history_size(&self) -> usize {
                self.lock_write().history_size()
            }

            /// Save history entries to the specified file.
            ///
            /// If the file does not exist, it is created and all history entries are
            /// written to the new file.
            ///
            /// If the file does exist, entries added since the last call to `save_history`
            /// (or since the start of the application) are appended to the named file.
            ///
            /// If the file would contain more than `self.history_size()` entries,
            /// it is first truncated, discarding the oldest entries.
            pub fn save_history<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
                let path = path.as_ref();
                let mut w = self.lock_write();

                if !path.exists() || w.history_size() == !0 {
                    self.append_history(path, &w)?;
                } else {
                    self.rewrite_history(path, &w)?;
                }

                w.reset_new_history();
                Ok(())
            }

            fn append_history<P: AsRef<Path>>(&self, path: P, w: &WriteLock<Term>)
                    -> io::Result<()> {
                let file = OpenOptions::new()
                    .append(true)
                    .create(true)
                    .open(path.as_ref())?;

                self.append_history_to(&file, w)
            }

            fn append_history_to(&self, file: &File, w: &WriteLock<Term>) -> io::Result<()> {
                let mut wtr = BufWriter::new(file);

                for entry in w.new_history() {
                    wtr.write_all(entry.as_bytes())?;
                    wtr.write_all(b"\n")?;
                }

                wtr.flush()
            }

            fn rewrite_history<P: AsRef<Path>>(&self, path: P, w: &WriteLock<Term>)
                    -> io::Result<()> {
                fn nth_line(s: &str, n: usize) -> Option<usize> {
                    let start = s.as_ptr() as usize;

                    s.lines().nth(n)
                        .map(|s| s.as_ptr() as usize - start)
                }

                let mut file = OpenOptions::new()
                    .create(true)
                    .read(true)
                    .write(true)
                    .open(path.as_ref())?;

                let mut hist = String::new();

                file.read_to_string(&mut hist)?;

                let n_lines = hist.lines().count();
                let n = n_lines.saturating_sub(
                    w.history_size() - w.new_history_entries());

                if n != 0 {
                    if let Some(pos) = nth_line(&hist, n) {
                        file.seek(SeekFrom::Start(0))?;
                        file.write_all(hist[pos..].as_bytes())?;

                        let n = file.seek(SeekFrom::Current(0))?;
                        file.set_len(n)?;
                    }
                }

                self.append_history_to(&file, w)
            }

            /// Load history entries from the specified file.
            pub fn load_history<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {
                let mut writer = self.lock_write();

                let file = File::open(&path)?;
                let rdr = BufReader::new(file);

                for line in rdr.lines() {
                    writer.add_history(line?);
                }

                writer.reset_new_history();

                Ok(())
            }

            /// Writes formatted text to the terminal display.
            ///
            /// This method enables `Interface` to be used as the receiver to
            /// the [`writeln!`] macro.
            ///
            /// If the text contains any unprintable characters (e.g. escape sequences),
            /// those characters will be escaped before printing.
            ///
            /// # Notes
            ///
            /// If this method is called during a [`read_line`] call, the prompt will
            /// first be erased, then restored after the given string is printed.
            /// Therefore, the written text should end with a newline. If the `writeln!`
            /// macro is used, a newline is automatically added to the end of the text.
            ///
            /// To instead write text after the prompt, use [`lock_writer_append`].
            ///
            /// [`read_line`]: #method.read_line
            /// [`writeln!`]: https://doc.rust-lang.org/std/macro.writeln.html
            /// [`lock_writer_append`]: #method.lock_writer_append
            pub fn write_fmt(&self, args: fmt::Arguments) -> io::Result<()> {
                let s = args.to_string();
                self.write_str(&s)
            }

            fn write_str(&self, line: &str) -> io::Result<()> {
                self.lock_writer_erase()?.write_str(line)
            }
        }

        /// ## Locking
        ///
        /// The following methods internally acquire both the read and write locks.
        ///
        /// The locks are released before the method returns.
        ///
        /// If either lock is already held, the method will block until it is released.
        impl<Term: Terminal> Interface<Term> {
            /// Sets the prompt that will be displayed when `read_line` is called.
            ///
            /// # Notes
            ///
            /// If `prompt` contains any terminal escape sequences (e.g. color codes),
            /// such escape sequences should be immediately preceded by the character
            /// `'\x01'` and immediately followed by the character `'\x02'`.
            pub fn set_prompt(&self, prompt: &str) -> io::Result<()> {
                self.lock_reader().set_prompt(prompt)
            }

            /// Sets the input buffer to the given string.
            ///
            /// # Notes
            ///
            /// To prevent invalidating the cursor, this method sets the cursor
            /// position to the end of the new buffer.
            pub fn set_buffer(&self, buf: &str) -> io::Result<()> {
                self.lock_reader().set_buffer(buf)
            }

            /// Sets the cursor position in the input buffer.
            ///
            /// # Panics
            ///
            /// If the given position is out of bounds or not on a `char` boundary.
            pub fn set_cursor(&self, pos: usize) -> io::Result<()> {
                self.lock_reader().set_cursor(pos)
            }

            // History methods don't appear to require a read lock, but do acquire
            // it nonetheless because any operation that truncates history may interefere
            // with an ongoing `read_line` call. Therefore, the read lock is acquired
            // to check whether a `read_line` call is in progress.

            /// Adds a line to history.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn add_history(&self, line: String) {
                self.lock_reader().add_history(line);
            }

            /// Adds a line to history, unless it is identical to the most recent entry.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn add_history_unique(&self, line: String) {
                self.lock_reader().add_history_unique(line);
            }

            /// Removes all history entries.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn clear_history(&self) {
                self.lock_reader().clear_history();
            }

            /// Removes the history entry at the given index.
            ///
            /// If the index is out of bounds, this method has no effect.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn remove_history(&self, idx: usize) {
                self.lock_reader().remove_history(idx);
            }

            /// Sets the maximum number of history entries.
            ///
            /// If `n` is less than the current number of history entries,
            /// the oldest entries are truncated to meet the given requirement.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn set_history_size(&self, n: usize) {
                self.lock_reader().set_history_size(n);
            }

            /// Truncates history to the only the most recent `n` entries.
            ///
            /// If a `read_line` call is in progress, this method has no effect.
            pub fn truncate_history(&self, n: usize) {
                self.lock_reader().truncate_history(n);
            }
        }
    }
    /*
    */
    pub mod memory
    {
        //! Implements an in-memory `Terminal` interface
        //!
        //! The main purpose of the in-memory terminal is for internal testing

        use std::cmp::min;
        use std::iter::repeat;
        use std::io;
        use std::sync::{Arc, Mutex, MutexGuard};
        use std::time::Duration;

        use crate::terminal::{
            CursorMode, RawRead, SignalSet, Size,
            Terminal, TerminalReader, TerminalWriter,
        };

        /// Default size of a `MemoryTerminal` buffer
        pub const DEFAULT_SIZE: Size = Size{
            columns: 80,
            lines: 24,
        };

        /// Implements an in-memory `Terminal` interface
        ///
        /// The contents of a `MemoryTerminal` are shared. That is, cloning
        /// a `MemoryTerminal` value will share the contained terminal buffer.
        #[derive(Clone, Debug)]
        pub struct MemoryTerminal {
            write: Arc<Mutex<Writer>>,
            read: Arc<Mutex<Reader>>,
        }

        #[derive(Debug)]
        struct Writer {
            memory: Vec<char>,
            input: Vec<u8>,
            col: usize,
            line: usize,
            cursor_mode: CursorMode,
            size: Size,
        }

        #[derive(Debug)]
        struct Reader {
            input: Vec<u8>,
            resize: Option<Size>,
        }

        /// Holds the lock on read operations of a `MemoryTerminal`.
        pub struct MemoryReadGuard<'a>(MutexGuard<'a, Reader>);

        /// Holds the lock on write operations of a `MemoryTerminal`.
        pub struct MemoryWriteGuard<'a>(MutexGuard<'a, Writer>);

        impl MemoryTerminal {
            /// Returns a new `MemoryTerminal` with the default buffer size.
            pub fn new() -> MemoryTerminal {
                MemoryTerminal::default()
            }

            /// Returns a new `MemoryTerminal` with the given buffer size.
            ///
            /// # Panics
            ///
            /// If either of the `lines` or `columns` fields are `0`.
            pub fn with_size(size: Size) -> MemoryTerminal {
                MemoryTerminal{
                    read: Arc::new(Mutex::new(Reader::new())),
                    write: Arc::new(Mutex::new(Writer::new(size))),
                }
            }

            /// Clears the terminal buffer and places the cursor at `(0, 0)`.
            pub fn clear_all(&self) {
                self.lock_writer().clear_all();
            }

            /// Clears all characters beginning at the cursor and ending at buffer end.
            pub fn clear_to_end(&self) {
                self.lock_writer().clear_to_end();
            }

            /// Clears the input buffer.
            pub fn clear_input(&self) {
                self.lock_reader().clear_input();
            }

            /// Returns whether any input remains to be read.
            pub fn has_input(&self) -> bool {
                self.lock_reader().has_input()
            }

            /// Returns an iterator over lines in the buffer.
            ///
            /// # Notes
            ///
            /// The returned iterator immutably borrows the contents of the
            /// `MemoryTerminal`. Attempting to perform a mutating operation on the
            /// parent `MemoryTerminal` while the `Lines` iterator lives will cause
            /// a panic.
            pub fn lines(&self) -> Lines {
                Lines{
                    writer: self.lock_writer(),
                    line: 0,
                }
            }

            /// Moves the cursor up `n` cells.
            pub fn move_up(&self, n: usize) {
                self.lock_writer().move_up(n);
            }

            /// Moves the cursor down `n` cells.
            pub fn move_down(&self, n: usize) {
                self.lock_writer().move_down(n);
            }

            /// Moves the cursor left `n` cells.
            pub fn move_left(&self, n: usize) {
                self.lock_writer().move_left(n);
            }

            /// Moves the cursor right `n` cells.
            pub fn move_right(&self, n: usize) {
                self.lock_writer().move_right(n);
            }

            /// Moves the cursor to the first column of the current line.
            pub fn move_to_first_column(&self) {
                self.lock_writer().move_to_first_column()
            }

            /// Pushes a character sequence to the back of the input queue.
            pub fn push_input(&self, s: &str) {
                self.lock_reader().push_input(s.as_bytes());
            }

            /// Reads some input from the input buffer.
            pub fn read_input(&self, buf: &mut [u8]) -> usize {
                self.lock_reader().read_input(buf)
            }

            /// Changes the size of the terminal buffer.
            /// The buffer will be truncated or filled with spaces, as necessary.
            ///
            /// # Panics
            ///
            /// If either of the `lines` or `columns` fields are `0` or if the area
            /// exceeds `usize` maximum.
            pub fn resize(&self, new_size: Size) {
                self.lock_writer().resize(new_size);
                self.lock_reader().resize(new_size);
            }

            /// Moves the contents of the buffer up `n` lines.
            /// The first `n` lines of text will be erased.
            pub fn scroll_up(&self, n: usize) {
                self.lock_writer().scroll_up(n);
            }

            /// Returns the `(line, column)` position of the cursor.
            pub fn cursor(&self) -> (usize, usize) {
                let r = self.lock_writer();
                (r.line, r.col)
            }

            /// Sets the cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) {
                self.lock_writer().set_cursor_mode(mode);
            }

            /// Returns the cursor mode.
            pub fn cursor_mode(&self) -> CursorMode {
                self.lock_writer().cursor_mode()
            }

            /// Returns the size of the terminal buffer.
            pub fn size(&self) -> Size {
                self.lock_writer().size
            }

            /// Writes some text into the buffer.
            ///
            /// If the text extends beyond the length of the current line without a
            /// newline character (`'\n'`), the extraneous text will be dropped.
            pub fn write(&self, s: &str) {
                self.lock_writer().write(s);
            }

            fn lock_reader(&self) -> MutexGuard<Reader> {
                self.read.lock().unwrap()
            }

            fn lock_writer(&self) -> MutexGuard<Writer> {
                self.write.lock().unwrap()
            }
        }

        impl Default for MemoryTerminal {
            fn default() -> MemoryTerminal {
                MemoryTerminal::with_size(DEFAULT_SIZE)
            }
        }

        impl Reader {
            fn new() -> Reader {
                Reader{
                    input: Vec::new(),
                    resize: None,
                }
            }

            fn has_input(&mut self) -> bool {
                self.resize.is_some() || !self.input.is_empty()
            }

            fn clear_input(&mut self) {
                self.input.clear();
            }

            fn push_input(&mut self, bytes: &[u8]) {
                self.input.extend(bytes);
            }

            fn read_input(&mut self, buf: &mut [u8]) -> usize {
                let n = min(buf.len(), self.input.len());

                buf[..n].copy_from_slice(&self.input[..n]);
                let _ = self.input.drain(..n);
                n
            }

            fn resize(&mut self, size: Size) {
                self.resize = Some(size);
            }
        }

        impl Writer {
            fn new(size: Size) -> Writer {
                assert!(size.lines != 0 && size.columns != 0,
                    "zero-area terminal buffer: {:?}", size);

                let n_chars = size.lines * size.columns;

                Writer{
                    memory: vec![' '; n_chars],
                    input: Vec::new(),
                    col: 0,
                    line: 0,
                    cursor_mode: CursorMode::Normal,
                    size: size,
                }
            }

            fn clear_all(&mut self) {
                for ch in &mut self.memory {
                    *ch = ' ';
                }
                self.col = 0;
                self.line = 0;
            }

            fn clear_to_end(&mut self) {
                let idx = self.index();

                for ch in &mut self.memory[idx..] {
                    *ch = ' ';
                }
            }

            fn move_up(&mut self, n: usize) {
                self.line = self.line.saturating_sub(n);
            }

            fn move_down(&mut self, n: usize) {
                self.line = min(self.size.lines - 1, self.line + n);
            }

            fn move_left(&mut self, n: usize) {
                self.col = self.col.saturating_sub(n);
            }

            fn move_right(&mut self, n: usize) {
                self.col = min(self.size.columns - 1, self.col + n);
            }

            fn move_to_first_column(&mut self) {
                self.col = 0;
            }

            fn resize(&mut self, new_size: Size) {
                if self.size != new_size {
                    let n_chars = new_size.lines.checked_mul(new_size.columns)
                        .unwrap_or_else(|| panic!("terminal size too large: {:?}", new_size));

                    assert!(n_chars != 0, "zero-area terminal buffer: {:?}", new_size);

                    let mut new_buf = Vec::with_capacity(n_chars);

                    let (n_copy, n_extra) = if new_size.columns > self.size.columns {
                        (self.size.columns, new_size.columns - self.size.columns)
                    } else {
                        (new_size.columns, 0)
                    };

                    for line in self.memory.chunks(self.size.columns).take(new_size.lines) {
                        new_buf.extend(&line[..n_copy]);
                        new_buf.extend(repeat(' ').take(n_extra));
                    }

                    if new_size.lines > self.size.lines {
                        let n_lines = new_size.lines - self.size.lines;
                        new_buf.extend(repeat(' ').take(n_lines * new_size.columns));
                    }

                    debug_assert_eq!(new_buf.len(), n_chars);

                    self.col = min(self.col, new_size.columns);
                    self.line = min(self.line, new_size.lines);
                    self.size = new_size;
                    self.memory = new_buf;
                }
            }

            fn scroll_up(&mut self, n: usize) {
                let chars = min(self.memory.len(), self.size.columns * n);
                self.memory.drain(..chars);
                self.memory.extend(repeat(' ').take(chars));
                self.line = self.line.saturating_sub(n);
            }

            fn set_cursor_mode(&mut self, mode: CursorMode) {
                self.cursor_mode = mode;
            }

            fn cursor_mode(&self) -> CursorMode {
                self.cursor_mode
            }

            fn write(&mut self, s: &str) {
                for ch in s.chars() {
                    if ch == '\n' {
                        self.advance_line();
                    } else if ch == '\r' {
                        self.col = 0;
                    } else {
                        self.write_char(ch);
                    }
                }
            }

            fn advance_line(&mut self) {
                self.line += 1;
                self.col = 0;
                if self.line == self.size.lines {
                    self.scroll_up(1);
                }
            }

            fn write_char(&mut self, ch: char) {
                if self.col >= self.size.columns {
                    self.advance_line();
                }

                let idx = self.index();
                self.memory[idx] = ch;
                self.col += 1;
            }

            fn index(&self) -> usize {
                self.line * self.size.columns + self.col
            }
        }

        /// Iterator over lines in a `MemoryTerminal` buffer.
        ///
        /// Note that while this value behaves as an iterator, it cannot implement
        /// the `Iterator` trait because its yielded values borrow `self`.
        pub struct Lines<'a> {
            writer: MutexGuard<'a, Writer>,
            line: usize,
        }

        impl<'a> Lines<'a> {
            /// Returns the next line in the buffer.
            pub fn next(&mut self) -> Option<&[char]> {
                if self.line >= self.writer.size.lines {
                    None
                } else {
                    let start = self.writer.size.columns * self.line;
                    self.line += 1;
                    let end = self.writer.size.columns * self.line;

                    Some(&self.writer.memory[start..end])
                }
            }

            /// Returns the number of lines remaining in the iterator.
            pub fn lines_remaining(&self) -> usize {
                self.writer.size.lines - self.line
            }
        }

        impl Terminal for MemoryTerminal {
            // No preparation needed for in-memory terminal
            type PrepareState = ();
            //type Reader = MemoryReadGuard;
            //type Writer = MemoryWriteGuard;

            fn name(&self) -> &str { "memory-terminal" }

            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a> {
                Box::new(MemoryReadGuard(self.lock_reader()))
            }

            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a> {
                Box::new(MemoryWriteGuard(self.lock_writer()))
            }
        }

        impl<'a> TerminalReader<MemoryTerminal> for MemoryReadGuard<'a> {
            fn wait_for_input(&mut self, _timeout: Option<Duration>) -> io::Result<bool> {
                Ok(!self.0.input.is_empty())
            }

            fn prepare(&mut self, _block_signals: bool, _report_signals: SignalSet)
                    -> io::Result<()> { Ok(()) }

            unsafe fn prepare_with_lock(&mut self,
                    _lock: &mut dyn TerminalWriter<MemoryTerminal>,
                    _block_signals: bool, _report_signals: SignalSet)
                    -> io::Result<()> { Ok(()) }

            fn restore(&mut self, _state: ()) -> io::Result<()> { Ok(()) }

            unsafe fn restore_with_lock(&mut self,
                    _lock: &mut dyn TerminalWriter<MemoryTerminal>, _state: ())
                    -> io::Result<()> { Ok(()) }

            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead> {
                if let Some(size) = self.0.resize.take() {
                    return Ok(RawRead::Resize(size));
                }

                buf.reserve(16);

                let cap = buf.capacity();
                let len = buf.len();
                let n;

                unsafe {
                    buf.set_len(cap);
                    n = self.0.read_input(&mut buf[len..]);
                    buf.set_len(len + n);
                }

                Ok(RawRead::Bytes(n))
            }
        }

        impl<'a> TerminalWriter<MemoryTerminal> for MemoryWriteGuard<'a> {
            fn size(&self) -> io::Result<Size> {
                Ok(self.0.size)
            }

            fn clear_screen(&mut self) -> io::Result<()> {
                self.0.clear_all();
                Ok(())
            }

            fn clear_to_screen_end(&mut self) -> io::Result<()> {
                self.0.clear_to_end();
                Ok(())
            }

            fn move_up(&mut self, n: usize) -> io::Result<()> {
                self.0.move_up(n);
                Ok(())
            }

            fn move_down(&mut self, n: usize) -> io::Result<()> {
                self.0.move_down(n);
                Ok(())
            }

            fn move_left(&mut self, n: usize) -> io::Result<()> {
                self.0.move_left(n);
                Ok(())
            }

            fn move_right(&mut self, n: usize) -> io::Result<()> {
                self.0.move_right(n);
                Ok(())
            }

            fn move_to_first_column(&mut self) -> io::Result<()> {
                self.0.move_to_first_column();
                Ok(())
            }

            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                self.0.set_cursor_mode(mode);
                Ok(())
            }

            fn write(&mut self, s: &str) -> io::Result<()> {
                self.0.write(s);
                Ok(())
            }

            fn flush(&mut self) -> io::Result<()> { Ok(()) }
        }
    }
    /*
    */
    pub mod prompter
    {
        //! Provides access to prompt input state

        use std::io;
        use std::mem::replace;
        use std::ops::Range;
        use std::sync::Arc;
        use std::time::Instant;

        use mortal::FindResult;

        use crate::chars::{is_ctrl, is_printable, DELETE, EOF};
        use crate::command::{Category, Command};
        use crate::complete::Completion;
        use crate::function::Function;
        use crate::reader::{BindingIter, InputState, ReadLock, ReadResult};
        use crate::table::{format_columns, Line, Table};
        use crate::terminal::{CursorMode, Signal, Size, Terminal};
        use crate::util::{
            get_open_paren, find_matching_paren, first_word,
            longest_common_prefix, repeat_char,
            back_n_words, forward_n_words,
            backward_char, forward_char, backward_word, forward_word,
            word_start, word_end, RangeArgument,
        };
        use crate::variables::VariableIter;
        use crate::writer::{
            BLINK_DURATION, display_str,
            Digit, Display, HistoryIter, PromptType, Writer, WriteLock,
        };

        /// Provides access to the current state of input while a `read_line` call
        /// is in progress.
        pub struct Prompter<'a, 'b: 'a, Term: 'b + Terminal> {
            pub(crate) read: &'a mut ReadLock<'b, Term>,
            write: WriteLock<'b, Term>,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Prompter<'a, 'b, Term> {
            pub(crate) fn new(read: &'a mut ReadLock<'b, Term>, write: WriteLock<'b, Term>)
                    -> Prompter<'a, 'b, Term> {
                Prompter{read, write}
            }

            /// Returns a `Writer` instance using the currently held write lock.
            pub fn writer_append<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>> {
                Writer::with_ref(&mut self.write, false)
            }

            /// Returns a `Writer` instance using the currently held write lock.
            pub fn writer_erase<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>> {
                Writer::with_ref(&mut self.write, true)
            }

            /// Resets input state at the start of `read_line`
            fn reset_input(&mut self) {
                self.read.reset_data();
                self.write.reset_data();
            }

            pub(crate) fn start_read_line(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.is_prompt_drawn = true;
                self.write.update_size()?;
                self.write.draw_prompt()
            }

            pub(crate) fn end_read_line(&mut self) -> io::Result<()> {
                self.write.expire_blink()?;

                if self.read.overwrite_mode {
                    self.write.set_cursor_mode(CursorMode::Normal)?;
                }
                if self.write.is_prompt_drawn {
                    self.write.move_to_end()?;
                    self.write.write_str("\n")?;
                    self.write.is_prompt_drawn = false;
                }

                self.reset_input();
                self.read.state = InputState::Inactive;

                Ok(())
            }

            pub(crate) fn handle_input(&mut self, ch: char) -> io::Result<Option<ReadResult>> {
                self.write.expire_blink()?;

                match self.read.state {
                    InputState::Inactive => panic!("input received in inactive state"),
                    InputState::NewSequence => {
                        if ch == EOF && self.write.buffer.is_empty() {
                            self.write.write_str("\n")?;
                            self.write.is_prompt_drawn = false;
                            return Ok(Some(ReadResult::Eof));
                        } else {
                            self.read.sequence.push(ch);
                            self.execute_sequence()?;

                            if self.read.input_accepted {
                                let s = replace(&mut self.write.buffer, String::new());
                                return Ok(Some(ReadResult::Input(s)));
                            }
                        }
                    }
                    InputState::ContinueSequence{expiry: _} => {
                        self.read.sequence.push(ch);

                        self.execute_sequence()?;

                        if self.read.input_accepted {
                            let s = replace(&mut self.write.buffer, String::new());
                            return Ok(Some(ReadResult::Input(s)));
                        }
                    }
                    InputState::Number => {
                        if let Some(digit) = ch.to_digit(10) {
                            self.write.input_arg.input(digit as i32);

                            if self.write.input_arg.is_out_of_bounds() {
                                self.read.state = InputState::NewSequence;
                                self.write.input_arg = Digit::None;
                                self.write.explicit_arg = false;
                                self.write.redraw_prompt(PromptType::Normal)?;
                            } else {
                                self.write.redraw_prompt(PromptType::Number)?;
                            }
                        } else {
                            self.read.state = InputState::NewSequence;
                            self.write.redraw_prompt(PromptType::Normal)?;
                            self.read.macro_buffer.insert(0, ch);
                        }
                    }
                    InputState::CharSearch{n, backward} => {
                        if n != 0 {
                            if backward {
                                self.write.backward_search_char(n, ch)?;
                            } else {
                                self.write.forward_search_char(n, ch)?;
                            }
                        }
                        self.read.state = InputState::NewSequence;
                    }
                    InputState::TextSearch => {
                        if ch == DELETE {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.pop();
                                write.last_search.clone_from(&write.search_buffer);
                            }
                            self.write.search_history_update()?;
                        } else if self.is_abort(ch) {
                            self.abort_search_history()?;
                        } else if is_ctrl(ch) {
                            // End search, handle input after cancelling
                            self.end_search_history()?;
                            self.read.macro_buffer.insert(0, ch);
                        } else {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.push(ch);
                                write.last_search.clone_from(&write.search_buffer);
                            }
                            self.write.search_history_update()?;
                        }
                    }
                    InputState::CompleteIntro => {
                        match ch {
                            'y' | 'Y' | ' ' => {
                                self.write.write_str("\n")?;
                                self.show_completions_page(0)?;
                            }
                            '\r' | '\n' => {
                                self.write.write_str("\n")?;
                                self.show_completions_line(0)?;
                            }
                            'q' | 'Q' |
                            'n' | 'N' | DELETE => {
                                self.write.write_str("\n")?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::CompleteMore(offset) => {
                        match ch {
                            'y' | 'Y' | ' ' => {
                                self.write.clear_prompt()?;
                                self.show_completions_page(offset)?;
                            }
                            '\r' | '\n' => {
                                self.write.clear_prompt()?;
                                self.show_completions_line(offset)?;
                            }
                            'q' | 'Q' |
                            'n' | 'N' | DELETE => {
                                self.write.clear_prompt()?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::QuotedInsert(n) => {
                        if n != 0 {
                            self.insert(n, ch)?;
                        }
                        self.read.state = InputState::NewSequence;
                    }
                }

                Ok(None)
            }

            /// Returns the current buffer.
            pub fn buffer(&self) -> &str {
                &self.write.buffer
            }

            /// Returns the "backup" buffer.
            pub fn backup_buffer(&self) -> &str {
                &self.write.backup_buffer
            }

            /// Returns the command `Category` of the most recently executed command.
            pub fn last_command_category(&self) -> Category {
                self.read.last_cmd
            }

            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars(&self) -> &str {
                &self.read.word_break
            }

            /// Sets the buffer to the given value.
            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
                self.write.set_buffer(buf)
            }

            /// Returns the current position of the cursor.
            pub fn cursor(&self) -> usize {
                self.write.cursor
            }

            /// Sets the cursor to the given position within the buffer.
            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
                self.write.set_cursor(pos)
            }

            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
                self.write.set_prompt(prompt)
            }

            /// Returns the size of the terminal at the last draw operation.
            pub fn screen_size(&self) -> Size {
                self.write.screen_size
            }

            /// Returns whether a numerical argument was explicitly supplied by the user.
            pub fn explicit_arg(&self) -> bool {
                self.write.explicit_arg
            }

            /// Returns the current input sequence.
            pub fn sequence(&self) -> &str {
                &self.read.sequence
            }

            /// Returns an iterator over bound sequences
            pub fn bindings(&self) -> BindingIter {
                self.read.bindings()
            }

            /// Returns an iterator over variable values.
            pub fn variables(&self) -> VariableIter {
                self.read.variables()
            }

            /// Returns an iterator over history entries
            pub fn history(&self) -> HistoryIter {
                self.write.history()
            }

            /// Returns the index into history currently being edited.
            pub fn history_index(&self) -> Option<usize> {
                self.write.history_index
            }

            /// Returns the current number of history entries.
            pub fn history_len(&self) -> usize {
                self.write.history.len()
            }

            fn next_history(&mut self, n: usize) -> io::Result<()> {
                self.write.next_history(n)
            }

            fn prev_history(&mut self, n: usize) -> io::Result<()> {
                self.write.prev_history(n)
            }

            /// Selects the history entry currently being edited by the user.
            pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> {
                self.write.select_history_entry(new)
            }

            /// Returns the current set of completions.
            pub fn completions(&self) -> Option<&[Completion]> {
                self.read.completions.as_ref().map(|v| &v[..])
            }

            /// Sets the current set of completions.
            pub fn set_completions(&mut self, completions: Option<Vec<Completion>>) {
                self.read.completions = completions;
            }

            /// Attempts to execute the current sequence.
            fn execute_sequence(&mut self) -> io::Result<()> {
                match self.find_binding(&self.read.sequence) {
                    FindResult::Found(cmd) => {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.read.state = InputState::NewSequence;
                        self.execute_command(cmd, n, ch)?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.read.state = InputState::NewSequence;
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => {
                        let expiry = None;
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                    FindResult::Undecided(_) => {
                        let expiry = self.keyseq_expiry();
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                }

                Ok(())
            }

            fn force_execute_sequence(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;

                match self.find_binding(&self.read.sequence) {
                    FindResult::Found(cmd) |
                    FindResult::Undecided(cmd) => {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.execute_command(cmd, n, ch)?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => unreachable!(),
                }

                Ok(())
            }

            /// Execute the command `SelfInsert` on the first character in the input
            /// sequence, if it is printable.
            fn insert_first_char(&mut self) -> io::Result<()> {
                let (first, rest) = {
                    let mut chars = self.read.sequence.chars();

                    (chars.next().unwrap(), chars.as_str().to_owned())
                };

                self.read.sequence.clear();

                if is_printable(first) {
                    let n = self.write.input_arg.to_i32();
                    self.execute_command(Command::SelfInsert, n, first)?;
                }

                if !rest.is_empty() {
                    self.read.queue_input(&rest);
                }

                Ok(())
            }

            fn find_binding(&self, seq: &str) -> FindResult<Command> {
                self.read.bindings.find(seq).cloned()
            }

            fn get_function(&self, name: &str) -> Option<&Arc<dyn Function<Term>>> {
                self.read.functions.get(name)
            }

            fn is_abort(&self, ch: char) -> bool {
                let mut buf = [0; 4];
                let s = ch.encode_utf8(&mut buf);

                self.find_binding(&s) == FindResult::Found(Command::Abort)
            }

            fn execute_command(&mut self, cmd: Command, n: i32, ch: char) -> io::Result<()> {
                use crate::command::Command::*;

                let mut category = cmd.category();

                if self.read.overwrite_mode {
                    match cmd {
                        DigitArgument | SelfInsert => (),
                        BackwardDeleteChar if n >= 0 => (),
                        _ => self.read.overwritten_chars.clear()
                    }
                }

                match cmd {
                    Abort => (),
                    AcceptLine => {
                        self.accept_input()?;
                    }
                    Complete => {
                        if !self.read.disable_completion {
                            self.complete_word()?;
                        } else if is_printable(ch) {
                            self.execute_command(SelfInsert, n, ch)?;
                        }
                    }
                    InsertCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some(completions) = self.read.completions.take() {
                            self.insert_completions(&completions)?;
                            self.read.completions = Some(completions);
                        }
                    }
                    PossibleCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some(completions) = self.read.completions.take() {
                            self.show_completions(&completions)?;
                            self.read.completions = Some(completions);
                        }
                    }
                    MenuComplete => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.next_completion(n as usize)?;
                        } else {
                            self.prev_completion((-n) as usize)?;
                        }
                    }
                    MenuCompleteBackward => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.prev_completion(n as usize)?;
                        } else {
                            self.next_completion((-n) as usize)?;
                        }
                    }
                    DigitArgument => {
                        self.read.state = InputState::Number;
                        self.write.set_digit_from_char(ch);
                        self.write.redraw_prompt(PromptType::Number)?;
                    }
                    SelfInsert => {
                        if n > 0 {
                            let n = n as usize;

                            if self.read.overwrite_mode {
                                self.overwrite(n, ch)?;
                            } else {
                                self.insert(n, ch)?;
                            }

                            if self.read.blink_matching_paren {
                                if let Some(open) = get_open_paren(ch) {
                                    if let Some(pos) = find_matching_paren(
                                            &self.write.buffer[..self.write.cursor],
                                            &self.read.string_chars, open, ch) {
                                        self.blink(pos)?;
                                    }
                                }
                            }
                        }
                    }
                    TabInsert => {
                        if n > 0 {
                            self.insert(n as usize, '\t')?;
                        }
                    }
                    InsertComment => {
                        if self.explicit_arg() &&
                                self.write.buffer.starts_with(&self.read.comment_begin[..]) {
                            self.write.move_to(0)?;
                            let n = self.read.comment_begin.len();

                            self.delete_range(..n)?;
                            self.accept_input()?;
                        } else {
                            self.write.move_to(0)?;
                            let s = self.read.comment_begin.clone();
                            self.insert_str(&s)?;
                            self.accept_input()?;
                        }
                    }
                    BackwardChar => {
                        if n > 0 {
                            self.write.backward_char(n as usize)?;
                        } else if n < 0 {
                            self.write.forward_char((-n) as usize)?;
                        }
                    }
                    ForwardChar => {
                        if n > 0 {
                            self.write.forward_char(n as usize)?;
                        } else if n < 0 {
                            self.write.backward_char((-n) as usize)?;
                        }
                    }
                    CharacterSearch => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: false,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: (-n) as usize,
                                backward: true,
                            };
                        }
                    }
                    CharacterSearchBackward => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: true,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: (-n) as usize,
                                backward: false,
                            };
                        }
                    }
                    BackwardWord => {
                        if n > 0 {
                            self.backward_word(n as usize)?;
                        } else if n < 0 {
                            self.forward_word((-n) as usize)?;
                        }
                    }
                    ForwardWord => {
                        if n > 0 {
                            let pos = forward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            self.write.move_to(pos)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            self.write.move_to(pos)?;
                        }
                    }
                    BackwardKillLine => {
                        let r = ..self.write.cursor;
                        self.kill_range(r)?;
                    }
                    KillLine => {
                        let r = self.write.cursor..;
                        self.kill_range(r)?;
                    }
                    BackwardKillWord => {
                        if n > 0 {
                            let pos = backward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        }
                    }
                    KillWord => {
                        if n > 0 {
                            let pos = forward_word(n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = backward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break);
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        }
                    }
                    UnixWordRubout => {
                        if n > 0 {
                            let pos = backward_word(n as usize,
                                &self.write.buffer, self.write.cursor, " \t\n");
                            let r = pos..self.write.cursor;
                            self.kill_range(r)?;
                        } else if n < 0 {
                            let pos = forward_word((-n) as usize,
                                &self.write.buffer, self.write.cursor, " \t\n");
                            let r = self.write.cursor..pos;
                            self.kill_range(r)?;
                        }
                    }
                    ClearScreen => {
                        self.write.clear_screen()?;
                    }
                    BeginningOfLine => self.write.move_to(0)?,
                    EndOfLine => self.write.move_to_end()?,
                    BackwardDeleteChar => {
                        if n > 0 {
                            if self.read.overwrite_mode {
                                self.overwrite_back(n as usize)?;
                            } else {
                                let pos = backward_char(n as usize,
                                    &self.write.buffer, self.write.cursor);
                                let r = pos..self.write.cursor;
                                self.delete_range(r)?;
                            }
                        } else if n < 0 {
                            let pos = forward_char((-n) as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = self.write.cursor..pos;
                            self.delete_range(r)?;
                        }
                    }
                    DeleteChar => {
                        if n > 0 {
                            let pos = forward_char(n as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = self.write.cursor..pos;
                            self.delete_range(r)?;
                        } else if n < 0 {
                            let pos = backward_char(n as usize,
                                &self.write.buffer, self.write.cursor);
                            let r = pos..self.write.cursor;
                            self.delete_range(r)?;
                        }
                    }
                    TransposeChars => {
                        if n != 0 && self.write.cursor != 0 {
                            let (src, dest);

                            if !self.explicit_arg() && self.write.cursor == self.write.buffer.len() {
                                let end = backward_char(1, &self.write.buffer, self.write.cursor);
                                let start = backward_char(1, &self.write.buffer, end);

                                src = start..end;
                                dest = end..self.write.cursor;
                            } else {
                                let start = backward_char(1, &self.write.buffer, self.write.cursor);
                                let end = self.write.cursor;

                                src = start..end;

                                dest = if n < 0 {
                                    let back = backward_char((-n) as usize, &self.write.buffer, start);
                                    back..start
                                } else {
                                    let fwd = forward_char(n as usize + 1, &self.write.buffer, start);
                                    end..fwd
                                };
                            }

                            self.transpose_range(src, dest)?;
                        }
                    }
                    TransposeWords => {
                        if n != 0 {
                            if let Some(first) = first_word(&self.write.buffer[..self.write.cursor], &self.read.word_break) {
                                let start = word_start(&self.write.buffer, self.write.cursor, &self.read.word_break);

                                if first != start {
                                    let (src, dest);

                                    if !self.explicit_arg() && start == self.write.buffer.len() {
                                        let dest_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                        let dest_end = word_end(&self.write.buffer, dest_start, &self.read.word_break);

                                        let src_start = backward_word(1, &self.write.buffer, dest_start, &self.read.word_break);
                                        let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                        src = src_start..src_end;
                                        dest = dest_start..dest_end;
                                    } else {
                                        let src_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                        let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                        src = src_start..src_end;

                                        dest = if n < 0 {
                                            back_n_words((-n) as usize, &self.write.buffer, src_start, &self.read.word_break)
                                        } else {
                                            forward_n_words(n as usize, &self.write.buffer, src_start, &self.read.word_break)
                                        };
                                    }

                                    self.transpose_range(src, dest)?;
                                }
                            }
                        }
                    }
                    BeginningOfHistory => {
                        self.select_history_entry(Some(0))?;
                    }
                    EndOfHistory => {
                        self.select_history_entry(None)?;
                    }
                    NextHistory => {
                        if n > 0 {
                            self.next_history(n as usize)?;
                        } else if n < 0 {
                            self.prev_history((-n) as usize)?;
                        }
                    }
                    PreviousHistory => {
                        if n > 0 {
                            self.prev_history(n as usize)?;
                        } else if n < 0 {
                            self.next_history((-n) as usize)?;
                        }
                    }
                    ForwardSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history(false)?;
                        } else {
                            self.write.start_search_history(false)?;
                        }
                    }
                    ReverseSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history(true)?;
                        } else {
                            self.write.start_search_history(true)?;
                        }
                    }
                    HistorySearchForward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search(false)?;
                        } else {
                            self.write.start_history_search(false)?;
                        }
                    }
                    HistorySearchBackward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search(true)?;
                        } else {
                            self.write.start_history_search(true)?;
                        }
                    }
                    QuotedInsert => {
                        self.read.state = InputState::QuotedInsert(
                            if n >= 0 { n as usize } else { 0 });
                    }
                    OverwriteMode => {
                        self.read.overwrite_mode = !self.read.overwrite_mode;

                        if !self.read.overwrite_mode {
                            self.read.overwritten_append = 0;
                            self.read.overwritten_chars.clear();
                        }

                        let mode = if self.read.overwrite_mode {
                            CursorMode::Overwrite
                        } else {
                            CursorMode::Normal
                        };

                        self.write.set_cursor_mode(mode)?;
                    }
                    Yank => {
                        self.yank()?;
                    }
                    YankPop => {
                        self.yank_pop()?;
                    }
                    Custom(ref name) => {
                        if let Some(fun) = self.get_function(name).cloned() {
                            fun.execute(self, n, ch)?;

                            category = fun.category();
                        }
                    }
                    Macro(ref seq) => {
                        self.read.queue_input(seq);
                    }
                }

                if category != Category::Digit {
                    self.write.input_arg = Digit::None;
                    self.write.explicit_arg = false;

                    self.read.last_cmd = category;

                    if category != Category::Complete {
                        self.read.completions = None;
                    }

                    if category != Category::Yank {
                        self.read.last_yank = None;
                    }
                }

                Ok(())
            }

            /// Accepts the current input buffer as user input.
            ///
            /// This method may be called by a [`Function`] implementation, immediately
            /// before ending execution, in order to simulate the `accept-line` command;
            /// e.g. to implement a command that extends the default behavior of the
            /// `accept-line` action.
            ///
            /// Behavior of this method is undefined if called outside of a `Function`
            /// implementation.
            ///
            /// [`Function`]: ../function/trait.Function.html
            pub fn accept_input(&mut self) -> io::Result<()> {
                self.write.move_to_end()?;
                self.write.write_str("\n")?;
                self.read.input_accepted = true;
                self.write.is_prompt_drawn = false;
                Ok(())
            }

            /// Moves the cursor to the given position, waits for 500 milliseconds
            /// (or until next user input), then restores the original cursor position.
            ///
            /// # Panics
            ///
            /// If the given position is out of bounds or is not aligned to `char` boundaries.
            pub fn blink(&mut self, pos: usize) -> io::Result<()> {
                self.write.blink(pos)?;

                self.read.max_wait_duration = Some(BLINK_DURATION);

                Ok(())
            }

            fn check_expire_blink(&mut self, now: Instant) -> io::Result<()> {
                if self.write.check_expire_blink(now)? {
                    self.read.max_wait_duration = None;
                }

                Ok(())
            }

            fn check_expire_sequence(&mut self, now: Instant) -> io::Result<()> {
                if let InputState::ContinueSequence{expiry: Some(expiry)} = self.read.state {
                    if now >= expiry {
                        self.read.max_wait_duration = None;
                        self.force_execute_sequence()?;
                    }
                }

                Ok(())
            }

            fn keyseq_expiry(&mut self) -> Option<Instant> {
                if let Some(t) = self.read.keyseq_timeout {
                    self.read.max_wait_duration = Some(t);
                    Some(Instant::now() + t)
                } else {
                    None
                }
            }

            pub(crate) fn check_expire_timeout(&mut self) -> io::Result<()> {
                let now = Instant::now();

                self.check_expire_blink(now)?;
                self.check_expire_sequence(now)
            }

            fn expire_blink(&mut self) -> io::Result<()> {
                self.read.max_wait_duration = None;
                self.write.expire_blink()
            }

            fn build_completions(&mut self) {
                let compl = self.read.completer.clone();
                let end = self.write.cursor;
                let start = compl.word_start(&self.write.buffer, end, self);

                if start > end {
                    panic!("Completer::word_start returned invalid index; \
                        start > end ({} > {})", start, end);
                }

                let unquoted = compl.unquote(&self.write.buffer[start..end]).into_owned();

                let completions = compl.complete(&unquoted, self, start, end);
                let n_completions = completions.as_ref().map_or(0, |c| c.len());

                self.read.completions = completions;
                self.read.completion_index = n_completions;
                self.read.completion_start = start;
                self.read.completion_prefix = end;
            }

            fn complete_word(&mut self) -> io::Result<()> {
                if let Some(completions) = self.read.completions.take() {
                    if completions.len() == 1 {
                        self.substitute_completion(&completions[0])?;
                    } else {
                        self.show_completions(&completions)?;
                        self.read.completions = Some(completions);
                    }
                } else {
                    self.build_completions();
                    let completions = self.read.completions.take().unwrap_or_default();

                    if completions.len() == 1 {
                        self.substitute_completion(&completions[0])?;
                    } else if !completions.is_empty() {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;

                        {
                            let pfx = longest_common_prefix(completions.iter()
                                .map(|compl| &compl.completion[..]))
                                .unwrap_or_default();
                            self.replace_str_forward(start..end, &pfx)?;
                        }

                        self.read.completions = Some(completions);
                    }
                }

                Ok(())
            }

            fn substitute_completion(&mut self, compl: &Completion) -> io::Result<()> {
                let mut s = self.read.completer.quote(&compl.completion);

                if let Some(suffix) = compl.suffix.with_default(self.read.completion_append_character) {
                    s.to_mut().push(suffix);
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;
                self.replace_str_forward(start..end, &s)
            }

            fn insert_completions(&mut self, completions: &[Completion]) -> io::Result<()> {
                let mut words = String::new();

                for compl in completions {
                    words.push_str(&self.read.completer.unquote(&compl.completion));
                    words.push(' ');
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;

                self.replace_str_forward(start..end, &words)
            }

            fn show_completions(&mut self, completions: &[Completion]) -> io::Result<()> {
                if completions.is_empty() {
                    return Ok(());
                }

                let eff_width = self.write.screen_size.columns
                    .min(self.read.completion_display_width);

                let completions = completions.iter()
                    .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                    .collect::<Vec<_>>();

                let cols = format_columns(&completions, eff_width,
                    self.read.print_completions_horizontally);
                let table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                    self.read.print_completions_horizontally);

                self.write.write_str("\n")?;

                let n_completions = completions.len();

                if self.read.page_completions &&
                        n_completions >= self.read.completion_query_items {
                    self.start_page_completions(n_completions)
                } else {
                    self.show_list_completions(table)?;
                    self.write.draw_prompt()
                }
            }

            fn start_page_completions(&mut self, n_completions: usize) -> io::Result<()> {
                self.read.state = InputState::CompleteIntro;
                self.write.redraw_prompt(PromptType::CompleteIntro(n_completions))
            }

            fn end_page_completions(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.prompt_type = PromptType::Normal;
                self.write.draw_prompt()
            }

            fn is_paging_completions(&self) -> bool {
                match self.read.state {
                    InputState::CompleteMore(_) => true,
                    _ => false
                }
            }

            fn show_completions_page(&mut self, offset: usize) -> io::Result<()> {
                if let Some(compl) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min(self.read.completion_display_width);
                    let n_lines = self.write.screen_size.lines - 1;

                    let completions = compl.iter()
                        .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                        .collect::<Vec<_>>();

                    let cols = format_columns(&completions, width,
                        self.read.print_completions_horizontally);
                    let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                        self.read.print_completions_horizontally);

                    for row in table.by_ref().skip(offset).take(n_lines) {
                        self.show_completion_line(row)?;
                    }

                    if table.has_more() {
                        self.read.completions = Some(compl);
                        self.read.state = InputState::CompleteMore(offset + n_lines);
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok(())
            }

            fn show_completions_line(&mut self, offset: usize) -> io::Result<()> {
                if let Some(compl) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min(self.read.completion_display_width);
                    let completions = compl.iter()
                        .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                        .collect::<Vec<_>>();

                    let cols = format_columns(&completions, width,
                        self.read.print_completions_horizontally);
                    let mut table = Table::new(&completions, cols.as_ref().map(|c| &c[..]),
                        self.read.print_completions_horizontally);

                    if let Some(row) = table.by_ref().skip(offset).next() {
                        self.show_completion_line(row)?;
                    }

                    if table.has_more() {
                        self.read.completions = Some(compl);
                        self.read.state = InputState::CompleteMore(offset + 1);
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok(())
            }

            fn show_completion_line<S: AsRef<str>>(&mut self, line: Line<S>) -> io::Result<()> {
                let mut space = 0;

                for (width, name) in line {
                    self.write.move_right(space)?;
                    self.write.write_str(name)?;
                    space = width - name.chars().count();
                }

                self.write.write_str("\n")
            }

            fn show_list_completions<S: AsRef<str>>(&mut self, table: Table<S>) -> io::Result<()> {
                for line in table {
                    let mut space = 0;

                    for (width, name) in line {
                        self.write.move_right(space)?;
                        self.write.write_str(name)?;
                        space = width - name.chars().count();
                    }
                    self.write.write_str("\n")?;
                }

                Ok(())
            }

            fn next_completion(&mut self, n: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let max = len + 1;

                let old = self.read.completion_index;
                let new = (old + n) % max;

                if old != new {
                    self.set_completion(new)?;
                }

                Ok(())
            }

            fn prev_completion(&mut self, n: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let max = len + 1;

                let old = self.read.completion_index;
                let new = if n <= old {
                    max - old - n
                } else {
                    old - n
                };

                self.set_completion(new)
            }

            fn set_completion(&mut self, new: usize) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                let old = self.read.completion_index;

                if old != new {
                    self.read.completion_index = new;

                    if new == len {
                        let start = self.read.completion_prefix;
                        let end = self.write.cursor;

                        self.delete_range(start..end)?;
                    } else {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;
                        let s = self.read.completions.as_ref().unwrap()[new]
                            .completion(self.read.completion_append_character).into_owned();

                        self.replace_str_forward(start..end, &s)?;
                    }
                }

                Ok(())
            }

            fn abort_search_history(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.read.last_cmd = Category::Other;
                self.write.abort_search_history()
            }

            fn end_search_history(&mut self) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.end_search_history()
            }

            pub(crate) fn handle_resize(&mut self, size: Size) -> io::Result<()> {
                self.expire_blink()?;

                if self.is_paging_completions() {
                    self.end_page_completions()?;
                }

                self.write.screen_size = size;

                let p = self.write.prompt_type;
                self.write.redraw_prompt(p)
            }

            pub(crate) fn handle_signal(&mut self, signal: Signal) -> io::Result<()> {
                self.expire_blink()?;

                match signal {
                    Signal::Continue => {
                        self.write.draw_prompt()?;
                    }
                    Signal::Interrupt => {
                        self.read.macro_buffer.clear();
                        self.write.move_to_end()?;

                        if self.read.echo_control_characters {
                            self.write.write_str("^C")?;
                        }

                        self.write.write_str("\n")?;
                        self.reset_input();
                        self.write.draw_prompt()?;
                    }
                    _ => ()
                }

                Ok(())
            }

            fn backward_word(&mut self, n: usize) -> io::Result<()> {
                let pos = backward_word(n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break);
                self.write.move_to(pos)
            }

            fn forward_word(&mut self, n: usize) -> io::Result<()> {
                let pos = forward_word(n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break);
                self.write.move_to(pos)
            }

            /// Deletes a range of text from the input buffer.
            pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                self.write.delete_range(range)
            }

            /// Deletes a range from the buffer and adds the removed text to the
            /// kill ring.
            pub fn kill_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
                let len = end - start;

                if len != 0 {
                    let buf = self.write.buffer[start..end].to_owned();

                    if self.read.last_cmd != Category::Kill {
                        self.push_kill_ring(buf);
                    } else if end == self.write.cursor {
                        self.prepend_kill_ring(buf);
                    } else {
                        self.append_kill_ring(buf);
                    }

                    self.delete_range(start..end)?;
                }

                Ok(())
            }

            fn push_kill_ring(&mut self, s: String) {
                if self.read.kill_ring.len() == self.read.kill_ring.capacity() {
                    self.read.kill_ring.pop_back();
                }
                self.read.kill_ring.push_front(s);
            }

            fn rotate_kill_ring(&mut self) {
                if let Some(kill) = self.read.kill_ring.pop_front() {
                    self.read.kill_ring.push_back(kill);
                }
            }

            fn append_kill_ring(&mut self, s: String) {
                if let Some(kill) = self.read.kill_ring.front_mut() {
                    kill.push_str(&s);
                    return;
                }
                self.push_kill_ring(s);
            }

            fn prepend_kill_ring(&mut self, s: String) {
                if let Some(kill) = self.read.kill_ring.front_mut() {
                    kill.insert_str(0, &s);
                    return;
                }
                self.push_kill_ring(s);
            }

            /// Transposes two regions of the buffer, `src` and `dest`.
            pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>)
                    -> io::Result<()> {
                self.write.transpose_range(src, dest)
            }

            /// Insert text from the front of the kill ring at the current cursor position.
            pub fn yank(&mut self) -> io::Result<()> {
                if let Some(kill) = self.read.kill_ring.front().cloned() {
                    let start = self.write.cursor;
                    self.read.last_yank = Some((start, start + kill.len()));

                    self.insert_str(&kill)?;
                }

                Ok(())
            }

            /// Rotates the kill ring and replaces yanked text with the new front.
            ///
            /// If the previous operation was not `yank`, this has no effect.
            pub fn yank_pop(&mut self) -> io::Result<()> {
                if let Some((start, end)) = self.read.last_yank {
                    self.rotate_kill_ring();

                    if let Some(kill) = self.read.kill_ring.front().cloned() {
                        self.read.last_yank = Some((start, start + kill.len()));

                        self.write.move_to(start)?;
                        self.replace_str_forward(start..end, &kill)?;
                    }
                }

                Ok(())
            }

            /// Overwrite `n` characters; assumes `n >= 1`
            fn overwrite(&mut self, n: usize, ch: char) -> io::Result<()> {
                let start = self.write.cursor;
                let end = forward_char(n, &self.write.buffer, start);

                {
                    let over = &self.write.buffer[start..end];
                    let n_chars = over.chars().count();

                    if n > n_chars {
                        self.read.overwritten_append += n - n_chars;
                    }

                    if !over.is_empty() {
                        self.read.overwritten_chars.push_str(&over);
                    }
                }

                let s = repeat_char(ch, n);
                self.replace_str_forward(start..end, &s)
            }

            fn overwrite_back(&mut self, mut n: usize) -> io::Result<()> {
                if self.read.overwritten_append != 0 {
                    let n_del = n.min(self.read.overwritten_append);

                    let pos = backward_char(n_del, &self.write.buffer, self.write.cursor);
                    let r = pos..self.write.cursor;
                    self.delete_range(r)?;

                    self.read.overwritten_append -= n_del;
                    n -= n_del;
                }

                if n != 0 && !self.read.overwritten_chars.is_empty() {
                    let n_repl = n.min(self.read.overwritten_chars.chars().count());

                    let pos = backward_char(n_repl, &self.write.buffer, self.write.cursor);

                    let over_pos = backward_char(n_repl,
                        &self.read.overwritten_chars, self.read.overwritten_chars.len());

                    let over = self.read.overwritten_chars.drain(over_pos..).collect::<String>();

                    let r = pos..self.write.cursor;
                    self.replace_str_backward(r, &over)?;

                    n -= n_repl;
                }

                if n != 0 {
                    self.write.backward_char(n)?;
                }

                Ok(())
            }

            /// Insert a given character at the current cursor position `n` times.
            ///
            /// The cursor position remains the same.
            pub fn insert(&mut self, n: usize, ch: char) -> io::Result<()> {
                if n != 0 {
                    let s = repeat_char(ch, n);
                    self.insert_str(&s)?;
                }

                Ok(())
            }

            /// Insert a string at the current cursor position.
            ///
            /// The cursor is placed at the end of the new string.
            pub fn insert_str(&mut self, s: &str) -> io::Result<()> {
                self.write.insert_str(s)
            }

            /// Replaces a range in the buffer and redraws.
            ///
            /// The cursor is placed at the start of the range.
            pub fn replace_str_backward<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                self.replace_str_impl(range, s)?;
                let len = self.write.buffer.len();
                self.write.move_from(len)
            }

            /// Replaces a range in the buffer and redraws.
            ///
            /// The cursor is placed at the end of the new string.
            pub fn replace_str_forward<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                self.replace_str_impl(range, s)?;
                self.write.cursor += s.len();
                let len = self.write.buffer.len();
                self.write.move_from(len)
            }

            /// Replaces a range in the buffer and redraws.
            ///
            /// The cursor position is set to start of range, on-screen cursor remains
            /// at end of buffer.
            fn replace_str_impl<R: RangeArgument<usize>>(&mut self,
                    range: R, s: &str) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
                self.write.move_to(start)?;

                let _ = self.write.buffer.drain(start..end);
                let cursor = self.write.cursor;
                self.write.buffer.insert_str(cursor, s);

                self.write.draw_buffer(cursor)?;
                self.write.clear_to_screen_end()
            }
        }
    }
    /*
    */
    pub mod reader
    {
        //! Provides access to terminal read operations

        use std::borrow::Cow;
        use std::collections::{HashMap, VecDeque};
        use std::io;
        use std::mem::replace;
        use std::ops::{Deref, DerefMut};
        use std::path::{Path, PathBuf};
        use std::slice;
        use std::sync::{Arc, MutexGuard};
        use std::time::{Duration, Instant};

        use mortal::SequenceMap;

        use crate::command::{Category, Command};
        use crate::complete::{Completer, Completion, DummyCompleter};
        use crate::function::Function;
        use crate::inputrc::{parse_file, Directive};
        use crate::interface::Interface;
        use crate::prompter::Prompter;
        use crate::sys::path::{env_init_file, system_init_file, user_init_file};
        use crate::terminal::{
            RawRead, Signal, SignalSet, Size,
            Terminal, TerminalReader,
        };
        use crate::util::{first_char, match_name};
        use crate::variables::{Variable, Variables, VariableIter};

        /// Default set of string characters
        pub const STRING_CHARS: &str = "\"'";

        /// Default set of word break characters
        pub const WORD_BREAK_CHARS: &str = " \t\n\"\\'`@$><=;|&{(";

        /// Indicates the start of a series of invisible characters in the prompt
        pub const START_INVISIBLE: char = '\x01';

        /// Indicates the end of a series of invisible characters in the prompt
        pub const END_INVISIBLE: char = '\x02';

        /// Maximum size of kill ring
        const MAX_KILLS: usize = 10;

        /// Provides access to data related to reading and processing user input.
        pub struct Reader<'a, Term: 'a + Terminal> {
            iface: &'a Interface<Term>,
            lock: ReadLock<'a, Term>,
        }

        pub(crate) struct Read<Term: Terminal> {
            /// Application name
            pub application: Cow<'static, str>,

            /// Pending input
            pub input_buffer: Vec<u8>,
            /// Pending macro sequence
            pub macro_buffer: String,

            pub bindings: SequenceMap<Cow<'static, str>, Command>,
            pub functions: HashMap<Cow<'static, str>, Arc<dyn Function<Term>>>,

            /// Current input sequence
            pub sequence: String,
            /// Whether newline has been received
            pub input_accepted: bool,

            /// Whether overwrite mode is currently active
            pub overwrite_mode: bool,
            /// Characters appended while in overwrite mode
            pub overwritten_append: usize,
            /// Characters overwritten in overwrite mode
            pub overwritten_chars: String,

            /// Configured completer
            pub completer: Arc<dyn Completer<Term>>,
            /// Character appended to completions
            pub completion_append_character: Option<char>,
            /// Current set of possible completions
            pub completions: Option<Vec<Completion>>,
            /// Current "menu-complete" entry being viewed:
            pub completion_index: usize,
            /// Start of the completed word
            pub completion_start: usize,
            /// Start of the inserted prefix of a completed word
            pub completion_prefix: usize,

            pub string_chars: Cow<'static, str>,
            pub word_break: Cow<'static, str>,

            pub last_cmd: Category,
            pub last_yank: Option<(usize, usize)>,
            pub kill_ring: VecDeque<String>,

            pub catch_signals: bool,
            pub ignore_signals: SignalSet,
            pub report_signals: SignalSet,
            pub last_resize: Option<Size>,
            pub last_signal: Option<Signal>,

            variables: Variables,

            pub state: InputState,
            pub max_wait_duration: Option<Duration>,
        }

        pub(crate) struct ReadLock<'a, Term: 'a + Terminal> {
            term: Box<dyn TerminalReader<Term> + 'a>,
            data: MutexGuard<'a, Read<Term>>,
        }

        /// Returned from [`read_line`] to indicate user input
        #[derive(Debug)]
        pub enum ReadResult {
            /// User issued end-of-file
            Eof,
            /// User input received
            Input(String),
            /// Reported signal was received
            Signal(Signal),
        }

        #[derive(Copy, Clone, Debug)]
        pub(crate) enum InputState {
            Inactive,
            NewSequence,
            ContinueSequence{
                expiry: Option<Instant>,
            },
            Number,
            CharSearch{
                n: usize,
                backward: bool,
            },
            TextSearch,
            CompleteIntro,
            CompleteMore(usize),
            QuotedInsert(usize),
        }

        impl<'a, Term: 'a + Terminal> Reader<'a, Term> 
        {
            pub(crate) fn new(iface: &'a Interface<Term>, lock: ReadLock<'a, Term>) -> Reader<'a, Term>
            {
                Reader{iface, lock}
            }

            /// Interactively reads a line from the terminal device.
            pub fn read_line(&mut self) -> io::Result<ReadResult> 
            {
                loop 
                {
                    if let Some(res) = self.read_line_step(None)?
                    { return Ok(res); }
                }
            }

            /// Performs one step of the interactive `read_line` loop.
            pub fn read_line_step(&mut self, timeout: Option<Duration>) -> io::Result<Option<ReadResult>> 
            {
                self.initialize_read_line()?;
                let state = self.prepare_term()?;
                let res = self.read_line_step_impl(timeout);
                self.lock.term.restore(state)?;
                res
            }

            /// Cancels an in-progress `read_line` operation.
            pub fn cancel_read_line(&mut self) -> io::Result<()> 
            { self.end_read_line() }

            fn initialize_read_line(&mut self) -> io::Result<()>
            {
                if !self.lock.is_active()
                { self.prompter().start_read_line()?; }

                Ok(())
            }

            fn read_line_step_impl(&mut self, timeout: Option<Duration>) -> io::Result<Option<ReadResult>>
            {
                let do_read = if self.lock.is_input_available() 
                {
                    self.lock.term.wait_for_input(Some(Duration::from_secs(0)))?
                } 
                else 
                {
                    let timeout = limit_duration(timeout, self.lock.max_wait_duration);
                    self.lock.term.wait_for_input(timeout)?
                };

                if do_read
                { self.lock.read_input()?; }

                if let Some(size) = self.lock.take_resize()
                { self.handle_resize(size)?; }

                if let Some(sig) = self.lock.take_signal()
                {
                    if self.lock.report_signals.contains(sig)
                    { return Ok(Some(ReadResult::Signal(sig))); }
                    
                    if !self.lock.ignore_signals.contains(sig)
                    { self.handle_signal(sig)?; }
                }

                // Acquire the write lock and process all available input
                {
                    let mut prompter = self.prompter();
                    prompter.check_expire_timeout()?;
                    
                    let mut macro_len = prompter.read.data.macro_buffer.len();
                    while prompter.read.is_input_available()
                    {
                        if let Some(ch) = prompter.read.read_char()?
                        {
                            if let Some(r) = prompter.handle_input(ch)?
                            {
                                prompter.end_read_line()?;
                                return Ok(Some(r));
                            }
                        }

                        let new_macro_len = prompter.read.data.macro_buffer.len();

                        if new_macro_len != 0 && new_macro_len >= macro_len
                        { break; }

                        macro_len = new_macro_len;
                    }
                }

                Ok(None)
            }

            fn end_read_line(&mut self) -> io::Result<()>
            {
                if self.lock.is_active()
                { self.prompter().end_read_line()?; }

                Ok(())
            }

            fn prepare_term(&mut self) -> io::Result<Term::PrepareState>
            {
                if self.read_next_raw()
                { self.lock.term.prepare(true, SignalSet::new()) }
                
                else 
                {
                    let mut signals = self.lock.report_signals.union(self.lock.ignore_signals);
                    if self.lock.catch_signals 
                    { signals.insert(Signal::Interrupt); }

                    let block_signals = !self.lock.catch_signals;
                    self.lock.term.prepare(block_signals, signals)
                }
            }

            fn read_next_raw(&self) -> bool
            {
                match self.lock.state
                {
                    InputState::QuotedInsert(_) => true,
                    _ => false
                }
            }

            /// Sets the input buffer to the given string.
            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()>
            {
                if self.lock.is_active()
                { self.prompter().set_buffer(buf) } 
                else 
                {
                    self.iface.lock_write_data().set_buffer(buf);
                    Ok(())
                }
            }

            /// Sets the cursor position in the input buffer.
            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()>
            {
                if self.lock.is_active()
                { self.prompter().set_cursor(pos) } 
                else 
                {
                    self.iface.lock_write_data().set_cursor(pos);
                    Ok(())
                }
            }

            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()>
            { self.prompter().set_prompt(prompt) }

            /// Adds a line to history.
            pub fn add_history(&self, line: String)
            {
                if !self.lock.is_active()
                { self.iface.lock_write().add_history(line); }
            }

            /// Adds a line to history, unless it is identical to the most recent entry.
            pub fn add_history_unique(&self, line: String)
            {
                if !self.lock.is_active()
                { self.iface.lock_write().add_history_unique(line); }
            }

            /// Removes all history entries.
            pub fn clear_history(&self)
            {
                if !self.lock.is_active()
                { self.iface.lock_write().clear_history(); }
            }

            /// Removes the history entry at the given index.
            pub fn remove_history(&self, idx: usize)
            {
                if !self.lock.is_active()
                {
                    self.iface.lock_write().remove_history(idx);
                }
            }

            /// Sets the maximum number of history entries.
            pub fn set_history_size(&self, n: usize)
            {
                if !self.lock.is_active()
                { self.iface.lock_write().set_history_size(n); }
            }

            /// Truncates history to the only the most recent `n` entries.
            pub fn truncate_history(&self, n: usize) 
            {
                if !self.lock.is_active()
                { self.iface.lock_write().truncate_history(n); }
            }

            /// Returns the application name
            pub fn application(&self) -> &str
            { &self.lock.application }

            /// Sets the application name
            pub fn set_application<T>(&mut self, application: T) where 
            T: Into<Cow<'static, str>> 
            { self.lock.application = application.into(); }

            /// Returns a reference to the current completer instance.
            pub fn completer(&self) -> &Arc<dyn Completer<Term>>
            { &self.lock.completer }

            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer(&mut self, completer: Arc<dyn Completer<Term>>) -> Arc<dyn Completer<Term>>
            { replace(&mut self.lock.completer, completer) }

            /// Returns the value of the named variable or `None` if no such variable exists.
            pub fn get_variable(&self, name: &str) -> Option<Variable>
            { self.lock.get_variable(name) }

            /// Sets the value of the named variable and returns the previous value.
            pub fn set_variable(&mut self, name: &str, value: &str) -> Option<Variable>
            { self.lock.set_variable(name, value) }

            /// Returns an iterator over stored variables.
            pub fn variables(&self) -> VariableIter 
            { self.lock.variables.iter() }

            /// Returns whether to "blink" matching opening parenthesis character
            /// when a closing parenthesis character is entered.
            pub fn blink_matching_paren(&self) -> bool 
            { self.lock.blink_matching_paren }

            /// Sets the `blink-matching-paren` variable.
            pub fn set_blink_matching_paren(&mut self, set: bool)
            { self.lock.blink_matching_paren = set; }

            /// Returns whether `linefeed` will catch certain signals.
            pub fn catch_signals(&self) -> bool 
            { self.lock.catch_signals }

            /// Sets whether `linefeed` will catch certain signals.
            pub fn set_catch_signals(&mut self, enabled: bool) 
            { self.lock.catch_signals = enabled; }

            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal(&self, signal: Signal) -> bool
            { self.lock.ignore_signals.contains(signal) }

            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal(&mut self, signal: Signal, set: bool)
            {
                if set 
                {
                    self.lock.ignore_signals.insert(signal);
                    self.lock.report_signals.remove(signal);
                } 
                
                else
                { self.lock.ignore_signals.remove(signal); }
            }

            /// Returns whether the given `Signal` is to be reported.
            pub fn report_signal(&self, signal: Signal) -> bool
            { self.lock.report_signals.contains(signal) }

            /// Sets whether to report the given `Signal`.
            pub fn set_report_signal(&mut self, signal: Signal, set: bool)
            {
                if set
                {
                    self.lock.report_signals.insert(signal);
                    self.lock.ignore_signals.remove(signal);
                }
                
                else
                { self.lock.report_signals.remove(signal); }
            }

            /// Returns whether Tab completion is disabled.
            pub fn disable_completion(&self) -> bool 
            { self.lock.disable_completion }

            /// Sets the `disable-completion` variable.
            pub fn set_disable_completion(&mut self, disable: bool)
            { self.lock.disable_completion = disable; }

            /// When certain control characters are pressed, a character sequence
            /// equivalent to this character will be echoed.
            pub fn echo_control_characters(&self) -> bool
            { self.lock.echo_control_characters }

            /// Sets the `echo-control-characters` variable.
            pub fn set_echo_control_characters(&mut self, echo: bool)
            { self.lock.echo_control_characters = echo; }

            /// Returns the character, if any, that is appended to a successful completion.
            pub fn completion_append_character(&self) -> Option<char>
            { self.lock.completion_append_character }

            /// Sets the character, if any, that is appended to a successful completion.
            pub fn set_completion_append_character(&mut self, ch: Option<char>)
            { self.lock.completion_append_character = ch; }

            /// Returns the width of completion listing display.
            pub fn completion_display_width(&self) -> usize
            { self.lock.completion_display_width }

            /// Sets the `completion-display-width` variable.
            pub fn set_completion_display_width(&mut self, n: usize)
            { self.lock.completion_display_width = n; }

            /// Returns the minimum number of completion items that require user confirmation before listing.
            pub fn completion_query_items(&self) -> usize
            { self.lock.completion_query_items }

            /// Sets the `completion-query-items` variable.
            pub fn set_completion_query_items(&mut self, n: usize)
            { self.lock.completion_query_items = n; }

            /// Returns timeout to wait for further user input when an ambiguous sequence has been entered.
            pub fn keyseq_timeout(&self) -> Option<Duration>
            { self.lock.keyseq_timeout }

            /// Sets the `keyseq-timeout` variable.
            pub fn set_keyseq_timeout(&mut self, timeout: Option<Duration>)
            { self.lock.keyseq_timeout = timeout; }

            /// Returns whether to list possible completions one page at a time.
            pub fn page_completions(&self) -> bool
            { self.lock.page_completions }

            /// Sets the `page-completions` variable.
            pub fn set_page_completions(&mut self, set: bool)
            { self.lock.page_completions = set; }

            /// Returns whether to list completions horizontally, rather than down the screen.
            pub fn print_completions_horizontally(&self) -> bool
            { self.lock.print_completions_horizontally }

            /// Sets the `print-completions-horizontally` variable.
            pub fn set_print_completions_horizontally(&mut self, set: bool)
            { self.lock.print_completions_horizontally = set; }

            /// Returns the set of characters that delimit strings.
            pub fn string_chars(&self) -> &str
            { &self.lock.string_chars }

            /// Sets the set of characters that delimit strings.
            pub fn set_string_chars<T>(&mut self, chars: T) where
            T: Into<Cow<'static, str>>
            { self.lock.string_chars = chars.into(); }

            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars(&self) -> &str
            { &self.lock.word_break }

            /// Sets the set of characters that indicate a word break.
            pub fn set_word_break_chars<T>(&mut self, chars: T) where 
            T: Into<Cow<'static, str>>
            { self.lock.word_break = chars.into(); }

            /// Returns an iterator over bound sequences
            pub fn bindings(&self) -> BindingIter
            { self.lock.bindings() }

            /// Binds a sequence to a command.
            pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command> where 
            T: Into<Cow<'static, str>>
            { self.lock.bind_sequence(seq, cmd) }

            /// Binds a sequence to a command, if and only if the given sequence is not already bound to a command.
            pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool where 
            T: Into<Cow<'static, str>>
            { self.lock.bind_sequence_if_unbound(seq, cmd) }

            /// Removes a binding for the given sequence.
            pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command>
            { self.lock.unbind_sequence(seq) }

            /// Defines a named function to which sequences may be bound.
            pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>) -> Option<Arc<dyn Function<Term>>> where 
            T: Into<Cow<'static, str>> 
            { self.lock.define_function(name, cmd) }

            /// Removes a function defined with the given name.
            pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>>
            { self.lock.remove_function(name) }

            pub(crate) fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>)
            { self.lock.data.evaluate_directives(term, dirs) }

            pub(crate) fn evaluate_directive(&mut self, term: &Term, dir: Directive)
            { self.lock.data.evaluate_directive(term, dir) }

            fn prompter<'b>(&'b mut self) -> Prompter<'b, 'a, Term>
            {
                Prompter::new
                (
                    &mut self.lock,
                    self.iface.lock_write()
                )
            }

            fn handle_resize(&mut self, size: Size) -> io::Result<()>
            { self.prompter().handle_resize(size) }

            fn handle_signal(&mut self, sig: Signal) -> io::Result<()>
            { self.prompter().handle_signal(sig) }
        }

        impl<'a, Term: 'a + Terminal> ReadLock<'a, Term> 
        {
            pub fn new(term: Box<dyn TerminalReader<Term> + 'a>, data: MutexGuard<'a, Read<Term>>)
                    -> ReadLock<'a, Term> {
                ReadLock{term, data}
            }

            /// Reads the next character of input.
            pub fn read_char(&mut self) -> io::Result<Option<char>> {
                if let Some(ch) = self.macro_pop() {
                    Ok(Some(ch))
                } else if let Some(ch) = self.decode_input()? {
                    Ok(Some(ch))
                } else {
                    Ok(None)
                }
            }

            fn read_input(&mut self) -> io::Result<()> {
                match self.term.read(&mut self.data.input_buffer)? {
                    RawRead::Bytes(_) => (),
                    RawRead::Resize(new_size) => {
                        self.last_resize = Some(new_size);
                    }
                    RawRead::Signal(sig) => {
                        self.last_signal = Some(sig);
                    }
                }

                Ok(())
            }

            fn is_input_available(&self) -> bool {
                !self.data.macro_buffer.is_empty() || match self.peek_input() {
                    Ok(Some(_)) | Err(_) => true,
                    Ok(None) => false
                }
            }

            fn macro_pop(&mut self) -> Option<char> {
                if self.data.macro_buffer.is_empty() {
                    None
                } else {
                    Some(self.data.macro_buffer.remove(0))
                }
            }

            fn decode_input(&mut self) -> io::Result<Option<char>> {
                let res = self.peek_input();

                if let Ok(Some(ch)) = res {
                    self.data.input_buffer.drain(..ch.len_utf8());
                }

                res
            }

            fn peek_input(&self) -> io::Result<Option<char>> {
                if self.data.input_buffer.is_empty() {
                    Ok(None)
                } else {
                    first_char(&self.data.input_buffer)
                }
            }

            pub fn reset_data(&mut self) {
                self.data.reset_data();
            }
        }

        impl<'a, Term: 'a + Terminal> Deref for ReadLock<'a, Term> {
            type Target = Read<Term>;

            fn deref(&self) -> &Read<Term> {
                &self.data
            }
        }

        impl<'a, Term: 'a + Terminal> DerefMut for ReadLock<'a, Term> {
            fn deref_mut(&mut self) -> &mut Read<Term> {
                &mut self.data
            }
        }

        impl<Term: Terminal> Deref for Read<Term> {
            type Target = Variables;

            fn deref(&self) -> &Variables {
                &self.variables
            }
        }

        impl<Term: Terminal> DerefMut for Read<Term> {
            fn deref_mut(&mut self) -> &mut Variables {
                &mut self.variables
            }
        }

        impl<Term: Terminal> Read<Term> {
            pub fn new(term: &Term, application: Cow<'static, str>) -> Read<Term> {
                let mut r = Read{
                    application,

                    bindings: default_bindings(),
                    functions: HashMap::new(),

                    input_buffer: Vec::new(),
                    macro_buffer: String::new(),

                    sequence: String::new(),
                    input_accepted: false,

                    overwrite_mode: false,
                    overwritten_append: 0,
                    overwritten_chars: String::new(),

                    completer: Arc::new(DummyCompleter),
                    completion_append_character: Some(' '),
                    completions: None,
                    completion_index: 0,
                    completion_start: 0,
                    completion_prefix: 0,

                    string_chars: STRING_CHARS.into(),
                    word_break: WORD_BREAK_CHARS.into(),

                    last_cmd: Category::Other,
                    last_yank: None,
                    kill_ring: VecDeque::with_capacity(MAX_KILLS),

                    catch_signals: true,
                    ignore_signals: SignalSet::new(),
                    report_signals: SignalSet::new(),
                    last_resize: None,
                    last_signal: None,

                    variables: Variables::default(),

                    state: InputState::Inactive,
                    max_wait_duration: None,
                };

                r.read_init(term);
                r
            }

            pub fn bindings(&self) -> BindingIter {
                BindingIter(self.bindings.sequences().iter())
            }

            pub fn variables(&self) -> VariableIter {
                self.variables.iter()
            }

            fn take_resize(&mut self) -> Option<Size> {
                self.last_resize.take()
            }

            fn take_signal(&mut self) -> Option<Signal> {
                self.last_signal.take()
            }

            pub fn queue_input(&mut self, seq: &str) {
                self.macro_buffer.insert_str(0, seq);
            }

            pub fn is_active(&self) -> bool {
                match self.state {
                    InputState::Inactive => false,
                    _ => true
                }
            }

            pub fn reset_data(&mut self) {
                self.state = InputState::NewSequence;
                self.input_accepted = false;
                self.overwrite_mode = false;
                self.overwritten_append = 0;
                self.overwritten_chars.clear();
                self.sequence.clear();

                self.completions = None;

                self.last_cmd = Category::Other;
                self.last_yank = None;

                self.last_resize = None;
                self.last_signal = None;
            }

            pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.bindings.insert(seq.into(), cmd)
            }

            pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool
                    where T: Into<Cow<'static, str>> {
                use mortal::sequence::Entry;

                match self.bindings.entry(seq.into()) {
                    Entry::Occupied(_) => false,
                    Entry::Vacant(ent) => {
                        ent.insert(cmd);
                        true
                    }
                }
            }

            pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> {
                self.bindings.remove(seq)
                    .map(|(_, cmd)| cmd)
            }

            pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>)
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.functions.insert(name.into(), cmd)
            }

            pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>> {
                self.functions.remove(name)
            }

            fn read_init(&mut self, term: &Term) {
                if let Some(path) = env_init_file() {
                    // If `INPUTRC` is present, even if invalid, parse nothing else.
                    // Thus, an empty `INPUTRC` will inhibit loading configuration.
                    self.read_init_file_if_exists(term, Some(path));
                } else {
                    if !self.read_init_file_if_exists(term, user_init_file()) {
                        self.read_init_file_if_exists(term, system_init_file());
                    }
                }
            }

            fn read_init_file_if_exists(&mut self, term: &Term, path: Option<PathBuf>) -> bool {
                match path {
                    Some(ref path) if path.exists() => {
                        self.read_init_file(term, path);
                        true
                    }
                    _ => false
                }
            }

            fn read_init_file(&mut self, term: &Term, path: &Path) {
                if let Some(dirs) = parse_file(path) {
                    self.evaluate_directives(term, dirs);
                }
            }

            /// Evaluates a series of configuration directives.
            pub(crate) fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>) {
                for dir in dirs {
                    self.evaluate_directive(term, dir);
                }
            }

            /// Evaluates a single configuration directive.
            pub(crate) fn evaluate_directive(&mut self, term: &Term, dir: Directive) {
                match dir {
                    Directive::Bind(seq, cmd) => {
                        self.bind_sequence(seq, cmd);
                    }
                    Directive::Conditional{name, value, then_group, else_group} => {
                        let name = name.as_ref().map(|s| &s[..]);

                        if self.eval_condition(term, name, &value) {
                            self.evaluate_directives(term, then_group);
                        } else {
                            self.evaluate_directives(term, else_group);
                        }
                    }
                    Directive::SetVariable(name, value) => {
                        self.set_variable(&name, &value);
                    }
                }
            }

            fn eval_condition(&self, term: &Term, name: Option<&str>, value: &str) -> bool {
                match name {
                    None => self.application == value,
                    Some("lib") => value == "linefeed",
                    Some("mode") => value == "emacs",
                    Some("term") => self.term_matches(term, value),
                    _ => false
                }
            }

            fn term_matches(&self, term: &Term, value: &str) -> bool {
                match_name(term.name(), value)
            }
        }

        /// Iterator over `Reader` bindings
        pub struct BindingIter<'a>(slice::Iter<'a, (Cow<'static, str>, Command)>);

        impl<'a> ExactSizeIterator for BindingIter<'a> {}

        impl<'a> Iterator for BindingIter<'a> {
            type Item = (&'a str, &'a Command);

            #[inline]
            fn next(&mut self) -> Option<Self::Item> {
                self.0.next().map(|&(ref s, ref cmd)| (&s[..], cmd))
            }

            #[inline]
            fn nth(&mut self, n: usize) -> Option<Self::Item> {
                self.0.nth(n).map(|&(ref s, ref cmd)| (&s[..], cmd))
            }

            #[inline]
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.0.size_hint()
            }
        }

        impl<'a> DoubleEndedIterator for BindingIter<'a> {
            #[inline]
            fn next_back(&mut self) -> Option<Self::Item> {
                self.0.next_back().map(|&(ref s, ref cmd)| (&s[..], cmd))
            }
        }

        fn default_bindings() -> SequenceMap<Cow<'static, str>, Command> {
            use crate::command::Command::*;

            SequenceMap::from(vec![
                // Carriage return and line feed
                ("\r".into(), AcceptLine),
                ("\n".into(), AcceptLine),

                // Possible sequences for arrow keys, Home, End
                ("\x1b[A".into(), PreviousHistory),
                ("\x1b[B".into(), NextHistory),
                ("\x1b[C".into(), ForwardChar),
                ("\x1b[D".into(), BackwardChar),
                ("\x1b[H".into(), BeginningOfLine),
                ("\x1b[F".into(), EndOfLine),

                // More possible sequences for arrow keys, Home, End
                ("\x1bOA".into(), PreviousHistory),
                ("\x1bOB".into(), NextHistory),
                ("\x1bOC".into(), ForwardChar),
                ("\x1bOD".into(), BackwardChar),
                ("\x1bOH".into(), BeginningOfLine),
                ("\x1bOF".into(), EndOfLine),

                // Possible sequences for Insert, Delete
                ("\x1b[2~".into(), OverwriteMode),
                ("\x1b[3~".into(), DeleteChar),

                // Basic commands
                ("\x01"    .into(), BeginningOfLine),           // Ctrl-A
                ("\x02"    .into(), BackwardChar),              // Ctrl-B
                ("\x04"    .into(), DeleteChar),                // Ctrl-D
                ("\x05"    .into(), EndOfLine),                 // Ctrl-E
                ("\x06"    .into(), ForwardChar),               // Ctrl-F
                ("\x07"    .into(), Abort),                     // Ctrl-G
                ("\x08"    .into(), BackwardDeleteChar),        // Ctrl-H
                ("\x0b"    .into(), KillLine),                  // Ctrl-K
                ("\x0c"    .into(), ClearScreen),               // Ctrl-L
                ("\x0e"    .into(), NextHistory),               // Ctrl-N
                ("\x10"    .into(), PreviousHistory),           // Ctrl-P
                ("\x12"    .into(), ReverseSearchHistory),      // Ctrl-R
                ("\x14"    .into(), TransposeChars),            // Ctrl-T
                ("\x15"    .into(), BackwardKillLine),          // Ctrl-U
                ("\x16"    .into(), QuotedInsert),              // Ctrl-V
                ("\x17"    .into(), UnixWordRubout),            // Ctrl-W
                ("\x19"    .into(), Yank),                      // Ctrl-Y
                ("\x1d"    .into(), CharacterSearch),           // Ctrl-]
                ("\x7f"    .into(), BackwardDeleteChar),        // Rubout
                ("\x1b\x08".into(), BackwardKillWord),          // Escape, Ctrl-H
                ("\x1b\x1d".into(), CharacterSearchBackward),   // Escape, Ctrl-]
                ("\x1b\x7f".into(), BackwardKillWord),          // Escape, Rubout
                ("\x1bb"   .into(), BackwardWord),              // Escape, b
                ("\x1bd"   .into(), KillWord),                  // Escape, d
                ("\x1bf"   .into(), ForwardWord),               // Escape, f
                ("\x1bt"   .into(), TransposeWords),            // Escape, t
                ("\x1by"   .into(), YankPop),                   // Escape, y
                ("\x1b#"   .into(), InsertComment),             // Escape, #
                ("\x1b<"   .into(), BeginningOfHistory),        // Escape, <
                ("\x1b>"   .into(), EndOfHistory),              // Escape, >

                // Completion commands
                ("\t"   .into(), Complete),             // Tab
                ("\x1b?".into(), PossibleCompletions),  // Escape, ?
                ("\x1b*".into(), InsertCompletions),    // Escape, *

                // Digit commands
                ("\x1b-".into(), DigitArgument),    // Escape, -
                ("\x1b0".into(), DigitArgument),    // Escape, 0
                ("\x1b1".into(), DigitArgument),    // Escape, 1
                ("\x1b2".into(), DigitArgument),    // Escape, 2
                ("\x1b3".into(), DigitArgument),    // Escape, 3
                ("\x1b4".into(), DigitArgument),    // Escape, 4
                ("\x1b5".into(), DigitArgument),    // Escape, 5
                ("\x1b6".into(), DigitArgument),    // Escape, 6
                ("\x1b7".into(), DigitArgument),    // Escape, 7
                ("\x1b8".into(), DigitArgument),    // Escape, 8
                ("\x1b9".into(), DigitArgument),    // Escape, 9
            ])
        }

        fn limit_duration(dur: Option<Duration>, max: Option<Duration>) -> Option<Duration> {
            match (dur, max) {
                (dur, None) | (None, dur) => dur,
                (Some(dur), Some(max)) => Some(dur.min(max)),
            }
        }
    }
    /*
    */
    pub mod table
    {
        //! Provides utilities for formatting strings in a table
        use ::cmp::min;

        const COL_SPACE: usize = 2;

        /// Represents a table of strings, formatted into rows and columns.
        pub struct Table<'a, S: 'a> 
        {
            strings: &'a [S],
            sizes: Option<&'a [usize]>,
            offset: usize,
            per_col: usize,
            rows: usize,
            horizontal: bool,
        }

        impl<'a, S: 'a + AsRef<str>> Table<'a, S> 
        {
            /// Constructs a new table from the given set of strings, using the given column sizes.
            pub fn new(strs: &'a [S], mut sizes: Option<&'a [usize]>, horizontal: bool) -> Table<'a, S> 
            {
                if let Some(sz) = sizes 
                {
                    if sz.is_empty() 
                    { sizes = None; }
                }

                let n_strs = strs.len();
                let n_cols = sizes.map_or(1, |sz| sz.len());

                let rows = n_strs / n_cols + (n_strs % n_cols != 0) as usize;

                Table
                {
                    strings: strs,
                    sizes: sizes,
                    offset: 0,
                    per_col: (strs.len() + (n_cols - 1)) / n_cols,
                    rows: rows,
                    horizontal: horizontal,
                }
            }

            /// Returns whether more lines are present in the table.
            pub fn has_more(&self) -> bool
            { self.offset < self.rows }

            fn num_cols(&self) -> usize 
            { self.sizes.map_or(1, |sz| sz.len()) }
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Table<'a, S> 
        {
            type Item = Line<'a, S>;

            fn next(&mut self) -> Option<Line<'a, S>>
            {
                if self.offset == self.rows 
                { return None; }

                let n = self.num_cols();

                let (start, end, stride) = if self.horizontal
                {
                    let start = self.offset * n;
                    let end = min(self.strings.len(), start + n);
                    (start, end, 1)
                } 
                else
                {
                    let start = self.offset;
                    let end = min(self.strings.len(), start + self.per_col * n);
                    (start, end, self.per_col)
                };

                self.offset += 1;

                Some
                (
                    Line
                    {
                        strings: &self.strings[start..end],
                        sizes: self.sizes,
                        stride: stride,
                        offset: 0,
                    }
                )
            }
        }

        /// Represents a single line of the table.
        pub struct Line<'a, S: 'a> 
        {
            strings: &'a [S],
            sizes: Option<&'a [usize]>,
            stride: usize,
            offset: usize,
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Line<'a, S>
        {
            type Item = (usize, &'a str);

            fn next(&mut self) -> Option<(usize, &'a str)>
            {
                let s = self.strings.get(self.offset * self.stride)?.as_ref();

                let width = self.sizes
                    .and_then(|sz| sz.get(self.offset).cloned())
                    .unwrap_or_else(|| s.chars().count());

                self.offset += 1;

                Some((width, s))
            }
        }

        /// Formats a series of strings into columns, fitting within a given screen width.
        pub fn format_columns<S: AsRef<str>>(strs: &[S], screen_width: usize, horizontal: bool) -> Option<Vec<usize>>
        {
            if strs.is_empty()
            { return None; }

            let n_strs = strs.len();

            let (mut min_len, mut max_len) = min_max(strs.iter().map(|s| s.as_ref().chars().count()));

            if min_len == 0 { min_len = 1; }
            if max_len == 0 { max_len = 1; }

            let mut min_cols = min(n_strs, screen_width / max_len);
            let max_cols = min(n_strs, screen_width / min_len);

            if min_cols <= 1 
            { min_cols = 2; }

            if max_cols <= 1
            { return None; }

            let mut col_sizes = if min_cols == max_cols
            { vec![vec![0; max_cols]] } 

            else 
            { (min_cols..max_cols + 1).map(|n| vec![0; n]).collect::<Vec<_>>() };

            for (i, s) in strs.iter().enumerate()
            {
                let len = s.as_ref().chars().count();

                for cols in &mut col_sizes
                {
                    let n_cols = cols.len();

                    let col = if horizontal
                    { i % n_cols }

                    else 
                    {
                        let per_col = (n_strs + (n_cols - 1)) / n_cols;
                        i / per_col
                    };

                    let real_len = if col == n_cols - 1 { len } else { len + COL_SPACE };

                    if real_len > cols[col]
                    { cols[col] = real_len; }
                }
            }

            for cols in col_sizes.into_iter().rev()
            {
                if cols.iter().fold(0, |a, b| a + b) <= screen_width
                { return Some(cols); }
            }

            None
        }

        fn min_max<I>(iter: I) -> (usize, usize) where I: Iterator<Item=usize> {
            let mut min = usize::max_value();
            let mut max = 0;

            for n in iter {
                if n < min {
                    min = n;
                }
                if n + COL_SPACE > max {
                    max = n + COL_SPACE;
                }
            }

            (min, max)
        }
    }
    /*
    */
    pub mod terminal
    {
        //! Provides a low-level terminal interface

        use ::io;
        use ::time::Duration;

        use ::mortal::{self, PrepareConfig, PrepareState, TerminalReadGuard, TerminalWriteGuard};
        use ::linefeed::sys;

        pub use ::mortal::{CursorMode, Signal, SignalSet, Size};

        /// Default `Terminal` interface
        pub struct DefaultTerminal(mortal::Terminal);

        /// Represents the result of a `Terminal` read operation
        pub enum RawRead 
        {
            /// `n` bytes were read from the device
            Bytes(usize),
            /// The terminal window was resized
            Resize(Size),
            /// A signal was received while waiting for input
            Signal(Signal),
        }

        /// Defines a low-level interface to the terminal
        pub trait Terminal: Sized + Send + Sync 
        {
            /// Returned by `prepare`; passed to `restore` to restore state.
            type PrepareState;

            /// Returns the name of the terminal.
            fn name(&self) -> &str;

            /// Acquires a lock on terminal read operations and returns a value holding
            /// that lock and granting access to such operations.
            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a>;

            /// Acquires a lock on terminal write operations and returns a value holding
            /// that lock and granting access to such operations.
            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a>;
        }

        /// Holds a lock on `Terminal` read operations
        pub trait TerminalReader<Term: Terminal>
        {
            /// Prepares the terminal for line reading and editing operations.
            fn prepare(&mut self, block_signals: bool, report_signals: SignalSet)
            -> io::Result<Term::PrepareState>;

            /// Like `prepare`, but called when the write lock is already held.
            unsafe fn prepare_with_lock(&mut self, lock: &mut dyn TerminalWriter<Term>, block_signals: bool, report_signals: SignalSet)
            -> io::Result<Term::PrepareState>;

            /// Restores the terminal state using the given state data.
            fn restore(&mut self, state: Term::PrepareState) -> io::Result<()>;

            /// Like `restore`, but called when the write lock is already held.
            unsafe fn restore_with_lock(&mut self, lock: &mut dyn TerminalWriter<Term>, state: Term::PrepareState) -> io::Result<()>;

            /// Reads some input from the terminal and appends it to the given buffer.
            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead>;

            /// Waits `timeout` for user input. If `timeout` is `None`, waits indefinitely.
            fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool>;
        }

        /// Holds a lock on `Terminal` write operations
        pub trait TerminalWriter<Term: Terminal> 
        {
            /// Returns the size of the terminal window
            fn size(&self) -> io::Result<Size>;

            /// Presents a clear terminal screen, with cursor at first row, first column.
            fn clear_screen(&mut self) -> io::Result<()>;

            /// Clears characters on the line occupied by the cursor, 
            /// beginning with the cursor and ending at the end of the line.
            fn clear_to_screen_end(&mut self) -> io::Result<()>;

            /// Moves the cursor up `n` cells; `n` may be zero.
            fn move_up(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor down `n` cells; `n` may be zero.
            fn move_down(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor left `n` cells; `n` may be zero.
            fn move_left(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor right `n` cells; `n` may be zero.
            fn move_right(&mut self, n: usize) -> io::Result<()>;

            /// Moves the cursor to the first column of the current line
            fn move_to_first_column(&mut self) -> io::Result<()>;

            /// Set the current cursor mode
            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>;

            /// Writes output to the terminal.
            fn write(&mut self, s: &str) -> io::Result<()>;

            /// Flushes any currently buffered output data.
            fn flush(&mut self) -> io::Result<()>;
        }

        impl DefaultTerminal 
        {
            /// Opens access to the terminal device associated with standard output.
            pub fn new() -> io::Result<DefaultTerminal> 
            {
                mortal::Terminal::new().map(DefaultTerminal)
            }

            /// Opens access to the terminal device associated with standard error.
            pub fn stderr() -> io::Result<DefaultTerminal> 
            {
                mortal::Terminal::stderr().map(DefaultTerminal)
            }

            unsafe fn cast_writer<'a>(writer: &'a mut dyn TerminalWriter<Self>) -> &'a mut TerminalWriteGuard<'a> 
            {
                &mut *(writer as *mut _ as *mut TerminalWriteGuard)
            }
        }

        impl Terminal for DefaultTerminal 
        {
            type PrepareState = PrepareState;

            fn name(&self) -> &str { self.0.name() }

            fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a>
            { Box::new(self.0.lock_read().unwrap()) }

            fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a> 
            { Box::new(self.0.lock_write().unwrap()) }
        }

        impl<'a> TerminalReader<DefaultTerminal> for TerminalReadGuard<'a>
        {
            fn prepare(&mut self, block_signals: bool, report_signals: SignalSet) -> io::Result<PrepareState> 
            {
                self.prepare
                (
                    PrepareConfig
                    {
                        block_signals,
                        enable_control_flow: !block_signals,
                        enable_keypad: false,
                        report_signals,
                        .. PrepareConfig::default()
                    }
                )
            }

            unsafe fn prepare_with_lock(&mut self, lock: &mut dyn TerminalWriter<DefaultTerminal>, block_signals: bool, report_signals: SignalSet) -> io::Result<PrepareState>
            {
                let lock = DefaultTerminal::cast_writer(lock);

                self.prepare_with_lock
                (
                    lock, 
                    PrepareConfig
                    {
                        block_signals,
                        enable_control_flow: !block_signals,
                        enable_keypad: false,
                        report_signals,
                        .. PrepareConfig::default()
                    }
                )
            }

            fn restore(&mut self, state: PrepareState) -> io::Result<()>
            { self.restore(state) }

            unsafe fn restore_with_lock(&mut self, lock: &mut dyn TerminalWriter<DefaultTerminal>, state: PrepareState) -> io::Result<()> 
            {
                let lock = DefaultTerminal::cast_writer(lock);
                self.restore_with_lock(lock, state)
            }

            fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead> 
            { sys::terminal_read(self, buf) }

            fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool> 
            { self.wait_event(timeout) }
        }

        impl<'a> TerminalWriter<DefaultTerminal> for TerminalWriteGuard<'a> 
        {
            fn size(&self) -> io::Result<Size>
            { self.size() }

            fn clear_screen(&mut self) -> io::Result<()>
            { self.clear_screen() }

            fn clear_to_screen_end(&mut self) -> io::Result<()>
            { self.clear_to_screen_end() }

            fn move_up(&mut self, n: usize) -> io::Result<()>
            { self.move_up(n) }
            
            fn move_down(&mut self, n: usize) -> io::Result<()>
            { self.move_down(n) }

            fn move_left(&mut self, n: usize) -> io::Result<()>
            { self.move_left(n) }

            fn move_right(&mut self, n: usize) -> io::Result<()>
            { self.move_right(n) }

            fn move_to_first_column(&mut self) -> io::Result<()>
            { self.move_to_first_column() }

            fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>
            { self.set_cursor_mode(mode) }

            fn write(&mut self, s: &str) -> io::Result<()>
            { self.write_str(s) }

            fn flush(&mut self) -> io::Result<()>
            { self.flush() }
        }
    }
    /*
    */
    pub mod util
    {
        //! Provides miscellaneous utilities

        use ::borrow::Cow;
        use ::io;
        use ::ops::{Range, RangeFrom, RangeFull, RangeTo};
        use ::str::{from_utf8, from_utf8_unchecked};

        pub fn filter_visible(s: &str) -> Cow<str> 
        {
            use crate::reader::{START_INVISIBLE, END_INVISIBLE};

            if !s.contains(START_INVISIBLE)
            { return Cow::Borrowed(s); }

            let mut virt = String::new();
            let mut ignore = false;

            for ch in s.chars()
            {
                if ch == START_INVISIBLE
                { ignore = true; } 
                
                else if ch == END_INVISIBLE
                { ignore = false; }
                
                else if !ignore
                { virt.push(ch); }
            }

            Cow::Owned(virt)
        }

        /// Returns the longest common prefix of a set of strings.
        pub fn longest_common_prefix<'a, I, S>(iter: I) -> Option<&'a str> where
        I: IntoIterator<Item=&'a S>,
        S: 'a + ?Sized + AsRef<str>,
        {
            let mut iter = iter.into_iter();
            let mut pfx = iter.next()?.as_ref();
            for s in iter 
            {
                let s = s.as_ref();
                let n = pfx.chars().zip(s.chars())
                .take_while(|&(a, b)| a == b)
                .map(|(ch, _)| ch.len_utf8()).sum();

                if n == 0 
                { return None; }
                
                else 
                { pfx = &pfx[..n]; }
            }

            Some(pfx)
        }

        /// Returns a string consisting of a `char`, repeated `n` times.
        pub fn repeat_char(ch: char, n: usize) -> String
        {
            let mut buf = [0; 4];
            let s = ch.encode_utf8(&mut buf);
            s.repeat(n)
        }

        /// Implemented for built-in range types.
        pub trait RangeArgument<T>
        {
            /// Returns the start of range, if present.
            fn start(&self) -> Option<&T> { None }

            /// Returns the end of range, if present.
            fn end(&self) -> Option<&T> { None }
        }

        impl<T> RangeArgument<T> for Range<T> 
        {
            fn start(&self) -> Option<&T> { Some(&self.start) }

            fn end(&self) -> Option<&T> { Some(&self.end) }
        }

        impl<T> RangeArgument<T> for RangeFrom<T>
        {
            fn start(&self) -> Option<&T> { Some(&self.start) }
        }

        impl<T> RangeArgument<T> for RangeTo<T>
        {
            fn end(&self) -> Option<&T> { Some(&self.end) }
        }

        impl<T> RangeArgument<T> for RangeFull {}

        pub fn backward_char(n: usize, s: &str, cur: usize) -> usize
        {
            let mut chars = s[..cur].char_indices().filter(|&(_, ch)| !is_combining_mark(ch));
            let mut res = cur;

            for _ in 0..n 
            {
                match chars.next_back() 
                {
                    Some((idx, _)) => res = idx,
                    None => return 0
                }
            }

            res
        }

        pub fn forward_char(n: usize, s: &str, cur: usize) -> usize
        {
            let mut chars = s[cur..].char_indices().filter(|&(_, ch)| !is_combining_mark(ch));

            for _ in 0..n 
            {
                match chars.next()
                {
                    Some(_) => (),
                    None => return s.len()
                }
            }

            match chars.next()
            {
                Some((idx, _)) => cur + idx,
                None => s.len()
            }
        }

        pub fn backward_search_char(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize>
        {
            let mut pos = None;

            for _ in 0..n
            {
                match buf[..cur].rfind(ch)
                {
                    Some(p) =>
                    {
                        cur = p;
                        pos = Some(cur);
                    }
                    None => break
                }
            }

            pos
        }

        pub fn forward_search_char(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize>
        {
            let mut pos = None;

            for _ in 0..n 
            {
                let off = match buf[cur..].chars().next()
                {
                    Some(ch) => ch.len_utf8(),
                    None => break
                };

                match buf[cur + off..].find(ch)
                {
                    Some(p) =>
                    {
                        cur += off + p;
                        pos = Some(cur);
                    }
                    None => break
                }
            }

            pos
        }

        pub fn backward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
        {
            let mut chars = buf[..cur].char_indices().rev();

            for _ in 0..n
            {
                drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
            }

            match chars.next()
            {
                Some((ind, ch)) => ind + ch.len_utf8(),
                None => 0
            }
        }

        pub fn forward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
        {
            let mut chars = buf[cur..].char_indices();

            for _ in 0..n
            {
                drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
            }

            match chars.next()
            {
                Some((ind, _)) => cur + ind,
                None => buf.len()
            }
        }

        pub fn back_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize>
        {
            let prev = backward_word(1, buf, cur, word_break);
            let end = word_end(&buf, prev, word_break);

            if n > 1
            {
                let start = backward_word(n - 1, buf, prev, word_break);
                start..end
            } 
            
            else 
            { prev..end }
        }

        pub fn forward_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize> 
        {
            let start = next_word(1, buf, cur, word_break);

            if n > 1 
            {
                let last = next_word(n - 1, buf, start, word_break);
                let end = word_end(buf, last, word_break);
                start..end
            } 
            else 
            {
                let end = word_end(buf, start, word_break);
                start..end
            }
        }

        /// Returns the first character in the buffer, if it contains any valid characters.
        pub fn first_char(buf: &[u8]) -> io::Result<Option<char>> 
        {
            match from_utf8(buf) 
            {
                Ok(s) => Ok(s.chars().next()),
                Err(e) => 
                {
                    if e.error_len().is_some() 
                    {
                        return Err(io::Error::new(io::ErrorKind::InvalidData,
                            "invalid utf-8 input received"));
                    }

                    let valid = e.valid_up_to();

                    let s = unsafe { from_utf8_unchecked(&buf[..valid]) };
                    Ok(s.chars().next())
                }
            }
        }

        pub fn first_word(buf: &str, word_break: &str) -> Option<usize> 
        {
            let mut chars = buf.char_indices();

            drop_while(&mut chars, |(_, ch)| word_break.contains(ch));

            chars.next().map(|(idx, _)| idx)
        }

        pub fn word_start(buf: &str, cur: usize, word_break: &str) -> usize 
        {
            let fwd = match buf[cur..].chars().next() 
            {
                Some(ch) => word_break.contains(ch),
                None => return buf.len()
            };

            if fwd 
            {
                next_word(1, buf, cur, word_break)
            } 
            else 
            {
                let mut chars = buf[..cur].char_indices().rev();
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

                match chars.next() 
                {
                    Some((idx, ch)) => idx + ch.len_utf8(),
                    None => 0
                }
            }
        }

        pub fn next_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize 
        {
            let mut chars = buf[cur..].char_indices();

            for _ in 0..n 
            {
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
                drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                if chars.clone().next().is_none() { break; }
            }

            match chars.next() 
            {
                Some((idx, _)) => cur + idx,
                None => buf.len()
            }
        }

        pub fn word_end(buf: &str, cur: usize, word_break: &str) -> usize 
        {
            let mut chars = buf[cur..].char_indices();

            drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

            match chars.next() 
            {
                Some((idx, _)) => cur + idx,
                None => buf.len()
            }
        }

        pub fn drop_while<I, T, F>(iter: &mut I, mut f: F) where
        I: Iterator<Item=T> + Clone, F: FnMut(T) -> bool 
        {
            loop 
            {
                let mut clone = iter.clone();
                match clone.next() 
                {
                    None => break,
                    Some(t) => 
                    {
                        if f(t) 
                        { *iter = clone; } 

                        else { break; }
                    }
                }
            }
        }

        pub fn get_open_paren(ch: char) -> Option<char>
        {
            match ch
            {
                ')' => Some('('),
                ']' => Some('['),
                '}' => Some('{'),
                _ => None
            }
        }

        pub fn find_matching_paren(s: &str, quotes: &str, open: char, close: char) -> Option<usize>
        {
            let mut chars = s.char_indices().rev();
            let mut level = 0;
            let mut string_delim = None;

            while let Some((ind, ch)) = chars.next()
            {
                if string_delim == Some(ch) 
                { string_delim = None; } 
                
                else if quotes.contains(ch)
                { string_delim = Some(ch); } 

                else if string_delim.is_none() && ch == close
                { level += 1; }
                
                else if string_delim.is_none() && ch == open
                {
                    level -= 1;
                    if level == 0 
                    { return Some(ind); }
                }
            }

            None
        }

        pub fn is_combining_mark(ch: char) -> bool
        {
            use ::mortal::util::is_combining_mark;
            is_combining_mark(ch)
        }

        pub fn is_wide(ch: char) -> bool 
        {
            use ::mortal::util::char_width;
            char_width(ch) == Some(2)
        }

        pub fn match_name(name: &str, value: &str) -> bool 
        {
            // A value of "foo" matches both "foo" and "foo-bar"
            name == value 
            || (name.starts_with(value) && name.as_bytes()[value.len()] == b'-')
        }
    }
    /*
    */
    pub mod variables
    {
        //! Contains types associated with user-configurable variables
        use ::borrow::Cow;
        use ::fmt;
        use ::mem::replace;
        use ::time::Duration;

        macro_rules! define_variables 
        {
            ( $( $field:ident : $ty:ty => ( $name:expr , $conv:ident , |$gr:ident| $getter:expr , |$sr:ident, $v:ident| $setter:expr ) , )+ ) => 
            {
                static VARIABLE_NAMES: &[&str] = &[ $( $name ),+ ];

                pub(crate) struct Variables 
                {
                    $( pub $field : $ty ),*
                }

                impl Variables 
                {
                    pub fn get_variable(&self, name: &str) -> Option<Variable>
                    {
                        match name
                        {
                            $( $name => {
                                let $gr = self;
                                Some(Variable::from($getter))
                            } )+
                            _ => None
                        }
                    }

                    pub fn set_variable(&mut self, name: &str, value: &str)
                            -> Option<Variable> {
                        match name {
                            $( $name => {
                                if let Some($v) = $conv(value) {
                                    let $sr = self;
                                    Some(Variable::from($setter))
                                } else {
                                    None
                                }
                            } )+
                            _ => None
                        }
                    }

                    pub fn iter(&self) -> VariableIter {
                        VariableIter{vars: self, n: 0}
                    }
                }

                impl<'a> Iterator for VariableIter<'a> 
                {
                    type Item = (&'static str, Variable);

                    fn next(&mut self) -> Option<Self::Item> 
                    {
                        let res = match VARIABLE_NAMES.get(self.n).cloned() {
                            $( Some($name) => ($name, {
                                let $gr = self.vars;
                                Variable::from($getter)
                            }) , )+
                            _ => return None
                        };

                        self.n += 1;
                        Some(res)
                    }
                }
            }
        }

        /// Default `keyseq_timeout`, in milliseconds
        const KEYSEQ_TIMEOUT_MS: u64 = 500;

        /// Iterator over `Reader` variable values
        #[derive(Clone)]
        pub struct VariableIter<'a> 
        {
            vars: &'a Variables,
            n: usize,
        }

        /// Represents a `Reader` variable of a given type
        #[derive(Clone, Debug)]
        pub enum Variable 
        {
            /// Boolean variable
            Boolean(bool),
            /// Integer variable
            Integer(i32),
            /// String variable
            String(Cow<'static, str>),
        }

        impl From<bool> for Variable 
        {
            fn from(b: bool) -> Variable 
            {
                Variable::Boolean(b)
            }
        }

        impl From<i32> for Variable 
        {
            fn from(i: i32) -> Variable 
            {
                Variable::Integer(i)
            }
        }

        impl From<&'static str> for Variable 
        {
            fn from(s: &'static str) -> Variable 
            {
                Variable::String(s.into())
            }
        }

        impl From<Cow<'static, str>> for Variable 
        {
            fn from(s: Cow<'static, str>) -> Variable 
            {
                Variable::String(s)
            }
        }

        impl From<String> for Variable 
        {
            fn from(s: String) -> Variable 
            {
                Variable::String(s.into())
            }
        }

        impl fmt::Display for Variable 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
            {
                match *self {
                    Variable::Boolean(b) => f.write_str(if b { "on" } else { "off" }),
                    Variable::Integer(n) => fmt::Display::fmt(&n, f),
                    Variable::String(ref s) => fmt::Display::fmt(&s[..], f),
                }
            }
        }

        define_variables!
        {
            blink_matching_paren: bool => ("blink-matching-paren", parse_bool,
                |r| r.blink_matching_paren,
                |r, v| replace(&mut r.blink_matching_paren, v)),
            comment_begin: Cow<'static, str> => ("comment-begin", parse_string,
                |r| r.comment_begin.clone(),
                |r, v| replace(&mut r.comment_begin, v.into())),
            completion_display_width: usize => ("completion-display-width", parse_usize,
                |r| usize_as_i32(r.completion_display_width),
                |r, v| usize_as_i32(replace(&mut r.completion_display_width, v))),
            completion_query_items: usize => ("completion-query-items", parse_usize,
                |r| usize_as_i32(r.completion_query_items),
                |r, v| usize_as_i32(replace(&mut r.completion_query_items, v))),
            disable_completion: bool => ("disable-completion", parse_bool,
                |r| r.disable_completion,
                |r, v| replace(&mut r.disable_completion, v)),
            echo_control_characters: bool => ("echo-control-characters", parse_bool,
                |r| r.echo_control_characters,
                |r, v| replace(&mut r.echo_control_characters, v)),
            keyseq_timeout: Option<Duration> => ("keyseq-timeout", parse_duration,
                |r| as_millis(r.keyseq_timeout),
                |r, v| as_millis(replace(&mut r.keyseq_timeout, v))),
            page_completions: bool => ("page-completions", parse_bool,
                |r| r.page_completions,
                |r, v| replace(&mut r.page_completions, v)),
            print_completions_horizontally: bool => ("print-completions-horizontally", parse_bool,
                |r| r.print_completions_horizontally,
                |r, v| replace(&mut r.print_completions_horizontally, v)),
        }

        impl Default for Variables 
        {
            fn default() -> Variables 
            {
                Variables
                {
                    blink_matching_paren: false,
                    comment_begin: "#".into(),
                    completion_display_width: usize::max_value(),
                    completion_query_items: 100,
                    disable_completion: false,
                    echo_control_characters: true,
                    keyseq_timeout: Some(Duration::from_millis(KEYSEQ_TIMEOUT_MS)),
                    page_completions: true,
                    print_completions_horizontally: false,
                }
            }
        }

        fn parse_bool(s: &str) -> Option<bool> 
        {
            match s 
            {
                "0" => Some(false),
                "1" => Some(true),
                s if s.eq_ignore_ascii_case("off") => Some(false),
                s if s.eq_ignore_ascii_case("on") => Some(true),
                _ => None
            }
        }

        fn parse_string(s: &str) -> Option<String> 
        {
            Some(s.to_owned())
        }

        fn as_millis(timeout: Option<Duration>) -> i32 
        {
            match timeout 
            {
                Some(t) => 
                {
                    let s = (t.as_secs() * 1_000) as i32;
                    let ms = (t.subsec_nanos() / 1_000_000) as i32;

                    s + ms
                }
                None => -1
            }
        }

        fn parse_duration(s: &str) -> Option<Option<Duration>> 
        {
            match s.parse::<i32>() 
            {
                Ok(n) if n <= 0 => Some(None),
                Ok(n) => Some(Some(Duration::from_millis(n as u64))),
                Err(_) => Some(None)
            }
        }

        fn usize_as_i32(u: usize) -> i32 
        {
            match u 
            {
                u if u > i32::max_value() as usize => -1,
                u => u as i32
            }
        }

        fn parse_usize(s: &str) -> Option<usize> 
        {
            match s.parse::<i32>() 
            {
                Ok(n) if n < 0 => Some(usize::max_value()),
                Ok(n) => Some(n as usize),
                Err(_) => None
            }
        }
    }
    /*
    */
    pub mod writer
    {
        //! Provides access to terminal write operations

        #![allow(dead_code)] // XXX

        use ::borrow::Cow::{self, Borrowed, Owned};
        use ::collections::{vec_deque, VecDeque};
        use ::fmt;
        use ::io;
        use ::iter::{repeat, Skip};
        use ::mem::swap;
        use ::ops::{Deref, DerefMut, Range};
        use ::sync::MutexGuard;
        use ::time::{Duration, Instant};

        use ::linefeed::chars::{is_ctrl, unctrl, ESCAPE, RUBOUT};
        use ::linefeed::reader::{START_INVISIBLE, END_INVISIBLE};
        use ::linefeed::terminal::{CursorMode, Size, Terminal, TerminalWriter};
        use ::linefeed::util::
        {
            backward_char, forward_char, backward_search_char, forward_search_char,
            filter_visible, is_combining_mark, is_wide, RangeArgument,
        };

        /// Duration to wait for input when "blinking"
        pub(crate) const BLINK_DURATION: Duration = Duration::from_millis(500);

        const COMPLETE_MORE: &'static str = "--More--";

        /// Default maximum history size
        const MAX_HISTORY: usize = !0;

        /// Tab column interval
        const TAB_STOP: usize = 8;

        // Length of "(arg: "
        const PROMPT_NUM_PREFIX: usize = 6;
        // Length of ") "
        const PROMPT_NUM_SUFFIX: usize = 2;

        // Length of "(i-search)`"
        const PROMPT_SEARCH_PREFIX: usize = 11;
        // Length of "failed "
        const PROMPT_SEARCH_FAILED_PREFIX: usize = 7;
        // Length of "reverse-"
        const PROMPT_SEARCH_REVERSE_PREFIX: usize = 8;
        // Length of "': "
        const PROMPT_SEARCH_SUFFIX: usize = 3;

        /// Provides an interface to write line-by-line output to the terminal device.
        pub struct Writer<'a, 'b: 'a, Term: 'b + Terminal>
        {
            write: WriterImpl<'a, 'b, Term>,
        }

        enum WriterImpl<'a, 'b: 'a, Term: 'b + Terminal>
        {
            Mutex(WriteLock<'b, Term>),
            MutRef(&'a mut WriteLock<'b, Term>),
        }

        pub(crate) struct Write 
        {
            /// Input buffer
            pub buffer: String,
            /// Original buffer entered before searching through history
            pub backup_buffer: String,
            /// Position of the cursor
            pub cursor: usize,
            /// Position of the cursor if currently performing a blink
            blink: Option<Blink>,

            /// Stored history entries
            pub history: VecDeque<String>,
            /// History entry currently being edited;
            /// `None` if the new buffer is being edited
            pub history_index: Option<usize>,
            /// Maximum size of history
            history_size: usize,
            /// Number of history entries added since last loading history
            history_new_entries: usize,

            /// Whether the prompt is drawn; i.e. a `read_line` operation is in progress
            pub is_prompt_drawn: bool,

            /// Portion of prompt up to and including the final newline
            pub prompt_prefix: String,
            prompt_prefix_len: usize,
            /// Portion of prompt after the final newline
            pub prompt_suffix: String,
            prompt_suffix_len: usize,

            /// Current type of prompt
            pub prompt_type: PromptType,

            /// Whether a search in progress is a reverse search
            pub reverse_search: bool,
            /// Whether a search in progress has failed to find a match
            pub search_failed: bool,
            /// Current search string
            pub search_buffer: String,
            /// Last search string
            pub last_search: String,
            /// Selected history entry prior to a history search
            pub prev_history: Option<usize>,
            /// Position of the cursor prior to a history search
            pub prev_cursor: usize,

            /// Numerical argument
            pub input_arg: Digit,
            /// Whether a numerical argument was supplied
            pub explicit_arg: bool,

            /// Terminal size as of last draw operation
            pub screen_size: Size,
        }

        pub(crate) struct WriteLock<'a, Term: 'a + Terminal> 
        {
            term: Box<dyn TerminalWriter<Term> + 'a>,
            data: MutexGuard<'a, Write>,
        }

        impl<'a, Term: Terminal> WriteLock<'a, Term> 
        {
            pub fn new(term: Box<dyn TerminalWriter<Term> + 'a>, data: MutexGuard<'a, Write>)
                    -> WriteLock<'a, Term> {
                WriteLock{term, data}
            }

            pub fn size(&self) -> io::Result<Size> {
                self.term.size()
            }

            pub fn flush(&mut self) -> io::Result<()> {
                self.term.flush()
            }

            pub fn update_size(&mut self) -> io::Result<()> {
                let size = self.size()?;
                self.screen_size = size;
                Ok(())
            }

            pub fn blink(&mut self, pos: usize) -> io::Result<()> {
                self.expire_blink()?;

                let orig = self.cursor;
                self.move_to(pos)?;
                self.cursor = orig;

                let expiry = Instant::now() + BLINK_DURATION;

                self.blink = Some(Blink{
                    pos,
                    expiry,
                });

                Ok(())
            }

            pub fn check_expire_blink(&mut self, now: Instant) -> io::Result<bool> {
                if let Some(blink) = self.data.blink {
                    if now >= blink.expiry {
                        self.expire_blink()?;
                    }
                }

                Ok(self.blink.is_none())
            }

            pub fn expire_blink(&mut self) -> io::Result<()> {
                if let Some(blink) = self.data.blink.take() {
                    self.move_from(blink.pos)?;
                }

                Ok(())
            }

            pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> {
                self.expire_blink()?;

                let redraw = self.is_prompt_drawn && self.prompt_type.is_normal();

                if redraw {
                    self.clear_full_prompt()?;
                }

                self.data.set_prompt(prompt);

                if redraw {
                    self.draw_prompt()?;
                }

                Ok(())
            }

            /// Draws the prompt and current input, assuming the cursor is at column 0
            pub fn draw_prompt(&mut self) -> io::Result<()> {
                self.draw_prompt_prefix()?;
                self.draw_prompt_suffix()
            }

            pub fn draw_prompt_prefix(&mut self) -> io::Result<()> {
                match self.prompt_type {
                    // Prefix is not drawn when completions are shown
                    PromptType::CompleteMore => Ok(()),
                    _ => {
                        let pfx = self.prompt_prefix.clone();
                        self.draw_raw_prompt(&pfx)
                    }
                }
            }

            pub fn draw_prompt_suffix(&mut self) -> io::Result<()> {
                match self.prompt_type {
                    PromptType::Normal => {
                        let sfx = self.prompt_suffix.clone();
                        self.draw_raw_prompt(&sfx)?;
                    }
                    PromptType::Number => {
                        let n = self.input_arg.to_i32();
                        let s = format!("(arg: {}) ", n);
                        self.draw_text(0, &s)?;
                    }
                    PromptType::Search => {
                        let pre = match (self.reverse_search, self.search_failed) {
                            (false, false) => "(i-search)",
                            (false, true)  => "(failed i-search)",
                            (true,  false) => "(reverse-i-search)",
                            (true,  true)  => "(failed reverse-i-search)",
                        };

                        let ent = self.get_history(self.history_index).to_owned();
                        let s = format!("{}`{}': {}", pre, self.search_buffer, ent);

                        self.draw_text(0, &s)?;
                        let pos = self.cursor;

                        let (lines, cols) = self.move_delta(ent.len(), pos, &ent);
                        return self.move_rel(lines, cols);
                    }
                    PromptType::CompleteIntro(n) => {
                        return self.term.write(&complete_intro(n));
                    }
                    PromptType::CompleteMore => {
                        return self.term.write(COMPLETE_MORE);
                    }
                }

                self.draw_buffer(0)?;
                let len = self.buffer.len();
                self.move_from(len)
            }

            pub fn redraw_prompt(&mut self, new_prompt: PromptType) -> io::Result<()> {
                self.clear_prompt()?;
                self.prompt_type = new_prompt;
                self.draw_prompt_suffix()
            }

            /// Draws a portion of the buffer, starting from the given cursor position
            pub fn draw_buffer(&mut self, pos: usize) -> io::Result<()> {
                let (_, col) = self.line_col(pos);

                let buf = self.buffer[pos..].to_owned();
                self.draw_text(col, &buf)?;
                Ok(())
            }

            /// Draw some text with the cursor beginning at the given column.
            fn draw_text(&mut self, start_col: usize, text: &str) -> io::Result<()> {
                self.draw_text_impl(start_col, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                }, false)
            }

            fn draw_raw_prompt(&mut self, text: &str) -> io::Result<()> {
                self.draw_text_impl(0, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    allow_escape: true,
                }, true)
            }

            fn draw_text_impl(&mut self, start_col: usize, text: &str, disp: Display,
                    handle_invisible: bool) -> io::Result<()> {
                let width = self.screen_size.columns;
                let mut col = start_col;
                let mut out = String::with_capacity(text.len());

                let mut clear = false;
                let mut hidden = false;

                for ch in text.chars() {
                    if handle_invisible && ch == START_INVISIBLE {
                        hidden = true;
                    } else if handle_invisible && ch == END_INVISIBLE {
                        hidden = false;
                    } else if hidden {
                        // Render the character, but assume it has 0 width.
                        out.push(ch);
                    } else {
                        for ch in display(ch, disp) {
                            if ch == '\t' {
                                let n = TAB_STOP - (col % TAB_STOP);

                                if col + n > width {
                                    let pre = width - col;
                                    out.extend(repeat(' ').take(pre));
                                    out.push_str(" \r");
                                    out.extend(repeat(' ').take(n - pre));
                                    col = n - pre;
                                } else {
                                    out.extend(repeat(' ').take(n));
                                    col += n;

                                    if col == width {
                                        out.push_str(" \r");
                                        col = 0;
                                    }
                                }
                            } else if ch == '\n' {
                                if !clear {
                                    self.term.write(&out)?;
                                    out.clear();
                                    self.term.clear_to_screen_end()?;
                                    clear = true;
                                }

                                out.push('\n');
                                col = 0;
                            } else if is_combining_mark(ch) {
                                out.push(ch);
                            } else if is_wide(ch) {
                                if col == width - 1 {
                                    out.push_str("  \r");
                                    out.push(ch);
                                    col = 2;
                                } else {
                                    out.push(ch);
                                    col += 2;
                                }
                            } else {
                                out.push(ch);
                                col += 1;

                                if col == width {
                                    // Space pushes the cursor to the next line,
                                    // CR brings back to the start of the line.
                                    out.push_str(" \r");
                                    col = 0;
                                }
                            }
                        }
                    }
                }

                if col == width {
                    out.push_str(" \r");
                }

                self.term.write(&out)
            }

            pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> {
                self.expire_blink()?;

                self.move_to(0)?;
                self.buffer.clear();
                self.buffer.push_str(buf);
                self.new_buffer()
            }

            pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> {
                self.expire_blink()?;

                if !self.buffer.is_char_boundary(pos) {
                    panic!("invalid cursor position {} in buffer {:?}",
                        pos, self.buffer);
                }

                self.move_to(pos)
            }

            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                self.term.set_cursor_mode(mode)
            }

            pub fn history_len(&self) -> usize {
                self.history.len()
            }

            pub fn history_size(&self) -> usize {
                self.history_size
            }

            pub fn set_history_size(&mut self, n: usize) {
                self.history_size = n;
                self.truncate_history(n);
            }

            pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                self.term.write(s)
            }

            pub fn start_history_search(&mut self, reverse: bool) -> io::Result<()> {
                self.search_buffer = self.buffer[..self.cursor].to_owned();

                self.continue_history_search(reverse)
            }

            pub fn continue_history_search(&mut self, reverse: bool) -> io::Result<()> {
                if let Some(idx) = self.find_history_search(reverse) {
                    self.set_history_entry(Some(idx));

                    let pos = self.cursor;
                    let end = self.buffer.len();

                    self.draw_buffer(pos)?;
                    self.clear_to_screen_end()?;
                    self.move_from(end)?;
                }

                Ok(())
            }

            fn find_history_search(&self, reverse: bool) -> Option<usize> {
                let len = self.history.len();
                let idx = self.history_index.unwrap_or(len);

                if reverse {
                    self.history.iter().rev().skip(len - idx)
                        .position(|ent| ent.starts_with(&self.search_buffer))
                        .map(|pos| idx - (pos + 1))
                } else {
                    self.history.iter().skip(idx + 1)
                        .position(|ent| ent.starts_with(&self.search_buffer))
                        .map(|pos| idx + (pos + 1))
                }
            }

            pub fn start_search_history(&mut self, reverse: bool) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;
                self.search_buffer.clear();
                self.prev_history = self.history_index;
                self.prev_cursor = self.cursor;

                self.redraw_prompt(PromptType::Search)
            }

            pub fn continue_search_history(&mut self, reverse: bool) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;

                {
                    let data = &mut *self.data;
                    data.search_buffer.clone_from(&data.last_search);
                }

                self.search_history_step()
            }

            pub fn end_search_history(&mut self) -> io::Result<()> {
                self.redraw_prompt(PromptType::Normal)
            }

            pub fn abort_search_history(&mut self) -> io::Result<()> {
                self.clear_prompt()?;

                let ent = self.prev_history;
                self.set_history_entry(ent);
                self.cursor = self.prev_cursor;

                self.prompt_type = PromptType::Normal;
                self.draw_prompt_suffix()
            }

            fn show_search_match(&mut self, next_match: Option<(Option<usize>, usize)>)
                    -> io::Result<()> {
                self.clear_prompt()?;

                if let Some((idx, pos)) = next_match {
                    self.search_failed = false;
                    self.set_history_entry(idx);
                    self.cursor = pos;
                } else {
                    self.search_failed = true;
                }

                self.prompt_type = PromptType::Search;
                self.draw_prompt_suffix()
            }

            pub fn search_history_update(&mut self) -> io::Result<()> {
                // Search for the next match, perhaps including the current position
                let next_match = if self.reverse_search {
                    self.search_history_backward(&self.search_buffer, true)
                } else {
                    self.search_history_forward(&self.search_buffer, true)
                };

                self.show_search_match(next_match)
            }

            fn search_history_step(&mut self) -> io::Result<()> {
                if self.search_buffer.is_empty() {
                    return self.redraw_prompt(PromptType::Search);
                }

                // Search for the next match
                let next_match = if self.reverse_search {
                    self.search_history_backward(&self.search_buffer, false)
                } else {
                    self.search_history_forward(&self.search_buffer, false)
                };

                self.show_search_match(next_match)
            }

            fn search_history_backward(&self, s: &str, include_cur: bool)
                    -> Option<(Option<usize>, usize)> {
                let mut idx = self.history_index;
                let mut pos = Some(self.cursor);

                if include_cur && !self.search_failed {
                    if let Some(p) = pos {
                        if self.get_history(idx).is_char_boundary(p + s.len()) {
                            pos = Some(p + s.len());
                        }
                    }
                }

                loop {
                    let line = self.get_history(idx);

                    match line[..pos.unwrap_or(line.len())].rfind(s) {
                        Some(found) => {
                            pos = Some(found);
                            break;
                        }
                        None => {
                            match idx {
                                Some(0) => return None,
                                Some(n) => {
                                    idx = Some(n - 1);
                                    pos = None;
                                }
                                None => {
                                    if self.history.is_empty() {
                                        return None;
                                    } else {
                                        idx = Some(self.history.len() - 1);
                                        pos = None;
                                    }
                                }
                            }
                        }
                    }
                }

                pos.map(|pos| (idx, pos))
            }

            fn search_history_forward(&self, s: &str, include_cur: bool)
                    -> Option<(Option<usize>, usize)> {
                let mut idx = self.history_index;
                let mut pos = Some(self.cursor);

                if !include_cur {
                    if let Some(p) = pos {
                        pos = Some(forward_char(1, self.get_history(idx), p));
                    }
                }

                loop {
                    let line = self.get_history(idx);

                    match line[pos.unwrap_or(0)..].find(s) {
                        Some(found) => {
                            pos = pos.map(|n| n + found).or(Some(found));
                            break;
                        }
                        None => {
                            if let Some(n) = idx {
                                if n + 1 == self.history.len() {
                                    idx = None;
                                } else {
                                    idx = Some(n + 1);
                                }
                                pos = None;
                            } else {
                                return None;
                            }
                        }
                    }
                }

                pos.map(|pos| (idx, pos))
            }

            pub fn add_history(&mut self, line: String) {
                if self.history.len() == self.history_size {
                    self.history.pop_front();
                }

                self.history.push_back(line);
                self.history_new_entries = self.history.len()
                    .min(self.history_new_entries + 1);
            }

            pub fn add_history_unique(&mut self, line: String) {
                let is_duplicate = self.history.back().map_or(false, |ent| *ent == line);

                if !is_duplicate {
                    self.add_history(line);
                }
            }

            pub fn clear_history(&mut self) {
                self.truncate_history(0);
                self.history_new_entries = 0;
            }

            pub fn remove_history(&mut self, n: usize) {
                if n < self.history.len() {
                    let first_new = self.history.len() - self.history_new_entries;

                    if n >= first_new {
                        self.history_new_entries -= 1;
                    }

                    self.history.remove(n);
                }
            }

            pub fn truncate_history(&mut self, n: usize) {
                let len = self.history.len();

                if n < len {
                    let _ = self.history.drain(..len - n);
                    self.history_new_entries = self.history_new_entries.max(n);
                }
            }

            pub fn next_history(&mut self, n: usize) -> io::Result<()> {
                if let Some(old) = self.history_index {
                    let new = old.saturating_add(n);

                    if new >= self.history.len() {
                        self.select_history_entry(None)?;
                    } else {
                        self.select_history_entry(Some(new))?;
                    }
                }

                Ok(())
            }

            pub fn prev_history(&mut self, n: usize) -> io::Result<()> {
                if !self.history.is_empty() && self.history_index != Some(0) {
                    let new = if let Some(old) = self.history_index {
                        old.saturating_sub(n)
                    } else {
                        self.history.len().saturating_sub(n)
                    };

                    self.select_history_entry(Some(new))?;
                }

                Ok(())
            }

            pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> {
                if new != self.history_index {
                    self.move_to(0)?;
                    self.set_history_entry(new);
                    self.new_buffer()?;
                }

                Ok(())
            }

            pub fn set_history_entry(&mut self, new: Option<usize>) {
                let old = self.history_index;

                if old != new {
                    let data = &mut *self.data;
                    data.history_index = new;

                    if let Some(old) = old {
                        data.history[old].clone_from(&data.buffer);
                    } else {
                        swap(&mut data.buffer, &mut data.backup_buffer);
                    }

                    if let Some(new) = new {
                        data.buffer.clone_from(&data.history[new]);
                    } else {
                        data.buffer.clear();
                        swap(&mut data.buffer, &mut data.backup_buffer);
                    }
                }
            }

            fn get_history(&self, n: Option<usize>) -> &str {
                if self.history_index == n {
                    &self.buffer
                } else if let Some(n) = n {
                    &self.history[n]
                } else {
                    &self.backup_buffer
                }
            }

            pub fn backward_char(&mut self, n: usize) -> io::Result<()> {
                let pos = backward_char(n, &self.buffer, self.cursor);
                self.move_to(pos)
            }

            pub fn forward_char(&mut self, n: usize) -> io::Result<()> {
                let pos = forward_char(n, &self.buffer, self.cursor);
                self.move_to(pos)
            }

            pub fn backward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> {
                if let Some(pos) = backward_search_char(n, &self.buffer, self.cursor, ch) {
                    self.move_to(pos)?;
                }

                Ok(())
            }

            pub fn forward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> {
                if let Some(pos) = forward_search_char(n, &self.buffer, self.cursor, ch) {
                    self.move_to(pos)?;
                }

                Ok(())
            }

            /// Deletes a range from the buffer; the cursor is moved to the end
            /// of the given range.
            pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or(0);
                let end = range.end().cloned().unwrap_or_else(|| self.buffer.len());

                self.move_to(start)?;

                let _ = self.buffer.drain(start..end);

                self.draw_buffer(start)?;
                self.term.clear_to_screen_end()?;
                let len = self.buffer.len();
                self.move_from(len)?;

                Ok(())
            }

            pub fn insert_str(&mut self, s: &str) -> io::Result<()> {
                // If the string insertion moves a combining character,
                // we must redraw starting from the character before the cursor.
                let moves_combining = match self.buffer[self.cursor..].chars().next() {
                    Some(ch) if is_combining_mark(ch) => true,
                    _ => false
                };

                let cursor = self.cursor;
                self.buffer.insert_str(cursor, s);

                if moves_combining && cursor != 0 {
                    let pos = backward_char(1, &self.buffer, self.cursor);
                    // Move without updating the cursor
                    let (lines, cols) = self.move_delta(cursor, pos, &self.buffer);
                    self.move_rel(lines, cols)?;
                    self.draw_buffer(pos)?;
                } else {
                    self.draw_buffer(cursor)?;
                }

                self.cursor += s.len();

                let len = self.buffer.len();
                self.move_from(len)
            }

            pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>)
                    -> io::Result<()> {
                // Ranges must not overlap
                assert!(src.end <= dest.start || src.start >= dest.end);

                // Final cursor position
                let final_cur = if src.start < dest.start {
                    dest.end
                } else {
                    dest.start + (src.end - src.start)
                };

                let (left, right) = if src.start < dest.start {
                    (src, dest)
                } else {
                    (dest, src)
                };

                self.move_to(left.start)?;

                let a = self.buffer[left.clone()].to_owned();
                let b = self.buffer[right.clone()].to_owned();

                let _ = self.buffer.drain(right.clone());
                self.buffer.insert_str(right.start, &a);

                let _ = self.buffer.drain(left.clone());
                self.buffer.insert_str(left.start, &b);

                let cursor = self.cursor;
                self.draw_buffer(cursor)?;
                self.term.clear_to_screen_end()?;

                self.cursor = final_cur;
                let len = self.buffer.len();
                self.move_from(len)
            }

            fn prompt_suffix_length(&self) -> usize {
                match self.prompt_type {
                    PromptType::Normal => self.prompt_suffix_len,
                    PromptType::Number => {
                        let n = number_len(self.input_arg.to_i32());
                        PROMPT_NUM_PREFIX + PROMPT_NUM_SUFFIX + n
                    }
                    PromptType::Search => {
                        let mut prefix = PROMPT_SEARCH_PREFIX;

                        if self.reverse_search {
                            prefix += PROMPT_SEARCH_REVERSE_PREFIX;
                        }
                        if self.search_failed {
                            prefix += PROMPT_SEARCH_FAILED_PREFIX;
                        }

                        let n = self.display_size(&self.search_buffer, prefix);
                        prefix + n + PROMPT_SEARCH_SUFFIX
                    }
                    PromptType::CompleteIntro(n) => complete_intro(n).len(),
                    PromptType::CompleteMore => COMPLETE_MORE.len(),
                }
            }

            fn line_col(&self, pos: usize) -> (usize, usize) {
                let prompt_len = self.prompt_suffix_length();

                match self.prompt_type {
                    PromptType::CompleteIntro(_) |
                    PromptType::CompleteMore => {
                        let width = self.screen_size.columns;
                        (prompt_len / width, prompt_len % width)
                    }
                    _ => self.line_col_with(pos, &self.buffer, prompt_len)
                }
            }

            fn line_col_with(&self, pos: usize, buf: &str, start_col: usize) -> (usize, usize) {
                let width = self.screen_size.columns;
                if width == 0 {
                    return (0, 0);
                }

                let n = start_col + self.display_size(&buf[..pos], start_col);

                (n / width, n % width)
            }

            pub fn clear_screen(&mut self) -> io::Result<()> {
                self.term.clear_screen()?;
                self.draw_prompt()?;

                Ok(())
            }

            pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
                self.term.clear_to_screen_end()
            }

            /// Draws a new buffer on the screen. Cursor position is assumed to be `0`.
            pub fn new_buffer(&mut self) -> io::Result<()> {
                self.draw_buffer(0)?;
                self.cursor = self.buffer.len();

                self.term.clear_to_screen_end()?;

                Ok(())
            }

            pub fn clear_full_prompt(&mut self) -> io::Result<()> {
                let prefix_lines = self.prompt_prefix_len / self.screen_size.columns;
                let (line, _) = self.line_col(self.cursor);
                self.term.move_up(prefix_lines + line)?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }

            pub(crate) fn clear_prompt(&mut self) -> io::Result<()> {
                let (line, _) = self.line_col(self.cursor);

                self.term.move_up(line)?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }

            /// Move back to true cursor position from some other position
            pub fn move_from(&mut self, pos: usize) -> io::Result<()> {
                let (lines, cols) = self.move_delta(pos, self.cursor, &self.buffer);
                self.move_rel(lines, cols)
            }

            pub fn move_to(&mut self, pos: usize) -> io::Result<()> {
                if pos != self.cursor {
                    let (lines, cols) = self.move_delta(self.cursor, pos, &self.buffer);
                    self.move_rel(lines, cols)?;
                    self.cursor = pos;
                }

                Ok(())
            }

            pub fn move_to_end(&mut self) -> io::Result<()> {
                let pos = self.buffer.len();
                self.move_to(pos)
            }

            pub fn move_right(&mut self, n: usize) -> io::Result<()> {
                self.term.move_right(n)
            }

            /// Moves from `old` to `new` cursor position, using the given buffer
            /// as current input.
            fn move_delta(&self, old: usize, new: usize, buf: &str) -> (isize, isize) {
                let prompt_len = self.prompt_suffix_length();
                let (old_line, old_col) = self.line_col_with(old, buf, prompt_len);
                let (new_line, new_col) = self.line_col_with(new, buf, prompt_len);

                (new_line as isize - old_line as isize,
                new_col as isize - old_col as isize)
            }

            fn move_rel(&mut self, lines: isize, cols: isize) -> io::Result<()> {
                if lines > 0 {
                    self.term.move_down(lines as usize)?;
                } else if lines < 0 {
                    self.term.move_up((-lines) as usize)?;
                }

                if cols > 0 {
                    self.term.move_right(cols as usize)?;
                } else if cols < 0 {
                    self.term.move_left((-cols) as usize)?;
                }

                Ok(())
            }

            pub fn reset_data(&mut self) {
                self.data.reset_data();
            }

            pub fn set_digit_from_char(&mut self, ch: char) {
                let digit = match ch {
                    '-' => Digit::NegNone,
                    '0' ..= '9' => Digit::from(ch),
                    _ => Digit::None
                };

                self.input_arg = digit;
                self.explicit_arg = true;
            }
        }

        #[derive(Copy, Clone)]
        struct Blink 
        {
            pos: usize,
            expiry: Instant,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Writer<'a, 'b, Term> 
        {
            fn new(mut write: WriterImpl<'a, 'b, Term>, clear: bool) -> io::Result<Self> 
            {
                write.expire_blink()?;

                if write.is_prompt_drawn {
                    if clear {
                        write.clear_full_prompt()?;
                    } else {
                        write.move_to_end()?;
                        write.write_str("\n")?;
                    }
                }

                Ok(Writer{write})
            }

            pub(crate) fn with_lock(write: WriteLock<'b, Term>, clear: bool) -> io::Result<Self>
            {
                Writer::new(WriterImpl::Mutex(write), clear)
            }

            pub(crate) fn with_ref(write: &'a mut WriteLock<'b, Term>, clear: bool) -> io::Result<Self> 
            {
                Writer::new(WriterImpl::MutRef(write), clear)
            }

            /// Returns an iterator over history entries.
            pub fn history(&self) -> HistoryIter 
            {
                self.write.history()
            }

            /// Writes some text to the terminal device.
            pub fn write_str(&mut self, s: &str) -> io::Result<()>
            {
                self.write.write_str(s)
            }

            /// Writes formatted text to the terminal display.
            pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()>
            {
                let s = args.to_string();
                self.write_str(&s)
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Drop for Writer<'a, 'b, Term> 
        {
            fn drop(&mut self) 
            {
                if self.write.is_prompt_drawn 
                {
                    // There's not really anything useful to be done with this error.
                    let _ = self.write.draw_prompt();
                }
            }
        }

        impl<'a, Term: 'a + Terminal> Deref for WriteLock<'a, Term> 
        {
            type Target = Write;

            fn deref(&self) -> &Write
            { &self.data }
        }

        impl<'a, Term: 'a + Terminal> DerefMut for WriteLock<'a, Term> 
        {
            fn deref_mut(&mut self) -> &mut Write 
            {
                &mut self.data
            }
        }

        impl Write 
        {
            pub fn new(screen_size: Size) -> Write
            {
                Write{
                    buffer: String::new(),
                    backup_buffer: String::new(),
                    cursor: 0,
                    blink: None,

                    history: VecDeque::new(),
                    history_index: None,
                    history_size: MAX_HISTORY,
                    history_new_entries: 0,

                    is_prompt_drawn: false,

                    prompt_prefix: String::new(),
                    prompt_prefix_len: 0,
                    prompt_suffix: String::new(),
                    prompt_suffix_len: 0,

                    prompt_type: PromptType::Normal,

                    reverse_search: false,
                    search_failed: false,
                    search_buffer: String::new(),
                    last_search: String::new(),
                    prev_history: None,
                    prev_cursor: !0,

                    input_arg: Digit::None,
                    explicit_arg: false,

                    screen_size,
                }
            }

            pub fn history(&self) -> HistoryIter 
            {
                HistoryIter(self.history.iter())
            }

            pub fn new_history(&self) -> Skip<HistoryIter> 
            {
                let first_new = self.history.len() - self.history_new_entries;
                self.history().skip(first_new)
            }

            pub fn new_history_entries(&self) -> usize 
            {
                self.history_new_entries
            }

            pub fn reset_data(&mut self) 
            {
                self.buffer.clear();
                self.backup_buffer.clear();
                self.cursor = 0;
                self.history_index = None;

                self.prompt_type = PromptType::Normal;

                self.input_arg = Digit::None;
                self.explicit_arg = false;
            }

            pub fn reset_new_history(&mut self) 
            {
                self.history_new_entries = 0;
            }

            pub fn set_buffer(&mut self, buf: &str) 
            {
                self.buffer.clear();
                self.buffer.push_str(buf);
                self.cursor = buf.len();
            }

            pub fn set_cursor(&mut self, pos: usize) 
            {
                if !self.buffer.is_char_boundary(pos) {
                    panic!("invalid cursor position {} in buffer {:?}",
                        pos, self.buffer);
                }

                self.cursor = pos;
            }

            pub fn set_prompt(&mut self, prompt: &str) 
            {
                let (pre, suf) = match prompt.rfind('\n') {
                    Some(pos) => (&prompt[..pos + 1], &prompt[pos + 1..]),
                    None => (&prompt[..0], prompt)
                };

                self.prompt_prefix = pre.to_owned();
                self.prompt_suffix = suf.to_owned();

                let pre_virt = filter_visible(pre);
                self.prompt_prefix_len = self.display_size(&pre_virt, 0);

                let suf_virt = filter_visible(suf);
                self.prompt_suffix_len = self.display_size(&suf_virt, 0);
            }

            pub fn display_size(&self, s: &str, start_col: usize) -> usize
            {
                let width = self.screen_size.columns;
                let mut col = start_col;

                let disp = Display
                {
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                };

                for ch in s.chars().flat_map(|ch| display(ch, disp))
                {
                    let n = match ch {
                        '\n' => width - (col % width),
                        '\t' => TAB_STOP - (col % TAB_STOP),
                        ch if is_combining_mark(ch) => 0,
                        ch if is_wide(ch) => {
                            if col % width == width - 1 {
                                // Can't render a fullwidth character into last column
                                3
                            } else {
                                2
                            }
                        }
                        _ => 1
                    };

                    col += n;
                }

                col - start_col
            }
        }

        /// Maximum value of digit input
        const NUMBER_MAX: i32 = 1_000_000;

        #[derive(Copy, Clone, Debug)]
        pub(crate) enum Digit 
        {
            None,
            NegNone,
            Num(i32),
            NegNum(i32),
        }

        impl Digit 
        {
            pub fn input(&mut self, n: i32)
            {
                match *self
                {
                    Digit::None => *self = Digit::Num(n),
                    Digit::NegNone => *self = Digit::NegNum(n),
                    Digit::Num(ref mut m) | Digit::NegNum(ref mut m) => 
                    {
                        *m *= 10;
                        *m += n;
                    }
                }
            }

            pub fn is_out_of_bounds(&self) -> bool
            {
                match *self
                {
                    Digit::Num(n) | Digit::NegNum(n) if n > NUMBER_MAX => true,
                    _ => false
                }
            }

            pub fn to_i32(&self) -> i32 
            {
                match *self
                {
                    Digit::None => 1,
                    Digit::NegNone => -1,
                    Digit::Num(n) => n,
                    Digit::NegNum(n) => -n,
                }
            }
        }

        impl From<char> for Digit 
        {
            /// Convert a decimal digit character to a `Digit` value.
            fn from(ch: char) -> Digit 
            {
                let n = (ch as u8) - b'0';
                Digit::Num(n as i32)
            }
        }

        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub(crate) enum PromptType 
        {
            Normal,
            Number,
            Search,
            CompleteIntro(usize),
            CompleteMore,
        }

        impl PromptType 
        {
            pub(crate) fn is_normal(&self) -> bool 
            {
                *self == PromptType::Normal
            }
        }

        impl<'a, 'b, Term: 'b + Terminal> Deref for WriterImpl<'a, 'b, Term>
        {
            type Target = WriteLock<'b, Term>;

            fn deref(&self) -> &WriteLock<'b, Term>
            {
                match *self
                {
                    WriterImpl::Mutex(ref m) => m,
                    WriterImpl::MutRef(ref m) => m,
                }
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> DerefMut for WriterImpl<'a, 'b, Term>
        {
            fn deref_mut(&mut self) -> &mut WriteLock<'b, Term>
            {
                match *self
                {
                    WriterImpl::Mutex(ref mut m) => m,
                    WriterImpl::MutRef(ref mut m) => m,
                }
            }
        }

        /// Iterator over `Interface` history entries
        pub struct HistoryIter<'a>(vec_deque::Iter<'a, String>);

        impl<'a> ExactSizeIterator for HistoryIter<'a> {}

        impl<'a> Iterator for HistoryIter<'a> 
        {
            type Item = &'a str;

            #[inline] fn next(&mut self) -> Option<&'a str> 
            {
                self.0.next().map(|s| &s[..])
            }

            #[inline] fn nth(&mut self, n: usize) -> Option<&'a str>
            {
                self.0.nth(n).map(|s| &s[..])
            }

            #[inline] fn size_hint(&self) -> (usize, Option<usize>)
            {
                self.0.size_hint()
            }
        }

        impl<'a> DoubleEndedIterator for HistoryIter<'a>
        {
            #[inline] fn next_back(&mut self) -> Option<&'a str> 
            {
                self.0.next_back().map(|s| &s[..])
            }
        }

        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub(crate) enum DisplaySequence
        {
            Char(char),
            Escape(char),
            End,
        }

        impl Iterator for DisplaySequence
        {
            type Item = char;

            fn next(&mut self) -> Option<char>
            {
                use self::DisplaySequence::*;

                let (res, next) = match *self {
                    Char(ch) => (ch, End),
                    Escape(ch) => ('^', Char(ch)),
                    End => return None
                };

                *self = next;
                Some(res)
            }

            fn size_hint(&self) -> (usize, Option<usize>) 
            {
                use self::DisplaySequence::*;

                let n = match *self {
                    Char(_) => 1,
                    Escape(_) => 2,
                    End => 0,
                };

                (n, Some(n))
            }
        }

        #[derive(Copy, Clone, Debug, Default)]
        pub(crate) struct Display
        {
            allow_tab: bool,
            allow_newline: bool,
            allow_escape: bool,
        }

        pub(crate) fn display(ch: char, style: Display) -> DisplaySequence 
        {
            match ch
            {
                '\t' if style.allow_tab => DisplaySequence::Char(ch),
                '\n' if style.allow_newline => DisplaySequence::Char(ch),
                ESCAPE if style.allow_escape => DisplaySequence::Char(ch),
                '\0' => DisplaySequence::Escape('@'),
                RUBOUT => DisplaySequence::Escape('?'),
                ch if is_ctrl(ch) => DisplaySequence::Escape(unctrl(ch)),
                ch => DisplaySequence::Char(ch)
            }
        }

        pub(crate) fn display_str<'a>(s: &'a str, style: Display) -> Cow<'a, str> 
        {
            if s.chars().all(|ch| display(ch, style) == DisplaySequence::Char(ch)) 
            { Borrowed(s) }
            else 
            { Owned(s.chars().flat_map(|ch| display(ch, style)).collect()) }
        }

        fn complete_intro(n: usize) -> String 
        {
            format!("Display all {} possibilities? (y/n)", n)
        }

        fn number_len(n: i32) -> usize 
        {
            match n 
            {
                -1_000_000              => 8,
                -  999_999 ..= -100_000 => 7,
                -   99_999 ..= - 10_000 => 6,
                -    9_999 ..= -  1_000 => 5,
                -      999 ..= -    100 => 4,
                -       99 ..= -     10 => 3,
                -        9 ..= -      1 => 2,
                        0 ..=        9 => 1,
                        10 ..=       99 => 2,
                    100 ..=      999 => 3,
                    1_000 ..=    9_999 => 4,
                    10_000 ..=   99_999 => 5,
                100_000 ..=  999_999 => 6,
                1_000_000              => 7,
                _ => unreachable!()
            }
        }
    }
    /*
    */
    pub mod unix
    {
        //! Unix platform support
        pub use self::terminal::terminal_read;

        pub mod path
        {
            use ::env::var_os;
            use ::path::PathBuf;

            use ::dirs::home_dir;

            pub fn env_init_file() -> Option<PathBuf> {
                var_os("INPUTRC").map(PathBuf::from)
            }

            pub fn system_init_file() -> Option<PathBuf> {
                Some(PathBuf::from("/etc/inputrc"))
            }

            pub fn user_init_file() -> Option<PathBuf> {
                home_dir().map(|p| p.join(".inputrc"))
            }
        }

        pub mod terminal
        {
            use ::io;
            use ::time::Duration;

            use ::mortal::{Event, TerminalReadGuard};
            use ::mortal::unix::TerminalExt;

            use ::linefeed::terminal::RawRead;

            pub fn terminal_read(term: &mut TerminalReadGuard, buf: &mut Vec<u8>) -> io::Result<RawRead> 
            {
                let mut buffer = [0; 1024];

                match term.read_raw(&mut buffer, Some(Duration::new(0, 0)))? 
                {
                    None => Ok(RawRead::Bytes(0)),
                    Some(Event::Raw(n)) => 
                    {
                        buf.extend(&buffer[..n]);
                        Ok(RawRead::Bytes(n))
                    }
                    Some(Event::Resize(size)) => Ok(RawRead::Resize(size)),
                    Some(Event::Signal(sig)) => Ok(RawRead::Signal(sig)),
                    _ => unreachable!()
                }
            }   
        }
    }
    /*
    */
    pub mod windows
    {
        //! Windows platform support
        pub use self::console::terminal_read;

        pub mod console
        {
            use std::char;
            use std::io;
            use std::mem::zeroed;
            use std::os::raw::c_int;
            use std::time::Duration;

            use mortal::{Event, TerminalReadGuard};
            use mortal::windows::TerminalExt;

            use winapi::shared::minwindef::{
                DWORD,
                TRUE,
            };
            use winapi::um::wincon::{
                self,
                INPUT_RECORD,
                KEY_EVENT,
                KEY_EVENT_RECORD,
            };
            use winapi::um::winuser;

            use crate::chars::DELETE;
            use crate::terminal::RawRead;

            // Generate some sequences for special characters.
            // The basic ones align with common Unix terminals, so that they match up with
            // default bindings. Ctrl/Shift/Alt combinations for arrow keys are somewhat
            // arbitrary, as Unix terminals can't seem to agree on those.
            const HOME_SEQ: &str = "\x1b[H";
            const END_SEQ: &str = "\x1b[F";
            const INSERT_SEQ: &str = "\x1b[2~";
            const DELETE_SEQ: &str = "\x1b[3~";
            const PAGE_UP_SEQ: &str = "\x1b[5~";
            const PAGE_DOWN_SEQ: &str = "\x1b[6~";

            struct SeqGroup {
                norm: &'static str,
                ctrl: &'static str,
                shift: &'static str,
                alt: &'static str,
                ctrl_shift: &'static str,
                ctrl_alt: &'static str,
                shift_alt: &'static str,
                ctrl_shift_alt: &'static str,
            }

            impl SeqGroup {
                fn select(&self, state: DWORD) -> &'static str {
                    match (has_ctrl(state), has_shift(state), has_alt(state)) {
                        (false, false, false) => self.norm,
                        (true,  false, false) => self.ctrl,
                        (false, true,  false) => self.shift,
                        (true,  true,  false) => self.ctrl_shift,
                        (false, false, true)  => self.alt,
                        (true,  false, true)  => self.ctrl_alt,
                        (false, true,  true)  => self.shift_alt,
                        (true,  true,  true)  => self.ctrl_shift_alt,
                    }
                }
            }

            macro_rules! seq_group {
                ( $name:ident , $ch:expr ) => {
                    const $name: SeqGroup = SeqGroup {
                        norm:           concat!("\x1b[",  $ch),
                        ctrl:           concat!("\x1b[1", $ch),
                        shift:          concat!("\x1b[2", $ch),
                        alt:            concat!("\x1b[4", $ch),
                        ctrl_shift:     concat!("\x1b[3", $ch),
                        ctrl_alt:       concat!("\x1b[5", $ch),
                        shift_alt:      concat!("\x1b[6", $ch),
                        ctrl_shift_alt: concat!("\x1b[7", $ch),
                    };
                }
            }

            seq_group!{ UP_SEQ, "A" }
            seq_group!{ DOWN_SEQ, "B" }
            seq_group!{ RIGHT_SEQ, "C" }
            seq_group!{ LEFT_SEQ, "D" }

            pub fn terminal_read(term: &mut TerminalReadGuard, buf: &mut Vec<u8>) -> io::Result<RawRead> {
                let mut events: [INPUT_RECORD; 1] = unsafe { zeroed() };

                let n = match term.read_raw_event(&mut events, Some(Duration::new(0, 0)))? {
                    Some(Event::Raw(n)) => n,
                    None => return Ok(RawRead::Bytes(0)),
                    Some(Event::Resize(size)) => return Ok(RawRead::Resize(size)),
                    Some(Event::Signal(sig)) => return Ok(RawRead::Signal(sig)),
                    _ => unreachable!()
                };

                if n == 1 {
                    let old_len = buf.len();

                    translate_event(buf, &events[0]);

                    Ok(RawRead::Bytes(buf.len() - old_len))
                } else {
                    Ok(RawRead::Bytes(0))
                }
            }

            fn translate_event(buf: &mut Vec<u8>, event: &INPUT_RECORD) {
                if event.EventType == KEY_EVENT {
                    translate_key(buf, unsafe { event.Event.KeyEvent() });
                }
            }

            fn translate_key(buf: &mut Vec<u8>, event: &KEY_EVENT_RECORD) {
                if event.bKeyDown == TRUE {
                    let start = buf.len();

                    match event.wVirtualKeyCode as c_int {
                        winuser::VK_BACK    => buf.push(DELETE as u8),
                        winuser::VK_TAB     => buf.push(b'\t'),
                        winuser::VK_RETURN  => {
                            buf.push(b'\r');
                        }
                        winuser::VK_ESCAPE  => buf.push(b'\x1b'),
                        // Page up
                        winuser::VK_PRIOR   => buf.extend(PAGE_UP_SEQ.as_bytes()),
                        // Page down
                        winuser::VK_NEXT    => buf.extend(PAGE_DOWN_SEQ.as_bytes()),
                        winuser::VK_END     => buf.extend(END_SEQ.as_bytes()),
                        winuser::VK_HOME    => buf.extend(HOME_SEQ.as_bytes()),
                        winuser::VK_LEFT    => {
                            buf.extend(LEFT_SEQ.select(event.dwControlKeyState).as_bytes());
                        }
                        winuser::VK_UP      => {
                            buf.extend(UP_SEQ.select(event.dwControlKeyState).as_bytes());
                        }
                        winuser::VK_RIGHT   => {
                            buf.extend(RIGHT_SEQ.select(event.dwControlKeyState).as_bytes());
                        }
                        winuser::VK_DOWN    => {
                            buf.extend(DOWN_SEQ.select(event.dwControlKeyState).as_bytes());
                        }
                        winuser::VK_INSERT  => buf.extend(INSERT_SEQ.as_bytes()),
                        winuser::VK_DELETE  => buf.extend(DELETE_SEQ.as_bytes()),
                        _ => {
                            let u_ch = unsafe { *event.uChar.UnicodeChar() };
                            if u_ch != 0 {
                                if let Some(ch) = char::from_u32(u_ch as u32) {
                                    let mut bytes = [0; 4];
                                    buf.extend(ch.encode_utf8(&mut bytes).as_bytes());
                                }
                            }
                        }
                    }

                    if event.wRepeatCount > 1 {
                        let seq = buf[start..].to_owned();

                        for _ in 1..event.wRepeatCount {
                            buf.extend(&seq);
                        }
                    }
                }
            }

            fn has_alt(state: DWORD) -> bool {
                state & (wincon::LEFT_ALT_PRESSED | wincon::RIGHT_ALT_PRESSED) != 0
            }

            fn has_ctrl(state: DWORD) -> bool {
                state & (wincon::LEFT_CTRL_PRESSED | wincon::RIGHT_CTRL_PRESSED) != 0
            }

            fn has_shift(state: DWORD) -> bool {
                state & wincon::SHIFT_PRESSED != 0
            }
        }

        pub mod path
        {
            use ::env::var_os;
            use ::path::PathBuf;
            use ::dirs::data_dir;

            pub fn env_init_file() -> Option<PathBuf> 
            {
                var_os("INPUTRC").map(PathBuf::from)
            }

            pub fn system_init_file() -> Option<PathBuf> 
            {
                None
            }

            pub fn user_init_file() -> Option<PathBuf> 
            {
                data_dir().map(|p| p.join(r"linefeed\inputrc"))
            }
        }
    }
    /*
    */
    pub mod sys
    {
        pub use super::unix::{*};
    }
}
/*
*/
pub fn main() 
{
    
} // 29270
