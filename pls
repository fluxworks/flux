#![allow(unknown_lints)]
/*
// #![feature(tool_lints)]
extern crate errno;
extern crate exec;
extern crate glob;
extern crate libc;
extern crate lineread;
extern crate nix;
extern crate regex;
extern crate rusqlite;
extern crate yaml_rust;

extern crate clap;

#[macro_use]
extern crate lazy_static;
extern crate pest;
#[macro_use]
extern crate pest_derive; */ 



pub mod borrow
{
    pub use ::borrow::{ * };
}

pub mod collections
{
    pub use ::collections::{ * };
}

pub mod convert
{
    pub use ::convert::{ * };
}

pub mod env
{
    pub use ::env::{ * };
}

pub mod error
{
    pub use ::error::{ * };
}

pub mod ffi
{
    pub use ::ffi::{ * };
}

pub mod fs
{
    pub use ::fs::{ * };
}

pub mod hash
{
    pub use ::hash::{ * };
}

pub mod io
{
    pub use ::io::{ * };
}

pub mod iter
{
    pub use ::iter::{ * };
}

pub mod marker
{
    pub use ::marker::{ * };
}

pub mod mem
{
    pub use ::mem::{ * };
    /* memchr v2.6.0 */
    pub mod chr
    {
        //! For skipping along search text quickly when a leading byte is known.
        use ::
        {
            *,
        };
    }
}

pub mod num
{
    pub use ::num::{ * };
}

pub mod ops
{
    pub use ::ops::{ * };
}

pub mod os
{
    pub mod unix
    {
        #[cfg(unix)] pub use ::os::unix::{ * };    
    }

    pub mod windows
    {
        #[cfg(windows)] pub use ::os::windows::{ * };    
    }

    pub use ::os::{ * };   
}

pub mod path
{
    pub use ::path::{ * };
}

pub mod process
{
    pub use ::process::{ * };
}

pub mod ptr
{
    pub use ::ptr::{ * };
}

pub mod result
{
    pub use ::result::{ * };
}

pub mod str
{
    pub use ::str::{ * };
}

pub mod string
{
    pub use ::string::{ * };
}

pub mod sync
{
    pub use ::sync::{ * };
}

pub mod time
{
    pub use ::time::{ * };
}

pub mod vec
{
    pub use ::vec::{ * };
    /* smallvec = "1.6.1" */
    pub mod small
    {
        use ::
        {
            *,
        };
    }
}

/*
extern crate errno;
extern crate exec;
extern crate glob;
extern crate libc;
extern crate lineread;
extern crate nix;
extern crate regex;
extern crate rusqlite;
extern crate yaml_rust; 
extern crate clap;

#[macro_use]
extern crate lazy_static;
extern crate pest;
#[macro_use]
extern crate pest_derive;
*/
pub mod _
{
    use ::
    {
        *,
    };
}
// aho_corasick v1.0.0
pub mod aho_corasick
{
    use ::
    {
        *,
    };
}
/* bitflags = "2.0" */
#[macro_use] pub mod bitflags
{
    use ::
    {
        *,
    };
}

#[macro_use] pub mod lazy_static
{
    use ::
    {
        *,
    };
}

#[macro_use] pub mod pest_derive
{
    use ::
    {
        *,
    };
}

#[macro_use] pub mod tlog
{
    use ::
    {
        *,
    };
    pub fn getpid() -> i32 {
        unsafe { libc::getpid() }
    }
    
    #[macro_export]
    macro_rules! log {
        ($fmt:expr) => (
            let log_file = if let Ok(x) = ::env::var("CICADA_LOG_FILE") {
                x.clone()
            } else {
                String::new()
            };
    
            if !log_file.is_empty() {
                use ::io::Write as _;
    
                let msg = $fmt;
                match ::fs::OpenOptions::new().append(true).create(true).open(&log_file) {
                    Ok(mut cfile) => {
                        let pid = $crate::tlog::getpid();
                        let now = $crate::ctime::DateTime::now();
                        let msg = format!("[{}][{}] {}", now, pid, msg);
                        let msg = if msg.ends_with('\n') { msg } else { format!("{}\n", msg) };
                        match cfile.write_all(msg.as_bytes()) {
                            Ok(_) => {}
                            Err(_) => println!("tlog: write_all error")
                        }
                    }
                    Err(_) => println!("tlog: open file error"),
                }
    
            }
        );
    
        ($fmt:expr, $($arg:tt)*) => (
            let msg = format!($fmt, $($arg)*);
            log!(&msg);
        );
    }
}

#[macro_use] pub mod tools
{
    use ::
    {
        *,
    };
    /*
    use ::collections::HashMap;
    use ::env;
    use ::fs::File;
    use ::fs::OpenOptions;
    use ::io::Write;
    use ::os::unix::io::IntoRawFd;
    use ::path::{Path, PathBuf};
    
    use regex::Regex;
    
    use crate::execute;
    use crate::libs::re::re_contains;
    use crate::parsers;
    use crate::shell;
    */
    macro_rules! println_stderr 
    {
        ($fmt:expr) => (
            match writeln!(&mut ::io::stderr(), $fmt) {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );
        ($fmt:expr, $($arg:tt)*) => (
            match writeln!(&mut ::io::stderr(), $fmt, $($arg)*) {
                Ok(_) => {}
                Err(e) => println!("write to stderr failed: {:?}", e)
            }
        );
    }

    pub fn is_signal_handler_enabled() -> bool {
        env::var("CICADA_ENABLE_SIG_HANDLER").map_or(false, |x| x == "1")
    }

    pub fn get_user_name() -> String {
        match env::var("USER") {
            Ok(x) => {
                return x;
            }
            Err(e) => {
                log!("cicada: env USER error: {}", e);
            }
        }
        let cmd_result = execute::run("whoami");
        return cmd_result.stdout.trim().to_string();
    }

    pub fn get_user_home() -> String {
        match env::var("HOME") {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: env HOME error: {}", e);
                String::new()
            }
        }
    }

    pub fn get_config_dir() -> String {
        if let Ok(x) = env::var("XDG_CONFIG_HOME") {
            format!("{}/cicada", x)
        } else {
            let home = get_user_home();
            format!("{}/.config/cicada", home)
        }
    }

    pub fn get_user_completer_dir() -> String {
        let dir_config = get_config_dir();
        format!("{}/completers", dir_config)
    }

    pub fn unquote(s: &str) -> String {
        let args = parsers::parser_line::line_to_plain_tokens(s);
        if args.is_empty() {
            return String::new();
        }
        args[0].clone()
    }

    pub fn is_env(line: &str) -> bool {
        re_contains(line, r"^[a-zA-Z_][a-zA-Z0-9_]*=.*$")
    }

    // #[allow(clippy::trivial_regex)]
    pub fn extend_bangbang(sh: &shell::Shell, line: &mut String) {
        if !re_contains(line, r"!!") {
            return;
        }
        if sh.previous_cmd.is_empty() {
            return;
        }

        let re = Regex::new(r"!!").unwrap();
        let mut replaced = false;
        let mut new_line = String::new();
        let linfo = parsers::parser_line::parse_line(line);
        for (sep, token) in linfo.tokens {
            if !sep.is_empty() {
                new_line.push_str(&sep);
            }

            if re_contains(&token, r"!!") && sep != "'" {
                let line2 = token.clone();
                let result = re.replace_all(&line2, sh.previous_cmd.as_str());
                new_line.push_str(&result);
                replaced = true;
            } else {
                new_line.push_str(&token);
            }

            if !sep.is_empty() {
                new_line.push_str(&sep);
            }
            new_line.push(' ');
        }

        *line = new_line.trim_end().to_string();
        // print full line after extending
        if replaced {
            println!("{}", line);
        }
    }

    pub fn wrap_sep_string(sep: &str, s: &str) -> String {
        let mut _token = String::new();
        let mut met_subsep = false;
        // let set previous_subsep to any char except '`' or '"'
        let mut previous_subsep = 'N';
        for c in s.chars() {
            // handle cmds like: export DIR=`brew --prefix openssl`/include
            // or like: export foo="hello world"
            if sep.is_empty() && (c == '`' || c == '"') {
                if !met_subsep {
                    met_subsep = true;
                    previous_subsep = c;
                } else if c == previous_subsep {
                    met_subsep = false;
                    previous_subsep = 'N';
                }
            }
            if c.to_string() == sep {
                _token.push('\\');
            }
            if c == ' ' && sep.is_empty() && !met_subsep {
                _token.push('\\');
            }
            _token.push(c);
        }
        format!("{}{}{}", sep, _token, sep)
    }

    pub fn env_args_to_command_line() -> String {
        let mut result = String::new();
        let env_args = env::args();
        if env_args.len() <= 1 {
            return result;
        }
        for (i, arg) in env_args.enumerate() {
            if i == 0 || arg == "-c" {
                continue;
            }
            result.push_str(arg.as_str());
        }
        result
    }

    extern "C" {
        fn gethostname(name: *mut libc::c_char, size: libc::size_t) -> libc::c_int;
    }

    /// via: https://gist.github.com/conradkleinespel/6c8174aee28fa22bfe26
    pub fn get_hostname() -> String {
        let len = 255;
        let mut buf = Vec::<u8>::with_capacity(len);

        let ptr = buf.as_mut_slice().as_mut_ptr();

        let err = unsafe { gethostname(ptr as *mut libc::c_char, len as libc::size_t) } as i32;

        match err {
            0 => {
                let real_len;
                let mut i = 0;
                loop {
                    let byte = unsafe { *(((ptr as u64) + (i as u64)) as *const u8) };
                    if byte == 0 {
                        real_len = i;
                        break;
                    }

                    i += 1;
                }
                unsafe { buf.set_len(real_len) }
                String::from_utf8_lossy(buf.as_slice()).into_owned()
            }
            _ => String::from("unknown"),
        }
    }

    pub fn is_arithmetic(line: &str) -> bool {
        if !re_contains(line, r"[0-9]+") {
            return false;
        }
        if !re_contains(line, r"\+|\-|\*|/|\^") {
            return false;
        }
        re_contains(line, r"^[ 0-9\.\(\)\+\-\*/\^]+[\.0-9 \)]$")
    }

    pub fn create_raw_fd_from_file(file_name: &str, append: bool) -> Result<i32, String> {
        let mut oos = OpenOptions::new();
        if append {
            oos.append(true);
        } else {
            oos.write(true);
            oos.truncate(true);
        }
        match oos.create(true).open(file_name) {
            Ok(x) => {
                let fd = x.into_raw_fd();
                Ok(fd)
            }
            Err(e) => Err(format!("{}", e)),
        }
    }

    pub fn get_fd_from_file(file_name: &str) -> i32 {
        let path = Path::new(file_name);
        let display = path.display();
        let file = match File::open(path) {
            Err(why) => {
                println_stderr!("cicada: {}: {}", display, why);
                return -1;
            }
            Ok(file) => file,
        };
        file.into_raw_fd()
    }

    pub fn escape_path(path: &str) -> String {
        let re = Regex::new(r##"(?P<c>[!\(\)<>,\?\]\[\{\} \\'"`*\^#|$&;])"##).unwrap();
        return re.replace_all(path, "\\$c").to_string();
    }

    pub fn get_current_dir() -> String {
        let mut current_dir = PathBuf::new();
        match env::current_dir() {
            Ok(x) => current_dir = x,
            Err(e) => {
                println_stderr!("env current_dir() failed: {}", e);
            }
        }
        let mut str_current_dir = "";
        match current_dir.to_str() {
            Some(x) => str_current_dir = x,
            None => {
                println_stderr!("current_dir to str failed.");
            }
        }
        str_current_dir.to_string()
    }

    pub fn split_into_fields(
        sh: &shell::Shell,
        line: &str,
        envs: &HashMap<String, String>,
    ) -> Vec<String> {
        let ifs_chars;
        if envs.contains_key("IFS") {
            ifs_chars = envs[&"IFS".to_string()].chars().collect();
        } else if let Some(x) = sh.get_env("IFS") {
            ifs_chars = x.chars().collect();
        } else if let Ok(x) = env::var("IFS") {
            ifs_chars = x.chars().collect();
        } else {
            ifs_chars = vec![];
        }

        if ifs_chars.is_empty() {
            return line
                .split(&[' ', '\t', '\n'][..])
                .map(|x| x.to_string())
                .collect();
        } else {
            return line.split(&ifs_chars[..]).map(|x| x.to_string()).collect();
        }
    }

    pub fn is_builtin(s: &str) -> bool {
        let builtins = [
            "alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg",
            "history", "jobs", "read", "source", "ulimit", "unalias", "vox",
            "minfd", "set", "unset", "unpath",
        ];
        builtins.contains(&s)
    }

    pub fn init_path_env() {
        // order matters. took from `runc spec`
        let mut paths: Vec<String> = vec![];
        for x in [
            "/usr/local/sbin",
            "/usr/local/bin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
        ] {
            if Path::new(x).exists() {
                paths.push(x.to_string());
            }
        }

        if let Ok(env_path) = env::var("PATH") {
            for x in env_path.split(":") {
                if !paths.contains(&x.to_string()) {
                    paths.push(x.to_string());
                }
            }
        }
        let paths = paths.join(":");
        env::set_var("PATH", paths);
    }

    pub fn is_shell_altering_command(line: &str) -> bool {
        let line = line.trim();
        if re_contains(line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$") {
            return true;
        }
        line.starts_with("alias ")
            || line.starts_with("export ")
            || line.starts_with("unalias ")
            || line.starts_with("unset ")
            || line.starts_with("source ")
    }
}

#[macro_use] pub mod macros
{
    use ::
    {
        *,
    };
}

pub mod clap
{
    use ::
    {
        *,
    };
    // default-features = false
    pub mod v233
    {
        use ::
        {
            *,
        };
    }
    // default-features = ["std", "derive", "help"]
    pub mod v450
    {
        use ::
        {
            *,
        };
    }
}

pub mod errno
{
    use ::
    {
        *,
    };
}

pub mod exec
{
    use ::
    {
        *,
    };
}

pub mod fallible
{
    use ::
    {
        *,
    };
    /* fallible-iterator = "0.3" */
    pub mod iterator
    {
        use ::
        {
            *,
        };
        /*
        */
    }
    /* fallible-streaming-iterator = "0.1" */
    pub mod streaming
    {
        use ::
        {
            *,
        };
        /*
        */
    }
}

pub mod glob
{
    use ::
    {
        *,
    };
}
/* hashlink = "0.9" */
pub mod hashlink
{
    use ::
    {
        *,
    };
    /*
    */
}

pub mod libc
{
    use ::
    {
        *,
    };
    
    // pub mod jobc
    pub mod job
    {
        use ::
        {
            *,
        };
        /*
        use ::io::Write;
        
        use nix::sys::signal::Signal;
        use nix::sys::wait::waitpid;
        use nix::sys::wait::WaitPidFlag as WF;
        use nix::sys::wait::WaitStatus as WS;
        use nix::uni ::Pid;
        
        use crate::shell;
        use crate::signals;
        use crate::types::{self, CommandResult};
        */
        pub fn get_job_line(job: &types::Job, trim: bool) -> String {
            let mut cmd = job.cmd.clone();
            if trim && cmd.len() > 50 {
                cmd.truncate(50);
                cmd.push_str(" ...");
            }
            let _cmd = if job.is_bg && job.status == "Running" {
                format!("{} &", cmd)
            } else {
                cmd
            };
            format!("[{}] {}  {}   {}", job.id, job.gid, job.status, _cmd)
        }
        
        pub fn print_job(job: &types::Job) {
            let line = get_job_line(job, true);
            println_stderr!("{}", line);
        }
        
        pub fn mark_job_as_done(sh: &mut shell::Shell, gid: i32, pid: i32, reason: &str) {
            if let Some(mut job) = sh.remove_pid_from_job(gid, pid) {
                job.status = reason.to_string();
                if job.is_bg {
                    println_stderr!("");
                    print_job(&job);
                }
            }
        }
        
        pub fn mark_job_as_stopped(sh: &mut shell::Shell, gid: i32, report: bool) {
            sh.mark_job_as_stopped(gid);
            if !report {
                return;
            }
        
            // add an extra line to separate output of fg commands if any.
            if let Some(job) = sh.get_job_by_gid(gid) {
                println_stderr!("");
                print_job(job);
            }
        }
        
        pub fn mark_job_member_stopped(sh: &mut shell::Shell, pid: i32, gid: i32, report: bool) {
            let _gid = if gid == 0 {
                unsafe { libc::getpgid(pid) }
            } else {
                gid
            };
        
            if let Some(job) = sh.mark_job_member_stopped(pid, gid) {
                if job.all_members_stopped() {
                    mark_job_as_stopped(sh, gid, report);
                }
            }
        }
        
        pub fn mark_job_member_continued(sh: &mut shell::Shell, pid: i32, gid: i32) {
            let _gid = if gid == 0 {
                unsafe { libc::getpgid(pid) }
            } else {
                gid
            };
        
            if let Some(job) = sh.mark_job_member_continued(pid, gid) {
                if job.all_members_running() {
                    mark_job_as_running(sh, gid, true);
                }
            }
        }
        
        pub fn mark_job_as_running(sh: &mut shell::Shell, gid: i32, bg: bool) {
            sh.mark_job_as_running(gid, bg);
        }
        
        #[allow(unreachable_patterns)]
        pub fn waitpidx(wpid: i32, block: bool) -> types::WaitStatus {
            let options = if block {
                Some(WF::WUNTRACED | WF::WCONTINUED)
            } else {
                Some(WF::WUNTRACED | WF::WCONTINUED | WF::WNOHANG)
            };
            match waitpid(Pid::from_raw(wpid), options) {
                Ok(WS::Exited(pid, status)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_exited(pid, status)
                }
                Ok(WS::Stopped(pid, sig)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_stopped(pid, sig as i32)
                }
                Ok(WS::Continued(pid)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_continuted(pid)
                }
                Ok(WS::Signaled(pid, sig, _core_dumped)) => {
                    let pid = i32::from(pid);
                    types::WaitStatus::from_signaled(pid, sig as i32)
                }
                Ok(WS::StillAlive) => {
                    types::WaitStatus::empty()
                }
                Ok(_others) => {
                    // this is for PtraceEvent and PtraceSyscall on Linux,
                    // unreachable on other platforms.
                    types::WaitStatus::from_others()
                }
                Err(e) => {
                    types::WaitStatus::from_error(e as i32)
                }
            }
        }
        
        pub fn wait_fg_job(sh: &mut shell::Shell, gid: i32, pids: &[i32]) -> CommandResult {
            let mut cmd_result = CommandResult::new();
            let mut count_waited = 0;
            let count_child = pids.len();
            if count_child == 0 {
                return cmd_result;
            }
            let pid_last = pids.last().unwrap();
        
            loop {
                let ws = waitpidx(-1, true);
                // here when we calling waitpidx(), all signals should have
                // been masked. There should no errors (ECHILD/EINTR etc) happen.
                if ws.is_error() {
                    let err = ws.get_errno();
                    if err == nix::Error::ECHILD {
                        break;
                    }
        
                    log!("jobc unexpected waitpid error: {}", err);
                    cmd_result = CommandResult::from_status(gid, err as i32);
                    break;
                }
        
                let pid = ws.get_pid();
                let is_a_fg_child = pids.contains(&pid);
                if is_a_fg_child && !ws.is_continued() {
                    count_waited += 1;
                }
        
                if ws.is_exited() {
                    if is_a_fg_child {
                        mark_job_as_done(sh, gid, pid, "Done");
                    } else {
                        let status = ws.get_status();
                        signals::insert_reap_map(pid, status);
                    }
                } else if ws.is_stopped() {
                    if is_a_fg_child {
                        // for stop signal of fg job (current job)
                        // i.e. Ctrl-Z is pressed on the fg job
                        mark_job_member_stopped(sh, pid, gid, true);
                    } else {
                        // for stop signal of bg jobs
                        signals::insert_stopped_map(pid);
                        mark_job_member_stopped(sh, pid, 0, false);
                    }
                } else if ws.is_continued() {
                    if !is_a_fg_child {
                        signals::insert_cont_map(pid);
                    }
                    continue;
                } else if ws.is_signaled() {
                    if is_a_fg_child {
                        mark_job_as_done(sh, gid, pid, "Killed");
                    } else {
                        signals::killed_map_insert(pid, ws.get_signal());
                    }
                }
        
                if is_a_fg_child && pid == *pid_last {
                    let status = ws.get_status();
                    cmd_result.status = status;
                }
        
                if count_waited >= count_child {
                    break;
                }
            }
            cmd_result
        }
        
        pub fn try_wait_bg_jobs(sh: &mut shell::Shell, report: bool, sig_handler_enabled: bool) {
            if sh.jobs.is_empty() {
                return;
            }
        
            if !sig_handler_enabled {
                // we need to wait pids in case CICADA_ENABLE_SIG_HANDLER=0
                signals::handle_sigchld(Signal::SIGCHLD as i32);
            }
        
            let jobs = sh.jobs.clone();
            for (_i, job) in jobs.iter() {
                for pid in job.pids.iter() {
                    if let Some(_status) = signals::pop_reap_map(*pid) {
                        mark_job_as_done(sh, job.gid, *pid, "Done");
                        continue;
                    }
        
                    if let Some(sig) = signals::killed_map_pop(*pid) {
                        let reason = if sig == Signal::SIGQUIT as i32 {
                            format!("Quit: {}", sig)
                        } else if sig == Signal::SIGINT as i32 {
                            format!("Interrupt: {}", sig)
                        } else if sig == Signal::SIGKILL as i32 {
                            format!("Killed: {}", sig)
                        } else if sig == Signal::SIGTERM as i32 {
                            format!("Terminated: {}", sig)
                        } else {
                            format!("Killed: {}", sig)
                        };
                        mark_job_as_done(sh, job.gid, *pid, &reason);
                        continue;
                    }
        
                    if signals::pop_stopped_map(*pid) {
                        mark_job_member_stopped(sh, *pid, job.gid, report);
                    } else if signals::pop_cont_map(*pid) {
                        mark_job_member_continued(sh, *pid, job.gid);
                    }
                }
            }
        }
    }
    // pub mod ctime
    pub mod time
    {
        use ::
        {
            *,
        };
        /*
        use ::fmt;
        use time::OffsetDateTime;
        */
        #[derive(Debug, PartialEq, Eq)]
        pub struct DateTime {
            odt: OffsetDateTime,
        }
        
        impl DateTime {
            pub fn now() -> Self {
                let odt: OffsetDateTime = match OffsetDateTime::now_local() {
                    Ok(dt) => dt,
                    Err(_) => OffsetDateTime::now_utc(),
                };
                DateTime { odt }
            }
        
            pub fn from_timestamp(ts: f64) -> Self {
                let dummy_now = Self::now();
                let offset_seconds = dummy_now.odt.offset().whole_minutes() * 60;
                let ts_nano = (ts + offset_seconds as f64) * 1000000000.0;
                let odt: OffsetDateTime = match OffsetDateTime::from_unix_timestamp_nanos(ts_nano as i128) {
                    Ok(x) => x,
                    Err(_) => OffsetDateTime::now_utc(),
                };
                DateTime { odt }
            }
        
            pub fn unix_timestamp(&self) -> f64 {
                self.odt.unix_timestamp_nanos() as f64 / 1000000000.0
            }
        }
        
        impl fmt::Display for DateTime {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, "{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                    self.odt.year(),
                    self.odt.month() as u8,
                    self.odt.day(),
                    self.odt.hour(),
                    self.odt.minute(),
                    self.odt.second(),
                    self.odt.millisecond(),
                )
            }
        }

    }
}

pub mod lineread
{
    use ::
    {
        *,
    };
} pub use lineread::{Command, Interface, ReadResult};

//linked-hash-map = ">=0.0.9, <0.6"
pub mod linked_hash_map
{
    //! A `HashMap` wrapper that holds key-value pairs in insertion order.
    use ::
    {
        *,
    };
    /*
    use ::borrow::Borrow;
    use ::cmp::Ordering;
    use ::collections::hash_map::{self, HashMap};
    use ::fmt;
    use ::hash::{BuildHasher, Hash, Hasher};
    use ::iter;
    use ::marker;
    use ::mem;
    use ::ops::{Index, IndexMut};
    use ::ptr::{self, addr_of_mut};
    */
    struct KeyRef<K> {
        k: *const K,
    }

    struct Node<K, V> {
        next: *mut Node<K, V>,
        prev: *mut Node<K, V>,
        key: K,
        value: V,
    }

    /// A linked hash map.
    pub struct LinkedHashMap<K, V, S = hash_map::RandomState> {
        map: HashMap<KeyRef<K>, *mut Node<K, V>, S>,
        head: *mut Node<K, V>,
        free: *mut Node<K, V>,
    }

    impl<K: Hash> Hash for KeyRef<K> {
        fn hash<H: Hasher>(&self, state: &mut H) {
            unsafe { (*self.k).hash(state) }
        }
    }

    impl<K: PartialEq> PartialEq for KeyRef<K> {
        fn eq(&self, other: &Self) -> bool {
            unsafe { (*self.k).eq(&*other.k) }
        }
    }

    impl<K: Eq> Eq for KeyRef<K> {}
    
    #[derive(Hash, PartialEq, Eq)]
    #[repr(transparent)]
    struct Qey<Q: ?Sized>(Q);

    impl<Q: ?Sized> Qey<Q> {
        fn from_ref(q: &Q) -> &Self {
            unsafe { mem::transmute(q) }
        }
    }

    impl<K, Q: ?Sized> Borrow<Qey<Q>> for KeyRef<K> where
        K: Borrow<Q>,
    {
        fn borrow(&self) -> &Qey<Q> {
            Qey::from_ref(unsafe { (*self.k).borrow() })
        }
    }

    impl<K, V> Node<K, V> {
        fn new(k: K, v: V) -> Self {
            Node {
                key: k,
                value: v,
                next: ptr::null_mut(),
                prev: ptr::null_mut(),
            }
        }
    }

    // drop empty node without dropping its key and value
    unsafe fn drop_empty_node<K, V>(the_box: *mut Node<K, V>) {
        let layout = ::::Layout::new::<Node<K, V>>();
        ::::dealloc(the_box as *mut u8, layout);
    }

    impl<K: Hash + Eq, V> LinkedHashMap<K, V> {
        /// Creates a linked hash map.
        pub fn new() -> Self {
            Self::with_map(HashMap::new())
        }

        /// Creates an empty linked hash map with the given initial capacity.
        pub fn with_capacity(capacity: usize) -> Self {
            Self::with_map(HashMap::with_capacity(capacity))
        }
    }

    impl<K, V, S> LinkedHashMap<K, V, S> {
        #[inline]
        fn detach(&mut self, node: *mut Node<K, V>) {
            unsafe {
                (*(*node).prev).next = (*node).next;
                (*(*node).next).prev = (*node).prev;
            }
        }

        #[inline]
        fn attach(&mut self, node: *mut Node<K, V>) {
            unsafe {
                (*node).next = (*self.head).next;
                (*node).prev = self.head;
                (*self.head).next = node;
                (*(*node).next).prev = node;
            }
        }
        
        unsafe fn drop_entries(&mut self) {
            let mut cur = (*self.head).next;
            while cur != self.head {
                let next = (*cur).next;
                Box::from_raw(cur);
                cur = next;
            }
        }

        fn clear_free_list(&mut self) {
            unsafe {
                let mut free = self.free;
                while !free.is_null() {
                    let next_free = (*free).next;
                    drop_empty_node(free);
                    free = next_free;
                }
                self.free = ptr::null_mut();
            }
        }

        fn ensure_guard_node(&mut self) {
            if self.head.is_null() {
                // allocate the guard node if not present
                unsafe {
                    let node_layout = ::::Layout::new::<Node<K, V>>();
                    self.head = ::::alloc(node_layout) as *mut Node<K, V>;
                    (*self.head).next = self.head;
                    (*self.head).prev = self.head;
                }
            }
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher> LinkedHashMap<K, V, S> {
        fn with_map(map: HashMap<KeyRef<K>, *mut Node<K, V>, S>) -> Self {
            LinkedHashMap {
                map,
                head: ptr::null_mut(),
                free: ptr::null_mut(),
            }
        }

        /// Creates an empty linked hash map with the given initial hash builder.
        pub fn with_hasher(hash_builder: S) -> Self {
            Self::with_map(HashMap::with_hasher(hash_builder))
        }

        /// Creates an empty linked hash map with the given initial capacity and hash builder.
        pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> Self {
            Self::with_map(HashMap::with_capacity_and_hasher(capacity, hash_builder))
        }

        /// Reserves capacity for at least `additional` more elements to be inserted into the map.
        pub fn reserve(&mut self, additional: usize) {
            self.map.reserve(additional);
        }

        /// Shrinks the capacity of the map as much as possible. 
        pub fn shrink_to_fit(&mut self) {
            self.map.shrink_to_fit();
            self.clear_free_list();
        }

        /// Gets the given key's corresponding entry in the map for in-place manipulation.
        pub fn entry(&mut self, k: K) -> Entry<K, V, S> {
            let self_ptr: *mut Self = self;

            if let Some(entry) = self.map.get_mut(&KeyRef { k: &k }) {
                return Entry::Occupied(OccupiedEntry {
                    entry: *entry,
                    map: self_ptr,
                    marker: marker::PhantomData,
                });
            }

            Entry::Vacant(VacantEntry { key: k, map: self })
        }

        /// Returns an iterator visiting all entries in insertion order.
        pub fn entries(&mut self) -> Entries<K, V, S> {
            let head = if !self.head.is_null() {
                unsafe { (*self.head).prev }
            } else {
                ptr::null_mut()
            };
            Entries {
                map: self,
                head,
                remaining: self.len(),
                marker: marker::PhantomData,
            }
        }

        /// Inserts a key-value pair into the map.
        pub fn insert(&mut self, k: K, v: V) -> Option<V> {
            self.ensure_guard_node();

            let (node, old_val) = match self.map.get(&KeyRef { k: &k }) {
                Some(node) => {
                    let old_val = unsafe { ptr::replace(&mut (**node).value, v) };
                    (*node, Some(old_val))
                }
                None => {
                    let node = if self.free.is_null() {
                        Box::into_raw(Box::new(Node::new(k, v)))
                    } else {
                        // use a recycled box
                        unsafe {
                            let free = self.free;
                            self.free = (*free).next;
                            ptr::write(free, Node::new(k, v));
                            free
                        }
                    };
                    (node, None)
                }
            };
            match old_val {
                Some(_) => {
                    self.detach(node);
                    self.attach(node);
                }
                None => {
                    let keyref = unsafe { &(*node).key };
                    self.map.insert(KeyRef { k: keyref }, node);
                    self.attach(node);
                }
            }
            old_val
        }

        /// Checks if the map contains the given key.
        pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool where 
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            self.map.contains_key(Qey::from_ref(k))
        }

        /// Returns the value corresponding to the key in the map.
        pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V> where 
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            self.map
                .get(Qey::from_ref(k))
                .map(|e| unsafe { &(**e).value })
        }

        /// Returns the mutable reference corresponding to the key in the map.
        pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V> where 
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            self.map
                .get(Qey::from_ref(k))
                .map(|e| unsafe { &mut (**e).value })
        }

        /// Returns the value corresponding to the key in the map.
        pub fn get_refresh<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V> where 
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            let (value, node_ptr_opt) = match self.map.get(Qey::from_ref(k)) {
                None => (None, None),
                Some(node) => (Some(unsafe { &mut (**node).value }), Some(*node)),
            };
            if let Some(node_ptr) = node_ptr_opt {
                self.detach(node_ptr);
                self.attach(node_ptr);
            }
            value
        }

        /// Removes and returns the value corresponding to the key from the map.
        pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V> where 
            K: Borrow<Q>,
            Q: Eq + Hash,
        {
            let removed = self.map.remove(Qey::from_ref(k));
            removed.map(|node| {
                self.detach(node);
                unsafe {
                    // add to free list
                    (*node).next = self.free;
                    self.free = node;
                    // drop the key and return the value
                    drop(ptr::read(&(*node).key));
                    ptr::read(&(*node).value)
                }
            })
        }

        /// Returns the maximum number of key-value pairs the map can hold without reallocating.
        pub fn capacity(&self) -> usize {
            self.map.capacity()
        }

        /// Removes the first entry.
        #[inline]
        pub fn pop_front(&mut self) -> Option<(K, V)> {
            if self.is_empty() {
                return None;
            }
            let lru = unsafe { (*self.head).prev };
            self.detach(lru);
            self.map
                .remove(&KeyRef {
                    k: unsafe { &(*lru).key },
                })
                .map(|e| {
                    let e = *unsafe { Box::from_raw(e) };
                    (e.key, e.value)
                })
        }

        /// Gets the first entry.
        #[inline]
        pub fn front(&self) -> Option<(&K, &V)> {
            if self.is_empty() {
                return None;
            }
            let lru = unsafe { (*self.head).prev };
            self.map
                .get(&KeyRef {
                    k: unsafe { &(*lru).key },
                })
                .map(|e| unsafe { (&(**e).key, &(**e).value) })
        }

        /// Removes the last entry.
        #[inline]
        pub fn pop_back(&mut self) -> Option<(K, V)> {
            if self.is_empty() {
                return None;
            }
            let mru = unsafe { (*self.head).next };
            self.detach(mru);
            self.map
                .remove(&KeyRef {
                    k: unsafe { &(*mru).key },
                })
                .map(|e| {
                    let e = *unsafe { Box::from_raw(e) };
                    (e.key, e.value)
                })
        }

        /// Gets the last entry.
        #[inline]
        pub fn back(&self) -> Option<(&K, &V)> {
            if self.is_empty() {
                return None;
            }
            let mru = unsafe { (*self.head).next };
            self.map
                .get(&KeyRef {
                    k: unsafe { &(*mru).key },
                })
                .map(|e| unsafe { (&(**e).key, &(**e).value) })
        }

        /// Returns the number of key-value pairs in the map.
        pub fn len(&self) -> usize {
            self.map.len()
        }

        /// Returns whether the map is currently empty.
        pub fn is_empty(&self) -> bool {
            self.len() == 0
        }

        /// Returns a reference to the map's hasher.
        pub fn hasher(&self) -> &S {
            self.map.hasher()
        }

        /// Clears the map of all key-value pairs.
        pub fn clear(&mut self) {
            self.map.clear();
            // update the guard node if present
            if !self.head.is_null() {
                unsafe {
                    self.drop_entries();
                    (*self.head).prev = self.head;
                    (*self.head).next = self.head;
                }
            }
        }

        /// Returns a double-ended iterator visiting all key-value pairs in order of insertion.
        pub fn iter(&self) -> Iter<K, V> {
            let head = if self.head.is_null() {
                ptr::null_mut()
            } else {
                unsafe { (*self.head).prev }
            };
            Iter {
                head,
                tail: self.head,
                remaining: self.len(),
                marker: marker::PhantomData,
            }
        }

        /// Returns a double-ended iterator visiting all key-value pairs in order of insertion.
        pub fn iter_mut(&mut self) -> IterMut<K, V> {
            let head = if self.head.is_null() {
                ptr::null_mut()
            } else {
                unsafe { (*self.head).prev }
            };
            IterMut {
                head,
                tail: self.head,
                remaining: self.len(),
                marker: marker::PhantomData,
            }
        }

        /// Clears the map, returning all key-value pairs as an iterator.
        pub fn drain(&mut self) -> Drain<K, V> {
            let len = self.len();
            self.map.clear();
            let (head, tail) = if len != 0 {
                unsafe {
                    debug_assert!(!self.head.is_null());
                    debug_assert!(!(*self.head).prev.is_null());
                    debug_assert!((*self.head).prev != self.head);
                    let head = (*self.head).prev;
                    let tail = (*self.head).next;
                    (*self.head).prev = self.head;
                    (*self.head).next = self.head;
                    (*head).next = self.free;
                    (*tail).prev = ptr::null_mut();
                    self.free = tail;
                    (head, tail)
                }
            } else {
                (ptr::null_mut(), ptr::null_mut())
            };

            Drain {
                head,
                tail,
                remaining: len,
                marker: marker::PhantomData,
            }
        }

        /// Returns a double-ended iterator visiting all key in order of insertion.
        pub fn keys(&self) -> Keys<K, V> {
            Keys { inner: self.iter() }
        }

        /// Returns a double-ended iterator visiting all values in order of insertion.
        pub fn values(&self) -> Values<K, V> {
            Values { inner: self.iter() }
        }
    }

    impl<'a, K, V, S, Q: ?Sized> Index<&'a Q> for LinkedHashMap<K, V, S> where
        K: Hash + Eq + Borrow<Q>,
        S: BuildHasher,
        Q: Eq + Hash,
    {
        type Output = V;

        fn index(&self, index: &'a Q) -> &V {
            self.get(index).expect("no entry found for key")
        }
    }

    impl<'a, K, V, S, Q: ?Sized> IndexMut<&'a Q> for LinkedHashMap<K, V, S> where
        K: Hash + Eq + Borrow<Q>,
        S: BuildHasher,
        Q: Eq + Hash,
    {
        fn index_mut(&mut self, index: &'a Q) -> &mut V {
            self.get_mut(index).expect("no entry found for key")
        }
    }

    impl<K: Hash + Eq + Clone, V: Clone, S: BuildHasher + Clone> Clone for LinkedHashMap<K, V, S> {
        fn clone(&self) -> Self {
            let mut map = Self::with_hasher(self.map.hasher().clone());
            map.extend(self.iter().map(|(k, v)| (k.clone(), v.clone())));
            map
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher + Default> Default for LinkedHashMap<K, V, S> {
        fn default() -> Self {
            Self::with_hasher(S::default())
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher> Extend<(K, V)> for LinkedHashMap<K, V, S> {
        fn extend<I: IntoIterator<Item = (K, V)>>(&mut self, iter: I) {
            for (k, v) in iter {
                self.insert(k, v);
            }
        }
    }

    impl<'a, K, V, S> Extend<(&'a K, &'a V)> for LinkedHashMap<K, V, S> where
        K: 'a + Hash + Eq + Copy,
        V: 'a + Copy,
        S: BuildHasher,
    {
        fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {
            for (&k, &v) in iter {
                self.insert(k, v);
            }
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher + Default> iter::FromIterator<(K, V)>
        for LinkedHashMap<K, V, S>
    {
        fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {
            let iter = iter.into_iter();
            let mut map = Self::with_capacity_and_hasher(iter.size_hint().0, S::default());
            map.extend(iter);
            map
        }
    }

    impl<A: fmt::Debug + Hash + Eq, B: fmt::Debug, S: BuildHasher> fmt::Debug
        for LinkedHashMap<A, B, S>
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.debug_map().entries(self).finish()
        }
    }

    impl<K: Hash + Eq, V: PartialEq, S: BuildHasher> PartialEq for LinkedHashMap<K, V, S> {
        fn eq(&self, other: &Self) -> bool {
            self.len() == other.len() && self.iter().eq(other)
        }
    }

    impl<K: Hash + Eq, V: Eq, S: BuildHasher> Eq for LinkedHashMap<K, V, S> {}

    impl<K: Hash + Eq + PartialOrd, V: PartialOrd, S: BuildHasher> PartialOrd
        for LinkedHashMap<K, V, S>
    {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            self.iter().partial_cmp(other)
        }

        fn lt(&self, other: &Self) -> bool {
            self.iter().lt(other)
        }

        fn le(&self, other: &Self) -> bool {
            self.iter().le(other)
        }

        fn ge(&self, other: &Self) -> bool {
            self.iter().ge(other)
        }

        fn gt(&self, other: &Self) -> bool {
            self.iter().gt(other)
        }
    }

    impl<K: Hash + Eq + Ord, V: Ord, S: BuildHasher> Ord for LinkedHashMap<K, V, S> {
        fn cmp(&self, other: &Self) -> Ordering {
            self.iter().cmp(other)
        }
    }

    impl<K: Hash + Eq, V: Hash, S: BuildHasher> Hash for LinkedHashMap<K, V, S> {
        fn hash<H: Hasher>(&self, h: &mut H) {
            for e in self.iter() {
                e.hash(h);
            }
        }
    }

    unsafe impl<K: Send, V: Send, S: Send> Send for LinkedHashMap<K, V, S> {}

    unsafe impl<K: Sync, V: Sync, S: Sync> Sync for LinkedHashMap<K, V, S> {}

    impl<K, V, S> Drop for LinkedHashMap<K, V, S> {
        fn drop(&mut self) {
            if !self.head.is_null() {
                unsafe {
                    self.drop_entries();
                    drop_empty_node(self.head);
                }
            }
            self.clear_free_list();
        }
    }

    /// An insertion-order iterator over a `LinkedHashMap`'s entries, with immutable references to the
    /// values.
    pub struct Iter<'a, K: 'a, V: 'a> {
        head: *const Node<K, V>,
        tail: *const Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(&'a K, &'a V)>,
    }

    /// An insertion-order iterator over a `LinkedHashMap`'s entries, with mutable references to the
    /// values.
    pub struct IterMut<'a, K: 'a, V: 'a> {
        head: *mut Node<K, V>,
        tail: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(&'a K, &'a mut V)>,
    }

    /// A consuming insertion-order iterator over a `LinkedHashMap`'s entries.
    pub struct IntoIter<K, V> {
        head: *mut Node<K, V>,
        tail: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(K, V)>,
    }

    /// A draining insertion-order iterator over a `LinkedHashMap`'s entries.
    pub struct Drain<'a, K, V> {
        head: *mut Node<K, V>,
        tail: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<&'a mut (K, V)>,
    }

    /// An insertion-order iterator over a `LinkedHashMap`'s entries represented as
    /// an `OccupiedEntry`.
    pub struct Entries<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> {
        map: *mut LinkedHashMap<K, V, S>,
        head: *mut Node<K, V>,
        remaining: usize,
        marker: marker::PhantomData<(&'a K, &'a mut V, &'a S)>,
    }

    unsafe impl<'a, K, V> Send for Iter<'a, K, V> where
        K: Send,
        V: Send,
    {
    }

    unsafe impl<'a, K, V> Send for IterMut<'a, K, V> where
        K: Send,
        V: Send,
    {
    }

    unsafe impl<'a, K, V> Send for Drain<'a, K, V> where
        K: Send,
        V: Send,
    {
    }

    unsafe impl<K, V> Send for IntoIter<K, V> where
        K: Send,
        V: Send,
    {
    }

    unsafe impl<'a, K, V, S> Send for Entries<'a, K, V, S> where
        K: Send,
        V: Send,
        S: Send,
    {
    }

    unsafe impl<'a, K, V> Sync for Iter<'a, K, V> where
        K: Sync,
        V: Sync,
    {
    }

    unsafe impl<'a, K, V> Sync for IterMut<'a, K, V> where
        K: Sync,
        V: Sync,
    {
    }

    unsafe impl<'a, K, V> Sync for Drain<'a, K, V> where
        K: Sync,
        V: Sync,
    {
    }
    unsafe impl<K, V> Sync for IntoIter<K, V> where
        K: Sync,
        V: Sync,
    {
    }

    unsafe impl<'a, K, V, S> Sync for Entries<'a, K, V, S> where
        K: Sync,
        V: Sync,
        S: Sync,
    {
    }

    impl<'a, K, V> Clone for Iter<'a, K, V> {
        fn clone(&self) -> Self {
            Iter { ..*self }
        }
    }

    impl<K, V> Clone for IntoIter<K, V> where
        K: Clone,
        V: Clone,
    {
        fn clone(&self) -> Self {
            if self.remaining == 0 {
                return IntoIter { ..*self };
            }

            fn clone_node<K, V>(e: *mut Node<K, V>) -> *mut Node<K, V>
            where
                K: Clone,
                V: Clone,
            {
                Box::into_raw(Box::new(Node::new(unsafe { (*e).key.clone() }, unsafe {
                    (*e).value.clone()
                })))
            }

            let mut cur = self.head;
            let head = clone_node(cur);
            let mut tail = head;
            for _ in 1..self.remaining {
                unsafe {
                    (*tail).prev = clone_node((*cur).prev);
                    (*(*tail).prev).next = tail;
                    tail = (*tail).prev;
                    cur = (*cur).prev;
                }
            }

            IntoIter {
                head,
                tail,
                remaining: self.remaining,
                marker: marker::PhantomData,
            }
        }
    }

    impl<'a, K, V> Iterator for Iter<'a, K, V> {
        type Item = (&'a K, &'a V);

        fn next(&mut self) -> Option<(&'a K, &'a V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    let r = Some((&(*self.head).key, &(*self.head).value));
                    self.head = (*self.head).prev;
                    r
                }
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> Iterator for IterMut<'a, K, V> {
        type Item = (&'a K, &'a mut V);

        fn next(&mut self) -> Option<(&'a K, &'a mut V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    let r = Some((&(*self.head).key, &mut (*self.head).value));
                    self.head = (*self.head).prev;
                    r
                }
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<K, V> Iterator for IntoIter<K, V> {
        type Item = (K, V);

        fn next(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let prev = (*self.head).prev;
                let e = *Box::from_raw(self.head);
                self.head = prev;
                Some((e.key, e.value))
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> Iterator for Drain<'a, K, V> {
        type Item = (K, V);

        fn next(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let prev = (*self.head).prev;
                let k = addr_of_mut!((*self.head).key).read();
                let v = addr_of_mut!((*self.head).value).read();
                self.head = prev;
                Some((k, v))
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Drain<'a, K, V> {
        fn next_back(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let next = (*self.tail).next;
                let k = addr_of_mut!((*self.tail).key).read();
                let v = addr_of_mut!((*self.tail).value).read();
                self.tail = next;
                Some((k, v))
            }
        }
    }

    impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<'a, K, V, S: BuildHasher> Iterator for Entries<'a, K, V, S> {
        type Item = OccupiedEntry<'a, K, V, S>;

        fn next(&mut self) -> Option<OccupiedEntry<'a, K, V, S>> {
            if self.remaining == 0 {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    let r = Some(OccupiedEntry {
                        map: self.map,
                        entry: self.head,
                        marker: marker::PhantomData,
                    });

                    self.head = (*self.head).prev;
                    r
                }
            }
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            (self.remaining, Some(self.remaining))
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {
        fn next_back(&mut self) -> Option<(&'a K, &'a V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    self.tail = (*self.tail).next;
                    Some((&(*self.tail).key, &(*self.tail).value))
                }
            }
        }
    }

    impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {
        fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {
            if self.head == self.tail {
                None
            } else {
                self.remaining -= 1;
                unsafe {
                    self.tail = (*self.tail).next;
                    Some((&(*self.tail).key, &mut (*self.tail).value))
                }
            }
        }
    }

    impl<K, V> DoubleEndedIterator for IntoIter<K, V> {
        fn next_back(&mut self) -> Option<(K, V)> {
            if self.remaining == 0 {
                return None;
            }
            self.remaining -= 1;
            unsafe {
                let next = (*self.tail).next;
                let e = *Box::from_raw(self.tail);
                self.tail = next;
                Some((e.key, e.value))
            }
        }
    }

    impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<K, V> ExactSizeIterator for IntoIter<K, V> {
        fn len(&self) -> usize {
            self.remaining
        }
    }

    impl<K, V> Drop for IntoIter<K, V> {
        fn drop(&mut self) {
            for _ in 0..self.remaining {
                unsafe {
                    let next = (*self.tail).next;
                    Box::from_raw(self.tail);
                    self.tail = next;
                }
            }
        }
    }

    impl<'a, K, V> Drop for Drain<'a, K, V> {
        fn drop(&mut self) {
            for _ in self {}
        }
    }

    /// An insertion-order iterator over a `LinkedHashMap`'s keys.
    pub struct Keys<'a, K: 'a, V: 'a> {
        inner: Iter<'a, K, V>,
    }

    impl<'a, K, V> Clone for Keys<'a, K, V> {
        fn clone(&self) -> Self {
            Keys {
                inner: self.inner.clone(),
            }
        }
    }

    impl<'a, K, V> Iterator for Keys<'a, K, V> {
        type Item = &'a K;

        #[inline]
        fn next(&mut self) -> Option<&'a K> {
            self.inner.next().map(|e| e.0)
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.inner.size_hint()
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {
        #[inline]
        fn next_back(&mut self) -> Option<&'a K> {
            self.inner.next_back().map(|e| e.0)
        }
    }

    impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {
        fn len(&self) -> usize {
            self.inner.len()
        }
    }

    /// An insertion-order iterator over a `LinkedHashMap`'s values.
    pub struct Values<'a, K: 'a, V: 'a> {
        inner: Iter<'a, K, V>,
    }

    impl<'a, K, V> Clone for Values<'a, K, V> {
        fn clone(&self) -> Self {
            Values {
                inner: self.inner.clone(),
            }
        }
    }

    impl<'a, K, V> Iterator for Values<'a, K, V> {
        type Item = &'a V;

        #[inline]
        fn next(&mut self) -> Option<&'a V> {
            self.inner.next().map(|e| e.1)
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.inner.size_hint()
        }
    }

    impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {
        #[inline]
        fn next_back(&mut self) -> Option<&'a V> {
            self.inner.next_back().map(|e| e.1)
        }
    }

    impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {
        fn len(&self) -> usize {
            self.inner.len()
        }
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> IntoIterator for &'a LinkedHashMap<K, V, S> {
        type Item = (&'a K, &'a V);
        type IntoIter = Iter<'a, K, V>;
        fn into_iter(self) -> Iter<'a, K, V> {
            self.iter()
        }
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> IntoIterator for &'a mut LinkedHashMap<K, V, S> {
        type Item = (&'a K, &'a mut V);
        type IntoIter = IterMut<'a, K, V>;
        fn into_iter(self) -> IterMut<'a, K, V> {
            self.iter_mut()
        }
    }

    impl<K: Hash + Eq, V, S: BuildHasher> IntoIterator for LinkedHashMap<K, V, S> {
        type Item = (K, V);
        type IntoIter = IntoIter<K, V>;
        fn into_iter(mut self) -> IntoIter<K, V> {
            let (head, tail) = if !self.head.is_null() {
                unsafe { ((*self.head).prev, (*self.head).next) }
            } else {
                (ptr::null_mut(), ptr::null_mut())
            };
            let len = self.len();

            if !self.head.is_null() {
                unsafe { drop_empty_node(self.head) }
            }
            self.clear_free_list();
            // drop the HashMap but not the LinkedHashMap
            unsafe {
                ptr::drop_in_place(&mut self.map);
            }
            mem::forget(self);

            IntoIter {
                head,
                tail,
                remaining: len,
                marker: marker::PhantomData,
            }
        }
    }

    /// A view into a single location in a map, which may be vacant or occupied.
    pub enum Entry<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> {
        /// An occupied Entry.
        Occupied(OccupiedEntry<'a, K, V, S>),
        /// A vacant Entry.
        Vacant(VacantEntry<'a, K, V, S>),
    }

    /// A view into a single occupied location in a `LinkedHashMap`.
    pub struct OccupiedEntry<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> {
        entry: *mut Node<K, V>,
        map: *mut LinkedHashMap<K, V, S>,
        marker: marker::PhantomData<&'a K>,
    }

    /// A view into a single empty location in a `LinkedHashMap`.
    pub struct VacantEntry<'a, K: 'a, V: 'a, S: 'a = hash_map::RandomState> {
        key: K,
        map: &'a mut LinkedHashMap<K, V, S>,
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> Entry<'a, K, V, S> {
        /// Returns the entry key
        pub fn key(&self) -> &K {
            match *self {
                Entry::Occupied(ref e) => e.key(),
                Entry::Vacant(ref e) => e.key(),
            }
        }

        /// Ensures a value is in the entry by inserting the default if empty, and returns
        /// a mutable reference to the value in the entry.
        pub fn or_insert(self, default: V) -> &'a mut V {
            match self {
                Entry::Occupied(entry) => entry.into_mut(),
                Entry::Vacant(entry) => entry.insert(default),
            }
        }

        /// Ensures a value is in the entry by inserting the result of the default function if empty,
        /// and returns a mutable reference to the value in the entry.
        pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {
            match self {
                Entry::Occupied(entry) => entry.into_mut(),
                Entry::Vacant(entry) => entry.insert(default()),
            }
        }

        /// Provides in-place mutable access to an occupied entry before any
        /// potential inserts into the map.
        pub fn and_modify<F>(self, f: F) -> Self where 
            F: FnOnce(&mut V),
        {
            match self {
                Entry::Occupied(mut entry) => {
                    f(entry.get_mut());
                    Entry::Occupied(entry)
                }
                Entry::Vacant(entry) => Entry::Vacant(entry),
            }
        }

        /// Ensures a value is in the entry by inserting the default value if empty,
        /// and returns a mutable reference to the value in the entry.
        pub fn or_default(self) -> &'a mut V where 
            V: Default,
        {
            match self {
                Entry::Occupied(entry) => entry.into_mut(),
                Entry::Vacant(entry) => entry.insert(V::default()),
            }
        }
    }

    impl<'a, K: Hash + Eq, V, S: BuildHasher> OccupiedEntry<'a, K, V, S> {
        /// Gets a reference to the entry key
        pub fn key(&self) -> &K {
            unsafe { &(*self.entry).key }
        }

        /// Gets a reference to the value in the entry.
        pub fn get(&self) -> &V {
            unsafe { &(*self.entry).value }
        }

        /// Gets a mutable reference to the value in the entry.
        pub fn get_mut(&mut self) -> &mut V {
            unsafe { &mut (*self.entry).value }
        }

        /// Converts the OccupiedEntry into a mutable reference to the value in the entry
        /// with a lifetime bound to the map itself
        pub fn into_mut(self) -> &'a mut V {
            unsafe { &mut (*self.entry).value }
        }

        /// Sets the value of the entry, and returns the entry's old value
        pub fn insert(&mut self, value: V) -> V {
            unsafe {
                (*self.map).ensure_guard_node();

                let old_val = mem::replace(&mut (*self.entry).value, value);
                let node_ptr: *mut Node<K, V> = self.entry;

                // Existing node, just update LRU position
                (*self.map).detach(node_ptr);
                (*self.map).attach(node_ptr);

                old_val
            }
        }

        /// Takes the value out of the entry, and returns it
        pub fn remove(self) -> V {
            unsafe { (*self.map).remove(&(*self.entry).key) }.unwrap()
        }
    }

    impl<'a, K: 'a + Hash + Eq, V: 'a, S: BuildHasher> VacantEntry<'a, K, V, S> {
        /// Gets a reference to the entry key
        pub fn key(&self) -> &K {
            &self.key
        }

        /// Sets the value of the entry with the VacantEntry's key,
        /// and returns a mutable reference to it
        pub fn insert(self, value: V) -> &'a mut V {
            self.map.ensure_guard_node();

            let node = if self.map.free.is_null() {
                Box::into_raw(Box::new(Node::new(self.key, value)))
            } else {
                // use a recycled box
                unsafe {
                    let free = self.map.free;
                    self.map.free = (*free).next;
                    ptr::write(free, Node::new(self.key, value));
                    free
                }
            };

            let keyref = unsafe { &(*node).key };

            self.map.attach(node);

            let ret = self.map.map.entry(KeyRef { k: keyref }).or_insert(node);
            unsafe { &mut (**ret).value }
        }
    }
}

pub mod nix
{
    use ::
    {
        *,
    };
}

pub mod pest
{
    use ::
    {
        *,
    };
}
// random v0.8
pub mod random
{
    use ::
    {
        *,
    };
    /*
    */
}
// regex v1.11.1
pub mod regex
{
    //! This crate provides routines for searching strings for matches of a [regular expression] (aka "regex").
    use ::
    {
        *,
    };
    /*
    #![no_std]
    #![deny(missing_docs)]
    #![cfg_attr(feature = "pattern", feature(pattern))]
    #![warn(missing_debug_implementations)]
    
    #[cfg(doctest)]
    doc_comment::doctest!("../README.md");
    
    extern crate alloc;
    #[cfg(any(test, feature = "std"))]
    extern crate std;
    
    pub use crate::error::Error;
    
    pub use crate::{builders::string::*, regex::string::*, regexset::string::*};
    */
    mod automata
    {
        //!Exposes a variety of regex engines used by the `regex` crate.
        use ::
        {
            *,
        };
        /*
        #[cfg(any(test, feature = "std"))]
        extern crate std;
        
        #[cfg(feature = "alloc")]
        extern crate alloc;
        
        #[cfg(doctest)]
        doc_comment::doctest!("../README.md");
        
        #[doc(inline)]
        pub use crate::util::primitives::PatternID;
        pub use crate::util::search::*;
        */

        pub mod nfa
        {
            //! Provides non-deterministic finite automata (NFA) and regex engines that use them.
            use ::
            {
                *,
            };
            /*
            */
            pub mod thompson
            {
                /*!
                Defines a Thompson NFA and provides the [`PikeVM`](pikevm::PikeVM) 
                and [`BoundedBacktracker`](backtrack::BoundedBacktracker) regex engines.
                */
                use ::
                {
                    *,
                };
                /*
                #[cfg(feature = "nfa-backtrack")]
                pub mod backtrack;
                mod builder;
                    mod compiler;
                mod error;
                    mod literal_trie;
                    mod map;
                mod nfa;
                #[cfg(feature = "nfa-pikevm")]
                pub mod pikevm;
                    mod range_trie;
                
                pub use self::{
                    builder::Builder,
                    error::BuildError,
                    nfa::{
                        DenseTransitions, PatternIter, SparseTransitions, State, Transition,
                        NFA,
                    },
                };
                    pub use compiler::{Compiler, Config, WhichCaptures};
                */
                pub mod backtrack
                {
                    //! An NFA backed bounded backtracker for executing regex searches with capturing groups.
                    use ::
                    {
                        *,
                    };
                    /*
                    use alloc::{vec, vec::Vec};
                    
                    use crate::{
                        nfa::thompson::{self, BuildError, State, NFA},
                        util::{
                            captures::Captures,
                            empty, iter,
                            prefilter::Prefilter,
                            primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},
                            search::{Anchored, HalfMatch, Input, Match, MatchError, Span},
                        },
                    };
                    */
                    /// Returns the minimum visited capacity for the given haystack.
                    pub fn min_visited_capacity(nfa: &NFA, input: &Input<'_>) -> usize {
                        div_ceil(nfa.states().len() * (input.get_span().len() + 1), 8)
                    }
                    
                    /// The configuration used for building a bounded backtracker.
                    #[derive(Clone, Debug, Default)]
                    pub struct Config {
                        pre: Option<Option<Prefilter>>,
                        visited_capacity: Option<usize>,
                    }
                    
                    impl Config {
                        /// Return a new default regex configuration.
                        pub fn new() -> Config {
                            Config::default()
                        }
                    
                        /// Set a prefilter to be used whenever a start state is entered.
                        pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {
                            self.pre = Some(pre);
                            self
                        }
                    
                        /// Set the visited capacity used to bound backtracking.
                        pub fn visited_capacity(mut self, capacity: usize) -> Config {
                            self.visited_capacity = Some(capacity);
                            self
                        }
                    
                        /// Returns the prefilter set in this configuration, if one at all.
                        pub fn get_prefilter(&self) -> Option<&Prefilter> {
                            self.pre.as_ref().unwrap_or(&None).as_ref()
                        }
                    
                        /// Returns the configured visited capacity.
                        pub fn get_visited_capacity(&self) -> usize {
                            const DEFAULT: usize = 256 * (1 << 10); // 256 KB
                            self.visited_capacity.unwrap_or(DEFAULT)
                        }
                    
                        /// Overwrite the default configuration such that the options in `o` are
                        /// always used.
                        pub(crate) fn overwrite(&self, o: Config) -> Config {
                            Config {
                                pre: o.pre.or_else(|| self.pre.clone()),
                                visited_capacity: o.visited_capacity.or(self.visited_capacity),
                            }
                        }
                    }
                    
                    /// A builder for a bounded backtracker.
                    #[derive(Clone, Debug)]
                    pub struct Builder {
                        config: Config,
                                    thompson: thompson::Compiler,
                    }
                    
                    impl Builder 
                    {
                        /// Create a new BoundedBacktracker builder with its default configuration.
                        pub fn new() -> Builder {
                            Builder {
                                config: Config::default(),
                                                    thompson: thompson::Compiler::new(),
                            }
                        }
                    
                        /// Build a `BoundedBacktracker` from the given pattern.
                        ///
                        /// If there was a problem parsing or compiling the pattern, then an error
                        /// is returned.
                        pub fn build(
                            &self,
                            pattern: &str,
                        ) -> Result<BoundedBacktracker, BuildError> {
                            self.build_many(&[pattern])
                        }
                    
                        /// Build a `BoundedBacktracker` from the given patterns.
                        pub fn build_many<P: AsRef<str>>(
                            &self,
                            patterns: &[P],
                        ) -> Result<BoundedBacktracker, BuildError> {
                            let nfa = self.thompson.build_many(patterns)?;
                            self.build_from_nfa(nfa)
                        }
                    
                        /// Build a `BoundedBacktracker` directly from its NFA.
                        pub fn build_from_nfa(
                            &self,
                            nfa: NFA,
                        ) -> Result<BoundedBacktracker, BuildError> {
                            nfa.look_set_any().available().map_err(BuildError::word)?;
                            Ok(BoundedBacktracker { config: self.config.clone(), nfa })
                        }
                    
                        /// Apply the given `BoundedBacktracker` configuration options to this
                        /// builder.
                        pub fn configure(&mut self, config: Config) -> &mut Builder {
                            self.config = self.config.overwrite(config);
                            self
                        }
                    
                        /// Set the syntax configuration for this builder using
                        /// [`syntax::Config`](crate::util::syntax::Config).
                        pub fn syntax(
                            &mut self,
                            config: crate::util::syntax::Config,
                        ) -> &mut Builder {
                            self.thompson.syntax(config);
                            self
                        }
                    
                        /// Set the Thompson NFA configuration for this builder using
                        /// [`nfa::thompson::Config`](crate::nfa::thompson::Config).
                        pub fn thompson(&mut self, config: thompson::Config) -> &mut Builder {
                            self.thompson.configure(config);
                            self
                        }
                    }
                    
                    /// A backtracking regex engine that bounds its execution to avoid exponential
                    /// blow-up.
                    #[derive(Clone, Debug)]
                    pub struct BoundedBacktracker {
                        config: Config,
                        nfa: NFA,
                    }
                    
                    impl BoundedBacktracker {
                        /// Parse the given regular expression using the default configuration and
                        /// return the corresponding `BoundedBacktracker`.
                        pub fn new(pattern: &str) -> Result<BoundedBacktracker, BuildError> {
                            BoundedBacktracker::builder().build(pattern)
                        }
                    
                        /// Like `new`, but parses multiple patterns into a single "multi regex."
                        /// This similarly uses the default regex configuration.
                        pub fn new_many<P: AsRef<str>>(
                            patterns: &[P],
                        ) -> Result<BoundedBacktracker, BuildError> {
                            BoundedBacktracker::builder().build_many(patterns)
                        }
                        
                        /// This shows how to hand assemble a regular expression via its HIR,
                        /// compile an NFA from it and build a BoundedBacktracker from the NFA.
                        pub fn new_from_nfa(nfa: NFA) -> Result<BoundedBacktracker, BuildError> {
                            BoundedBacktracker::builder().build_from_nfa(nfa)
                        }
                    
                        /// Create a new `BoundedBacktracker` that matches every input.
                        pub fn always_match() -> Result<BoundedBacktracker, BuildError> {
                            let nfa = thompson::NFA::always_match();
                            BoundedBacktracker::new_from_nfa(nfa)
                        }
                    
                        /// Create a new `BoundedBacktracker` that never matches any input.
                        pub fn never_match() -> Result<BoundedBacktracker, BuildError> {
                            let nfa = thompson::NFA::never_match();
                            BoundedBacktracker::new_from_nfa(nfa)
                        }
                    
                        /// Return a default configuration for a `BoundedBacktracker`.
                        pub fn config() -> Config {
                            Config::new()
                        }
                    
                        /// Return a builder for configuring the construction of a
                        /// `BoundedBacktracker`.
                        pub fn builder() -> Builder {
                            Builder::new()
                        }
                    
                        /// Create a new cache for this regex.
                        pub fn create_cache(&self) -> Cache {
                            Cache::new(self)
                        }
                    
                        /// Create a new empty set of capturing groups that is guaranteed to be
                        /// valid for the search APIs on this `BoundedBacktracker`.
                        pub fn create_captures(&self) -> Captures {
                            Captures::all(self.get_nfa().group_info().clone())
                        }
                    
                        /// Reset the given cache such that it can be used for searching with the
                        /// this `BoundedBacktracker` (and only this `BoundedBacktracker`).
                        pub fn reset_cache(&self, cache: &mut Cache) {
                            cache.reset(self);
                        }
                    
                        /// Returns the total number of patterns compiled into this
                        /// `BoundedBacktracker`.
                        pub fn pattern_len(&self) -> usize {
                            self.nfa.pattern_len()
                        }
                    
                        /// Return the config for this `BoundedBacktracker`.
                        #[inline]
                        pub fn get_config(&self) -> &Config {
                            &self.config
                        }
                    
                        /// Returns a reference to the underlying NFA.
                        #[inline]
                        pub fn get_nfa(&self) -> &NFA {
                            &self.nfa
                        }
                    
                        /// Returns the maximum haystack length supported by this backtracker.
                        #[inline]
                        pub fn max_haystack_len(&self) -> usize {
                            let capacity = 8 * self.get_config().get_visited_capacity();
                            let blocks = div_ceil(capacity, Visited::BLOCK_SIZE);
                            let real_capacity = blocks.saturating_mul(Visited::BLOCK_SIZE);
                            (real_capacity / self.nfa.states().len()).saturating_sub(1)
                        }
                    }
                    
                    impl BoundedBacktracker {
                        /// Returns true if and only if this regex matches the given haystack.
                        #[inline]
                        pub fn try_is_match<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                        ) -> Result<bool, MatchError> {
                            let input = input.into().earliest(true);
                            self.try_search_slots(cache, &input, &mut []).map(|pid| pid.is_some())
                        }
                    
                        /// Executes a leftmost forward search and returns a `Match` if one exists.
                        #[inline]
                        pub fn try_find<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                        ) -> Result<Option<Match>, MatchError> {
                            let input = input.into();
                            if self.get_nfa().pattern_len() == 1 {
                                let mut slots = [None, None];
                                let pid = match self.try_search_slots(cache, &input, &mut slots)? {
                                    None => return Ok(None),
                                    Some(pid) => pid,
                                };
                                let start = match slots[0] {
                                    None => return Ok(None),
                                    Some(s) => s.get(),
                                };
                                let end = match slots[1] {
                                    None => return Ok(None),
                                    Some(s) => s.get(),
                                };
                                return Ok(Some(Match::new(pid, Span { start, end })));
                            }
                            let ginfo = self.get_nfa().group_info();
                            let slots_len = ginfo.implicit_slot_len();
                            let mut slots = vec![None; slots_len];
                            let pid = match self.try_search_slots(cache, &input, &mut slots)? {
                                None => return Ok(None),
                                Some(pid) => pid,
                            };
                            let start = match slots[pid.as_usize() * 2] {
                                None => return Ok(None),
                                Some(s) => s.get(),
                            };
                            let end = match slots[pid.as_usize() * 2 + 1] {
                                None => return Ok(None),
                                Some(s) => s.get(),
                            };
                            Ok(Some(Match::new(pid, Span { start, end })))
                        }
                    
                        /// Executes a leftmost forward search and writes the spans of capturing
                        /// groups that participated in a match into the provided [`Captures`]
                        /// value.
                        #[inline]
                        pub fn try_captures<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                            caps: &mut Captures,
                        ) -> Result<(), MatchError> {
                            self.try_search(cache, &input.into(), caps)
                        }
                    
                        /// Returns an iterator over all non-overlapping leftmost matches in the
                        /// given bytes.
                        #[inline]
                        pub fn try_find_iter<'r, 'c, 'h, I: Into<Input<'h>>>(
                            &'r self,
                            cache: &'c mut Cache,
                            input: I,
                        ) -> TryFindMatches<'r, 'c, 'h> {
                            let caps = Captures::matches(self.get_nfa().group_info().clone());
                            let it = iter::Searcher::new(input.into());
                            TryFindMatches { re: self, cache, caps, it }
                        }
                    
                        /// Returns an iterator over all non-overlapping `Captures` values.
                        #[inline] pub fn try_captures_iter<'r, 'c, 'h, I: Into<Input<'h>>>(
                            &'r self,
                            cache: &'c mut Cache,
                            input: I,
                        ) -> TryCapturesMatches<'r, 'c, 'h> {
                            let caps = self.create_captures();
                            let it = iter::Searcher::new(input.into());
                            TryCapturesMatches { re: self, cache, caps, it }
                        }
                    }
                    
                    impl BoundedBacktracker {
                        /// Executes a leftmost forward search and writes the spans of capturing
                        /// groups that participated in a match into the provided [`Captures`]
                        /// value.
                        #[inline] pub fn try_search(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            caps: &mut Captures,
                        ) -> Result<(), MatchError> {
                            caps.set_pattern(None);
                            let pid = self.try_search_slots(cache, input, caps.slots_mut())?;
                            caps.set_pattern(pid);
                            Ok(())
                        }
                        /// Executes a leftmost forward search and writes the spans of capturing
                        /// groups that participated in a match into the provided `slots`, and
                        /// returns the matching pattern ID.
                        #[inline] pub fn try_search_slots(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Result<Option<PatternID>, MatchError>
                        {
                            let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                            if !utf8empty {
                                let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;
                                return Ok(maybe_hm.map(|hm| hm.pattern()));
                            }
                            
                            let min = self.get_nfa().group_info().implicit_slot_len();
                            if slots.len() >= min {
                                let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;
                                return Ok(maybe_hm.map(|hm| hm.pattern()));
                            }
                            if self.get_nfa().pattern_len() == 1 {
                                let mut enough = [None, None];
                                let got = self.try_search_slots_imp(cache, input, &mut enough)?;
                                slots.copy_from_slice(&enough[..slots.len()]);
                                return Ok(got.map(|hm| hm.pattern()));
                            }
                            let mut enough = vec![None; min];
                            let got = self.try_search_slots_imp(cache, input, &mut enough)?;
                            slots.copy_from_slice(&enough[..slots.len()]);
                            Ok(got.map(|hm| hm.pattern()))
                        }
                        /// This is the actual implementation of `try_search_slots_imp` that
                        /// doesn't account for the special case when 1) the NFA has UTF-8 mode
                        /// enabled, 2) the NFA can match the empty string and 3) the caller has
                        /// provided an insufficient number of slots to record match offsets.
                        #[inline(never)]
                        fn try_search_slots_imp(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Result<Option<HalfMatch>, MatchError> {
                            let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                            let hm = match self.search_imp(cache, input, slots)? {
                                None => return Ok(None),
                                Some(hm) if !utf8empty => return Ok(Some(hm)),
                                Some(hm) => hm,
                            };
                            empty::skip_splits_fwd(input, hm, hm.offset(), |input| {
                                Ok(self
                                    .search_imp(cache, input, slots)?
                                    .map(|hm| (hm, hm.offset())))
                            })
                        }
                    
                        /// The implementation of standard leftmost backtracking search.
                        fn search_imp(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Result<Option<HalfMatch>, MatchError> {
                            for slot in slots.iter_mut() {
                                *slot = None;
                            }
                            cache.setup_search(&self, input)?;
                            if input.is_done() {
                                return Ok(None);
                            }
                            let (anchored, start_id) = match input.get_anchored() {
                                Anchored::No => (
                                    self.nfa.is_always_start_anchored(),
                                    self.nfa.start_anchored(),
                                ),
                                Anchored::Yes => (true, self.nfa.start_anchored()),
                                Anchored::Pattern(pid) => match self.nfa.start_pattern(pid) {
                                    None => return Ok(None),
                                    Some(sid) => (true, sid),
                                },
                            };
                            if anchored {
                                let at = input.start();
                                return Ok(self.backtrack(cache, input, at, start_id, slots));
                            }
                            let pre = self.get_config().get_prefilter();
                            let mut at = input.start();
                            while at <= input.end() {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => break,
                                        Some(ref span) => at = span.start,
                                    }
                                }
                                if let Some(hm) = self.backtrack(cache, input, at, start_id, slots)
                                {
                                    return Ok(Some(hm));
                                }
                                at += 1;
                            }
                            Ok(None)
                        }
                    
                        /// Look for a match starting at `at` in `input` and write the matching
                        /// pattern ID and group spans to `caps`.
                        fn backtrack
                        (
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            at: usize,
                            start_id: StateID,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Option<HalfMatch> {
                            cache.stack.push(Frame::Step { sid: start_id, at });
                            while let Some(frame) = cache.stack.pop() {
                                match frame {
                                    Frame::Step { sid, at } => {
                                        if let Some(hm) = self.step(cache, input, sid, at, slots) {
                                            return Some(hm);
                                        }
                                    }
                                    Frame::RestoreCapture { slot, offset } => {
                                        slots[slot] = offset;
                                    }
                                }
                            }
                            None
                        }
                        /// Execute a "step" in the backtracing algorithm.
                        fn step(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            mut sid: StateID,
                            mut at: usize,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Option<HalfMatch> {
                            loop {
                                if !cache.visited.insert(sid, at - input.start()) {
                                    return None;
                                }
                                match *self.nfa.state(sid) {
                                    State::ByteRange { ref trans } => {
                                        if at >= input.end() {
                                            return None;
                                        }
                                        if !trans.matches(input.haystack(), at) {
                                            return None;
                                        }
                                        sid = trans.next;
                                        at += 1;
                                    }
                                    State::Sparse(ref sparse) => {
                                        if at >= input.end() {
                                            return None;
                                        }
                                        sid = sparse.matches(input.haystack(), at)?;
                                        at += 1;
                                    }
                                    State::Dense(ref dense) => {
                                        if at >= input.end() {
                                            return None;
                                        }
                                        sid = dense.matches(input.haystack(), at)?;
                                        at += 1;
                                    }
                                    State::Look { look, next } => {
                                        if !self.nfa.look_matcher().matches_inline(
                                            look,
                                            input.haystack(),
                                            at,
                                        ) {
                                            return None;
                                        }
                                        sid = next;
                                    }
                                    State::Union { ref alternates } => {
                                        sid = match alternates.get(0) {
                                            None => return None,
                                            Some(&sid) => sid,
                                        };
                                        cache.stack.extend(
                                            alternates[1..]
                                                .iter()
                                                .copied()
                                                .rev()
                                                .map(|sid| Frame::Step { sid, at }),
                                        );
                                    }
                                    State::BinaryUnion { alt1, alt2 } => {
                                        sid = alt1;
                                        cache.stack.push(Frame::Step { sid: alt2, at });
                                    }
                                    State::Capture { next, slot, .. } => {
                                        if slot.as_usize() < slots.len() {
                                            cache.stack.push(Frame::RestoreCapture {
                                                slot,
                                                offset: slots[slot],
                                            });
                                            slots[slot] = NonMaxUsize::new(at);
                                        }
                                        sid = next;
                                    }
                                    State::Fail => return None,
                                    State::Match { pattern_id } => {
                                        return Some(HalfMatch::new(pattern_id, at));
                                    }
                                }
                            }
                        }
                    }
                    
                    /// An iterator over all non-overlapping matches for a fallible search.
                    #[derive(Debug)]
                    pub struct TryFindMatches<'r, 'c, 'h> {
                        re: &'r BoundedBacktracker,
                        cache: &'c mut Cache,
                        caps: Captures,
                        it: iter::Searcher<'h>,
                    }
                    
                    impl<'r, 'c, 'h> Iterator for TryFindMatches<'r, 'c, 'h> {
                        type Item = Result<Match, MatchError>;
                    
                        #[inline]
                        fn next(&mut self) -> Option<Result<Match, MatchError>> {
                            // Splitting 'self' apart seems necessary to appease borrowck.
                            let TryFindMatches { re, ref mut cache, ref mut caps, ref mut it } =
                                *self;
                            it.try_advance(|input| {
                                re.try_search(cache, input, caps)?;
                                Ok(caps.get_match())
                            })
                            .transpose()
                        }
                    }
                    
                    /// An iterator over all non-overlapping leftmost matches, with their capturing
                    /// groups, for a fallible search.
                    #[derive(Debug)]
                    pub struct TryCapturesMatches<'r, 'c, 'h> {
                        re: &'r BoundedBacktracker,
                        cache: &'c mut Cache,
                        caps: Captures,
                        it: iter::Searcher<'h>,
                    }
                    
                    impl<'r, 'c, 'h> Iterator for TryCapturesMatches<'r, 'c, 'h> {
                        type Item = Result<Captures, MatchError>;
                    
                        #[inline]
                        fn next(&mut self) -> Option<Result<Captures, MatchError>> {
                            // Splitting 'self' apart seems necessary to appease borrowck.
                            let TryCapturesMatches { re, ref mut cache, ref mut caps, ref mut it } =
                                *self;
                            let _ = it
                                .try_advance(|input| {
                                    re.try_search(cache, input, caps)?;
                                    Ok(caps.get_match())
                                })
                                .transpose()?;
                            if caps.is_match() {
                                Some(Ok(caps.clone()))
                            } else {
                                None
                            }
                        }
                    }
                    /// A cache represents mutable state that a [`BoundedBacktracker`] requires
                    /// during a search.
                    #[derive(Clone, Debug)]
                    pub struct Cache {
                        /// Stack used on the heap for doing backtracking instead of the
                        /// traditional recursive approach.
                        stack: Vec<Frame>,
                        /// The set of (StateID, HaystackOffset) pairs that have been visited
                        /// by the backtracker within a single search.
                        visited: Visited,
                    }
                    
                    impl Cache
                    {
                        /// Create a new [`BoundedBacktracker`] cache.
                        pub fn new(re: &BoundedBacktracker) -> Cache {
                            Cache { stack: vec![], visited: Visited::new(re) }
                        }
                        /// Reset this cache such that it can be used for searching with different
                        /// [`BoundedBacktracker`].
                        pub fn reset(&mut self, re: &BoundedBacktracker) { self.visited.reset(re); }
                        /// Returns the heap memory usage, in bytes, of this cache.
                        pub fn memory_usage(&self) -> usize
                        {
                            self.stack.len() * ::mem::size_of::<Frame>()
                                + self.visited.memory_usage()
                        }
                        /// Clears this cache. 
                        fn setup_search(
                            &mut self,
                            re: &BoundedBacktracker,
                            input: &Input<'_>,
                        ) -> Result<(), MatchError> {
                            self.stack.clear();
                            self.visited.setup_search(re, input)?;
                            Ok(())
                        }
                    }
                    /// Represents a stack frame on the heap while doing backtracking.
                    #[derive(Clone, Debug)]
                    enum Frame
                    {
                        /// Look for a match starting at `sid` and the given position in the
                        /// haystack.
                        Step { sid: StateID, at: usize },
                        /// Reset the given `slot` to the given `offset` (which might be `None`).
                        RestoreCapture { slot: SmallIndex, offset: Option<NonMaxUsize> },
                    }
                    /// A bitset that keeps track of whether a particular (StateID, offset) has
                    /// been considered during backtracking.
                    #[derive(Clone, Debug)]
                    struct Visited {
                        /// The actual underlying bitset.
                        bitset: Vec<usize>,
                        /// The stride represents one plus length of the haystack we're searching
                        /// (as described above).
                        stride: usize,
                    }
                    
                    impl Visited
                    {
                        /// The size of each block, in bits.
                        const BLOCK_SIZE: usize = 8 * ::mem::size_of::<usize>();
                        /// Create a new visited set for the given backtracker.
                        fn new(re: &BoundedBacktracker) -> Visited
                        {
                            let mut visited = Visited { bitset: vec![], stride: 0 };
                            visited.reset(re);
                            visited
                        }
                        /// Insert the given (StateID, offset) pair into this set. 
                        fn insert(&mut self, sid: StateID, at: usize) -> bool
                        {
                            let table_index = sid.as_usize() * self.stride + at;
                            let block_index = table_index / Visited::BLOCK_SIZE;
                            let bit = table_index % Visited::BLOCK_SIZE;
                            let block_with_bit = 1 << bit;

                            if self.bitset[block_index] & block_with_bit != 0 { return false; }
                            
                            self.bitset[block_index] |= block_with_bit;
                            true
                        }
                        /// Reset this visited set to work with the given bounded backtracker.
                        fn reset(&mut self, _: &BoundedBacktracker) { self.bitset.truncate(0); }
                        /// Setup this visited set to work for a search using the given NFA
                        /// and input configuration.
                        fn setup_search
                        (
                            &mut self,
                            re: &BoundedBacktracker,
                            input: &Input<'_>,
                        ) -> Result<(), MatchError>
                        {
                            let haylen = input.get_span().len();
                            let err = || MatchError::haystack_too_long(haylen);
                            
                            self.stride = haylen + 1;
                            let needed_capacity =
                            match re.get_nfa().states().len().checked_mul(self.stride)
                            {
                                None => return Err(err()),
                                Some(capacity) => capacity,
                            };
                                
                            let max_capacity = 8 * re.get_config().get_visited_capacity();

                            if needed_capacity > max_capacity {  return Err(err()); }

                            let needed_blocks = div_ceil(needed_capacity, Visited::BLOCK_SIZE);

                            self.bitset.truncate(needed_blocks);

                            for block in self.bitset.iter_mut()
                            {
                                *block = 0;
                            }

                            if needed_blocks > self.bitset.len() { self.bitset.resize(needed_blocks, 0); }
                            
                            Ok(())
                        }
                        /// Return the heap memory usage, in bytes, of this visited set.
                        fn memory_usage(&self) -> usize
                        { self.bitset.len() * ::mem::size_of::<usize>() }
                    }
                    /// Integer division, but rounds up instead of down.
                    fn div_ceil(lhs: usize, rhs: usize) -> usize
                    {
                        if lhs % rhs == 0 {
                            lhs / rhs
                        } else {
                            (lhs / rhs) + 1
                        }
                    }
                }
                
                pub mod builder
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use core::mem;
                    
                    use alloc::{sync::Arc, vec, vec::Vec};
                    
                    use crate::{
                        nfa::thompson::{
                            error::BuildError,
                            nfa::{self, SparseTransitions, Transition, NFA},
                        },
                        util::{
                            look::{Look, LookMatcher},
                            primitives::{IteratorIndexExt, PatternID, SmallIndex, StateID},
                        },
                    };
                    */
                    /// An intermediate NFA state used during construction.
                    #[derive(Clone, Debug, Eq, PartialEq)]
                    enum State {
                        /// An empty state whose only purpose is to forward the automaton to
                        /// another state via an unconditional epsilon transition.
                        Empty {
                            /// The next state that this state should transition to.
                            next: StateID,
                        },
                        /// A state that only transitions to another state if the current input
                        /// byte is in a particular range of bytes.
                        ByteRange { trans: Transition },
                        /// A state with possibly many transitions, represented in a sparse
                        /// fashion.
                        Sparse { transitions: Vec<Transition> },
                        /// A conditional epsilon transition satisfied via some sort of
                        /// look-around.
                        Look { look: Look, next: StateID },
                        /// An empty state that records the start of a capture location.
                        CaptureStart {
                            /// The ID of the pattern that this capture was defined.
                            pattern_id: PatternID,
                            /// The capture group index that this capture state corresponds to.
                            group_index: SmallIndex,
                            /// The next state that this state should transition to.
                            next: StateID,
                        },
                        /// An empty state that records the end of a capture location.
                        CaptureEnd {
                            /// The ID of the pattern that this capture was defined.
                            pattern_id: PatternID,
                            /// The capture group index that this capture state corresponds to.
                            group_index: SmallIndex,
                            /// The next state that this state should transition to.
                            next: StateID,
                        },
                        /// An alternation such that there exists an epsilon transition to all
                        /// states in `alternates`, where matches found via earlier transitions
                        /// are preferred over later transitions.
                        Union { alternates: Vec<StateID> },
                        /// An alternation such that there exists an epsilon transition to all
                        /// states in `alternates`, where matches found via later transitions are
                        /// preferred over earlier transitions.
                        UnionReverse { alternates: Vec<StateID> },
                        /// A state that cannot be transitioned out of.
                        Fail,
                        /// A match state.
                        Match { pattern_id: PatternID },
                    }
                    
                    impl State {
                        /// If this state is an unconditional epsilon transition, then this returns
                        /// the target of the transition.
                        fn goto(&self) -> Option<StateID> {
                            match *self {
                                State::Empty { next } => Some(next),
                                State::Union { ref alternates } if alternates.len() == 1 => {
                                    Some(alternates[0])
                                }
                                State::UnionReverse { ref alternates }
                                    if alternates.len() == 1 =>
                                {
                                    Some(alternates[0])
                                }
                                _ => None,
                            }
                        }
                    
                        /// Returns the heap memory usage, in bytes, of this state.
                        fn memory_usage(&self) -> usize {
                            match *self {
                                State::Empty { .. }
                                | State::ByteRange { .. }
                                | State::Look { .. }
                                | State::CaptureStart { .. }
                                | State::CaptureEnd { .. }
                                | State::Fail
                                | State::Match { .. } => 0,
                                State::Sparse { ref transitions } => {
                                    transitions.len() * mem::size_of::<Transition>()
                                }
                                State::Union { ref alternates } => {
                                    alternates.len() * mem::size_of::<StateID>()
                                }
                                State::UnionReverse { ref alternates } => {
                                    alternates.len() * mem::size_of::<StateID>()
                                }
                            }
                        }
                    }
                    
                    /// An abstraction for building Thompson NFAs by hand.
                    #[derive(Clone, Debug, Default)]
                    pub struct Builder {
                        /// The ID of the pattern that we're currently building.
                        pattern_id: Option<PatternID>,
                        /// A sequence of intermediate NFA states.
                        states: Vec<State>,
                        /// The starting states for each individual pattern.
                        start_pattern: Vec<StateID>,
                        /// A map from pattern ID to capture group index to name.
                        captures: Vec<Vec<Option<Arc<str>>>>,
                        /// The combined memory used by each of the 'State's in 'states'.
                        memory_states: usize,
                        /// Whether this NFA only matches UTF-8 and whether regex engines using
                        /// this NFA for searching should report empty matches that split a
                        /// codepoint.
                        utf8: bool,
                        /// Whether this NFA should be matched in reverse or not.
                        reverse: bool,
                        /// The matcher to use for look-around assertions.
                        look_matcher: LookMatcher,
                        /// A size limit to respect when building an NFA.
                        size_limit: Option<usize>,
                    }
                    
                    impl Builder {
                        /// Create a new builder for hand-assembling NFAs.
                        pub fn new() -> Builder {
                            Builder::default()
                        }
                    
                        /// Clear this builder.
                        pub fn clear(&mut self) {
                            self.pattern_id = None;
                            self.states.clear();
                            self.start_pattern.clear();
                            self.captures.clear();
                            self.memory_states = 0;
                        }
                    
                        /// Assemble a [`NFA`] from the states added so far.
                        pub fn build(
                            &self,
                            start_anchored: StateID,
                            start_unanchored: StateID,
                        ) -> Result<NFA, BuildError> {
                            assert!(self.pattern_id.is_none(), "must call 'finish_pattern' first");
                            debug!(
                                "intermediate NFA compilation via builder is complete, \
                                 intermediate NFA size: {} states, {} bytes on heap",
                                self.states.len(),
                                self.memory_usage(),
                            );
                    
                            let mut nfa = nfa::Inner::default();
                            nfa.set_utf8(self.utf8);
                            nfa.set_reverse(self.reverse);
                            nfa.set_look_matcher(self.look_matcher.clone());
                            let mut empties = vec![];
                            let mut remap = vec![];
                            remap.resize(self.states.len(), StateID::ZERO);
                    
                            nfa.set_starts(start_anchored, start_unanchored, &self.start_pattern);
                            nfa.set_captures(&self.captures).map_err(BuildError::captures)?;
                            
                            for (sid, state) in self.states.iter().with_state_ids() {
                                match *state {
                                    State::Empty { next } => {
                                        empties.push((sid, next));
                                    }
                                    State::ByteRange { trans } => {
                                        remap[sid] = nfa.add(nfa::State::ByteRange { trans });
                                    }
                                    State::Sparse { ref transitions } => {
                                        remap[sid] = match transitions.len() {
                                            0 => nfa.add(nfa::State::Fail),
                                            1 => nfa.add(nfa::State::ByteRange {
                                                trans: transitions[0],
                                            }),
                                            _ => {
                                                let transitions =
                                                    transitions.to_vec().into_boxed_slice();
                                                let sparse = SparseTransitions { transitions };
                                                nfa.add(nfa::State::Sparse(sparse))
                                            }
                                        }
                                    }
                                    State::Look { look, next } => {
                                        remap[sid] = nfa.add(nfa::State::Look { look, next });
                                    }
                                    State::CaptureStart { pattern_id, group_index, next } => {
                                        let slot = nfa
                                            .group_info()
                                            .slot(pattern_id, group_index.as_usize())
                                            .expect("invalid capture index");
                                        let slot =
                                            SmallIndex::new(slot).expect("a small enough slot");
                                        remap[sid] = nfa.add(nfa::State::Capture {
                                            next,
                                            pattern_id,
                                            group_index,
                                            slot,
                                        });
                                    }
                                    State::CaptureEnd { pattern_id, group_index, next } => {
                                        let slot = nfa
                                            .group_info()
                                            .slot(pattern_id, group_index.as_usize())
                                            .expect("invalid capture index")
                                            .checked_add(1)
                                            .unwrap();
                                        let slot =
                                            SmallIndex::new(slot).expect("a small enough slot");
                                        remap[sid] = nfa.add(nfa::State::Capture {
                                            next,
                                            pattern_id,
                                            group_index,
                                            slot,
                                        });
                                    }
                                    State::Union { ref alternates } => {
                                        if alternates.is_empty() {
                                            remap[sid] = nfa.add(nfa::State::Fail);
                                        } else if alternates.len() == 1 {
                                            empties.push((sid, alternates[0]));
                                            remap[sid] = alternates[0];
                                        } else if alternates.len() == 2 {
                                            remap[sid] = nfa.add(nfa::State::BinaryUnion {
                                                alt1: alternates[0],
                                                alt2: alternates[1],
                                            });
                                        } else {
                                            let alternates =
                                                alternates.to_vec().into_boxed_slice();
                                            remap[sid] = nfa.add(nfa::State::Union { alternates });
                                        }
                                    }
                                    State::UnionReverse { ref alternates } => {
                                        if alternates.is_empty() {
                                            remap[sid] = nfa.add(nfa::State::Fail);
                                        } else if alternates.len() == 1 {
                                            empties.push((sid, alternates[0]));
                                            remap[sid] = alternates[0];
                                        } else if alternates.len() == 2 {
                                            remap[sid] = nfa.add(nfa::State::BinaryUnion {
                                                alt1: alternates[1],
                                                alt2: alternates[0],
                                            });
                                        } else {
                                            let mut alternates =
                                                alternates.to_vec().into_boxed_slice();
                                            alternates.reverse();
                                            remap[sid] = nfa.add(nfa::State::Union { alternates });
                                        }
                                    }
                                    State::Fail => {
                                        remap[sid] = nfa.add(nfa::State::Fail);
                                    }
                                    State::Match { pattern_id } => {
                                        remap[sid] = nfa.add(nfa::State::Match { pattern_id });
                                    }
                                }
                            }
                            
                            let mut remapped = vec![false; self.states.len()];
                            for &(empty_id, empty_next) in empties.iter() {
                                if remapped[empty_id] {
                                    continue;
                                }
                                
                                let mut new_next = empty_next;
                                while let Some(next) = self.states[new_next].goto() {
                                    new_next = next;
                                }
                                remap[empty_id] = remap[new_next];
                                remapped[empty_id] = true;
                                
                                let mut next2 = empty_next;
                                while let Some(next) = self.states[next2].goto() {
                                    remap[next2] = remap[new_next];
                                    remapped[next2] = true;
                                    next2 = next;
                                }
                            }
                            
                            nfa.remap(&remap);
                            let final_nfa = nfa.into_nfa();
                            debug!(
                                "NFA compilation via builder complete, \
                                 final NFA size: {} states, {} bytes on heap, \
                                 has empty? {:?}, utf8? {:?}",
                                final_nfa.states().len(),
                                final_nfa.memory_usage(),
                                final_nfa.has_empty(),
                                final_nfa.is_utf8(),
                            );
                            Ok(final_nfa)
                        }
                    
                        /// Start the assembly of a pattern in this NFA.
                        pub fn start_pattern(&mut self) -> Result<PatternID, BuildError> {
                            assert!(self.pattern_id.is_none(), "must call 'finish_pattern' first");
                    
                            let proposed = self.start_pattern.len();
                            let pid = PatternID::new(proposed)
                                .map_err(|_| BuildError::too_many_patterns(proposed))?;
                            self.pattern_id = Some(pid);
                            self.start_pattern.push(StateID::ZERO);
                            Ok(pid)
                        }
                    
                        /// Finish the assembly of a pattern in this NFA.
                        pub fn finish_pattern(
                            &mut self,
                            start_id: StateID,
                        ) -> Result<PatternID, BuildError> {
                            let pid = self.current_pattern_id();
                            self.start_pattern[pid] = start_id;
                            self.pattern_id = None;
                            Ok(pid)
                        }
                    
                        /// Returns the pattern identifier of the current pattern.
                        pub fn current_pattern_id(&self) -> PatternID {
                            self.pattern_id.expect("must call 'start_pattern' first")
                        }
                    
                        /// Returns the number of patterns added to this builder so far.
                        pub fn pattern_len(&self) -> usize {
                            self.start_pattern.len()
                        }
                    
                        /// Add an "empty" NFA state.
                        pub fn add_empty(&mut self) -> Result<StateID, BuildError> {
                            self.add(State::Empty { next: StateID::ZERO })
                        }
                    
                        /// Add a "union" NFA state.
                        pub fn add_union(
                            &mut self,
                            alternates: Vec<StateID>,
                        ) -> Result<StateID, BuildError> {
                            self.add(State::Union { alternates })
                        }
                    
                        /// Add a "reverse union" NFA state.
                        pub fn add_union_reverse(
                            &mut self,
                            alternates: Vec<StateID>,
                        ) -> Result<StateID, BuildError> {
                            self.add(State::UnionReverse { alternates })
                        }
                    
                        /// Add a "range" NFA state.
                        pub fn add_range(
                            &mut self,
                            trans: Transition,
                        ) -> Result<StateID, BuildError> {
                            self.add(State::ByteRange { trans })
                        }
                    
                        /// Add a "sparse" NFA state.
                        pub fn add_sparse(
                            &mut self,
                            transitions: Vec<Transition>,
                        ) -> Result<StateID, BuildError> {
                            self.add(State::Sparse { transitions })
                        }
                    
                        /// Add a "look" NFA state.
                        pub fn add_look(
                            &mut self,
                            next: StateID,
                            look: Look,
                        ) -> Result<StateID, BuildError> {
                            self.add(State::Look { look, next })
                        }
                    
                        /// Add a "start capture" NFA state.
                        pub fn add_capture_start(
                            &mut self,
                            next: StateID,
                            group_index: u32,
                            name: Option<Arc<str>>,
                        ) -> Result<StateID, BuildError> {
                            let pid = self.current_pattern_id();
                            let group_index = match SmallIndex::try_from(group_index) {
                                Err(_) => {
                                    return Err(BuildError::invalid_capture_index(group_index))
                                }
                                Ok(group_index) => group_index,
                            };
                            
                            if pid.as_usize() >= self.captures.len() {
                                for _ in 0..=(pid.as_usize() - self.captures.len()) {
                                    self.captures.push(vec![]);
                                }
                            }
                            
                            if group_index.as_usize() >= self.captures[pid].len() {
                                for _ in 0..(group_index.as_usize() - self.captures[pid].len()) {
                                    self.captures[pid].push(None);
                                }
                                self.captures[pid].push(name);
                            }
                            self.add(State::CaptureStart { pattern_id: pid, group_index, next })
                        }
                    
                        /// Add a "end capture" NFA state.
                        pub fn add_capture_end(
                            &mut self,
                            next: StateID,
                            group_index: u32,
                        ) -> Result<StateID, BuildError> {
                            let pid = self.current_pattern_id();
                            let group_index = match SmallIndex::try_from(group_index) {
                                Err(_) => {
                                    return Err(BuildError::invalid_capture_index(group_index))
                                }
                                Ok(group_index) => group_index,
                            };
                            self.add(State::CaptureEnd { pattern_id: pid, group_index, next })
                        }
                    
                        /// Adds a "fail" NFA state.
                        pub fn add_fail(&mut self) -> Result<StateID, BuildError> {
                            self.add(State::Fail)
                        }
                    
                        /// Adds a "match" NFA state.
                        pub fn add_match(&mut self) -> Result<StateID, BuildError> {
                            let pattern_id = self.current_pattern_id();
                            let sid = self.add(State::Match { pattern_id })?;
                            Ok(sid)
                        }
                    
                        /// The common implementation of "add a state."
                        fn add(&mut self, state: State) -> Result<StateID, BuildError> {
                            let id = StateID::new(self.states.len())
                                .map_err(|_| BuildError::too_many_states(self.states.len()))?;
                            self.memory_states += state.memory_usage();
                            self.states.push(state);
                            self.check_size_limit()?;
                            Ok(id)
                        }
                    
                        /// Add a transition from one state to another.
                        pub fn patch(
                            &mut self,
                            from: StateID,
                            to: StateID,
                        ) -> Result<(), BuildError> {
                            let old_memory_states = self.memory_states;
                            match self.states[from] {
                                State::Empty { ref mut next } => {
                                    *next = to;
                                }
                                State::ByteRange { ref mut trans } => {
                                    trans.next = to;
                                }
                                State::Sparse { .. } => {
                                    panic!("cannot patch from a sparse NFA state")
                                }
                                State::Look { ref mut next, .. } => {
                                    *next = to;
                                }
                                State::Union { ref mut alternates } => {
                                    alternates.push(to);
                                    self.memory_states += mem::size_of::<StateID>();
                                }
                                State::UnionReverse { ref mut alternates } => {
                                    alternates.push(to);
                                    self.memory_states += mem::size_of::<StateID>();
                                }
                                State::CaptureStart { ref mut next, .. } => {
                                    *next = to;
                                }
                                State::CaptureEnd { ref mut next, .. } => {
                                    *next = to;
                                }
                                State::Fail => {}
                                State::Match { .. } => {}
                            }
                            if old_memory_states != self.memory_states {
                                self.check_size_limit()?;
                            }
                            Ok(())
                        }
                    
                        /// Set whether the NFA produced by this builder should only match UTF-8.
                        pub fn set_utf8(&mut self, yes: bool) {
                            self.utf8 = yes;
                        }
                    
                        /// Returns whether UTF-8 mode is enabled for this builder.
                        pub fn get_utf8(&self) -> bool {
                            self.utf8
                        }
                    
                        /// Sets whether the NFA produced by this builder should be matched in
                        /// reverse or not.
                        pub fn set_reverse(&mut self, yes: bool) {
                            self.reverse = yes;
                        }
                    
                        /// Returns whether reverse mode is enabled for this builder.
                        pub fn get_reverse(&self) -> bool {
                            self.reverse
                        }
                    
                        /// Sets the look-around matcher that should be used for the resulting NFA.
                        pub fn set_look_matcher(&mut self, m: LookMatcher) {
                            self.look_matcher = m;
                        }
                    
                        /// Returns the look-around matcher used for this builder.
                        pub fn get_look_matcher(&self) -> &LookMatcher {
                            &self.look_matcher
                        }
                    
                        /// Set the size limit on this builder.
                        pub fn set_size_limit(
                            &mut self,
                            limit: Option<usize>,
                        ) -> Result<(), BuildError> {
                            self.size_limit = limit;
                            self.check_size_limit()
                        }
                    
                        /// Return the currently configured size limit.
                        pub fn get_size_limit(&self) -> Option<usize> {
                            self.size_limit
                        }
                    
                        /// Returns the heap memory usage, in bytes, used by the NFA states added
                        /// so far.
                        pub fn memory_usage(&self) -> usize {
                            self.states.len() * mem::size_of::<State>() + self.memory_states
                        }
                    
                        fn check_size_limit(&self) -> Result<(), BuildError> {
                            if let Some(limit) = self.size_limit {
                                if self.memory_usage() > limit {
                                    return Err(BuildError::exceeded_size_limit(limit));
                                }
                            }
                            Ok(())
                        }
                    }
                }
                
                pub mod compiler
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use core::{borrow::Borrow, cell::RefCell};
                    
                    use alloc::{sync::Arc, vec, vec::Vec};
                    
                    use regex_syntax::{
                        hir::{self, Hir},
                        utf8::{Utf8Range, Utf8Sequences},
                        ParserBuilder,
                    };
                    
                    use crate::{
                        nfa::thompson::{
                            builder::Builder,
                            error::BuildError,
                            literal_trie::LiteralTrie,
                            map::{Utf8BoundedMap, Utf8SuffixKey, Utf8SuffixMap},
                            nfa::{Transition, NFA},
                            range_trie::RangeTrie,
                        },
                        util::{
                            look::{Look, LookMatcher},
                            primitives::{PatternID, StateID},
                        },
                    };
                    */
                    
                    /// The configuration used for a Thompson NFA compiler.
                    #[derive(Clone, Debug, Default)]
                    pub struct Config {
                        utf8: Option<bool>,
                        reverse: Option<bool>,
                        nfa_size_limit: Option<Option<usize>>,
                        shrink: Option<bool>,
                        which_captures: Option<WhichCaptures>,
                        look_matcher: Option<LookMatcher>,
                        #[cfg(test)]
                        unanchored_prefix: Option<bool>,
                    }
                    
                    impl Config {
                        /// Return a new default Thompson NFA compiler configuration.
                        pub fn new() -> Config {
                            Config::default()
                        }
                    
                        /// Whether to enable UTF-8 mode during search or not.
                        ///
                        /// A regex engine is said to be in UTF-8 mode when it guarantees that
                        /// all matches returned by it have spans consisting of only valid UTF-8.
                        /// That is, it is impossible for a match span to be returned that
                        /// contains any invalid UTF-8.
                        ///
                        /// UTF-8 mode generally consists of two things:
                        ///
                        /// 1. Whether the NFA's states are constructed such that all paths to a
                        /// match state that consume at least one byte always correspond to valid
                        /// UTF-8.
                        /// 2. Whether all paths to a match state that do _not_ consume any bytes
                        /// should always correspond to valid UTF-8 boundaries.
                        ///
                        /// (1) is a guarantee made by whoever constructs the NFA.
                        /// If you're parsing a regex from its concrete syntax, then
                        /// [`syntax::Config::utf8`](crate::util::syntax::Config::utf8) can make
                        /// this guarantee for you. It does it by returning an error if the regex
                        /// pattern could every report a non-empty match span that contains invalid
                        /// UTF-8. So long as `syntax::Config::utf8` mode is enabled and your regex
                        /// successfully parses, then you're guaranteed that the corresponding NFA
                        /// will only ever report non-empty match spans containing valid UTF-8.
                        ///
                        /// (2) is a trickier guarantee because it cannot be enforced by the NFA
                        /// state graph itself. Consider, for example, the regex `a*`. It matches
                        /// the empty strings in `` at positions `0`, `1`, `2` and `3`, where
                        /// positions `1` and `2` occur within the UTF-8 encoding of a codepoint,
                        /// and thus correspond to invalid UTF-8 boundaries. Therefore, this
                        /// guarantee must be made at a higher level than the NFA state graph
                        /// itself. This crate deals with this case in each regex engine. Namely,
                        /// when a zero-width match that splits a codepoint is found and UTF-8
                        /// mode enabled, then it is ignored and the engine moves on looking for
                        /// the next match.
                        ///
                        /// Thus, UTF-8 mode is both a promise that the NFA built only reports
                        /// non-empty matches that are valid UTF-8, and an *instruction* to regex
                        /// engines that empty matches that split codepoints should be banned.
                        ///
                        /// Because UTF-8 mode is fundamentally about avoiding invalid UTF-8 spans,
                        /// it only makes sense to enable this option when you *know* your haystack
                        /// is valid UTF-8. (For example, a `&str`.) Enabling UTF-8 mode and
                        /// searching a haystack that contains invalid UTF-8 leads to **unspecified
                        /// behavior**.
                        ///
                        /// Therefore, it may make sense to enable `syntax::Config::utf8` while
                        /// simultaneously *disabling* this option. That would ensure all non-empty
                        /// match spans are valid UTF-8, but that empty match spans may still split
                        /// a codepoint or match at other places that aren't valid UTF-8.
                        ///
                        /// In general, this mode is only relevant if your regex can match the
                        /// empty string. Most regexes don't.
                        ///
                        /// This is enabled by default.
                        ///
                        /// # Example
                        ///
                        /// This example shows how UTF-8 mode can impact the match spans that may
                        /// be reported in certain cases.
                        ///
                        /// ```
                        /// use regex_automata::{
                        ///     nfa::thompson::{self, pikevm::PikeVM},
                        ///     Match, Input,
                        /// };
                        ///
                        /// let re = PikeVM::new("")?;
                        /// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());
                        ///
                        /// // UTF-8 mode is enabled by default.
                        /// let mut input = Input::new("");
                        /// re.search(&mut cache, &input, &mut caps);
                        /// assert_eq!(Some(Match::must(0, 0..0)), caps.get_match());
                        ///
                        /// // Even though an empty regex matches at 1..1, our next match is
                        /// // 3..3 because 1..1 and 2..2 split the snowman codepoint (which is
                        /// // three bytes long).
                        /// input.set_start(1);
                        /// re.search(&mut cache, &input, &mut caps);
                        /// assert_eq!(Some(Match::must(0, 3..3)), caps.get_match());
                        ///
                        /// // But if we disable UTF-8, then we'll get matches at 1..1 and 2..2:
                        /// let re = PikeVM::builder()
                        ///     .thompson(thompson::Config::new().utf8(false))
                        ///     .build("")?;
                        /// re.search(&mut cache, &input, &mut caps);
                        /// assert_eq!(Some(Match::must(0, 1..1)), caps.get_match());
                        ///
                        /// input.set_start(2);
                        /// re.search(&mut cache, &input, &mut caps);
                        /// assert_eq!(Some(Match::must(0, 2..2)), caps.get_match());
                        ///
                        /// input.set_start(3);
                        /// re.search(&mut cache, &input, &mut caps);
                        /// assert_eq!(Some(Match::must(0, 3..3)), caps.get_match());
                        ///
                        /// input.set_start(4);
                        /// re.search(&mut cache, &input, &mut caps);
                        /// assert_eq!(None, caps.get_match());
                        ///
                        /// # Ok::<(), Box<dyn std::error::Error>>(())
                        /// ```
                        pub fn utf8(mut self, yes: bool) -> Config {
                            self.utf8 = Some(yes);
                            self
                        }
                    
                        /// Reverse the NFA.
                        ///
                        /// A NFA reversal is performed by reversing all of the concatenated
                        /// sub-expressions in the original pattern, recursively. (Look around
                        /// operators are also inverted.) The resulting NFA can be used to match
                        /// the pattern starting from the end of a string instead of the beginning
                        /// of a string.
                        ///
                        /// Reversing the NFA is useful for building a reverse DFA, which is most
                        /// useful for finding the start of a match after its ending position has
                        /// been found. NFA execution engines typically do not work on reverse
                        /// NFAs. For example, currently, the Pike VM reports the starting location
                        /// of matches without a reverse NFA.
                        ///
                        /// Currently, enabling this setting requires disabling the
                        /// [`captures`](Config::captures) setting. If both are enabled, then the
                        /// compiler will return an error. It is expected that this limitation will
                        /// be lifted in the future.
                        ///
                        /// This is disabled by default.
                        ///
                        /// # Example
                        ///
                        /// This example shows how to build a DFA from a reverse NFA, and then use
                        /// the DFA to search backwards.
                        ///
                        /// ```
                        /// use regex_automata::{
                        ///     dfa::{self, Automaton},
                        ///     nfa::thompson::{NFA, WhichCaptures},
                        ///     HalfMatch, Input,
                        /// };
                        ///
                        /// let dfa = dfa::dense::Builder::new()
                        ///     .thompson(NFA::config()
                        ///         .which_captures(WhichCaptures::None)
                        ///         .reverse(true)
                        ///     )
                        ///     .build("baz[0-9]+")?;
                        /// let expected = Some(HalfMatch::must(0, 3));
                        /// assert_eq!(
                        ///     expected,
                        ///     dfa.try_search_rev(&Input::new("foobaz12345bar"))?,
                        /// );
                        ///
                        /// # Ok::<(), Box<dyn std::error::Error>>(())
                        /// ```
                        pub fn reverse(mut self, yes: bool) -> Config {
                            self.reverse = Some(yes);
                            self
                        }
                    
                        /// Sets an approximate size limit on the total heap used by the NFA being
                        /// compiled.
                        ///
                        /// This permits imposing constraints on the size of a compiled NFA. This
                        /// may be useful in contexts where the regex pattern is untrusted and one
                        /// wants to avoid using too much memory.
                        ///
                        /// This size limit does not apply to auxiliary heap used during
                        /// compilation that is not part of the built NFA.
                        ///
                        /// Note that this size limit is applied during compilation in order for
                        /// the limit to prevent too much heap from being used. However, the
                        /// implementation may use an intermediate NFA representation that is
                        /// otherwise slightly bigger than the final public form. Since the size
                        /// limit may be applied to an intermediate representation, there is not
                        /// necessarily a precise correspondence between the configured size limit
                        /// and the heap usage of the final NFA.
                        ///
                        /// There is no size limit by default.
                        ///
                        /// # Example
                        ///
                        /// This example demonstrates how Unicode mode can greatly increase the
                        /// size of the NFA.
                        ///
                        /// ```
                        /// # if cfg!(miri) { return Ok(()); } // miri takes too long
                        /// use regex_automata::nfa::thompson::NFA;
                        ///
                        /// // 400KB isn't enough!
                        /// NFA::compiler()
                        ///     .configure(NFA::config().nfa_size_limit(Some(400_000)))
                        ///     .build(r"\w{20}")
                        ///     .unwrap_err();
                        ///
                        /// // ... but 500KB probably is.
                        /// let nfa = NFA::compiler()
                        ///     .configure(NFA::config().nfa_size_limit(Some(500_000)))
                        ///     .build(r"\w{20}")?;
                        ///
                        /// assert_eq!(nfa.pattern_len(), 1);
                        ///
                        /// # Ok::<(), Box<dyn std::error::Error>>(())
                        /// ```
                        pub fn nfa_size_limit(mut self, bytes: Option<usize>) -> Config {
                            self.nfa_size_limit = Some(bytes);
                            self
                        }
                    
                        /// Apply best effort heuristics to shrink the NFA at the expense of more
                        /// time/memory.
                        ///
                        /// Generally speaking, if one is using an NFA to compile a DFA, then the
                        /// extra time used to shrink the NFA will be more than made up for during
                        /// DFA construction (potentially by a lot). In other words, enabling this
                        /// can substantially decrease the overall amount of time it takes to build
                        /// a DFA.
                        ///
                        /// A reason to keep this disabled is if you want to compile an NFA and
                        /// start using it as quickly as possible without needing to build a DFA,
                        /// and you don't mind using a bit of extra memory for the NFA. e.g., for
                        /// an NFA simulation or for a lazy DFA.
                        ///
                        /// NFA shrinking is currently most useful when compiling a reverse
                        /// NFA with large Unicode character classes. In particular, it trades
                        /// additional CPU time during NFA compilation in favor of generating fewer
                        /// NFA states.
                        ///
                        /// This is disabled by default because it can increase compile times
                        /// quite a bit if you aren't building a full DFA.
                        ///
                        /// # Example
                        ///
                        /// This example shows that NFA shrinking can lead to substantial space
                        /// savings in some cases. Notice that, as noted above, we build a reverse
                        /// DFA and use a pattern with a large Unicode character class.
                        ///
                        /// ```
                        /// # if cfg!(miri) { return Ok(()); } // miri takes too long
                        /// use regex_automata::nfa::thompson::{NFA, WhichCaptures};
                        ///
                        /// // Currently we have to disable captures when enabling reverse NFA.
                        /// let config = NFA::config()
                        ///     .which_captures(WhichCaptures::None)
                        ///     .reverse(true);
                        /// let not_shrunk = NFA::compiler()
                        ///     .configure(config.clone().shrink(false))
                        ///     .build(r"\w")?;
                        /// let shrunk = NFA::compiler()
                        ///     .configure(config.clone().shrink(true))
                        ///     .build(r"\w")?;
                        ///
                        /// // While a specific shrink factor is not guaranteed, the savings can be
                        /// // considerable in some cases.
                        /// assert!(shrunk.states().len() * 2 < not_shrunk.states().len());
                        ///
                        /// # Ok::<(), Box<dyn std::error::Error>>(())
                        /// ```
                        pub fn shrink(mut self, yes: bool) -> Config {
                            self.shrink = Some(yes);
                            self
                        }
                    
                        /// Whether to include 'Capture' states in the NFA.
                        ///
                        /// Currently, enabling this setting requires disabling the
                        /// [`reverse`](Config::reverse) setting. If both are enabled, then the
                        /// compiler will return an error. It is expected that this limitation will
                        /// be lifted in the future.
                        ///
                        /// This is enabled by default.
                        ///
                        /// # Example
                        ///
                        /// This example demonstrates that some regex engines, like the Pike VM,
                        /// require capturing states to be present in the NFA to report match
                        /// offsets.
                        ///
                        /// (Note that since this method is deprecated, the example below uses
                        /// [`Config::which_captures`] to disable capture states.)
                        ///
                        /// ```
                        /// use regex_automata::nfa::thompson::{
                        ///     pikevm::PikeVM,
                        ///     NFA,
                        ///     WhichCaptures,
                        /// };
                        ///
                        /// let re = PikeVM::builder()
                        ///     .thompson(NFA::config().which_captures(WhichCaptures::None))
                        ///     .build(r"[a-z]+")?;
                        /// let mut cache = re.create_cache();
                        ///
                        /// assert!(re.is_match(&mut cache, "abc"));
                        /// assert_eq!(None, re.find(&mut cache, "abc"));
                        ///
                        /// # Ok::<(), Box<dyn std::error::Error>>(())
                        /// ```
                        #[deprecated(since = "0.3.5", note = "use which_captures instead")]
                        pub fn captures(self, yes: bool) -> Config {
                            self.which_captures(if yes {
                                WhichCaptures::All
                            } else {
                                WhichCaptures::None
                            })
                        }
                    
                        /// Configures what kinds of capture groups are compiled into
                        /// [`State::Capture`](crate::nfa::thompson::State::Capture) states in a
                        /// Thompson NFA.
                        ///
                        /// Currently, using any option except for [`WhichCaptures::None`] requires
                        /// disabling the [`reverse`](Config::reverse) setting. If both are
                        /// enabled, then the compiler will return an error. It is expected that
                        /// this limitation will be lifted in the future.
                        ///
                        /// This is set to [`WhichCaptures::All`] by default. Callers may wish to
                        /// use [`WhichCaptures::Implicit`] in cases where one wants avoid the
                        /// overhead of capture states for explicit groups. Usually this occurs
                        /// when one wants to use the `PikeVM` only for determining the overall
                        /// match. Otherwise, the `PikeVM` could use much more memory than is
                        /// necessary.
                        ///
                        /// # Example
                        ///
                        /// This example demonstrates that some regex engines, like the Pike VM,
                        /// require capturing states to be present in the NFA to report match
                        /// offsets.
                        ///
                        /// ```
                        /// use regex_automata::nfa::thompson::{
                        ///     pikevm::PikeVM,
                        ///     NFA,
                        ///     WhichCaptures,
                        /// };
                        ///
                        /// let re = PikeVM::builder()
                        ///     .thompson(NFA::config().which_captures(WhichCaptures::None))
                        ///     .build(r"[a-z]+")?;
                        /// let mut cache = re.create_cache();
                        ///
                        /// assert!(re.is_match(&mut cache, "abc"));
                        /// assert_eq!(None, re.find(&mut cache, "abc"));
                        ///
                        /// # Ok::<(), Box<dyn std::error::Error>>(())
                        /// ```
                        ///
                        /// The same applies to the bounded backtracker:
                        ///
                        /// ```
                        /// use regex_automata::nfa::thompson::{
                        ///     backtrack::BoundedBacktracker,
                        ///     NFA,
                        ///     WhichCaptures,
                        /// };
                        ///
                        /// let re = BoundedBacktracker::builder()
                        ///     .thompson(NFA::config().which_captures(WhichCaptures::None))
                        ///     .build(r"[a-z]+")?;
                        /// let mut cache = re.create_cache();
                        ///
                        /// assert!(re.try_is_match(&mut cache, "abc")?);
                        /// assert_eq!(None, re.try_find(&mut cache, "abc")?);
                        ///
                        /// # Ok::<(), Box<dyn std::error::Error>>(())
                        /// ```
                        pub fn which_captures(mut self, which_captures: WhichCaptures) -> Config {
                            self.which_captures = Some(which_captures);
                            self
                        }
                    
                        /// Sets the look-around matcher that should be used with this NFA.
                        ///
                        /// A look-around matcher determines how to match look-around assertions.
                        /// In particular, some assertions are configurable. For example, the
                        /// `(?m:^)` and `(?m:$)` assertions can have their line terminator changed
                        /// from the default of `\n` to any other byte.
                        ///
                        /// # Example
                        ///
                        /// This shows how to change the line terminator for multi-line assertions.
                        ///
                        /// ```
                        /// use regex_automata::{
                        ///     nfa::thompson::{self, pikevm::PikeVM},
                        ///     util::look::LookMatcher,
                        ///     Match, Input,
                        /// };
                        ///
                        /// let mut lookm = LookMatcher::new();
                        /// lookm.set_line_terminator(b'\x00');
                        ///
                        /// let re = PikeVM::builder()
                        ///     .thompson(thompson::Config::new().look_matcher(lookm))
                        ///     .build(r"(?m)^[a-z]+$")?;
                        /// let mut cache = re.create_cache();
                        ///
                        /// // Multi-line assertions now use NUL as a terminator.
                        /// assert_eq!(
                        ///     Some(Match::must(0, 1..4)),
                        ///     re.find(&mut cache, b"\x00abc\x00"),
                        /// );
                        /// // ... and \n is no longer recognized as a terminator.
                        /// assert_eq!(
                        ///     None,
                        ///     re.find(&mut cache, b"\nabc\n"),
                        /// );
                        ///
                        /// # Ok::<(), Box<dyn std::error::Error>>(())
                        /// ```
                        pub fn look_matcher(mut self, m: LookMatcher) -> Config {
                            self.look_matcher = Some(m);
                            self
                        }
                    
                        /// Whether to compile an unanchored prefix into this NFA.
                        ///
                        /// This is enabled by default. It is made available for tests only to make
                        /// it easier to unit test the output of the compiler.
                        #[cfg(test)]
                        fn unanchored_prefix(mut self, yes: bool) -> Config {
                            self.unanchored_prefix = Some(yes);
                            self
                        }
                    
                        /// Returns whether this configuration has enabled UTF-8 mode.
                        pub fn get_utf8(&self) -> bool {
                            self.utf8.unwrap_or(true)
                        }
                    
                        /// Returns whether this configuration has enabled reverse NFA compilation.
                        pub fn get_reverse(&self) -> bool {
                            self.reverse.unwrap_or(false)
                        }
                    
                        /// Return the configured NFA size limit, if it exists, in the number of
                        /// bytes of heap used.
                        pub fn get_nfa_size_limit(&self) -> Option<usize> {
                            self.nfa_size_limit.unwrap_or(None)
                        }
                    
                        /// Return whether NFA shrinking is enabled.
                        pub fn get_shrink(&self) -> bool {
                            self.shrink.unwrap_or(false)
                        }
                    
                        /// Return whether NFA compilation is configured to produce capture states.
                        #[deprecated(since = "0.3.5", note = "use get_which_captures instead")]
                        pub fn get_captures(&self) -> bool {
                            self.get_which_captures().is_any()
                        }
                    
                        /// Return what kinds of capture states will be compiled into an NFA.
                        pub fn get_which_captures(&self) -> WhichCaptures {
                            self.which_captures.unwrap_or(WhichCaptures::All)
                        }
                    
                        /// Return the look-around matcher for this NFA.
                        pub fn get_look_matcher(&self) -> LookMatcher {
                            self.look_matcher.clone().unwrap_or(LookMatcher::default())
                        }
                    
                        /// Return whether NFA compilation is configured to include an unanchored
                        /// prefix.
                        ///
                        /// This is always false when not in test mode.
                        fn get_unanchored_prefix(&self) -> bool {
                            #[cfg(test)]
                            {
                                self.unanchored_prefix.unwrap_or(true)
                            }
                            #[cfg(not(test))]
                            {
                                true
                            }
                        }
                    
                        /// Overwrite the default configuration such that the options in `o` are
                        /// always used. If an option in `o` is not set, then the corresponding
                        /// option in `self` is used. If it's not set in `self` either, then it
                        /// remains not set.
                        pub(crate) fn overwrite(&self, o: Config) -> Config {
                            Config {
                                utf8: o.utf8.or(self.utf8),
                                reverse: o.reverse.or(self.reverse),
                                nfa_size_limit: o.nfa_size_limit.or(self.nfa_size_limit),
                                shrink: o.shrink.or(self.shrink),
                                which_captures: o.which_captures.or(self.which_captures),
                                look_matcher: o.look_matcher.or_else(|| self.look_matcher.clone()),
                                #[cfg(test)]
                                unanchored_prefix: o.unanchored_prefix.or(self.unanchored_prefix),
                            }
                        }
                    }
                    
                    /// A configuration indicating which kinds of
                    /// [`State::Capture`](crate::nfa::thompson::State::Capture) states to include.
                    ///
                    /// This configuration can be used with [`Config::which_captures`] to control
                    /// which capture states are compiled into a Thompson NFA.
                    ///
                    /// The default configuration is [`WhichCaptures::All`].
                    #[derive(Clone, Copy, Debug)]
                    pub enum WhichCaptures {
                        /// All capture states, including those corresponding to both implicit and
                        /// explicit capture groups, are included in the Thompson NFA.
                        All,
                        /// Only capture states corresponding to implicit capture groups are
                        /// included.
                        Implicit,
                        /// No capture states are compiled into the Thompson NFA.
                        None,
                    }
                    
                    impl Default for WhichCaptures {
                        fn default() -> WhichCaptures {
                            WhichCaptures::All
                        }
                    }
                    
                    impl WhichCaptures {
                        /// Returns true if this configuration indicates that no capture states
                        /// should be produced in an NFA.
                        pub fn is_none(&self) -> bool {
                            matches!(*self, WhichCaptures::None)
                        }
                    
                        /// Returns true if this configuration indicates that some capture states
                        /// should be added to an NFA.
                        pub fn is_any(&self) -> bool {
                            !self.is_none()
                        }
                    }
                    
                    #[derive(Clone, Debug)]
                    pub struct Compiler {
                        /// A regex parser, used when compiling an NFA directly from a pattern
                        /// string.
                        parser: ParserBuilder,
                        /// The compiler configuration.
                        config: Config,
                        /// The builder for actually constructing an NFA. This provides a
                        /// convenient abstraction for writing a compiler.
                        builder: RefCell<Builder>,
                        /// State used for compiling character classes to UTF-8 byte automata.
                        /// State is not retained between character class compilations. This just
                        /// serves to amortize allocation to the extent possible.
                        utf8_state: RefCell<Utf8State>,
                        /// State used for arranging character classes in reverse into a trie.
                        trie_state: RefCell<RangeTrie>,
                        /// State used for caching common suffixes when compiling reverse UTF-8
                        /// automata (for Unicode character classes).
                        utf8_suffix: RefCell<Utf8SuffixMap>,
                    }
                    
                    impl Compiler {
                        /// Create a new NFA builder with its default configuration.
                        pub fn new() -> Compiler {
                            Compiler {
                                parser: ParserBuilder::new(),
                                config: Config::default(),
                                builder: RefCell::new(Builder::new()),
                                utf8_state: RefCell::new(Utf8State::new()),
                                trie_state: RefCell::new(RangeTrie::new()),
                                utf8_suffix: RefCell::new(Utf8SuffixMap::new(1000)),
                            }
                        }
                    
                        /// Compile the given regular expression pattern into an NFA.
                        pub fn build(&self, pattern: &str) -> Result<NFA, BuildError> {
                            self.build_many(&[pattern])
                        }
                    
                        /// Compile the given regular expression patterns into a single NFA.
                        pub fn build_many<P: AsRef<str>>(
                            &self,
                            patterns: &[P],
                        ) -> Result<NFA, BuildError> {
                            let mut hirs = vec![];
                            for p in patterns {
                                hirs.push(
                                    self.parser
                                        .build()
                                        .parse(p.as_ref())
                                        .map_err(BuildError::syntax)?,
                                );
                                debug!("parsed: {:?}", p.as_ref());
                            }
                            self.build_many_from_hir(&hirs)
                        }
                    
                        /// Compile the given high level intermediate representation of a regular
                        /// expression into an NFA.
                        pub fn build_from_hir(&self, expr: &Hir) -> Result<NFA, BuildError> {
                            self.build_many_from_hir(&[expr])
                        }
                    
                        /// Compile the given high level intermediate representations of regular
                        /// expressions into a single NFA.
                        pub fn build_many_from_hir<H: Borrow<Hir>>(
                            &self,
                            exprs: &[H],
                        ) -> Result<NFA, BuildError> {
                            self.compile(exprs)
                        }
                    
                        /// Apply the given NFA configuration options to this builder.
                        pub fn configure(&mut self, config: Config) -> &mut Compiler {
                            self.config = self.config.overwrite(config);
                            self
                        }
                    
                        /// Set the syntax configuration for this builder using
                        /// [`syntax::Config`](crate::util::syntax::Config).
                        pub fn syntax(
                            &mut self,
                            config: crate::util::syntax::Config,
                        ) -> &mut Compiler {
                            config.apply(&mut self.parser);
                            self
                        }
                    }
                    
                    impl Compiler {
                        /// Compile the sequence of HIR expressions given. Pattern IDs are
                        /// allocated starting from 0, in correspondence with the slice given.
                        fn compile<H: Borrow<Hir>>(&self, exprs: &[H]) -> Result<NFA, BuildError> {
                            if exprs.len() > PatternID::LIMIT {
                                return Err(BuildError::too_many_patterns(exprs.len()));
                            }
                            if self.config.get_reverse()
                                && self.config.get_which_captures().is_any()
                            {
                                return Err(BuildError::unsupported_captures());
                            }
                    
                            self.builder.borrow_mut().clear();
                            self.builder.borrow_mut().set_utf8(self.config.get_utf8());
                            self.builder.borrow_mut().set_reverse(self.config.get_reverse());
                            self.builder
                                .borrow_mut()
                                .set_look_matcher(self.config.get_look_matcher());
                            self.builder
                                .borrow_mut()
                                .set_size_limit(self.config.get_nfa_size_limit())?;
                                
                            let all_anchored = exprs.iter().all(|e| {
                                let props = e.borrow().properties();
                                if self.config.get_reverse() {
                                    props.look_set_suffix().contains(hir::Look::End)
                                } else {
                                    props.look_set_prefix().contains(hir::Look::Start)
                                }
                            });
                            let anchored = !self.config.get_unanchored_prefix() || all_anchored;
                            let unanchored_prefix = if anchored {
                                self.c_empty()?
                            } else {
                                self.c_at_least(&Hir::dot(hir::Dot::AnyByte), false, 0)?
                            };
                    
                            let compiled = self.c_alt_iter(exprs.iter().map(|e| {
                                let _ = self.start_pattern()?;
                                let one = self.c_cap(0, None, e.borrow())?;
                                let match_state_id = self.add_match()?;
                                self.patch(one.end, match_state_id)?;
                                let _ = self.finish_pattern(one.start)?;
                                Ok(ThompsonRef { start: one.start, end: match_state_id })
                            }))?;
                            self.patch(unanchored_prefix.end, compiled.start)?;
                            let nfa = self
                                .builder
                                .borrow_mut()
                                .build(compiled.start, unanchored_prefix.start)?;
                    
                            debug!("HIR-to-NFA compilation complete, config: {:?}", self.config);
                            Ok(nfa)
                        }
                    
                        /// Compile an arbitrary HIR expression.
                        fn c(&self, expr: &Hir) -> Result<ThompsonRef, BuildError> {
                            use regex_syntax::hir::{Class, HirKind::*};
                    
                            match *expr.kind() {
                                Empty => self.c_empty(),
                                Literal(hir::Literal(ref bytes)) => self.c_literal(bytes),
                                Class(Class::Bytes(ref c)) => self.c_byte_class(c),
                                Class(Class::Unicode(ref c)) => self.c_unicode_class(c),
                                Look(ref look) => self.c_look(look),
                                Repetition(ref rep) => self.c_repetition(rep),
                                Capture(ref c) => self.c_cap(c.index, c.name.as_deref(), &c.sub),
                                Concat(ref es) => self.c_concat(es.iter().map(|e| self.c(e))),
                                Alternation(ref es) => self.c_alt_slice(es),
                            }
                        }
                    
                        /// Compile a concatenation of the sub-expressions yielded by the given
                        /// iterator.
                        fn c_concat<I>(&self, mut it: I) -> Result<ThompsonRef, BuildError>
                        where
                            I: DoubleEndedIterator<Item = Result<ThompsonRef, BuildError>>,
                        {
                            let first = if self.is_reverse() { it.next_back() } else { it.next() };
                            let ThompsonRef { start, mut end } = match first {
                                Some(result) => result?,
                                None => return self.c_empty(),
                            };
                            loop {
                                let next =
                                    if self.is_reverse() { it.next_back() } else { it.next() };
                                let compiled = match next {
                                    Some(result) => result?,
                                    None => break,
                                };
                                self.patch(end, compiled.start)?;
                                end = compiled.end;
                            }
                            Ok(ThompsonRef { start, end })
                        }
                    
                        /// Compile an alternation of the given HIR values.
                        fn c_alt_slice(&self, exprs: &[Hir]) -> Result<ThompsonRef, BuildError> {
                            // self.c_alt_iter(exprs.iter().map(|e| self.c(e)))
                            let literal_count = exprs
                                .iter()
                                .filter(|e| {
                                    matches!(*e.kind(), hir::HirKind::Literal(hir::Literal(_)))
                                })
                                .count();
                            if literal_count <= 1 || literal_count < exprs.len() {
                                return self.c_alt_iter(exprs.iter().map(|e| self.c(e)));
                            }
                    
                            let mut trie = if self.is_reverse() {
                                LiteralTrie::reverse()
                            } else {
                                LiteralTrie::forward()
                            };
                            for expr in exprs.iter() {
                                let literal = match *expr.kind() {
                                    hir::HirKind::Literal(hir::Literal(ref bytes)) => bytes,
                                    _ => unreachable!(),
                                };
                                trie.add(literal)?;
                            }
                            trie.compile(&mut self.builder.borrow_mut())
                        }
                    
                        /// Compile an alternation, where each element yielded by the given
                        /// iterator represents an item in the alternation.
                        fn c_alt_iter<I>(&self, mut it: I) -> Result<ThompsonRef, BuildError>
                        where
                            I: Iterator<Item = Result<ThompsonRef, BuildError>>,
                        {
                            let first = match it.next() {
                                None => return self.c_fail(),
                                Some(result) => result?,
                            };
                            let second = match it.next() {
                                None => return Ok(first),
                                Some(result) => result?,
                            };
                    
                            let union = self.add_union()?;
                            let end = self.add_empty()?;
                            self.patch(union, first.start)?;
                            self.patch(first.end, end)?;
                            self.patch(union, second.start)?;
                            self.patch(second.end, end)?;
                            for result in it {
                                let compiled = result?;
                                self.patch(union, compiled.start)?;
                                self.patch(compiled.end, end)?;
                            }
                            Ok(ThompsonRef { start: union, end })
                        }
                    
                        /// Compile the given capture sub-expression. `expr` should be the
                        /// sub-expression contained inside the capture.
                        fn c_cap(
                            &self,
                            index: u32,
                            name: Option<&str>,
                            expr: &Hir,
                        ) -> Result<ThompsonRef, BuildError> {
                            match self.config.get_which_captures() {
                                // No capture states means we always skip them.
                                WhichCaptures::None => return self.c(expr),
                                // Implicit captures states means we only add when index==0 since
                                // index==0 implies the group is implicit.
                                WhichCaptures::Implicit if index > 0 => return self.c(expr),
                                _ => {}
                            }
                    
                            let start = self.add_capture_start(index, name)?;
                            let inner = self.c(expr)?;
                            let end = self.add_capture_end(index)?;
                            self.patch(start, inner.start)?;
                            self.patch(inner.end, end)?;
                            Ok(ThompsonRef { start, end })
                        }
                    
                        /// Compile the given repetition expression. This handles all types of
                        /// repetitions and greediness.
                        fn c_repetition(
                            &self,
                            rep: &hir::Repetition,
                        ) -> Result<ThompsonRef, BuildError> {
                            match (rep.min, rep.max) {
                                (0, Some(1)) => self.c_zero_or_one(&rep.sub, rep.greedy),
                                (min, None) => self.c_at_least(&rep.sub, rep.greedy, min),
                                (min, Some(max)) if min == max => self.c_exactly(&rep.sub, min),
                                (min, Some(max)) => self.c_bounded(&rep.sub, rep.greedy, min, max),
                            }
                        }
                    
                        /// Compile the given expression such that it matches at least `min` times,
                        /// but no more than `max` times.
                        fn c_bounded(
                            &self,
                            expr: &Hir,
                            greedy: bool,
                            min: u32,
                            max: u32,
                        ) -> Result<ThompsonRef, BuildError> {
                            let prefix = self.c_exactly(expr, min)?;
                            if min == max {
                                return Ok(prefix);
                            }
                            
                            let empty = self.add_empty()?;
                            let mut prev_end = prefix.end;
                            for _ in min..max {
                                let union = if greedy {
                                    self.add_union()
                                } else {
                                    self.add_union_reverse()
                                }?;
                                let compiled = self.c(expr)?;
                                self.patch(prev_end, union)?;
                                self.patch(union, compiled.start)?;
                                self.patch(union, empty)?;
                                prev_end = compiled.end;
                            }
                            self.patch(prev_end, empty)?;
                            Ok(ThompsonRef { start: prefix.start, end: empty })
                        }
                    
                        /// Compile the given expression such that it may be matched `n` or more
                        /// times, where `n` can be any integer.
                        fn c_at_least(
                            &self,
                            expr: &Hir,
                            greedy: bool,
                            n: u32,
                        ) -> Result<ThompsonRef, BuildError> {
                            if n == 0 {
                                if expr.properties().minimum_len().map_or(false, |len| len > 0) {
                                    let union = if greedy {
                                        self.add_union()
                                    } else {
                                        self.add_union_reverse()
                                    }?;
                                    let compiled = self.c(expr)?;
                                    self.patch(union, compiled.start)?;
                                    self.patch(compiled.end, union)?;
                                    return Ok(ThompsonRef { start: union, end: union });
                                }
                                
                                let compiled = self.c(expr)?;
                                let plus = if greedy {
                                    self.add_union()
                                } else {
                                    self.add_union_reverse()
                                }?;
                                self.patch(compiled.end, plus)?;
                                self.patch(plus, compiled.start)?;
                    
                                let question = if greedy {
                                    self.add_union()
                                } else {
                                    self.add_union_reverse()
                                }?;
                                let empty = self.add_empty()?;
                                self.patch(question, compiled.start)?;
                                self.patch(question, empty)?;
                                self.patch(plus, empty)?;
                                Ok(ThompsonRef { start: question, end: empty })
                            } else if n == 1 {
                                let compiled = self.c(expr)?;
                                let union = if greedy {
                                    self.add_union()
                                } else {
                                    self.add_union_reverse()
                                }?;
                                self.patch(compiled.end, union)?;
                                self.patch(union, compiled.start)?;
                                Ok(ThompsonRef { start: compiled.start, end: union })
                            } else {
                                let prefix = self.c_exactly(expr, n - 1)?;
                                let last = self.c(expr)?;
                                let union = if greedy {
                                    self.add_union()
                                } else {
                                    self.add_union_reverse()
                                }?;
                                self.patch(prefix.end, last.start)?;
                                self.patch(last.end, union)?;
                                self.patch(union, last.start)?;
                                Ok(ThompsonRef { start: prefix.start, end: union })
                            }
                        }
                    
                        /// Compile the given expression such that it may be matched zero or one
                        /// times.
                        fn c_zero_or_one(
                            &self,
                            expr: &Hir,
                            greedy: bool,
                        ) -> Result<ThompsonRef, BuildError> {
                            let union =
                                if greedy { self.add_union() } else { self.add_union_reverse() }?;
                            let compiled = self.c(expr)?;
                            let empty = self.add_empty()?;
                            self.patch(union, compiled.start)?;
                            self.patch(union, empty)?;
                            self.patch(compiled.end, empty)?;
                            Ok(ThompsonRef { start: union, end: empty })
                        }
                    
                        /// Compile the given HIR expression exactly `n` times.
                        fn c_exactly(
                            &self,
                            expr: &Hir,
                            n: u32,
                        ) -> Result<ThompsonRef, BuildError> {
                            let it = (0..n).map(|_| self.c(expr));
                            self.c_concat(it)
                        }
                    
                        /// Compile the given byte oriented character class.
                        fn c_byte_class(
                            &self,
                            cls: &hir::ClassBytes,
                        ) -> Result<ThompsonRef, BuildError> {
                            let end = self.add_empty()?;
                            let mut trans = Vec::with_capacity(cls.ranges().len());
                            for r in cls.iter() {
                                trans.push(Transition {
                                    start: r.start(),
                                    end: r.end(),
                                    next: end,
                                });
                            }
                            Ok(ThompsonRef { start: self.add_sparse(trans)?, end })
                        }
                    
                        /// Compile the given Unicode character class.
                        fn c_unicode_class(
                            &self,
                            cls: &hir::ClassUnicode,
                        ) -> Result<ThompsonRef, BuildError> {
                            if cls.is_ascii() {
                                let end = self.add_empty()?;
                                let mut trans = Vec::with_capacity(cls.ranges().len());
                                for r in cls.iter() {
                                    trans.push(Transition {
                                        start: u8::try_from(u32::from(r.start())).unwrap(),
                                        end: u8::try_from(u32::from(r.end())).unwrap(),
                                        next: end,
                                    });
                                }
                                Ok(ThompsonRef { start: self.add_sparse(trans)?, end })
                            } else if self.is_reverse() {
                                if !self.config.get_shrink() {
                                    self.c_unicode_class_reverse_with_suffix(cls)
                                } else {
                                    let mut trie = self.trie_state.borrow_mut();
                                    trie.clear();
                    
                                    for rng in cls.iter() {
                                        for mut seq in Utf8Sequences::new(rng.start(), rng.end()) {
                                            seq.reverse();
                                            trie.insert(seq.as_slice());
                                        }
                                    }
                                    let mut builder = self.builder.borrow_mut();
                                    let mut utf8_state = self.utf8_state.borrow_mut();
                                    let mut utf8c =
                                        Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;
                                    trie.iter(|seq| {
                                        utf8c.add(&seq)?;
                                        Ok(())
                                    })?;
                                    utf8c.finish()
                                }
                            } else {
                                let mut builder = self.builder.borrow_mut();
                                let mut utf8_state = self.utf8_state.borrow_mut();
                                let mut utf8c =
                                    Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;
                                for rng in cls.iter() {
                                    for seq in Utf8Sequences::new(rng.start(), rng.end()) {
                                        utf8c.add(seq.as_slice())?;
                                    }
                                }
                                utf8c.finish()
                            }
                        }
                    
                        /// Compile the given Unicode character class in reverse with suffix
                        /// caching.
                        fn c_unicode_class_reverse_with_suffix(
                            &self,
                            cls: &hir::ClassUnicode,
                        ) -> Result<ThompsonRef, BuildError> {
                            let mut cache = self.utf8_suffix.borrow_mut();
                            cache.clear();
                    
                            let union = self.add_union()?;
                            let alt_end = self.add_empty()?;
                            for urng in cls.iter() {
                                for seq in Utf8Sequences::new(urng.start(), urng.end()) {
                                    let mut end = alt_end;
                                    for brng in seq.as_slice() {
                                        let key = Utf8SuffixKey {
                                            from: end,
                                            start: brng.start,
                                            end: brng.end,
                                        };
                                        let hash = cache.hash(&key);
                                        if let Some(id) = cache.get(&key, hash) {
                                            end = id;
                                            continue;
                                        }
                    
                                        let compiled = self.c_range(brng.start, brng.end)?;
                                        self.patch(compiled.end, end)?;
                                        end = compiled.start;
                                        cache.set(key, hash, end);
                                    }
                                    self.patch(union, end)?;
                                }
                            }
                            Ok(ThompsonRef { start: union, end: alt_end })
                        }
                    
                        /// Compile the given HIR look-around assertion to an NFA look-around
                        /// assertion.
                        fn c_look(&self, anchor: &hir::Look) -> Result<ThompsonRef, BuildError> {
                            let look = match *anchor {
                                hir::Look::Start => Look::Start,
                                hir::Look::End => Look::End,
                                hir::Look::StartLF => Look::StartLF,
                                hir::Look::EndLF => Look::EndLF,
                                hir::Look::StartCRLF => Look::StartCRLF,
                                hir::Look::EndCRLF => Look::EndCRLF,
                                hir::Look::WordAscii => Look::WordAscii,
                                hir::Look::WordAsciiNegate => Look::WordAsciiNegate,
                                hir::Look::WordUnicode => Look::WordUnicode,
                                hir::Look::WordUnicodeNegate => Look::WordUnicodeNegate,
                                hir::Look::WordStartAscii => Look::WordStartAscii,
                                hir::Look::WordEndAscii => Look::WordEndAscii,
                                hir::Look::WordStartUnicode => Look::WordStartUnicode,
                                hir::Look::WordEndUnicode => Look::WordEndUnicode,
                                hir::Look::WordStartHalfAscii => Look::WordStartHalfAscii,
                                hir::Look::WordEndHalfAscii => Look::WordEndHalfAscii,
                                hir::Look::WordStartHalfUnicode => Look::WordStartHalfUnicode,
                                hir::Look::WordEndHalfUnicode => Look::WordEndHalfUnicode,
                            };
                            let id = self.add_look(look)?;
                            Ok(ThompsonRef { start: id, end: id })
                        }
                    
                        /// Compile the given byte string to a concatenation of bytes.
                        fn c_literal(&self, bytes: &[u8]) -> Result<ThompsonRef, BuildError> {
                            self.c_concat(bytes.iter().copied().map(|b| self.c_range(b, b)))
                        }
                    
                        /// Compile a "range" state with one transition that may only be followed
                        /// if the input byte is in the (inclusive) range given.
                        fn c_range(&self, start: u8, end: u8) -> Result<ThompsonRef, BuildError> {
                            let id = self.add_range(start, end)?;
                            Ok(ThompsonRef { start: id, end: id })
                        }
                    
                        /// Compile an "empty" state with one unconditional epsilon transition.
                        fn c_empty(&self) -> Result<ThompsonRef, BuildError> {
                            let id = self.add_empty()?;
                            Ok(ThompsonRef { start: id, end: id })
                        }
                    
                        /// Compile a "fail" state that can never have any outgoing transitions.
                        fn c_fail(&self) -> Result<ThompsonRef, BuildError> {
                            let id = self.add_fail()?;
                            Ok(ThompsonRef { start: id, end: id })
                        }
                    
                        fn patch(&self, from: StateID, to: StateID) -> Result<(), BuildError> {
                            self.builder.borrow_mut().patch(from, to)
                        }
                    
                        fn start_pattern(&self) -> Result<PatternID, BuildError> {
                            self.builder.borrow_mut().start_pattern()
                        }
                    
                        fn finish_pattern(
                            &self,
                            start_id: StateID,
                        ) -> Result<PatternID, BuildError> {
                            self.builder.borrow_mut().finish_pattern(start_id)
                        }
                    
                        fn add_empty(&self) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_empty()
                        }
                    
                        fn add_range(&self, start: u8, end: u8) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_range(Transition {
                                start,
                                end,
                                next: StateID::ZERO,
                            })
                        }
                    
                        fn add_sparse(
                            &self,
                            ranges: Vec<Transition>,
                        ) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_sparse(ranges)
                        }
                    
                        fn add_look(&self, mut look: Look) -> Result<StateID, BuildError> {
                            if self.is_reverse() {
                                look = look.reversed();
                            }
                            self.builder.borrow_mut().add_look(StateID::ZERO, look)
                        }
                    
                        fn add_union(&self) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_union(vec![])
                        }
                    
                        fn add_union_reverse(&self) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_union_reverse(vec![])
                        }
                    
                        fn add_capture_start(
                            &self,
                            capture_index: u32,
                            name: Option<&str>,
                        ) -> Result<StateID, BuildError> {
                            let name = name.map(|n| Arc::from(n));
                            self.builder.borrow_mut().add_capture_start(
                                StateID::ZERO,
                                capture_index,
                                name,
                            )
                        }
                    
                        fn add_capture_end(
                            &self,
                            capture_index: u32,
                        ) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_capture_end(StateID::ZERO, capture_index)
                        }
                    
                        fn add_fail(&self) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_fail()
                        }
                    
                        fn add_match(&self) -> Result<StateID, BuildError> {
                            self.builder.borrow_mut().add_match()
                        }
                    
                        fn is_reverse(&self) -> bool {
                            self.config.get_reverse()
                        }
                    }
                    
                    /// A value that represents the result of compiling a sub-expression of a
                    /// regex's HIR.
                    pub(crate) struct ThompsonRef {
                        pub(crate) start: StateID,
                        pub(crate) end: StateID,
                    }
                    
                    /// A UTF-8 compiler based on Daciuk's algorithm for compilining minimal DFAs
                    /// from a lexicographically sorted sequence of strings in linear time.
                    #[derive(Debug)]
                    struct Utf8Compiler<'a> {
                        builder: &'a mut Builder,
                        state: &'a mut Utf8State,
                        target: StateID,
                    }
                    
                    #[derive(Clone, Debug)]
                    struct Utf8State {
                        compiled: Utf8BoundedMap,
                        uncompiled: Vec<Utf8Node>,
                    }
                    
                    #[derive(Clone, Debug)]
                    struct Utf8Node {
                        trans: Vec<Transition>,
                        last: Option<Utf8LastTransition>,
                    }
                    
                    #[derive(Clone, Debug)]
                    struct Utf8LastTransition {
                        start: u8,
                        end: u8,
                    }
                    
                    impl Utf8State {
                        fn new() -> Utf8State {
                            Utf8State { compiled: Utf8BoundedMap::new(10_000), uncompiled: vec![] }
                        }
                    
                        fn clear(&mut self) {
                            self.compiled.clear();
                            self.uncompiled.clear();
                        }
                    }
                    
                    impl<'a> Utf8Compiler<'a> {
                        fn new(
                            builder: &'a mut Builder,
                            state: &'a mut Utf8State,
                        ) -> Result<Utf8Compiler<'a>, BuildError> {
                            let target = builder.add_empty()?;
                            state.clear();
                            let mut utf8c = Utf8Compiler { builder, state, target };
                            utf8c.add_empty();
                            Ok(utf8c)
                        }
                    
                        fn finish(&mut self) -> Result<ThompsonRef, BuildError> {
                            self.compile_from(0)?;
                            let node = self.pop_root();
                            let start = self.compile(node)?;
                            Ok(ThompsonRef { start, end: self.target })
                        }
                    
                        fn add(&mut self, ranges: &[Utf8Range]) -> Result<(), BuildError> {
                            let prefix_len = ranges
                                .iter()
                                .zip(&self.state.uncompiled)
                                .take_while(|&(range, node)| {
                                    node.last.as_ref().map_or(false, |t| {
                                        (t.start, t.end) == (range.start, range.end)
                                    })
                                })
                                .count();
                            assert!(prefix_len < ranges.len());
                            self.compile_from(prefix_len)?;
                            self.add_suffix(&ranges[prefix_len..]);
                            Ok(())
                        }
                    
                        fn compile_from(&mut self, from: usize) -> Result<(), BuildError> {
                            let mut next = self.target;
                            while from + 1 < self.state.uncompiled.len() {
                                let node = self.pop_freeze(next);
                                next = self.compile(node)?;
                            }
                            self.top_last_freeze(next);
                            Ok(())
                        }
                    
                        fn compile(
                            &mut self,
                            node: Vec<Transition>,
                        ) -> Result<StateID, BuildError> {
                            let hash = self.state.compiled.hash(&node);
                            if let Some(id) = self.state.compiled.get(&node, hash) {
                                return Ok(id);
                            }
                            let id = self.builder.add_sparse(node.clone())?;
                            self.state.compiled.set(node, hash, id);
                            Ok(id)
                        }
                    
                        fn add_suffix(&mut self, ranges: &[Utf8Range])
                        {
                            assert!(!ranges.is_empty());
                            let last = self
                            .state
                            .uncompiled
                            .len()
                            .checked_sub(1)
                            .expect("non-empty nodes");
                                
                            assert!(self.state.uncompiled[last].last.is_none());
                            
                            self.state.uncompiled[last].last = Some(Utf8LastTransition
                            {
                                start: ranges[0].start,
                                end: ranges[0].end,
                            });
                            
                            for r in &ranges[1..]
                            {
                                self.state.uncompiled.push(Utf8Node
                                {
                                    trans: vec![],
                                    last: Some(Utf8LastTransition { start: r.start, end: r.end }),
                                });
                            }
                        }
                    
                        fn add_empty(&mut self)
                        { self.state.uncompiled.push(Utf8Node { trans: vec![], last: None }); }
                    
                        fn pop_freeze(&mut self, next: StateID) -> Vec<Transition>
                        {
                            let mut uncompiled = self.state.uncompiled.pop().unwrap();
                            uncompiled.set_last_transition(next);
                            uncompiled.trans
                        }
                    
                        fn pop_root(&mut self) -> Vec<Transition>
                        {
                            assert_eq!(self.state.uncompiled.len(), 1);
                            assert!(self.state.uncompiled[0].last.is_none());
                            self.state.uncompiled.pop().expect("non-empty nodes").trans
                        }
                    
                        fn top_last_freeze(&mut self, next: StateID)
                        {
                            let last = self
                                .state
                                .uncompiled
                                .len()
                                .checked_sub(1)
                                .expect("non-empty nodes");
                            self.state.uncompiled[last].set_last_transition(next);
                        }
                    }
                    
                    impl Utf8Node
                    {
                        fn set_last_transition(&mut self, next: StateID)
                        {
                            if let Some(last) = self.last.take() {
                                self.trans.push(Transition {
                                    start: last.start,
                                    end: last.end,
                                    next,
                                });
                            }
                        }
                    }
                }
                
                pub mod error
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }
                
                pub mod literal_trie
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }
                
                pub mod map
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }
                
                pub mod nfa
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }
                
                pub mod pikevm
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }
                
                pub mod range_trie
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }

                pub use self::{
                    builder::Builder,
                    error::BuildError,
                    nfa::{
                        DenseTransitions, PatternIter, SparseTransitions, State, Transition,
                        NFA,
                    },
                };
                
                pub use compiler::{Compiler, Config, WhichCaptures};
            }
        }
        
        pub mod util
        {
            //! A collection of modules that provide APIs that are useful across many regex engines.
            use ::
            {
                *,
            };
            /*
            */
            pub mod alphabet
            {
                //! This module provides APIs for dealing with the alphabets of finite state machines.
                use ::
                {
                    *,
                };
                /*
                use crate::util::{
                    escape::DebugByte,
                    wire::{self, DeserializeError, SerializeError},
                };
                */
                /// Unit represents a single unit of haystack for DFA based regex engines.
                #[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]
                pub struct Unit(UnitKind);
                
                #[derive(Clone, Copy, Eq, PartialEq, PartialOrd, Ord)]
                enum UnitKind {
                    /// Represents a byte value, or more typically, an equivalence class
                    /// represented as a byte value.
                    U8(u8),
                    /// Represents the "end of input" sentinel
                    EOI(u16),
                }
                
                impl Unit {
                    /// Create a new haystack unit from a byte value.
                    pub fn u8(byte: u8) -> Unit {
                        Unit(UnitKind::U8(byte))
                    }
                
                    /// Create a new "end of input" haystack unit.
                    pub fn eoi(num_byte_equiv_classes: usize) -> Unit {
                        assert!(
                            num_byte_equiv_classes <= 256,
                            "max number of byte-based equivalent classes is 256, but got {}",
                            num_byte_equiv_classes,
                        );
                        Unit(UnitKind::EOI(u16::try_from(num_byte_equiv_classes).unwrap()))
                    }
                
                    /// If this unit is not an "end of input" sentinel, then returns its
                    /// underlying byte value. Otherwise return `None`.
                    pub fn as_u8(self) -> Option<u8>
                    {
                        match self.0 {
                            UnitKind::U8(b) => Some(b),
                            UnitKind::EOI(_) => None,
                        }
                    }
                    /// If this unit is an "end of input" sentinel, then return the underlying
                    /// sentinel value that was given to [`Unit::eoi`].
                    pub fn as_eoi(self) -> Option<u16>
                    {
                        match self.0 {
                            UnitKind::U8(_) => None,
                            UnitKind::EOI(sentinel) => Some(sentinel),
                        }
                    }
                    /// Return this unit as a `usize`, regardless of whether it is a byte value or an "end of input" sentinel.
                    pub fn as_usize(self) -> usize
                    {
                        match self.0 {
                            UnitKind::U8(b) => usize::from(b),
                            UnitKind::EOI(eoi) => usize::from(eoi),
                        }
                    }
                    /// Returns true if and only of this unit is a byte value equivalent to the byte given.
                    pub fn is_byte(self, byte: u8) -> bool
                    {
                        self.as_u8().map_or(false, |b| b == byte)
                    }
                    /// Returns true when this unit represents an "end of input" sentinel.
                    pub fn is_eoi(self) -> bool
                    {
                        self.as_eoi().is_some()
                    }
                    /// Returns true when this unit corresponds to an ASCII word byte.
                    pub fn is_word_byte(self) -> bool
                    {
                        self.as_u8().map_or(false, crate::util::utf8::is_word_byte)
                    }
                }
                
                impl ::fmt::Debug for Unit
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        match self.0 {
                            UnitKind::U8(b) => write!(f, "{:?}", DebugByte(b)),
                            UnitKind::EOI(_) => write!(f, "EOI"),
                        }
                    }
                }                
                /// A representation of byte oriented equivalence classes.
                #[derive(Clone, Copy)]
                pub struct ByteClasses([u8; 256]);
                
                impl ByteClasses 
                {
                    /// Creates a new set of equivalence classes where all bytes are mapped to the same class.
                    #[inline] pub fn empty() -> ByteClasses
                    {
                        ByteClasses([0; 256])
                    }
                    /// Creates a new set of equivalence classes where each byte belongs to its own equivalence class.
                    #[inline] pub fn singletons() -> ByteClasses
                    {
                        let mut classes = ByteClasses::empty();
                        for b in 0..=255 {
                            classes.set(b, b);
                        }
                        classes
                    }
                    /// Deserializes a byte class map from the given slice.
                    pub fn from_bytes
                    (
                        slice: &[u8],
                    ) -> Result<(ByteClasses, usize), DeserializeError>
                    {
                        wire::check_slice_len(slice, 256, "byte class map")?;
                        let mut classes = ByteClasses::empty();
                        for (b, &class) in slice[..256].iter().enumerate() {
                            classes.set(u8::try_from(b).unwrap(), class);
                        }
                        
                        for &b in classes.0.iter() {
                            if usize::from(b) >= classes.alphabet_len() {
                                return Err(DeserializeError::generic(
                                    "found equivalence class greater than alphabet len",
                                ));
                            }
                        }
                        Ok((classes, 256))
                    }                
                    /// Writes this byte class map to the given byte buffer.
                    pub fn write_to
                    (
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("byte class map"));
                        }
                        for b in 0..=255 {
                            dst[0] = self.get(b);
                            dst = &mut dst[1..];
                        }
                        Ok(nwrite)
                    }
                    /// Returns the total number of bytes written by `write_to`.
                    pub fn write_to_len(&self) -> usize
                    {
                        256
                    }                
                    /// Set the equivalence class for the given byte.
                    #[inline] pub fn set(&mut self, byte: u8, class: u8)
                    {
                        self.0[usize::from(byte)] = class;
                    }
                    /// Get the equivalence class for the given byte.
                    #[inline] pub fn get(&self, byte: u8) -> u8
                    {
                        self.0[usize::from(byte)]
                    } 
                    /// Get the equivalence class for the given haystack unit and return the class as a `usize`.
                    #[inline] pub fn get_by_unit(&self, unit: Unit) -> usize
                    {
                        match unit.0 {
                            UnitKind::U8(b) => usize::from(self.get(b)),
                            UnitKind::EOI(b) => usize::from(b),
                        }
                    }
                    /// Create a unit that represents the "end of input" sentinel based on the number of equivalence classes.
                    #[inline] pub fn eoi(&self) -> Unit
                    {
                        Unit::eoi(self.alphabet_len().checked_sub(1).unwrap())
                    }
                    /// Return the total number of elements in the alphabet represented by these equivalence classes.
                    #[inline] pub fn alphabet_len(&self) -> usize
                    {
                        usize::from(self.0[255]) + 1 + 1
                    }
                    /// Returns the stride, as a base-2 exponent, required for these equivalence classes.
                    #[inline] pub fn stride2(&self) -> usize
                    {
                        let zeros = self.alphabet_len().next_power_of_two().trailing_zeros();
                        usize::try_from(zeros).unwrap()
                    }
                    /// Returns true if and only if every byte in this class maps to its own equivalence class.
                    #[inline] pub fn is_singleton(&self) -> bool
                    {
                        self.alphabet_len() == 257
                    }
                    /// Returns an iterator over all equivalence classes in this set.
                    #[inline] pub fn iter(&self) -> ByteClassIter<'_>
                    {
                        ByteClassIter { classes: self, i: 0 }
                    }
                    /// Returns an iterator over a sequence of representative bytes from each equivalence class within the range of bytes given.
                    pub fn representatives<R: ::ops::RangeBounds<u8>>
                    (
                        &self,
                        range: R,
                    ) -> ByteClassRepresentatives<'_>
                    {
                        use ::ops::Bound;
                
                        let cur_byte = match range.start_bound() {
                            Bound::Included(&i) => usize::from(i),
                            Bound::Excluded(&i) => usize::from(i).checked_add(1).unwrap(),
                            Bound::Unbounded => 0,
                        };
                        let end_byte = match range.end_bound() {
                            Bound::Included(&i) => {
                                Some(usize::from(i).checked_add(1).unwrap())
                            }
                            Bound::Excluded(&i) => Some(usize::from(i)),
                            Bound::Unbounded => None,
                        };
                        assert_ne!(
                            cur_byte,
                            usize::MAX,
                            "start range must be less than usize::MAX",
                        );
                        ByteClassRepresentatives {
                            classes: self,
                            cur_byte,
                            end_byte,
                            last_class: None,
                        }
                    }
                    /// Returns an iterator of the bytes in the given equivalence class.
                    #[inline] pub fn elements(&self, class: Unit) -> ByteClassElements
                    {
                        ByteClassElements { classes: self, class, byte: 0 }
                    }
                    /// Returns an iterator of byte ranges in the given equivalence class.
                    fn element_ranges(&self, class: Unit) -> ByteClassElementRanges
                    {
                        ByteClassElementRanges { elements: self.elements(class), range: None }
                    }
                }
                
                impl Default for ByteClasses {
                    fn default() -> ByteClasses {
                        ByteClasses::singletons()
                    }
                }
                
                impl ::fmt::Debug for ByteClasses {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        if self.is_singleton() {
                            write!(f, "ByteClasses({{singletons}})")
                        } else {
                            write!(f, "ByteClasses(")?;
                            for (i, class) in self.iter().enumerate() {
                                if i > 0 {
                                    write!(f, ", ")?;
                                }
                                write!(f, "{:?} => [", class.as_usize())?;
                                for (start, end) in self.element_ranges(class) {
                                    if start == end {
                                        write!(f, "{:?}", start)?;
                                    } else {
                                        write!(f, "{:?}-{:?}", start, end)?;
                                    }
                                }
                                write!(f, "]")?;
                            }
                            write!(f, ")")
                        }
                    }
                }
                
                /// An iterator over each equivalence class.
                #[derive(Debug)]
                pub struct ByteClassIter<'a> {
                    classes: &'a ByteClasses,
                    i: usize,
                }
                
                impl<'a> Iterator for ByteClassIter<'a> {
                    type Item = Unit;
                
                    fn next(&mut self) -> Option<Unit> {
                        if self.i + 1 == self.classes.alphabet_len() {
                            self.i += 1;
                            Some(self.classes.eoi())
                        } else if self.i < self.classes.alphabet_len() {
                            let class = u8::try_from(self.i).unwrap();
                            self.i += 1;
                            Some(Unit::u8(class))
                        } else {
                            None
                        }
                    }
                }
                
                /// An iterator over representative bytes from each equivalence class.
                #[derive(Debug)]
                pub struct ByteClassRepresentatives<'a> {
                    classes: &'a ByteClasses,
                    cur_byte: usize,
                    end_byte: Option<usize>,
                    last_class: Option<u8>,
                }
                
                impl<'a> Iterator for ByteClassRepresentatives<'a> {
                    type Item = Unit;
                
                    fn next(&mut self) -> Option<Unit> {
                        while self.cur_byte < self.end_byte.unwrap_or(256) {
                            let byte = u8::try_from(self.cur_byte).unwrap();
                            let class = self.classes.get(byte);
                            self.cur_byte += 1;
                
                            if self.last_class != Some(class) {
                                self.last_class = Some(class);
                                return Some(Unit::u8(byte));
                            }
                        }
                        if self.cur_byte != usize::MAX && self.end_byte.is_none() {
                            self.cur_byte = usize::MAX;
                            return Some(self.classes.eoi());
                        }
                        None
                    }
                }
                
                /// An iterator over all elements in an equivalence class.
                #[derive(Debug)]
                pub struct ByteClassElements<'a> {
                    classes: &'a ByteClasses,
                    class: Unit,
                    byte: usize,
                }
                
                impl<'a> Iterator for ByteClassElements<'a>
                {
                    type Item = Unit;
                
                    fn next(&mut self) -> Option<Unit> {
                        while self.byte < 256 {
                            let byte = u8::try_from(self.byte).unwrap();
                            self.byte += 1;
                            if self.class.is_byte(self.classes.get(byte)) {
                                return Some(Unit::u8(byte));
                            }
                        }
                        if self.byte < 257 {
                            self.byte += 1;
                            if self.class.is_eoi() {
                                return Some(Unit::eoi(256));
                            }
                        }
                        None
                    }
                }
                /// An iterator over all elements in an equivalence class expressed as a sequence of contiguous ranges.
                #[derive(Debug)] struct ByteClassElementRanges<'a>
                {
                    elements: ByteClassElements<'a>,
                    range: Option<(Unit, Unit)>,
                }
                
                impl<'a> Iterator for ByteClassElementRanges<'a>
                {
                    type Item = (Unit, Unit);
                
                    fn next(&mut self) -> Option<(Unit, Unit)> {
                        loop {
                            let element = match self.elements.next() {
                                None => return self.range.take(),
                                Some(element) => element,
                            };
                            match self.range.take() {
                                None => {
                                    self.range = Some((element, element));
                                }
                                Some((start, end)) => {
                                    if end.as_usize() + 1 != element.as_usize()
                                        || element.is_eoi()
                                    {
                                        self.range = Some((element, element));
                                        return Some((start, end));
                                    }
                                    self.range = Some((start, element));
                                }
                            }
                        }
                    }
                }                
                /// A partitioning of bytes into equivalence classes.
                #[derive(Clone, Debug)]
                pub struct ByteClassSet(ByteSet);
                
                impl Default for ByteClassSet
                {
                    fn default() -> ByteClassSet {
                        ByteClassSet::empty()
                    }
                }
                
                impl ByteClassSet
                {
                    /// Create a new set of byte classes where all bytes are part of the same equivalence class.
                    pub fn empty() -> Self
                    {
                        ByteClassSet(ByteSet::empty())
                    }
                    /// Indicate the range of byte given (inclusive) can discriminate a match between it and all other bytes outside of the range.
                    pub fn set_range(&mut self, start: u8, end: u8)
                    {
                        debug_assert!(start <= end);
                        if start > 0 {
                            self.0.add(start - 1);
                        }
                        self.0.add(end);
                    }
                    /// Add the contiguous ranges in the set given to this byte class set.
                    pub fn add_set(&mut self, set: &ByteSet)
                    {
                        for (start, end) in set.iter_ranges() {
                            self.set_range(start, end);
                        }
                    }
                    /// Convert this boolean set to a map that maps all byte values to their corresponding equivalence class.
                    pub fn byte_classes(&self) -> ByteClasses
                    {
                        let mut classes = ByteClasses::empty();
                        let mut class = 0u8;
                        let mut b = 0u8;
                        loop {
                            classes.set(b, class);
                            if b == 255 {
                                break;
                            }
                            if self.0.contains(b) {
                                class = class.checked_add(1).unwrap();
                            }
                            b = b.checked_add(1).unwrap();
                        }
                        classes
                    }
                }
                /// A simple set of bytes that is reasonably cheap to copy and allocation free.
                #[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
                pub struct ByteSet
                {
                    bits: BitSet,
                }
                /// The representation of a byte set.
                #[derive(Clone, Copy, Default, Eq, PartialEq)]
                struct BitSet( [ u128; 2 ] );
                
                impl ByteSet
                {
                    /// Create an empty set of bytes.
                    pub fn empty() -> ByteSet
                    {
                        ByteSet { bits: BitSet([0; 2]) }
                    }
                    /// Add a byte to this set.
                    pub fn add(&mut self, byte: u8)
                    {
                        let bucket = byte / 128;
                        let bit = byte % 128;
                        self.bits.0[usize::from(bucket)] |= 1 << bit;
                    }
                    /// Remove a byte from this set.
                    pub fn remove(&mut self, byte: u8)
                    {
                        let bucket = byte / 128;
                        let bit = byte % 128;
                        self.bits.0[usize::from(bucket)] &= !(1 << bit);
                    }
                    /// Return true if and only if the given byte is in this set.
                    pub fn contains(&self, byte: u8) -> bool
                    {
                        let bucket = byte / 128;
                        let bit = byte % 128;
                        self.bits.0[usize::from(bucket)] & (1 << bit) > 0
                    }
                    /// Return true if and only if the given inclusive range of bytes is in this set.
                    pub fn contains_range(&self, start: u8, end: u8) -> bool
                    {
                        (start..=end).all(|b| self.contains(b))
                    }
                    /// Returns an iterator over all bytes in this set.
                    pub fn iter(&self) -> ByteSetIter
                    {
                        ByteSetIter { set: self, b: 0 }
                    }
                    /// Returns an iterator over all contiguous ranges of bytes in this set.
                    pub fn iter_ranges(&self) -> ByteSetRangeIter
                    {
                        ByteSetRangeIter { set: self, b: 0 }
                    }
                    /// Return true if and only if this set is empty.
                    #[inline( always )] pub fn is_empty(&self) -> bool
                    {
                        self.bits.0 == [0, 0]
                    }
                    /// Deserializes a byte set from the given slice.
                    pub fn from_bytes
                    (
                        slice: &[u8],
                    ) -> Result<(ByteSet, usize), DeserializeError>
                    {
                        use ::mem::size_of;
                
                        wire::check_slice_len(slice, 2 * size_of::<u128>(), "byte set")?;
                        let mut nread = 0;
                        let (low, nr) = wire::try_read_u128(slice, "byte set low bucket")?;
                        nread += nr;
                        let (high, nr) = wire::try_read_u128(slice, "byte set high bucket")?;
                        nread += nr;
                        Ok((ByteSet { bits: BitSet([low, high]) }, nread))
                    }
                    /// Writes this byte set to the given byte buffer.
                    pub fn write_to<E: crate::util::wire::Endian>( 
                        &self,
                        dst: &mut [u8], ) -> 
                    Result<usize, SerializeError>
                    {
                        use ::mem::size_of;
                
                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("byte set"));
                        }
                        let mut nw = 0;
                        E::write_u128(self.bits.0[0], &mut dst[nw..]);
                        nw += size_of::<u128>();
                        E::write_u128(self.bits.0[1], &mut dst[nw..]);
                        nw += size_of::<u128>();
                        assert_eq!(nwrite, nw, "expected to write certain number of bytes",);
                        assert_eq!(
                            nw % 8,
                            0,
                            "expected to write multiple of 8 bytes for byte set",
                        );
                        Ok(nw)
                    }
                    /// Returns the total number of bytes written by `write_to`.
                    pub fn write_to_len(&self) -> usize
                    {
                        2 * ::mem::size_of::<u128>()
                    }
                }
                
                impl ::fmt::Debug for BitSet
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        let mut fmtd = f.debug_set();
                        for b in 0u8..=255 {
                            if (ByteSet { bits: *self }).contains(b) {
                                fmtd.entry(&b);
                            }
                        }
                        fmtd.finish()
                    }
                }
                
                #[derive(Debug)]
                pub struct ByteSetIter<'a>
                {
                    set: &'a ByteSet,
                    b: usize,
                }
                
                impl<'a> Iterator for ByteSetIter<'a>
                {
                    type Item = u8;
                
                    fn next(&mut self) -> Option<u8> {
                        while self.b <= 255 {
                            let b = u8::try_from(self.b).unwrap();
                            self.b += 1;
                            if self.set.contains(b) {
                                return Some(b);
                            }
                        }
                        None
                    }
                }
                
                #[derive(Debug)]
                pub struct ByteSetRangeIter<'a>
                {
                    set: &'a ByteSet,
                    b: usize,
                }
                
                impl<'a> Iterator for ByteSetRangeIter<'a>
                {
                    type Item = (u8, u8);
                
                    fn next(&mut self) -> Option<(u8, u8)> {
                        let asu8 = |n: usize| u8::try_from(n).unwrap();
                        while self.b <= 255 {
                            let start = asu8(self.b);
                            self.b += 1;
                            if !self.set.contains(start) {
                                continue;
                            }
                
                            let mut end = start;
                            while self.b <= 255 && self.set.contains(asu8(self.b)) {
                                end = asu8(self.b);
                                self.b += 1;
                            }
                            return Some((start, end));
                        }
                        None
                    }
                }
            }

            pub mod captures
            {
                //! Provides types for dealing with capturing groups.
                use ::
                {
                    *,
                };
                /*
                use ::{string::String, sync::Arc, vec, vec::Vec};
                
                use crate::util::{
                    interpolate,
                    primitives::{
                        NonMaxUsize, PatternID, PatternIDError, PatternIDIter, SmallIndex,
                    },
                    search::{Match, Span},
                };
                */
                /// The span offsets of capturing groups after a match has been found.
                #[derive(Clone)]
                pub struct Captures {
                    /// The group info that these capture groups are coupled to. This is what
                    /// gives the "convenience" of the `Captures` API.
                    group_info: GroupInfo,
                    /// The ID of the pattern that matched. Regex engines must set this to
                    /// None when no match occurs.
                    pid: Option<PatternID>,
                    /// The slot values, i.e., submatch offsets.
                    slots: Vec<Option<NonMaxUsize>>,
                }
                
                impl Captures {
                    /// Create new storage for the offsets of all matching capturing groups.
                    pub fn all(group_info: GroupInfo) -> Captures {
                        let slots = group_info.slot_len();
                        Captures { group_info, pid: None, slots: vec![None; slots] }
                    }
                
                    /// Create new storage for only the full match spans of a pattern.
                    pub fn matches(group_info: GroupInfo) -> Captures {
                        let slots = group_info.pattern_len().checked_mul(2).unwrap();
                        Captures { group_info, pid: None, slots: vec![None; slots] }
                    }
                
                    /// Create new storage for only tracking which pattern matched. No offsets
                    /// are stored at all.
                    pub fn empty(group_info: GroupInfo) -> Captures {
                        Captures { group_info, pid: None, slots: vec![] }
                    }
                
                    /// Returns true if and only if this capturing group represents a match.
                    #[inline]
                    pub fn is_match(&self) -> bool {
                        self.pid.is_some()
                    }
                
                    /// Returns the identifier of the pattern that matched when this
                    /// capturing group represents a match.
                    #[inline]
                    pub fn pattern(&self) -> Option<PatternID> {
                        self.pid
                    }
                
                    /// Returns the pattern ID and the span of the match, if one occurred.
                    #[inline]
                    pub fn get_match(&self) -> Option<Match> {
                        Some(Match::new(self.pattern()?, self.get_group(0)?))
                    }
                
                    /// Returns the span of a capturing group match corresponding to the group
                    /// index given, only if both the overall pattern matched and the capturing
                    /// group participated in that match.
                    #[inline]
                    pub fn get_group(&self, index: usize) -> Option<Span> {
                        let pid = self.pattern()?;
                        let (slot_start, slot_end) = if self.group_info().pattern_len() == 1 {
                            (index.checked_mul(2)?, index.checked_mul(2)?.checked_add(1)?)
                        } else {
                            self.group_info().slots(pid, index)?
                        };
                        let start = self.slots.get(slot_start).copied()??;
                        let end = self.slots.get(slot_end).copied()??;
                        Some(Span { start: start.get(), end: end.get() })
                    }
                
                    /// Returns the span of a capturing group match corresponding to the group
                    /// name given, only if both the overall pattern matched and the capturing
                    /// group participated in that match.
                    pub fn get_group_by_name(&self, name: &str) -> Option<Span> {
                        let index = self.group_info().to_index(self.pattern()?, name)?;
                        self.get_group(index)
                    }
                
                    /// Returns an iterator of possible spans for every capturing group in the
                    /// matching pattern.
                    pub fn iter(&self) -> CapturesPatternIter<'_> {
                        let names = self
                            .pattern()
                            .map_or(GroupInfoPatternNames::empty().enumerate(), |pid| {
                                self.group_info().pattern_names(pid).enumerate()
                            });
                        CapturesPatternIter { caps: self, names }
                    }
                
                    /// Return the total number of capturing groups for the matching pattern.
                    pub fn group_len(&self) -> usize {
                        let pid = match self.pattern() {
                            None => return 0,
                            Some(pid) => pid,
                        };
                        self.group_info().group_len(pid)
                    }
                
                    /// Returns a reference to the underlying group info on which these
                    /// captures are based.
                    pub fn group_info(&self) -> &GroupInfo {
                        &self.group_info
                    }
                
                    /// Interpolates the capture references in `replacement` with the
                    /// corresponding substrings in `haystack` matched by each reference.
                    pub fn interpolate_string(
                        &self,
                        haystack: &str,
                        replacement: &str,
                    ) -> String {
                        let mut dst = String::new();
                        self.interpolate_string_into(haystack, replacement, &mut dst);
                        dst
                    }
                
                    /// Interpolates the capture references in `replacement` with the
                    /// corresponding substrings in `haystack` matched by each reference.
                    pub fn interpolate_string_into(
                        &self,
                        haystack: &str,
                        replacement: &str,
                        dst: &mut String,
                    ) {
                        interpolate::string(
                            replacement,
                            |index, dst| {
                                let span = match self.get_group(index) {
                                    None => return,
                                    Some(span) => span,
                                };
                                dst.push_str(&haystack[span]);
                            },
                            |name| self.group_info().to_index(self.pattern()?, name),
                            dst,
                        );
                    }
                
                    /// Interpolates the capture references in `replacement` with the
                    /// corresponding substrings in `haystack` matched by each reference.
                    pub fn interpolate_bytes(
                        &self,
                        haystack: &[u8],
                        replacement: &[u8],
                    ) -> Vec<u8> {
                        let mut dst = vec![];
                        self.interpolate_bytes_into(haystack, replacement, &mut dst);
                        dst
                    }
                
                    /// Interpolates the capture references in `replacement` with the
                    /// corresponding substrings in `haystack` matched by each reference
                    pub fn interpolate_bytes_into(
                        &self,
                        haystack: &[u8],
                        replacement: &[u8],
                        dst: &mut Vec<u8>,
                    ) {
                        interpolate::bytes(
                            replacement,
                            |index, dst| {
                                let span = match self.get_group(index) {
                                    None => return,
                                    Some(span) => span,
                                };
                                dst.extend_from_slice(&haystack[span]);
                            },
                            |name| self.group_info().to_index(self.pattern()?, name),
                            dst,
                        );
                    }
                
                    /// This is a convenience routine for extracting the substrings
                    /// corresponding to matching capture groups in the given `haystack`.
                    pub fn extract<'h, const N: usize>(
                        &self,
                        haystack: &'h str,
                    ) -> (&'h str, [&'h str; N]) {
                        let mut matched = self.iter().flatten();
                        let whole_match = &haystack[matched.next().expect("a match")];
                        let group_matches = [0; N].map(|_| {
                            let sp = matched.next().expect("too few matching groups");
                            &haystack[sp]
                        });
                        (whole_match, group_matches)
                    }
                
                    /// This is a convenience routine for extracting the substrings
                    /// corresponding to matching capture groups in the given `haystack`
                    pub fn extract_bytes<'h, const N: usize>(
                        &self,
                        haystack: &'h [u8],
                    ) -> (&'h [u8], [&'h [u8]; N]) {
                        let mut matched = self.iter().flatten();
                        let whole_match = &haystack[matched.next().expect("a match")];
                        let group_matches = [0; N].map(|_| {
                            let sp = matched.next().expect("too few matching groups");
                            &haystack[sp]
                        });
                        (whole_match, group_matches)
                    }
                }
                
                /// Lower level "slot" oriented APIs.
                impl Captures {
                    /// Clear this `Captures` value.
                    #[inline]
                    pub fn clear(&mut self) {
                        self.pid = None;
                        for slot in self.slots.iter_mut() {
                            *slot = None;
                        }
                    }
                
                    /// Set the pattern on this `Captures` value.
                    #[inline]
                    pub fn set_pattern(&mut self, pid: Option<PatternID>) {
                        self.pid = pid;
                    }
                
                    /// Returns the underlying slots, where each slot stores a single offset.
                    #[inline]
                    pub fn slots(&self) -> &[Option<NonMaxUsize>] {
                        &self.slots
                    }
                
                    /// Returns the underlying slots as a mutable slice, where each slot stores
                    /// a single offset.
                    #[inline]
                    pub fn slots_mut(&mut self) -> &mut [Option<NonMaxUsize>] {
                        &mut self.slots
                    }
                }
                
                impl ::fmt::Debug for Captures {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        let mut dstruct = f.debug_struct("Captures");
                        dstruct.field("pid", &self.pid);
                        if let Some(pid) = self.pid {
                            dstruct.field("spans", &CapturesDebugMap { pid, caps: self });
                        }
                        dstruct.finish()
                    }
                }
                
                /// A little helper type to provide a nice map-like debug representation for
                /// our capturing group spans.
                struct CapturesDebugMap<'a> {
                    pid: PatternID,
                    caps: &'a Captures,
                }
                
                impl<'a> ::fmt::Debug for CapturesDebugMap<'a> {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        struct Key<'a>(usize, Option<&'a str>);
                
                        impl<'a> ::fmt::Debug for Key<'a> {
                            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                                write!(f, "{}", self.0)?;
                                if let Some(name) = self.1 {
                                    write!(f, "/{:?}", name)?;
                                }
                                Ok(())
                            }
                        }
                
                        let mut map = f.debug_map();
                        let names = self.caps.group_info().pattern_names(self.pid);
                        for (group_index, maybe_name) in names.enumerate() {
                            let key = Key(group_index, maybe_name);
                            match self.caps.get_group(group_index) {
                                None => map.entry(&key, &None::<()>),
                                Some(span) => map.entry(&key, &span),
                            };
                        }
                        map.finish()
                    }
                }
                
                /// An iterator over all capturing groups in a `Captures` value.
                #[derive(Clone, Debug)]
                pub struct CapturesPatternIter<'a> {
                    caps: &'a Captures,
                    names: ::iter::Enumerate<GroupInfoPatternNames<'a>>,
                }
                
                impl<'a> Iterator for CapturesPatternIter<'a> {
                    type Item = Option<Span>;
                
                    fn next(&mut self) -> Option<Option<Span>> {
                        let (group_index, _) = self.names.next()?;
                        Some(self.caps.get_group(group_index))
                    }
                
                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.names.size_hint()
                    }
                
                    fn count(self) -> usize {
                        self.names.count()
                    }
                }
                
                impl<'a> ExactSizeIterator for CapturesPatternIter<'a> {}
                impl<'a> ::iter::FusedIterator for CapturesPatternIter<'a> {}
                
                /// Represents information about capturing groups in a compiled regex.
                #[derive(Clone, Debug, Default)]
                pub struct GroupInfo(Arc<GroupInfoInner>);
                
                impl GroupInfo {
                    /// Creates a new group info from a sequence of patterns, where each
                    /// sequence of patterns yields a sequence of possible group names.
                    pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>
                    where
                        P: IntoIterator<Item = G>,
                        G: IntoIterator<Item = Option<N>>,
                        N: AsRef<str>,
                    {
                        let mut group_info = GroupInfoInner {
                            slot_ranges: vec![],
                            name_to_index: vec![],
                            index_to_name: vec![],
                            memory_extra: 0,
                        };
                        for (pattern_index, groups) in pattern_groups.into_iter().enumerate() {
                            let pid = PatternID::new(pattern_index)
                                .map_err(GroupInfoError::too_many_patterns)?;
                
                            let mut groups_iter = groups.into_iter().enumerate();
                            match groups_iter.next() {
                                None => return Err(GroupInfoError::missing_groups(pid)),
                                Some((_, Some(_))) => {
                                    return Err(GroupInfoError::first_must_be_unnamed(pid))
                                }
                                Some((_, None)) => {}
                            }
                            group_info.add_first_group(pid);
                            
                            for (group_index, maybe_name) in groups_iter {
                                let group = SmallIndex::new(group_index).map_err(|_| {
                                    GroupInfoError::too_many_groups(pid, group_index)
                                })?;
                                group_info.add_explicit_group(pid, group, maybe_name)?;
                            }
                        }
                        group_info.fixup_slot_ranges()?;
                        Ok(GroupInfo(Arc::new(group_info)))
                    }
                
                    /// This creates an empty `GroupInfo`.
                    pub fn empty() -> GroupInfo {
                        GroupInfo::new(::iter::empty::<[Option<&str>; 0]>())
                            .expect("empty group info is always valid")
                    }
                
                    /// Return the capture group index corresponding to the given name in the
                    /// given pattern.
                    #[inline]
                    pub fn to_index(&self, pid: PatternID, name: &str) -> Option<usize> {
                        let indices = self.0.name_to_index.get(pid.as_usize())?;
                        indices.get(name).cloned().map(|i| i.as_usize())
                    }
                
                    /// Return the capture name for the given index and given pattern
                    #[inline]
                    pub fn to_name(&self, pid: PatternID, group_index: usize) -> Option<&str> {
                        let pattern_names = self.0.index_to_name.get(pid.as_usize())?;
                        pattern_names.get(group_index)?.as_deref()
                    }
                
                    /// Return an iterator of all capture groups and their names (if present)
                    /// for a particular pattern.
                    #[inline]
                    pub fn pattern_names(&self, pid: PatternID) -> GroupInfoPatternNames<'_> {
                        GroupInfoPatternNames {
                            it: self
                                .0
                                .index_to_name
                                .get(pid.as_usize())
                                .map(|indices| indices.iter())
                                .unwrap_or([].iter()),
                        }
                    }
                
                    /// Return an iterator of all capture groups for all patterns supported by
                    /// this `GroupInfo`.
                    #[inline]
                    pub fn all_names(&self) -> GroupInfoAllNames<'_> {
                        GroupInfoAllNames {
                            group_info: self,
                            pids: PatternID::iter(self.pattern_len()),
                            current_pid: None,
                            names: None,
                        }
                    }
                
                    /// Returns the starting and ending slot corresponding to the given
                    /// capturing group for the given pattern.
                    #[inline]
                    pub fn slots(
                        &self,
                        pid: PatternID,
                        group_index: usize,
                    ) -> Option<(usize, usize)> {
                        self.slot(pid, group_index).map(|start| (start, start + 1))
                    }
                
                    /// Returns the starting slot corresponding to the given capturing group
                    /// for the given pattern.
                    #[inline]
                    pub fn slot(&self, pid: PatternID, group_index: usize) -> Option<usize> {
                        if group_index >= self.group_len(pid) {
                            return None;
                        }
                        
                        if group_index == 0 {
                            Some(pid.as_usize() * 2)
                        } else {
                            let (start, _) = self.0.slot_ranges[pid];
                            Some(start.as_usize() + ((group_index - 1) * 2))
                        }
                    }
                
                    /// Returns the total number of patterns in this `GroupInfo`.
                    #[inline]
                    pub fn pattern_len(&self) -> usize {
                        self.0.pattern_len()
                    }
                
                    /// Return the number of capture groups in a pattern.
                    #[inline]
                    pub fn group_len(&self, pid: PatternID) -> usize {
                        self.0.group_len(pid)
                    }
                
                    /// Return the total number of capture groups across all patterns.
                    #[inline]
                    pub fn all_group_len(&self) -> usize {
                        self.slot_len() / 2
                    }
                
                    /// Returns the total number of slots in this `GroupInfo` across all
                    /// patterns.
                    #[inline]
                    pub fn slot_len(&self) -> usize {
                        self.0.small_slot_len().as_usize()
                    }
                
                    /// Returns the total number of slots for implicit capturing groups.
                    #[inline]
                    pub fn implicit_slot_len(&self) -> usize {
                        self.pattern_len() * 2
                    }
                
                    /// Returns the total number of slots for explicit capturing groups.
                    #[inline]
                    pub fn explicit_slot_len(&self) -> usize {
                        self.slot_len().saturating_sub(self.implicit_slot_len())
                    }
                
                    /// Returns the memory usage, in bytes, of this `GroupInfo`.
                    #[inline]
                    pub fn memory_usage(&self) -> usize {
                        use ::mem::size_of as s;
                
                        s::<GroupInfoInner>()
                            + self.0.slot_ranges.len() * s::<(SmallIndex, SmallIndex)>()
                            + self.0.name_to_index.len() * s::<CaptureNameMap>()
                            + self.0.index_to_name.len() * s::<Vec<Option<Arc<str>>>>()
                            + self.0.memory_extra
                    }
                }
                
                /// A map from capture group name to its corresponding capture group index.
                
                type CaptureNameMap = ::collections::HashMap<Arc<str>, SmallIndex>;
                #[cfg(not(feature = "std"))]
                type CaptureNameMap = ::collections::BTreeMap<Arc<str>, SmallIndex>;
                
                /// The inner guts of `GroupInfo`.
                #[derive(Debug, Default)]
                struct GroupInfoInner {
                    slot_ranges: Vec<(SmallIndex, SmallIndex)>,
                    name_to_index: Vec<CaptureNameMap>,
                    index_to_name: Vec<Vec<Option<Arc<str>>>>,
                    memory_extra: usize,
                }
                
                impl GroupInfoInner {
                    /// This adds the first unnamed group for the given pattern ID.
                    fn add_first_group(&mut self, pid: PatternID) {
                        assert_eq!(pid.as_usize(), self.slot_ranges.len());
                        assert_eq!(pid.as_usize(), self.name_to_index.len());
                        assert_eq!(pid.as_usize(), self.index_to_name.len());
                        let slot_start = self.small_slot_len();
                        self.slot_ranges.push((slot_start, slot_start));
                        self.name_to_index.push(CaptureNameMap::new());
                        self.index_to_name.push(vec![None]);
                        self.memory_extra += ::mem::size_of::<Option<Arc<str>>>();
                    }
                
                    /// Add an explicit capturing group for the given pattern with the given
                    /// index.
                    fn add_explicit_group<N: AsRef<str>>(
                        &mut self,
                        pid: PatternID,
                        group: SmallIndex,
                        maybe_name: Option<N>,
                    ) -> Result<(), GroupInfoError> {
                        let end = &mut self.slot_ranges[pid].1;
                        *end = SmallIndex::new(end.as_usize() + 2).map_err(|_| {
                            GroupInfoError::too_many_groups(pid, group.as_usize())
                        })?;
                        if let Some(name) = maybe_name {
                            let name = Arc::<str>::from(name.as_ref());
                            if self.name_to_index[pid].contains_key(&*name) {
                                return Err(GroupInfoError::duplicate(pid, &name));
                            }
                            let len = name.len();
                            self.name_to_index[pid].insert(Arc::clone(&name), group);
                            self.index_to_name[pid].push(Some(name));
                            self.memory_extra +=
                                2 * (len + ::mem::size_of::<Option<Arc<str>>>());
                            self.memory_extra += ::mem::size_of::<SmallIndex>();
                        } else {
                            self.index_to_name[pid].push(None);
                            self.memory_extra += ::mem::size_of::<Option<Arc<str>>>();
                        }
                        assert_eq!(group.one_more(), self.group_len(pid));
                        assert_eq!(group.one_more(), self.index_to_name[pid].len());
                        Ok(())
                    }
                
                    /// This corrects the slot ranges to account for the slots corresponding
                    /// to the zeroth group of each pattern.
                    fn fixup_slot_ranges(&mut self) -> Result<(), GroupInfoError> {
                        use crate::util::primitives::IteratorIndexExt;
                        
                        let offset = self.pattern_len().checked_mul(2).unwrap();
                        for (pid, &mut (ref mut start, ref mut end)) in
                            self.slot_ranges.iter_mut().with_pattern_ids()
                        {
                            let group_len = 1 + ((end.as_usize() - start.as_usize()) / 2);
                            let new_end = match end.as_usize().checked_add(offset) {
                                Some(new_end) => new_end,
                                None => {
                                    return Err(GroupInfoError::too_many_groups(
                                        pid, group_len,
                                    ))
                                }
                            };
                            *end = SmallIndex::new(new_end).map_err(|_| {
                                GroupInfoError::too_many_groups(pid, group_len)
                            })?;
                            
                            *start = SmallIndex::new(start.as_usize() + offset).unwrap();
                        }
                        Ok(())
                    }
                
                    /// Return the total number of patterns represented by this capture slot
                    /// info.
                    fn pattern_len(&self) -> usize {
                        self.slot_ranges.len()
                    }
                
                    /// Return the total number of capturing groups for the given pattern.
                    fn group_len(&self, pid: PatternID) -> usize {
                        let (start, end) = match self.slot_ranges.get(pid.as_usize()) {
                            None => return 0,
                            Some(range) => range,
                        };
                        
                        1 + ((end.as_usize() - start.as_usize()) / 2)
                    }
                
                    /// Return the total number of slots in this capture slot info as a
                    /// "small index."
                    fn small_slot_len(&self) -> SmallIndex {
                        self.slot_ranges.last().map_or(SmallIndex::ZERO, |&(_, end)| end)
                    }
                }
                
                /// An error that may occur when building a `GroupInfo`.
                #[derive(Clone, Debug)]
                pub struct GroupInfoError {
                    kind: GroupInfoErrorKind,
                }
                
                /// The kind of error that occurs when building a `GroupInfo` fails.
                #[derive(Clone, Debug)]
                enum GroupInfoErrorKind {
                    /// This occurs when too many patterns have been added.
                    TooManyPatterns { err: PatternIDError },
                    /// This occurs when too many capturing groups have been added for a
                    /// particular pattern.
                    TooManyGroups {
                        /// The ID of the pattern that had too many groups.
                        pattern: PatternID,
                        /// The minimum number of groups that the caller has tried to add for
                        /// a pattern.
                        minimum: usize,
                    },
                    /// An error that occurs when a pattern has no capture groups.
                    MissingGroups {
                        /// The ID of the pattern that had no capturing groups.
                        pattern: PatternID,
                    },
                    /// An error that occurs when one tries to provide a name for the capture
                    /// group at index 0. This capturing group must currently always be
                    /// unnamed.
                    FirstMustBeUnnamed {
                        /// The ID of the pattern that was found to have a named first
                        /// capturing group.
                        pattern: PatternID,
                    },
                    /// An error that occurs when duplicate capture group names for the same
                    /// pattern are added.
                    Duplicate {
                        /// The pattern in which the duplicate capture group name was found.
                        pattern: PatternID,
                        /// The duplicate name.
                        name: String,
                    },
                }
                
                impl GroupInfoError {
                    fn too_many_patterns(err: PatternIDError) -> GroupInfoError {
                        GroupInfoError { kind: GroupInfoErrorKind::TooManyPatterns { err } }
                    }
                
                    fn too_many_groups(pattern: PatternID, minimum: usize) -> GroupInfoError {
                        GroupInfoError {
                            kind: GroupInfoErrorKind::TooManyGroups { pattern, minimum },
                        }
                    }
                
                    fn missing_groups(pattern: PatternID) -> GroupInfoError {
                        GroupInfoError { kind: GroupInfoErrorKind::MissingGroups { pattern } }
                    }
                
                    fn first_must_be_unnamed(pattern: PatternID) -> GroupInfoError {
                        GroupInfoError {
                            kind: GroupInfoErrorKind::FirstMustBeUnnamed { pattern },
                        }
                    }
                
                    fn duplicate(pattern: PatternID, name: &str) -> GroupInfoError {
                        GroupInfoError {
                            kind: GroupInfoErrorKind::Duplicate {
                                pattern,
                                name: String::from(name),
                            },
                        }
                    }
                }
                
                
                impl ::error::Error for GroupInfoError {
                    fn source(&self) -> Option<&(dyn ::error::Error + 'static)> {
                        match self.kind {
                            GroupInfoErrorKind::TooManyPatterns { .. }
                            | GroupInfoErrorKind::TooManyGroups { .. }
                            | GroupInfoErrorKind::MissingGroups { .. }
                            | GroupInfoErrorKind::FirstMustBeUnnamed { .. }
                            | GroupInfoErrorKind::Duplicate { .. } => None,
                        }
                    }
                }
                
                impl ::fmt::Display for GroupInfoError {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        use self::GroupInfoErrorKind::*;
                
                        match self.kind {
                            TooManyPatterns { ref err } => {
                                write!(f, "too many patterns to build capture info: {}", err)
                            }
                            TooManyGroups { pattern, minimum } => {
                                write!(
                                    f,
                                    "too many capture groups (at least {}) were \
                                     found for pattern {}",
                                    minimum,
                                    pattern.as_usize()
                                )
                            }
                            MissingGroups { pattern } => write!(
                                f,
                                "no capturing groups found for pattern {} \
                                 (either all patterns have zero groups or all patterns have \
                                  at least one group)",
                                pattern.as_usize(),
                            ),
                            FirstMustBeUnnamed { pattern } => write!(
                                f,
                                "first capture group (at index 0) for pattern {} has a name \
                                 (it must be unnamed)",
                                pattern.as_usize(),
                            ),
                            Duplicate { pattern, ref name } => write!(
                                f,
                                "duplicate capture group name '{}' found for pattern {}",
                                name,
                                pattern.as_usize(),
                            ),
                        }
                    }
                }
                
                /// An iterator over capturing groups and their names for a specific pattern.
                #[derive(Clone, Debug)]
                pub struct GroupInfoPatternNames<'a> {
                    it: ::slice::Iter<'a, Option<Arc<str>>>,
                }
                
                impl GroupInfoPatternNames<'static> {
                    fn empty() -> GroupInfoPatternNames<'static> {
                        GroupInfoPatternNames { it: [].iter() }
                    }
                }
                
                impl<'a> Iterator for GroupInfoPatternNames<'a> {
                    type Item = Option<&'a str>;
                
                    fn next(&mut self) -> Option<Option<&'a str>> {
                        self.it.next().map(|x| x.as_deref())
                    }
                
                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.it.size_hint()
                    }
                
                    fn count(self) -> usize {
                        self.it.count()
                    }
                }
                
                impl<'a> ExactSizeIterator for GroupInfoPatternNames<'a> {}
                impl<'a> ::iter::FusedIterator for GroupInfoPatternNames<'a> {}
                
                /// An iterator over capturing groups and their names for a `GroupInfo`.
                #[derive(Debug)]
                pub struct GroupInfoAllNames<'a> {
                    group_info: &'a GroupInfo,
                    pids: PatternIDIter,
                    current_pid: Option<PatternID>,
                    names: Option<::iter::Enumerate<GroupInfoPatternNames<'a>>>,
                }
                
                impl<'a> Iterator for GroupInfoAllNames<'a> {
                    type Item = (PatternID, usize, Option<&'a str>);
                
                    fn next(&mut self) -> Option<(PatternID, usize, Option<&'a str>)> {
                        if self.group_info.0.index_to_name.is_empty() {
                            return None;
                        }
                        if self.current_pid.is_none() {
                            self.current_pid = Some(self.pids.next()?);
                        }
                        let pid = self.current_pid.unwrap();
                        if self.names.is_none() {
                            self.names = Some(self.group_info.pattern_names(pid).enumerate());
                        }
                        let (group_index, name) = match self.names.as_mut().unwrap().next() {
                            Some((group_index, name)) => (group_index, name),
                            None => {
                                self.current_pid = None;
                                self.names = None;
                                return self.next();
                            }
                        };
                        Some((pid, group_index, name))
                    }
                }
            }
            
            pub mod escape
            {
                //! Provides convenience routines for escaping raw bytes.
                use ::
                {
                    *,
                };
                /*
                use crate::util::utf8;
                */
                /// Provides a convenient `Debug` implementation for a `u8`.
                #[derive(Clone, Copy)]
                pub struct DebugByte(pub u8);
                
                impl ::fmt::Debug for DebugByte {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        if self.0 == b' ' {
                            return write!(f, "' '");
                        }
                        
                        let mut bytes = [0u8; 10];
                        let mut len = 0;
                        for (i, mut b) in ::ascii::escape_default(self.0).enumerate() {
                            if i >= 2 && b'a' <= b && b <= b'f' {
                                b -= 32;
                            }
                            bytes[len] = b;
                            len += 1;
                        }
                        write!(f, "{}", ::str::from_utf8(&bytes[..len]).unwrap())
                    }
                }
            }

            pub mod interpolate
            {
                //! Provides routines for interpolating capture group references.
                use ::
                {
                    *,
                };
                /*
                use ::{string::String, vec::Vec};
                
                use crate::util::mem::chr::memchr;
                */
                /// Accepts a replacement string and interpolates capture references with their
                /// corresponding values.
                pub fn string(
                    mut replacement: &str,
                    mut append: impl FnMut(usize, &mut String),
                    mut name_to_index: impl FnMut(&str) -> Option<usize>,
                    dst: &mut String,
                ) {
                    while !replacement.is_empty() {
                        match memchr(b'$', replacement.as_bytes()) {
                            None => break,
                            Some(i) => {
                                dst.push_str(&replacement[..i]);
                                replacement = &replacement[i..];
                            }
                        }
                        // Handle escaping of '$'.
                        if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {
                            dst.push_str("$");
                            replacement = &replacement[2..];
                            continue;
                        }
                        debug_assert!(!replacement.is_empty());
                        let cap_ref = match find_cap_ref(replacement.as_bytes()) {
                            Some(cap_ref) => cap_ref,
                            None => {
                                dst.push_str("$");
                                replacement = &replacement[1..];
                                continue;
                            }
                        };
                        replacement = &replacement[cap_ref.end..];
                        match cap_ref.cap {
                            Ref::Number(i) => append(i, dst),
                            Ref::Named(name) => {
                                if let Some(i) = name_to_index(name) {
                                    append(i, dst);
                                }
                            }
                        }
                    }
                    dst.push_str(replacement);
                }
                
                /// Accepts a replacement byte string and interpolates capture references with
                /// their corresponding values.
                pub fn bytes(
                    mut replacement: &[u8],
                    mut append: impl FnMut(usize, &mut Vec<u8>),
                    mut name_to_index: impl FnMut(&str) -> Option<usize>,
                    dst: &mut Vec<u8>,
                ) {
                    while !replacement.is_empty() {
                        match memchr(b'$', replacement) {
                            None => break,
                            Some(i) => {
                                dst.extend_from_slice(&replacement[..i]);
                                replacement = &replacement[i..];
                            }
                        }
                        // Handle escaping of '$'.
                        if replacement.get(1).map_or(false, |&b| b == b'$') {
                            dst.push(b'$');
                            replacement = &replacement[2..];
                            continue;
                        }
                        debug_assert!(!replacement.is_empty());
                        let cap_ref = match find_cap_ref(replacement) {
                            Some(cap_ref) => cap_ref,
                            None => {
                                dst.push(b'$');
                                replacement = &replacement[1..];
                                continue;
                            }
                        };
                        replacement = &replacement[cap_ref.end..];
                        match cap_ref.cap {
                            Ref::Number(i) => append(i, dst),
                            Ref::Named(name) => {
                                if let Some(i) = name_to_index(name) {
                                    append(i, dst);
                                }
                            }
                        }
                    }
                    dst.extend_from_slice(replacement);
                }
                
                /// `CaptureRef` represents a reference to a capture group inside some text.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                struct CaptureRef<'a> {
                    cap: Ref<'a>,
                    end: usize,
                }
                
                /// A reference to a capture group in some text.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                enum Ref<'a> {
                    Named(&'a str),
                    Number(usize),
                }
                
                impl<'a> From<&'a str> for Ref<'a> {
                    fn from(x: &'a str) -> Ref<'a> {
                        Ref::Named(x)
                    }
                }
                
                impl From<usize> for Ref<'static> {
                    fn from(x: usize) -> Ref<'static> {
                        Ref::Number(x)
                    }
                }
                
                /// Parses a possible reference to a capture group name in the given text,
                /// starting at the beginning of `replacement`.
                fn find_cap_ref(replacement: &[u8]) -> Option<CaptureRef<'_>> {
                    let mut i = 0;
                    let rep: &[u8] = replacement;
                    if rep.len() <= 1 || rep[0] != b'$' {
                        return None;
                    }
                    i += 1;
                    if rep[i] == b'{' {
                        return find_cap_ref_braced(rep, i + 1);
                    }
                    let mut cap_end = i;
                    while rep.get(cap_end).copied().map_or(false, is_valid_cap_letter) {
                        cap_end += 1;
                    }
                    if cap_end == i {
                        return None;
                    }
                    
                    let cap = ::str::from_utf8(&rep[i..cap_end])
                        .expect("valid UTF-8 capture name");
                    Some(CaptureRef {
                        cap: match cap.parse::<usize>() {
                            Ok(i) => Ref::Number(i),
                            Err(_) => Ref::Named(cap),
                        },
                        end: cap_end,
                    })
                }
                
                /// Looks for a braced reference, e.g., `${foo1}`.
                fn find_cap_ref_braced(rep: &[u8], mut i: usize) -> Option<CaptureRef<'_>> {
                    assert_eq!(b'{', rep[i.checked_sub(1).unwrap()]);
                    let start = i;
                    while rep.get(i).map_or(false, |&b| b != b'}') {
                        i += 1;
                    }
                    if !rep.get(i).map_or(false, |&b| b == b'}') {
                        return None;
                    }
                    
                    let cap = match ::str::from_utf8(&rep[start..i]) {
                        Err(_) => return None,
                        Ok(cap) => cap,
                    };
                    Some(CaptureRef {
                        cap: match cap.parse::<usize>() {
                            Ok(i) => Ref::Number(i),
                            Err(_) => Ref::Named(cap),
                        },
                        end: i + 1,
                    })
                }
                
                /// Returns true if and only if the given byte is allowed in a capture name
                /// written in non-brace form.
                fn is_valid_cap_letter(b: u8) -> bool {
                    match b {
                        b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z' | b'_' => true,
                        _ => false,
                    }
                }
            }

            pub mod iter
            {
                //! Generic helpers for iteration of matches from a regex engine in a haystack.
                use ::
                {
                    *,
                };
                /*
                #[cfg(feature = "alloc")]
                use crate::util::captures::Captures;
                use crate::util::search::{HalfMatch, Input, Match, MatchError};
                */
                /// A searcher for creating iterators and performing lower level iteration.
                #[derive(Clone, Debug)]
                pub struct Searcher<'h>
                {
                    /// The input parameters to give to each regex engine call.
                    input: Input<'h>,
                    /// Records the end offset of the most recent match.
                    last_match_end: Option<usize>,
                }
                
                impl<'h> Searcher<'h>
                {
                    /// Create a new fallible non-overlapping matches iterator.
                    pub fn new(input: Input<'h>) -> Searcher<'h>
                    {
                        Searcher { input, last_match_end: None }
                    }
                    /// Returns the current `Input` used by this searcher.
                    pub fn input<'s>(&'s self) -> &'s Input<'h>
                    {
                        &self.input
                    }
                    /// Return the next half match for an infallible search if one exists, and advance to the next position.
                    #[inline] pub fn advance_half<F>(&mut self, finder: F) -> Option<HalfMatch> where
                    F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>                    {
                        match self.try_advance_half(finder) {
                            Ok(m) => m,
                            Err(err) => panic!(
                                "unexpected regex half find error: {}\n\
                                 to handle find errors, use 'try' or 'search' methods",
                                err,
                            ),
                        }
                    }
                    /// Return the next match for an infallible search if one exists, and advance to the next position.
                    #[inline] pub fn advance<F>(&mut self, finder: F) -> Option<Match> where
                    F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>
                    {
                        match self.try_advance(finder) {
                            Ok(m) => m,
                            Err(err) => panic!(
                                "unexpected regex find error: {}\n\
                                 to handle find errors, use 'try' or 'search' methods",
                                err,
                            ),
                        }
                    }
                    /// Return the next half match for a fallible search if one exists, and advance to the next position.
                    #[inline] pub fn try_advance_half<F>
                    (
                        
                        &mut self,
                        mut finder: F,
                    ) -> Result<Option<HalfMatch>, MatchError> where
                    F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>
                    {
                        let mut m = match finder(&self.input)? {
                            None => return Ok(None),
                            Some(m) => m,
                        };
                        if Some(m.offset()) == self.last_match_end {
                            m = match self.handle_overlapping_empty_half_match(m, finder)? {
                                None => return Ok(None),
                                Some(m) => m,
                            };
                        }
                        self.input.set_start(m.offset());
                        self.last_match_end = Some(m.offset());
                        Ok(Some(m))
                    }
                    /// Return the next match for a fallible search if one exists, and advance to the next position.
                    #[inline] pub fn try_advance<F>
                    (
                        
                        &mut self,
                        mut finder: F,
                    ) -> Result<Option<Match>, MatchError> where
                    F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>
                    {
                        let mut m = match finder(&self.input)? {
                            None => return Ok(None),
                            Some(m) => m,
                        };
                        if m.is_empty() && Some(m.end()) == self.last_match_end {
                            m = match self.handle_overlapping_empty_match(m, finder)? {
                                None => return Ok(None),
                                Some(m) => m,
                            };
                        }
                        self.input.set_start(m.end());
                        self.last_match_end = Some(m.end());
                        Ok(Some(m))
                    }
                    /// Given a closure that executes a single search, return an iterator over all successive non-overlapping half matches.
                    #[inline] pub fn into_half_matches_iter<F>
                    (
                        
                        self,
                        finder: F,
                    ) -> TryHalfMatchesIter<'h, F> where
                    F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>
                    {
                        TryHalfMatchesIter { it: self, finder }
                    }
                    /// Given a closure that executes a single search, return an iterator over all successive non-overlapping matches.
                    #[inline] pub fn into_matches_iter<F>(self, finder: F) -> TryMatchesIter<'h, F> where
                    F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>,
                    {
                        TryMatchesIter { it: self, finder }
                    }
                    /// Given a closure that executes a single search, return an iterator over
                    /// all successive non-overlapping `Captures` values.
                    #[inline]pub fn into_captures_iter<F>
                    (
                        
                        self,
                        caps: Captures,
                        finder: F,
                    ) -> TryCapturesIter<'h, F> where
                    F: FnMut(&Input<'_>, &mut Captures) -> Result<(), MatchError>
                    {
                        TryCapturesIter { it: self, caps, finder }
                    }
                    /// Handles the special case of a match that begins where the previous match ended.
                    #[cold] #[inline( never )] fn handle_overlapping_empty_half_match<F>
                    (
                        
                        &mut self,
                        _: HalfMatch,
                        mut finder: F,
                    ) -> Result<Option<HalfMatch>, MatchError> where
                    F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>
                    {
                        self.input.set_start(self.input.start().checked_add(1).unwrap());
                        finder(&self.input)
                    }
                    /// Handles the special case of an empty match by ensuring that 1) the
                    /// iterator always advances and 2) empty matches never overlap with other
                    /// matches.
                    #[cold] #[inline( never )] fn handle_overlapping_empty_match<F>
                    (
                        
                        &mut self,
                        m: Match,
                        mut finder: F,
                    ) -> Result<Option<Match>, MatchError> where
                    F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>
                    {
                        assert!(m.is_empty());
                        self.input.set_start(self.input.start().checked_add(1).unwrap());
                        finder(&self.input)
                    }
                }
                /// An iterator over all non-overlapping half matches for a fallible search.
                pub struct TryHalfMatchesIter<'h, F>
                {
                    it: Searcher<'h>,
                    finder: F,
                }
                
                impl<'h, F> TryHalfMatchesIter<'h, F> 
                {
                    /// Return an infallible version of this iterator.
                    pub fn infallible(self) -> HalfMatchesIter<'h, F>
                    {
                        HalfMatchesIter(self)
                    }                
                    /// Returns the current `Input` used by this iterator.
                    pub fn input<'i>(&'i self) -> &'i Input<'h>
                    {
                        self.it.input()
                    }
                }
                
                impl<'h, F> Iterator for TryHalfMatchesIter<'h, F> where
                F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>
                {
                    type Item = Result<HalfMatch, MatchError>;
                
                    #[inline]
                    fn next(&mut self) -> Option<Result<HalfMatch, MatchError>> {
                        self.it.try_advance_half(&mut self.finder).transpose()
                    }
                }
                
                impl<'h, F> ::fmt::Debug for TryHalfMatchesIter<'h, F>
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        f.debug_struct("TryHalfMatchesIter")
                            .field("it", &self.it)
                            .field("finder", &"<closure>")
                            .finish()
                    }
                }
                /// An iterator over all non-overlapping half matches for an infallible search.
                #[derive(Debug)]
                pub struct HalfMatchesIter<'h, F>(TryHalfMatchesIter<'h, F>);
                
                impl<'h, F> HalfMatchesIter<'h, F>
                {
                    /// Returns the current `Input` used by this iterator.
                    pub fn input<'i>(&'i self) -> &'i Input<'h> {
                        self.0.it.input()
                    }
                }
                
                impl<'h, F> Iterator for HalfMatchesIter<'h, F> where
                F: FnMut(&Input<'_>) -> Result<Option<HalfMatch>, MatchError>
                {
                    type Item = HalfMatch;
                
                    #[inline]
                    fn next(&mut self) -> Option<HalfMatch> {
                        match self.0.next()? {
                            Ok(m) => Some(m),
                            Err(err) => panic!(
                                "unexpected regex half find error: {}\n\
                                 to handle find errors, use 'try' or 'search' methods",
                                err,
                            ),
                        }
                    }
                }
                /// An iterator over all non-overlapping matches for a fallible search.
                pub struct TryMatchesIter<'h, F>
                {
                    it: Searcher<'h>,
                    finder: F,
                }
                
                impl<'h, F> TryMatchesIter<'h, F>
                {
                    /// Return an infallible version of this iterator.
                    pub fn infallible(self) -> MatchesIter<'h, F>
                    {
                        MatchesIter(self)
                    }
                    /// Returns the current `Input` used by this iterator.
                    pub fn input<'i>(&'i self) -> &'i Input<'h>
                    {
                        self.it.input()
                    }
                }
                
                impl<'h, F> Iterator for TryMatchesIter<'h, F> where
                F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>
                {
                    type Item = Result<Match, MatchError>;
                
                    #[inline]
                    fn next(&mut self) -> Option<Result<Match, MatchError>> {
                        self.it.try_advance(&mut self.finder).transpose()
                    }
                }
                
                impl<'h, F> ::fmt::Debug for TryMatchesIter<'h, F>
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        f.debug_struct("TryMatchesIter")
                            .field("it", &self.it)
                            .field("finder", &"<closure>")
                            .finish()
                    }
                }
                /// An iterator over all non-overlapping matches for an infallible search.
                #[derive(Debug)]
                pub struct MatchesIter<'h, F>(TryMatchesIter<'h, F>);
                
                impl<'h, F> MatchesIter<'h, F>
                {
                    /// Returns the current `Input` used by this iterator.
                    pub fn input<'i>(&'i self) -> &'i Input<'h>
                    {
                        self.0.it.input()
                    }
                }
                
                impl<'h, F> Iterator for MatchesIter<'h, F> where
                F: FnMut(&Input<'_>) -> Result<Option<Match>, MatchError>,
                {
                    type Item = Match;
                
                    #[inline]
                    fn next(&mut self) -> Option<Match> {
                        match self.0.next()? {
                            Ok(m) => Some(m),
                            Err(err) => panic!(
                                "unexpected regex find error: {}\n\
                                 to handle find errors, use 'try' or 'search' methods",
                                err,
                            ),
                        }
                    }
                }
                
                /// An iterator over all non-overlapping captures for a fallible search.
                pub struct TryCapturesIter<'h, F> {
                    it: Searcher<'h>,
                    caps: Captures,
                    finder: F,
                }
                
                impl<'h, F> TryCapturesIter<'h, F>
                {
                    /// Return an infallible version of this iterator.
                    pub fn infallible(self) -> CapturesIter<'h, F> {
                        CapturesIter(self)
                    }
                }
                
                impl<'h, F> Iterator for TryCapturesIter<'h, F> where
                F: FnMut(&Input<'_>, &mut Captures) -> Result<(), MatchError>,
                {
                    type Item = Result<Captures, MatchError>;
                
                    #[inline]
                    fn next(&mut self) -> Option<Result<Captures, MatchError>> {
                        let TryCapturesIter { ref mut it, ref mut caps, ref mut finder } =
                            *self;
                        let result = it
                            .try_advance(|input| {
                                (finder)(input, caps)?;
                                Ok(caps.get_match())
                            })
                            .transpose()?;
                        match result {
                            Ok(_) => Some(Ok(caps.clone())),
                            Err(err) => Some(Err(err)),
                        }
                    }
                }
                
                impl<'h, F> ::fmt::Debug for TryCapturesIter<'h, F>
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        f.debug_struct("TryCapturesIter")
                            .field("it", &self.it)
                            .field("caps", &self.caps)
                            .field("finder", &"<closure>")
                            .finish()
                    }
                }                
                /// An iterator over all non-overlapping captures for an infallible search.
                #[derive(Debug)]
                pub struct CapturesIter<'h, F>(TryCapturesIter<'h, F>);
                
                impl<'h, F> Iterator for CapturesIter<'h, F> where
                F: FnMut(&Input<'_>, &mut Captures) -> Result<(), MatchError>,
                {
                    type Item = Captures;
                
                    #[inline]
                    fn next(&mut self) -> Option<Captures> {
                        match self.0.next()? {
                            Ok(m) => Some(m),
                            Err(err) => panic!(
                                "unexpected regex captures error: {}\n\
                                 to handle find errors, use 'try' or 'search' methods",
                                err,
                            ),
                        }
                    }
                }
            }

            pub mod lazy
            {
                //! A lazily initialized value for safe sharing between threads.
                use ::
                {
                    *,
                };
                /*
                */
                ///
                /// A `Lazy` takes an initialization function and permits callers from any
                /// thread to access the result of that initialization function in a safe
                /// manner.
                pub struct Lazy<T, F = fn() -> T>(lazy::Lazy<T, F>);
                
                impl<T, F> Lazy<T, F> {
                    /// Create a new `Lazy` value that is initialized via the given function.
                    pub const fn new(create: F) -> Lazy<T, F> {
                        Lazy(lazy::Lazy::new(create))
                    }
                }
                
                impl<T, F: Fn() -> T> Lazy<T, F> {
                    /// Return a reference to the lazily initialized value.
                    pub fn get(this: &Lazy<T, F>) -> &T {
                        this.0.get()
                    }
                }
                
                impl<T, F: Fn() -> T> ::ops::Deref for Lazy<T, F> {
                    type Target = T;
                
                    fn deref(&self) -> &T {
                        Lazy::get(self)
                    }
                }
                
                impl<T: fmt::Debug, F: Fn() -> T> fmt::Debug for Lazy<T, F> {
                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                        self.0.fmt(f)
                    }
                }
                
                #[cfg(feature = "alloc")]
                mod lazy {
                    use ::{
                        fmt,
                        marker::PhantomData,
                        sync::atomic::{AtomicPtr, Ordering},
                    };
                
                    use ::boxed::Box;
                
                    /// A non-std lazy initialized value.
                    pub(super) struct Lazy<T, F> {
                        data: AtomicPtr<T>,
                        create: F,
                        owned: PhantomData<Box<T>>,
                    }
                
                    // SAFETY: So long as T and &T (and F and &F) can themselves be safely
                    // shared among threads, so to can a Lazy<T, _>.
                    unsafe impl<T: Send + Sync, F: Send + Sync> Sync for Lazy<T, F> {}
                
                    impl<T, F> Lazy<T, F> {
                        /// Create a new alloc but non-std lazy value that is racily
                        /// initialized.
                        pub(super) const fn new(create: F) -> Lazy<T, F> {
                            Lazy {
                                data: AtomicPtr::new(::ptr::null_mut()),
                                create,
                                owned: PhantomData,
                            }
                        }
                    }
                
                    impl<T, F: Fn() -> T> Lazy<T, F> {
                        /// Get the underlying lazy value.
                        pub fn get(&self) -> &T {
                            if let Some(data) = self.poll() {
                                return data;
                            }
                            let data = (self.create)();
                            let mut ptr = Box::into_raw(Box::new(data));
                            
                            let result = self.data.compare_exchange(
                                ::ptr::null_mut(),
                                ptr,
                                Ordering::AcqRel,
                                Ordering::Acquire,
                            );
                            if let Err(old) = result {
                                drop(unsafe { Box::from_raw(ptr) });
                                ptr = old;
                            }
                            
                            unsafe { &*ptr }
                        }
                
                        /// If this lazy value has been initialized successfully, then return
                        /// that value.
                        fn poll(&self) -> Option<&T> {
                            let ptr = self.data.load(Ordering::Acquire);
                            if ptr.is_null() {
                                return None;
                            }
                            Some(unsafe { &*ptr })
                        }
                    }
                
                    impl<T: fmt::Debug, F: Fn() -> T> fmt::Debug for Lazy<T, F> {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                            f.debug_struct("Lazy").field("data", &self.poll()).finish()
                        }
                    }
                
                    impl<T, F> Drop for Lazy<T, F> {
                        fn drop(&mut self) {
                            let ptr = *self.data.get_mut();
                            if !ptr.is_null() {
                                drop(unsafe { Box::from_raw(ptr) });
                            }
                        }
                    }
                }
            }

            pub mod look
            {
                //! Types and routines for working with look-around assertions.
                use ::
                {
                    *,
                };
                /*
                use crate::util::{escape::DebugByte, utf8};
                */
                /// An assertion matches at a position between characters in a haystack.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                pub enum Look
                {
                    /// Match the beginning of text.
                    Start = 1 << 0,
                    /// Match the end of text.
                    End = 1 << 1,
                    /// Match the beginning of a line or the beginning of text.
                    StartLF = 1 << 2,
                    /// Match the end of a line or the end of text.
                    EndLF = 1 << 3,
                    /// Match the beginning of a line or the beginning of text.
                    StartCRLF = 1 << 4,
                    /// Match the end of a line or the end of text.
                    EndCRLF = 1 << 5,
                    /// Match an ASCII-only word boundary.
                    WordAscii = 1 << 6,
                    /// Match an ASCII-only negation of a word boundary.
                    WordAsciiNegate = 1 << 7,
                    /// Match a Unicode-aware word boundary.
                    WordUnicode = 1 << 8,
                    /// Match a Unicode-aware negation of a word boundary.
                    WordUnicodeNegate = 1 << 9,
                    /// Match the start of an ASCII-only word boundary.
                    WordStartAscii = 1 << 10,
                    /// Match the end of an ASCII-only word boundary.
                    WordEndAscii = 1 << 11,
                    /// Match the start of a Unicode word boundary.
                    WordStartUnicode = 1 << 12,
                    /// Match the end of a Unicode word boundary.
                    WordEndUnicode = 1 << 13,
                    /// Match the start half of an ASCII-only word boundary.
                    WordStartHalfAscii = 1 << 14,
                    /// Match the end half of an ASCII-only word boundary.
                    WordEndHalfAscii = 1 << 15,
                    /// Match the start half of a Unicode word boundary.
                    WordStartHalfUnicode = 1 << 16,
                    /// Match the end half of a Unicode word boundary.
                    WordEndHalfUnicode = 1 << 17,
                }
                
                impl Look {
                    /// Flip the look-around assertion to its equivalent for reverse searches.
                    #[inline]
                    pub const fn reversed(self) -> Look {
                        match self {
                            Look::Start => Look::End,
                            Look::End => Look::Start,
                            Look::StartLF => Look::EndLF,
                            Look::EndLF => Look::StartLF,
                            Look::StartCRLF => Look::EndCRLF,
                            Look::EndCRLF => Look::StartCRLF,
                            Look::WordAscii => Look::WordAscii,
                            Look::WordAsciiNegate => Look::WordAsciiNegate,
                            Look::WordUnicode => Look::WordUnicode,
                            Look::WordUnicodeNegate => Look::WordUnicodeNegate,
                            Look::WordStartAscii => Look::WordEndAscii,
                            Look::WordEndAscii => Look::WordStartAscii,
                            Look::WordStartUnicode => Look::WordEndUnicode,
                            Look::WordEndUnicode => Look::WordStartUnicode,
                            Look::WordStartHalfAscii => Look::WordEndHalfAscii,
                            Look::WordEndHalfAscii => Look::WordStartHalfAscii,
                            Look::WordStartHalfUnicode => Look::WordEndHalfUnicode,
                            Look::WordEndHalfUnicode => Look::WordStartHalfUnicode,
                        }
                    }
                
                    /// Return the underlying representation of this look-around enumeration
                    /// as an integer.
                    #[inline]
                    pub const fn as_repr(self) -> u32 {
                        self as u32
                    }
                
                    /// Given the underlying representation of a `Look` value, return the
                    /// corresponding `Look` value if the representation is valid.
                    #[inline]
                    pub const fn from_repr(repr: u32) -> Option<Look> {
                        match repr {
                            0b00_0000_0000_0000_0001 => Some(Look::Start),
                            0b00_0000_0000_0000_0010 => Some(Look::End),
                            0b00_0000_0000_0000_0100 => Some(Look::StartLF),
                            0b00_0000_0000_0000_1000 => Some(Look::EndLF),
                            0b00_0000_0000_0001_0000 => Some(Look::StartCRLF),
                            0b00_0000_0000_0010_0000 => Some(Look::EndCRLF),
                            0b00_0000_0000_0100_0000 => Some(Look::WordAscii),
                            0b00_0000_0000_1000_0000 => Some(Look::WordAsciiNegate),
                            0b00_0000_0001_0000_0000 => Some(Look::WordUnicode),
                            0b00_0000_0010_0000_0000 => Some(Look::WordUnicodeNegate),
                            0b00_0000_0100_0000_0000 => Some(Look::WordStartAscii),
                            0b00_0000_1000_0000_0000 => Some(Look::WordEndAscii),
                            0b00_0001_0000_0000_0000 => Some(Look::WordStartUnicode),
                            0b00_0010_0000_0000_0000 => Some(Look::WordEndUnicode),
                            0b00_0100_0000_0000_0000 => Some(Look::WordStartHalfAscii),
                            0b00_1000_0000_0000_0000 => Some(Look::WordEndHalfAscii),
                            0b01_0000_0000_0000_0000 => Some(Look::WordStartHalfUnicode),
                            0b10_0000_0000_0000_0000 => Some(Look::WordEndHalfUnicode),
                            _ => None,
                        }
                    }
                
                    /// Returns a convenient single codepoint representation of this
                    /// look-around assertion.
                    #[inline]
                    pub const fn as_char(self) -> char {
                        match self {
                            Look::Start => 'A',
                            Look::End => 'z',
                            Look::StartLF => '^',
                            Look::EndLF => '$',
                            Look::StartCRLF => 'r',
                            Look::EndCRLF => 'R',
                            Look::WordAscii => 'b',
                            Look::WordAsciiNegate => 'B',
                            Look::WordUnicode => '',
                            Look::WordUnicodeNegate => '',
                            Look::WordStartAscii => '<',
                            Look::WordEndAscii => '>',
                            Look::WordStartUnicode => '',
                            Look::WordEndUnicode => '',
                            Look::WordStartHalfAscii => '',
                            Look::WordEndHalfAscii => '',
                            Look::WordStartHalfUnicode => '',
                            Look::WordEndHalfUnicode => '',
                        }
                    }
                }
                
                /// LookSet is a memory-efficient set of look-around assertions.
                #[derive(Clone, Copy, Default, Eq, PartialEq)]
                pub struct LookSet {
                    /// The underlying representation this set is exposed to make it possible
                    /// to store it somewhere efficiently.
                    pub bits: u32,
                }
                
                impl LookSet {
                    /// Create an empty set of look-around assertions.
                    #[inline]
                    pub fn empty() -> LookSet {
                        LookSet { bits: 0 }
                    }
                
                    /// Create a full set of look-around assertions.
                    #[inline]
                    pub fn full() -> LookSet {
                        LookSet { bits: !0 }
                    }
                
                    /// Create a look-around set containing the look-around assertion given.
                    #[inline]
                    pub fn singleton(look: Look) -> LookSet {
                        LookSet::empty().insert(look)
                    }
                
                    /// Returns the total number of look-around assertions in this set.
                    #[inline]
                    pub fn len(self) -> usize {
                        usize::try_from(self.bits.count_ones()).unwrap()
                    }
                
                    /// Returns true if and only if this set is empty.
                    #[inline]
                    pub fn is_empty(self) -> bool {
                        self.len() == 0
                    }
                
                    /// Returns true if and only if the given look-around assertion is in this
                    /// set.
                    #[inline]
                    pub fn contains(self, look: Look) -> bool {
                        self.bits & look.as_repr() != 0
                    }
                
                    /// Returns true if and only if this set contains any anchor assertions.
                    #[inline]
                    pub fn contains_anchor(&self) -> bool {
                        self.contains_anchor_haystack() || self.contains_anchor_line()
                    }
                
                    /// Returns true if and only if this set contains any "start/end of
                    /// haystack" anchors.
                    #[inline]
                    pub fn contains_anchor_haystack(&self) -> bool {
                        self.contains(Look::Start) || self.contains(Look::End)
                    }
                
                    /// Returns true if and only if this set contains any "start/end of line"
                    /// anchors.
                    #[inline]
                    pub fn contains_anchor_line(&self) -> bool {
                        self.contains(Look::StartLF)
                            || self.contains(Look::EndLF)
                            || self.contains(Look::StartCRLF)
                            || self.contains(Look::EndCRLF)
                    }
                
                    /// Returns true if and only if this set contains any "start/end of line"
                    /// anchors that only treat `\n` as line terminators.
                    #[inline]
                    pub fn contains_anchor_lf(&self) -> bool {
                        self.contains(Look::StartLF) || self.contains(Look::EndLF)
                    }
                
                    /// Returns true if and only if this set contains any "start/end of line"
                    /// anchors that are CRLF-aware.
                    #[inline]
                    pub fn contains_anchor_crlf(&self) -> bool {
                        self.contains(Look::StartCRLF) || self.contains(Look::EndCRLF)
                    }
                
                    /// Returns true if and only if this set contains any word boundary or
                    /// negated word boundary assertions.
                    #[inline]
                    pub fn contains_word(self) -> bool {
                        self.contains_word_unicode() || self.contains_word_ascii()
                    }
                
                    /// Returns true if and only if this set contains any Unicode word boundary
                    /// or negated Unicode word boundary assertions.
                    #[inline]
                    pub fn contains_word_unicode(self) -> bool {
                        self.contains(Look::WordUnicode)
                            || self.contains(Look::WordUnicodeNegate)
                            || self.contains(Look::WordStartUnicode)
                            || self.contains(Look::WordEndUnicode)
                            || self.contains(Look::WordStartHalfUnicode)
                            || self.contains(Look::WordEndHalfUnicode)
                    }
                
                    /// Returns true if and only if this set contains any ASCII word boundary
                    /// or negated ASCII word boundary assertions.
                    #[inline]
                    pub fn contains_word_ascii(self) -> bool {
                        self.contains(Look::WordAscii)
                            || self.contains(Look::WordAsciiNegate)
                            || self.contains(Look::WordStartAscii)
                            || self.contains(Look::WordEndAscii)
                            || self.contains(Look::WordStartHalfAscii)
                            || self.contains(Look::WordEndHalfAscii)
                    }
                
                    /// Returns an iterator over all of the look-around assertions in this set.
                    #[inline]
                    pub fn iter(self) -> LookSetIter {
                        LookSetIter { set: self }
                    }
                
                    /// Return a new set that is equivalent to the original, but with the given
                    /// assertion added to it.
                    #[inline]
                    pub fn insert(self, look: Look) -> LookSet {
                        LookSet { bits: self.bits | look.as_repr() }
                    }
                
                    /// Updates this set in place with the result of inserting the given
                    /// assertion into this set.
                    #[inline]
                    pub fn set_insert(&mut self, look: Look) {
                        *self = self.insert(look);
                    }
                
                    /// Return a new set that is equivalent to the original, but with the given
                    /// assertion removed from it. 
                    #[inline]
                    pub fn remove(self, look: Look) -> LookSet {
                        LookSet { bits: self.bits & !look.as_repr() }
                    }
                
                    /// Updates this set in place with the result of removing the given
                    /// assertion from this set.
                    #[inline]
                    pub fn set_remove(&mut self, look: Look) {
                        *self = self.remove(look);
                    }
                
                    /// Returns a new set that is the result of subtracting the given set from
                    /// this set.
                    #[inline]
                    pub fn subtract(self, other: LookSet) -> LookSet {
                        LookSet { bits: self.bits & !other.bits }
                    }
                
                    /// Updates this set in place with the result of subtracting the given set
                    /// from this set.
                    #[inline]
                    pub fn set_subtract(&mut self, other: LookSet) {
                        *self = self.subtract(other);
                    }
                
                    /// Returns a new set that is the union of this and the one given.
                    #[inline]
                    pub fn union(self, other: LookSet) -> LookSet {
                        LookSet { bits: self.bits | other.bits }
                    }
                
                    /// Updates this set in place with the result of unioning it with the one
                    /// given.
                    #[inline]
                    pub fn set_union(&mut self, other: LookSet) {
                        *self = self.union(other);
                    }
                
                    /// Returns a new set that is the intersection of this and the one given.
                    #[inline]
                    pub fn intersect(self, other: LookSet) -> LookSet {
                        LookSet { bits: self.bits & other.bits }
                    }
                
                    /// Updates this set in place with the result of intersecting it with the
                    /// one given.
                    #[inline]
                    pub fn set_intersect(&mut self, other: LookSet) {
                        *self = self.intersect(other);
                    }
                
                    /// Return a `LookSet` from the slice given as a native endian 32-bit
                    /// integer.
                    #[inline]
                    pub fn read_repr(slice: &[u8]) -> LookSet {
                        let bits = u32::from_ne_bytes(slice[..4].try_into().unwrap());
                        LookSet { bits }
                    }
                
                    /// Write a `LookSet` as a native endian 32-bit integer to the beginning
                    /// of the slice given.
                    #[inline]
                    pub fn write_repr(self, slice: &mut [u8]) {
                        let raw = self.bits.to_ne_bytes();
                        slice[0] = raw[0];
                        slice[1] = raw[1];
                        slice[2] = raw[2];
                        slice[3] = raw[3];
                    }
                
                    /// Checks that all assertions in this set can be matched.
                    pub fn available(self) -> Result<(), UnicodeWordBoundaryError> {
                        if self.contains_word_unicode() {
                            UnicodeWordBoundaryError::check()?;
                        }
                        Ok(())
                    }
                }
                
                impl ::fmt::Debug for LookSet {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        if self.is_empty() {
                            return write!(f, "");
                        }
                        for look in self.iter() {
                            write!(f, "{}", look.as_char())?;
                        }
                        Ok(())
                    }
                }
                
                /// An iterator over all look-around assertions in a [`LookSet`].
                #[derive(Clone, Debug)]
                pub struct LookSetIter {
                    set: LookSet,
                }
                
                impl Iterator for LookSetIter {
                    type Item = Look;
                
                    #[inline]
                    fn next(&mut self) -> Option<Look> {
                        if self.set.is_empty() {
                            return None;
                        }
                        
                        let bit = u16::try_from(self.set.bits.trailing_zeros()).unwrap();
                        let look = Look::from_repr(1 << bit)?;
                        self.set = self.set.remove(look);
                        Some(look)
                    }
                }
                
                /// A matcher for look-around assertions.
                #[derive(Clone, Debug)]
                pub struct LookMatcher {
                    lineterm: DebugByte,
                }
                
                impl LookMatcher {
                    /// Creates a new default matcher for look-around assertions.
                    pub fn new() -> LookMatcher {
                        LookMatcher { lineterm: DebugByte(b'\n') }
                    }
                
                    /// Sets the line terminator for use with `(?m:^)` and `(?m:$)`.
                    pub fn set_line_terminator(&mut self, byte: u8) -> &mut LookMatcher {
                        self.lineterm.0 = byte;
                        self
                    }
                
                    /// Returns the line terminator that was configured for this matcher.
                    pub fn get_line_terminator(&self) -> u8 {
                        self.lineterm.0
                    }
                
                    /// Returns true when the position `at` in `haystack` satisfies the given
                    /// look-around assertion.
                    #[inline]
                    pub fn matches(&self, look: Look, haystack: &[u8], at: usize) -> bool {
                        self.matches_inline(look, haystack, at)
                    }
                
                    /// Like `matches`, but forcefully inlined.
                    #[inline( always )]
                    pub fn matches_inline(
                        &self,
                        look: Look,
                        haystack: &[u8],
                        at: usize,
                    ) -> bool {
                        match look {
                            Look::Start => self.is_start(haystack, at),
                            Look::End => self.is_end(haystack, at),
                            Look::StartLF => self.is_start_lf(haystack, at),
                            Look::EndLF => self.is_end_lf(haystack, at),
                            Look::StartCRLF => self.is_start_crlf(haystack, at),
                            Look::EndCRLF => self.is_end_crlf(haystack, at),
                            Look::WordAscii => self.is_word_ascii(haystack, at),
                            Look::WordAsciiNegate => self.is_word_ascii_negate(haystack, at),
                            Look::WordUnicode => self.is_word_unicode(haystack, at).unwrap(),
                            Look::WordUnicodeNegate => {
                                self.is_word_unicode_negate(haystack, at).unwrap()
                            }
                            Look::WordStartAscii => self.is_word_start_ascii(haystack, at),
                            Look::WordEndAscii => self.is_word_end_ascii(haystack, at),
                            Look::WordStartUnicode => {
                                self.is_word_start_unicode(haystack, at).unwrap()
                            }
                            Look::WordEndUnicode => {
                                self.is_word_end_unicode(haystack, at).unwrap()
                            }
                            Look::WordStartHalfAscii => {
                                self.is_word_start_half_ascii(haystack, at)
                            }
                            Look::WordEndHalfAscii => {
                                self.is_word_end_half_ascii(haystack, at)
                            }
                            Look::WordStartHalfUnicode => {
                                self.is_word_start_half_unicode(haystack, at).unwrap()
                            }
                            Look::WordEndHalfUnicode => {
                                self.is_word_end_half_unicode(haystack, at).unwrap()
                            }
                        }
                    }
                
                    /// Returns true when _all_ of the assertions in the given set match at the
                    /// given position in the haystack.
                    #[inline]
                    pub fn matches_set(
                        &self,
                        set: LookSet,
                        haystack: &[u8],
                        at: usize,
                    ) -> bool {
                        self.matches_set_inline(set, haystack, at)
                    }
                
                    /// Like `LookSet::matches`, but forcefully inlined for perf.
                    #[inline( always )]
                    pub fn matches_set_inline(
                        &self,
                        set: LookSet,
                        haystack: &[u8],
                        at: usize,
                    ) -> bool {
                        if set.contains(Look::Start) {
                            if !self.is_start(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::End) {
                            if !self.is_end(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::StartLF) {
                            if !self.is_start_lf(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::EndLF) {
                            if !self.is_end_lf(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::StartCRLF) {
                            if !self.is_start_crlf(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::EndCRLF) {
                            if !self.is_end_crlf(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::WordAscii) {
                            if !self.is_word_ascii(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::WordAsciiNegate) {
                            if !self.is_word_ascii_negate(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::WordUnicode) {
                            if !self.is_word_unicode(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        if set.contains(Look::WordUnicodeNegate) {
                            if !self.is_word_unicode_negate(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        if set.contains(Look::WordStartAscii) {
                            if !self.is_word_start_ascii(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::WordEndAscii) {
                            if !self.is_word_end_ascii(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::WordStartUnicode) {
                            if !self.is_word_start_unicode(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        if set.contains(Look::WordEndUnicode) {
                            if !self.is_word_end_unicode(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        if set.contains(Look::WordStartHalfAscii) {
                            if !self.is_word_start_half_ascii(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::WordEndHalfAscii) {
                            if !self.is_word_end_half_ascii(haystack, at) {
                                return false;
                            }
                        }
                        if set.contains(Look::WordStartHalfUnicode) {
                            if !self.is_word_start_half_unicode(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        if set.contains(Look::WordEndHalfUnicode) {
                            if !self.is_word_end_half_unicode(haystack, at).unwrap() {
                                return false;
                            }
                        }
                        true
                    }
                
                    /// Split up the given byte classes into equivalence classes in a way that
                    /// is consistent with this look-around assertion.
                    #[cfg(feature = "alloc")]
                    pub fn add_to_byteset(
                        &self,
                        look: Look,
                        set: &mut crate::util::alphabet::ByteClassSet,
                    ) {
                        match look {
                            Look::Start | Look::End => {}
                            Look::StartLF | Look::EndLF => {
                                set.set_range(self.lineterm.0, self.lineterm.0);
                            }
                            Look::StartCRLF | Look::EndCRLF => {
                                set.set_range(b'\r', b'\r');
                                set.set_range(b'\n', b'\n');
                            }
                            Look::WordAscii
                            | Look::WordAsciiNegate
                            | Look::WordUnicode
                            | Look::WordUnicodeNegate
                            | Look::WordStartAscii
                            | Look::WordEndAscii
                            | Look::WordStartUnicode
                            | Look::WordEndUnicode
                            | Look::WordStartHalfAscii
                            | Look::WordEndHalfAscii
                            | Look::WordStartHalfUnicode
                            | Look::WordEndHalfUnicode => {
                                let iswb = utf8::is_word_byte;
                                let asu8 = |b: u16| u8::try_from(b).unwrap();
                                let mut b1: u16 = 0;
                                let mut b2: u16;
                                while b1 <= 255 {
                                    b2 = b1 + 1;
                                    while b2 <= 255 && iswb(asu8(b1)) == iswb(asu8(b2)) {
                                        b2 += 1;
                                    }
                                    assert!(b2 <= 256);
                                    set.set_range(asu8(b1), asu8(b2.checked_sub(1).unwrap()));
                                    b1 = b2;
                                }
                            }
                        }
                    }
                
                    /// Returns true when [`Look::Start`] is satisfied `at` the given position
                    /// in `haystack`.
                    #[inline]
                    pub fn is_start(&self, _haystack: &[u8], at: usize) -> bool {
                        at == 0
                    }
                
                    /// Returns true when [`Look::End`] is satisfied `at` the given position in
                    /// `haystack`.
                    #[inline]
                    pub fn is_end(&self, haystack: &[u8], at: usize) -> bool {
                        at == haystack.len()
                    }
                
                    /// Returns true when [`Look::StartLF`] is satisfied `at` the given
                    /// position in `haystack`.
                    #[inline]
                    pub fn is_start_lf(&self, haystack: &[u8], at: usize) -> bool {
                        self.is_start(haystack, at) || haystack[at - 1] == self.lineterm.0
                    }
                
                    /// Returns true when [`Look::EndLF`] is satisfied `at` the given position
                    /// in `haystack`.
                    #[inline]
                    pub fn is_end_lf(&self, haystack: &[u8], at: usize) -> bool {
                        self.is_end(haystack, at) || haystack[at] == self.lineterm.0
                    }
                
                    /// Returns true when [`Look::StartCRLF`] is satisfied `at` the given
                    /// position in `haystack`.
                    #[inline]
                    pub fn is_start_crlf(&self, haystack: &[u8], at: usize) -> bool {
                        self.is_start(haystack, at)
                            || haystack[at - 1] == b'\n'
                            || (haystack[at - 1] == b'\r'
                                && (at >= haystack.len() || haystack[at] != b'\n'))
                    }
                
                    /// Returns true when [`Look::EndCRLF`] is satisfied `at` the given
                    /// position in `haystack`.
                    #[inline]
                    pub fn is_end_crlf(&self, haystack: &[u8], at: usize) -> bool {
                        self.is_end(haystack, at)
                            || haystack[at] == b'\r'
                            || (haystack[at] == b'\n'
                                && (at == 0 || haystack[at - 1] != b'\r'))
                    }
                
                    /// Returns true when [`Look::WordAscii`] is satisfied `at` the given
                    /// position in `haystack`.
                    #[inline]
                    pub fn is_word_ascii(&self, haystack: &[u8], at: usize) -> bool {
                        let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);
                        let word_after =
                            at < haystack.len() && utf8::is_word_byte(haystack[at]);
                        word_before != word_after
                    }
                
                    /// Returns true when [`Look::WordAsciiNegate`] is satisfied `at` the given
                    /// position in `haystack`.
                    #[inline]
                    pub fn is_word_ascii_negate(&self, haystack: &[u8], at: usize) -> bool {
                        !self.is_word_ascii(haystack, at)
                    }
                
                    /// Returns true when [`Look::WordUnicode`] is satisfied `at` the given
                    /// position in `haystack`.
                    #[inline]
                    pub fn is_word_unicode(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_before = is_word_char::rev(haystack, at)?;
                        let word_after = is_word_char::fwd(haystack, at)?;
                        Ok(word_before != word_after)
                    }
                
                    /// Returns true when [`Look::WordUnicodeNegate`] is satisfied `at` the
                    /// given position in `haystack`.
                    #[inline]
                    pub fn is_word_unicode_negate(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_before = at > 0
                            && match utf8::decode_last(&haystack[..at]) {
                                None | Some(Err(_)) => return Ok(false),
                                Some(Ok(_)) => is_word_char::rev(haystack, at)?,
                            };
                        let word_after = at < haystack.len()
                            && match utf8::decode(&haystack[at..]) {
                                None | Some(Err(_)) => return Ok(false),
                                Some(Ok(_)) => is_word_char::fwd(haystack, at)?,
                            };
                        Ok(word_before == word_after)
                    }
                
                    /// Returns true when [`Look::WordStartAscii`] is satisfied `at` the given
                    /// position in `haystack`.
                    #[inline]
                    pub fn is_word_start_ascii(&self, haystack: &[u8], at: usize) -> bool {
                        let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);
                        let word_after =
                            at < haystack.len() && utf8::is_word_byte(haystack[at]);
                        !word_before && word_after
                    }
                
                    /// Returns true when [`Look::WordEndAscii`] is satisfied `at` the given
                    /// position in `haystack`.
                    #[inline]
                    pub fn is_word_end_ascii(&self, haystack: &[u8], at: usize) -> bool {
                        let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);
                        let word_after =
                            at < haystack.len() && utf8::is_word_byte(haystack[at]);
                        word_before && !word_after
                    }
                
                    /// Returns true when [`Look::WordStartUnicode`] is satisfied `at` the
                    /// given position in `haystack`.
                    #[inline]
                    pub fn is_word_start_unicode(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_before = is_word_char::rev(haystack, at)?;
                        let word_after = is_word_char::fwd(haystack, at)?;
                        Ok(!word_before && word_after)
                    }
                
                    /// Returns true when [`Look::WordEndUnicode`] is satisfied `at` the
                    /// given position in `haystack`.
                    #[inline]
                    pub fn is_word_end_unicode(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_before = is_word_char::rev(haystack, at)?;
                        let word_after = is_word_char::fwd(haystack, at)?;
                        Ok(word_before && !word_after)
                    }
                
                    /// Returns true when [`Look::WordStartHalfAscii`] is satisfied `at` the
                    /// given position in `haystack`.
                    #[inline]
                    pub fn is_word_start_half_ascii(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> bool {
                        let word_before = at > 0 && utf8::is_word_byte(haystack[at - 1]);
                        !word_before
                    }
                
                    /// Returns true when [`Look::WordEndHalfAscii`] is satisfied `at` the
                    /// given position in `haystack`.
                    #[inline]
                    pub fn is_word_end_half_ascii(&self, haystack: &[u8], at: usize) -> bool {
                        let word_after =
                            at < haystack.len() && utf8::is_word_byte(haystack[at]);
                        !word_after
                    }
                
                    /// Returns true when [`Look::WordStartHalfUnicode`] is satisfied `at` the
                    /// given position in `haystack`.
                    #[inline]
                    pub fn is_word_start_half_unicode(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_before = at > 0
                            && match utf8::decode_last(&haystack[..at]) {
                                None | Some(Err(_)) => return Ok(false),
                                Some(Ok(_)) => is_word_char::rev(haystack, at)?,
                            };
                        Ok(!word_before)
                    }
                
                    /// Returns true when [`Look::WordEndHalfUnicode`] is satisfied `at` the
                    /// given position in `haystack`.
                    #[inline]
                    pub fn is_word_end_half_unicode(
                        &self,
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, UnicodeWordBoundaryError> {
                        let word_after = at < haystack.len()
                            && match utf8::decode(&haystack[at..]) {
                                None | Some(Err(_)) => return Ok(false),
                                Some(Ok(_)) => is_word_char::fwd(haystack, at)?,
                            };
                        Ok(!word_after)
                    }
                }
                
                impl Default for LookMatcher {
                    fn default() -> LookMatcher {
                        LookMatcher::new()
                    }
                }
                
                /// An error that occurs when the Unicode-aware `\w` class is unavailable.
                #[derive(Clone, Debug)]
                pub struct UnicodeWordBoundaryError(());
                
                impl UnicodeWordBoundaryError 
                {
                    pub fn new() -> UnicodeWordBoundaryError 
                    {
                        UnicodeWordBoundaryError(())
                    }
                }
                
                impl ::error::Error for UnicodeWordBoundaryError {}
                
                impl ::fmt::Display for UnicodeWordBoundaryError {
                    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        write!(
                            f,
                            "Unicode-aware \\b and \\B are unavailable because the \
                             requisite data tables are missing, please enable the \
                             unicode-word-boundary feature"
                        )
                    }
                }                
                /// A module that looks for word codepoints using regex-automata's data tables.
                mod is_word_char 
                {
                    use super::utf8;
                
                    pub fn check() -> Result<(), super::UnicodeWordBoundaryError> {
                        Ok(())
                    }
                
                    #[inline( always )]
                    pub fn fwd(
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        Ok(match utf8::decode(&haystack[at..]) {
                            None | Some(Err(_)) => false,
                            Some(Ok(ch)) => is_word_character(ch),
                        })
                    }
                
                    #[inline( always )]
                    pub fn rev(
                        haystack: &[u8],
                        at: usize,
                    ) -> Result<bool, super::UnicodeWordBoundaryError> {
                        Ok(match utf8::decode_last(&haystack[..at]) {
                            None | Some(Err(_)) => false,
                            Some(Ok(ch)) => is_word_character(ch),
                        })
                    }
                
                    #[inline( always )]
                    fn is_word_character(c: char) -> bool {
                        use super::{unicode_data::perl_word::PERL_WORD, utf8};
                
                        if u8::try_from(c).map_or(false, utf8::is_word_byte) {
                            return true;
                        }
                        PERL_WORD
                            .binary_search_by(|&(start, end)| {
                                use ::cmp::Ordering;
                
                                if start <= c && c <= end {
                                    Ordering::Equal
                                } else if start > c {
                                    Ordering::Greater
                                } else {
                                    Ordering::Less
                                }
                            })
                            .is_ok()
                    }
                }
            }

            pub mod pool
            {
                //! A thread safe memory pool.
                use ::
                {
                    *,
                };
                /// Getting a value out comes with a guard.
                pub struct Pool<T, F = fn() -> T>(::boxed::Box<inner::Pool<T, F>>);
                
                impl<T, F> Pool<T, F> {
                    /// Create a new pool.
                    pub fn new(create: F) -> Pool<T, F> {
                        Pool(::boxed::Box::new(inner::Pool::new(create)))
                    }
                }
                
                impl<T: Send, F: Fn() -> T> Pool<T, F> {
                    /// Get a value from the pool.
                    #[inline]
                    pub fn get(&self) -> PoolGuard<'_, T, F> {
                        PoolGuard(self.0.get())
                    }
                }
                
                impl<T: ::fmt::Debug, F> ::fmt::Debug for Pool<T, F> {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        f.debug_tuple("Pool").field(&self.0).finish()
                    }
                }
                
                /// A guard that is returned when a caller requests a value from the pool.
                pub struct PoolGuard<'a, T: Send, F: Fn() -> T>(inner::PoolGuard<'a, T, F>);
                
                impl<'a, T: Send, F: Fn() -> T> PoolGuard<'a, T, F> {
                    /// Consumes this guard and puts it back into the pool.
                    #[inline]
                    pub fn put(this: PoolGuard<'_, T, F>) {
                        inner::PoolGuard::put(this.0);
                    }
                }
                
                impl<'a, T: Send, F: Fn() -> T> ::ops::Deref for PoolGuard<'a, T, F> {
                    type Target = T;
                
                    #[inline]
                    fn deref(&self) -> &T {
                        self.0.value()
                    }
                }
                
                impl<'a, T: Send, F: Fn() -> T> ::ops::DerefMut for PoolGuard<'a, T, F> {
                    #[inline]
                    fn deref_mut(&mut self) -> &mut T {
                        self.0.value_mut()
                    }
                }
                
                impl<'a, T: Send + ::fmt::Debug, F: Fn() -> T> ::fmt::Debug
                    for PoolGuard<'a, T, F>
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        f.debug_tuple("PoolGuard").field(&self.0).finish()
                    }
                }
                
                mod inner {
                    use ::{
                        cell::UnsafeCell,
                        panic::{RefUnwindSafe, UnwindSafe},
                        sync::atomic::{AtomicUsize, Ordering},
                    };
                
                    use ::{boxed::Box, vec, vec::Vec};
                
                    use  ::{sync::Mutex, thread_local};
                
                    /// An atomic counter used to allocate thread IDs.
                    static COUNTER: AtomicUsize = AtomicUsize::new(3);
                
                    /// A thread ID indicating that there is no owner.
                    static THREAD_ID_UNOWNED: usize = 0;
                
                    /// A thread ID indicating that the special owner value is in use and not
                    /// available.
                    static THREAD_ID_INUSE: usize = 1;
                
                    /// This sentinel is used to indicate that a guard has already been dropped
                    /// and should not be re-dropped.
                    static THREAD_ID_DROPPED: usize = 2;
                
                    /// The number of stacks we use inside of the pool.
                    const MAX_POOL_STACKS: usize = 8;
                
                    thread_local!(
                        /// A thread local used to assign an ID to a thread.
                        static THREAD_ID: usize = {
                            let next = COUNTER.fetch_add(1, Ordering::Relaxed);
                            if next == 0 {
                                panic!("regex: thread ID allocation space exhausted");
                            }
                            next
                        };
                    );
                
                    /// This puts each stack in the pool below into its own cache line. This is
                    /// an absolutely critical optimization that tends to have the most impact
                    /// in high contention workloads.
                    #[derive(Debug)]
                    #[repr(C, align(64))]
                    struct CacheLine<T>(T);
                
                    /// A thread safe pool utilizing std-only features.
                    pub(super) struct Pool<T, F> {
                        /// A function to create more T values when stack is empty and a caller
                        /// has requested a T.
                        create: F,
                        /// Multiple stacks of T values to hand out.
                        stacks: Vec<CacheLine<Mutex<Vec<Box<T>>>>>,
                        /// The ID of the thread that owns this pool.
                        owner: AtomicUsize,
                        /// A value to return when the caller is in the same thread that
                        /// first called `Pool::get`.
                        owner_val: UnsafeCell<Option<T>>,
                    }
                    
                    unsafe impl<T: Send, F: Send + Sync> Sync for Pool<T, F> {}
                    
                    impl<T: UnwindSafe, F: UnwindSafe + RefUnwindSafe> UnwindSafe for Pool<T, F> {}
                    
                    impl<T: UnwindSafe, F: UnwindSafe + RefUnwindSafe> RefUnwindSafe for Pool<T, F> {}
                
                    impl<T, F> Pool<T, F> {
                        /// Create a new pool. The given closure is used to create values in
                        /// the pool when necessary.
                        pub fn new(create: F) -> Pool<T, F> {
                            let mut stacks = Vec::with_capacity(MAX_POOL_STACKS);
                            for _ in 0..stacks.capacity() {
                                stacks.push(CacheLine(Mutex::new(vec![])));
                            }
                            let owner = AtomicUsize::new(THREAD_ID_UNOWNED);
                            let owner_val = UnsafeCell::new(None); // init'd on first access
                            Pool { create, stacks, owner, owner_val }
                        }
                    }
                
                    impl<T: Send, F: Fn() -> T> Pool<T, F> {
                        /// Get a value from the pool.
                        #[inline]
                        pub fn get(&self) -> PoolGuard<'_, T, F> {
                            let caller = THREAD_ID.with(|id| *id);
                            let owner = self.owner.load(Ordering::Acquire);
                            if caller == owner {
                                self.owner.store(THREAD_ID_INUSE, Ordering::Release);
                                return self.guard_owned(caller);
                            }
                            self.get_slow(caller, owner)
                        }
                
                        /// This is the "slow" version that goes through a mutex to pop an
                        /// allocated value off a stack to return to the caller.
                        #[cold]
                        fn get_slow(
                            &self,
                            caller: usize,
                            owner: usize,
                        ) -> PoolGuard<'_, T, F> {
                            if owner == THREAD_ID_UNOWNED {
                                // This sentinel means this pool is not yet owned.
                                let res = self.owner.compare_exchange(
                                    THREAD_ID_UNOWNED,
                                    THREAD_ID_INUSE,
                                    Ordering::AcqRel,
                                    Ordering::Acquire,
                                );
                                if res.is_ok() {
                                    unsafe {
                                        *self.owner_val.get() = Some((self.create)());
                                    }
                                    return self.guard_owned(caller);
                                }
                            }
                            let stack_id = caller % self.stacks.len();
                            
                            for _ in 0..1 {
                                let mut stack = match self.stacks[stack_id].0.try_lock() {
                                    Err(_) => continue,
                                    Ok(stack) => stack,
                                };
                                if let Some(value) = stack.pop() {
                                    return self.guard_stack(value);
                                }
                                
                                drop(stack);
                                let value = Box::new((self.create)());
                                return self.guard_stack(value);
                            }
                            self.guard_stack_transient(Box::new((self.create)()))
                        }
                
                        /// Puts a value back into the pool.
                        #[inline]
                        fn put_value(&self, value: Box<T>) {
                            let caller = THREAD_ID.with(|id| *id);
                            let stack_id = caller % self.stacks.len();
                            
                            for _ in 0..10 {
                                let mut stack = match self.stacks[stack_id].0.try_lock() {
                                    Err(_) => continue,
                                    Ok(stack) => stack,
                                };
                                stack.push(value);
                                return;
                            }
                        }
                        /// Create a guard that represents the special owned T.
                        #[inline] fn guard_owned(&self, caller: usize) -> PoolGuard<'_, T, F> {
                            PoolGuard { pool: self, value: Err(caller), discard: false }
                        }
                        /// Create a guard that contains a value from the pool's stack.
                        #[inline]
                        fn guard_stack(&self, value: Box<T>) -> PoolGuard<'_, T, F> {
                            PoolGuard { pool: self, value: Ok(value), discard: false }
                        }
                
                        /// Create a guard that contains a value from the pool's stack with an
                        /// instruction to throw away the value instead of putting it back
                        /// into the pool.
                        #[inline]
                        fn guard_stack_transient(&self, value: Box<T>) -> PoolGuard<'_, T, F> {
                            PoolGuard { pool: self, value: Ok(value), discard: true }
                        }
                    }
                
                    impl<T: ::fmt::Debug, F> ::fmt::Debug for Pool<T, F> {
                        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                            f.debug_struct("Pool")
                                .field("stacks", &self.stacks)
                                .field("owner", &self.owner)
                                .field("owner_val", &self.owner_val)
                                .finish()
                        }
                    }
                
                    /// A guard that is returned when a caller requests a value from the pool.
                    pub(super) struct PoolGuard<'a, T: Send, F: Fn() -> T> {
                        /// The pool that this guard is attached to.
                        pool: &'a Pool<T, F>,
                        /// This is Err when the guard represents the special "owned" value.
                        value: Result<Box<T>, usize>,
                        /// When true, the value should be discarded instead of being pushed
                        /// back into the pool.
                        discard: bool,
                    }
                
                    impl<'a, T: Send, F: Fn() -> T> PoolGuard<'a, T, F> {
                        /// Return the underlying value.
                        #[inline]
                        pub fn value(&self) -> &T {
                            match self.value {
                                Ok(ref v) => &**v,
                                Err(id) => unsafe {
                                    debug_assert_ne!(THREAD_ID_DROPPED, id);
                                    (*self.pool.owner_val.get()).as_ref().unwrap_unchecked()
                                },
                            }
                        }
                        /// Return the underlying value as a mutable borrow.
                        #[inline]
                        pub fn value_mut(&mut self) -> &mut T {
                            match self.value {
                                Ok(ref mut v) => &mut **v,
                                Err(id) => unsafe {
                                    debug_assert_ne!(THREAD_ID_DROPPED, id);
                                    (*self.pool.owner_val.get()).as_mut().unwrap_unchecked()
                                },
                            }
                        }
                
                        /// Consumes this guard and puts it back into the pool.
                        #[inline]
                        pub fn put(this: PoolGuard<'_, T, F>) {
                            let mut this = ::mem::ManuallyDrop::new(this);
                            this.put_imp();
                        }
                
                        /// Puts this guard back into the pool by only borrowing the guard as
                        /// mutable.
                        #[inline(always)]
                        fn put_imp(&mut self) {
                            match ::mem::replace(&mut self.value, Err(THREAD_ID_DROPPED)) {
                                Ok(value) => {
                                    if self.discard {
                                        return;
                                    }
                                    self.pool.put_value(value);
                                }
                                
                                Err(owner) => {
                                    assert_ne!(THREAD_ID_DROPPED, owner);
                                    self.pool.owner.store(owner, Ordering::Release);
                                }
                            }
                        }
                    }
                
                    impl<'a, T: Send, F: Fn() -> T> Drop for PoolGuard<'a, T, F> {
                        #[inline]
                        fn drop(&mut self) {
                            self.put_imp();
                        }
                    }
                
                    impl<'a, T: Send + ::fmt::Debug, F: Fn() -> T> ::fmt::Debug
                        for PoolGuard<'a, T, F>
                    {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            f.debug_struct("PoolGuard")
                                .field("pool", &self.pool)
                                .field("value", &self.value)
                                .finish()
                        }
                    }
                }
            }

            pub mod prefilter
            {
                //! Defines a prefilter for accelerating regex searches.
                use ::
                {
                    borrow::Borrow,
                    fmt::Debug,
                    panic::{RefUnwindSafe, UnwindSafe},
                    sync::Arc,
                    *,
                };
                /*
                    use regex_syntax::hir::{literal, Hir};
                
                use regex_automata::util::search::{MatchKind, Span};
                
                pub use regex_automata::util::prefilter::{
                    aho_corasick::AhoCorasick,
                    byteset::ByteSet,
                    mem::chr::{Memchr, Memchr2, Memchr3},
                    memmem::Memmem,
                    teddy::Teddy,
                };
                */                
                /// A prefilter for accelerating regex searches.
                #[derive(Clone, Debug)]
                pub struct Prefilter 
                {
                    pre: Arc<dyn PrefilterI>,
                    is_fast: bool,
                    max_needle_len: usize,
                }
                
                impl Prefilter 
                {
                    /// Create a new prefilter from a sequence of needles and a corresponding
                    /// match semantics.
                    pub fn new<B: AsRef<[u8]>>(
                        kind: MatchKind,
                        needles: &[B],
                    ) -> Option<Prefilter> {
                        Choice::new(kind, needles).and_then(|choice| {
                            let max_needle_len =
                                needles.iter().map(|b| b.as_ref().len()).max().unwrap_or(0);
                            Prefilter::from_choice(choice, max_needle_len)
                        })
                    }
                
                    /// This turns a prefilter selection into a `Prefilter`. That is, in turns
                    /// the enum given into a trait object.
                    fn from_choice(
                        choice: Choice,
                        max_needle_len: usize,
                    ) -> Option<Prefilter> {
                        let pre: Arc<dyn PrefilterI> = match choice {
                            Choice::Memchr(p) => Arc::new(p),
                            Choice::Memchr2(p) => Arc::new(p),
                            Choice::Memchr3(p) => Arc::new(p),
                            Choice::Memmem(p) => Arc::new(p),
                            Choice::Teddy(p) => Arc::new(p),
                            Choice::ByteSet(p) => Arc::new(p),
                            Choice::AhoCorasick(p) => Arc::new(p),
                        };
                        let is_fast = pre.is_fast();
                        Some(Prefilter { pre, is_fast, max_needle_len })
                    }
                
                    /// This attempts to extract prefixes from the given `Hir` expression for
                    /// the given match semantics, and if possible, builds a prefilter for
                    /// them.
                    pub fn from_hir_prefix(kind: MatchKind, hir: &Hir) -> Option<Prefilter> {
                        Prefilter::from_hirs_prefix(kind, &[hir])
                    }
                
                    /// This attempts to extract prefixes from the given `Hir` expressions for
                    /// the given match semantics, and if possible, builds a prefilter for
                    /// them.
                    pub fn from_hirs_prefix<H: Borrow<Hir>>(
                        kind: MatchKind,
                        hirs: &[H],
                    ) -> Option<Prefilter> {
                        prefixes(kind, hirs)
                            .literals()
                            .and_then(|lits| Prefilter::new(kind, lits))
                    }
                
                    /// Run this prefilter on `haystack[span.start..end]` and return a matching
                    /// span if one exists.
                    #[inline]
                    pub fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                        self.pre.find(haystack, span)
                    }
                
                    /// Returns the span of a prefix of `haystack[span.start..span.end]` if
                    /// the prefilter matches.
                    #[inline]
                    pub fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                        self.pre.prefix(haystack, span)
                    }
                
                    /// Returns the heap memory, in bytes, used by the underlying prefilter.
                    #[inline]
                    pub fn memory_usage(&self) -> usize { self.pre.memory_usage() }
                
                    /// Return the length of the longest needle
                    /// in this Prefilter
                    #[inline]
                    pub fn max_needle_len(&self) -> usize { self.max_needle_len }
                
                    /// Implementations might return true here if they believe themselves to
                    /// be "fast."
                    #[inline]
                    pub fn is_fast(&self) -> bool { self.is_fast }
                }
                
                /// A trait for abstracting over prefilters.
                pub trait PrefilterI:
                    Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static
                {
                    /// Run this prefilter on `haystack[span.start..end]` and return a matching
                    /// span if one exists.
                    fn find(&self, haystack: &[u8], span: Span) -> Option<Span>;
                
                    /// Returns the span of a prefix of `haystack[span.start..span.end]` if
                    /// the prefilter matches.
                    fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span>;
                
                    /// Returns the heap memory, in bytes, used by the underlying prefilter.
                    fn memory_usage(&self) -> usize;
                
                    /// Implementations might return true here if they believe themselves to
                    /// be "fast."
                    fn is_fast(&self) -> bool;
                }
                
                /// A type that encapsulates the selection of a prefilter algorithm from a
                /// sequence of needles.
                #[derive(Clone, Debug)]
                pub enum Choice {
                    Memchr(Memchr),
                    Memchr2(Memchr2),
                    Memchr3(Memchr3),
                    Memmem(Memmem),
                    Teddy(Teddy),
                    ByteSet(ByteSet),
                    AhoCorasick(AhoCorasick),
                }
                
                impl Choice 
                {
                    /// Select what is believed to be the best prefilter algorithm for the
                    /// match semantics and sequence of needles given.
                    pub fn new<B: AsRef<[u8]>>(
                        kind: MatchKind,
                        needles: &[B],
                    ) -> Option<Choice> {
                        if needles.len() == 0 {
                            debug!("prefilter building failed: found empty set of literals");
                            return None;
                        }
                        
                        if needles.iter().any(|n| n.as_ref().is_empty()) {
                            debug!("prefilter building failed: literals match empty string");
                            return None;
                        }
                        
                        if let Some(pre) = mem::chr::new(kind, needles) {
                            debug!("prefilter built: memchr");
                            return Some(Choice::Memchr(pre));
                        }
                        if let Some(pre) = Memchr2::new(kind, needles) {
                            debug!("prefilter built: memchr2");
                            return Some(Choice::Memchr2(pre));
                        }
                        if let Some(pre) = Memchr3::new(kind, needles) {
                            debug!("prefilter built: memchr3");
                            return Some(Choice::Memchr3(pre));
                        }
                        if let Some(pre) = Memmem::new(kind, needles) {
                            debug!("prefilter built: memmem");
                            return Some(Choice::Memmem(pre));
                        }
                        if let Some(pre) = Teddy::new(kind, needles) {
                            debug!("prefilter built: teddy");
                            return Some(Choice::Teddy(pre));
                        }
                        if let Some(pre) = ByteSet::new(kind, needles) {
                            debug!("prefilter built: byteset");
                            return Some(Choice::ByteSet(pre));
                        }
                        if let Some(pre) = AhoCorasick::new(kind, needles) {
                            debug!("prefilter built: aho-corasick");
                            return Some(Choice::AhoCorasick(pre));
                        }
                        debug!("prefilter building failed: no strategy could be found");
                        None
                    }
                }
                
                /// Extracts all of the prefix literals from the given HIR expressions into a
                /// single `Seq`.
                pub fn prefixes<H>(kind: MatchKind, hirs: &[H]) -> literal::Seq
                where
                    H: ::borrow::Borrow<Hir>,
                {
                    let mut extractor = literal::Extractor::new();
                    extractor.kind(literal::ExtractKind::Prefix);
                
                    let mut prefixes = literal::Seq::empty();
                    for hir in hirs {
                        prefixes.union(&mut extractor.extract(hir.borrow()));
                    }
                    debug!(
                        "prefixes (len={:?}, exact={:?}) extracted before optimization: {:?}",
                        prefixes.len(),
                        prefixes.is_exact(),
                        prefixes
                    );
                    match kind {
                        MatchKind::All => {
                            prefixes.sort();
                            prefixes.dedup();
                        }
                        MatchKind::LeftmostFirst => {
                            prefixes.optimize_for_prefix_by_preference();
                        }
                    }
                    debug!(
                        "prefixes (len={:?}, exact={:?}) extracted after optimization: {:?}",
                        prefixes.len(),
                        prefixes.is_exact(),
                        prefixes
                    );
                    prefixes
                }
                
                /// Like `prefixes`, but for all suffixes of all matches for the given HIRs.
                pub fn suffixes<H>(kind: MatchKind, hirs: &[H]) -> literal::Seq
                where
                    H: ::borrow::Borrow<Hir>,
                {
                    let mut extractor = literal::Extractor::new();
                    extractor.kind(literal::ExtractKind::Suffix);
                
                    let mut suffixes = literal::Seq::empty();
                    for hir in hirs {
                        suffixes.union(&mut extractor.extract(hir.borrow()));
                    }
                    debug!(
                        "suffixes (len={:?}, exact={:?}) extracted before optimization: {:?}",
                        suffixes.len(),
                        suffixes.is_exact(),
                        suffixes
                    );
                    match kind {
                        MatchKind::All => {
                            suffixes.sort();
                            suffixes.dedup();
                        }
                        MatchKind::LeftmostFirst => {
                            suffixes.optimize_for_suffix_by_preference();
                        }
                    }
                    debug!(
                        "suffixes (len={:?}, exact={:?}) extracted after optimization: {:?}",
                        suffixes.len(),
                        suffixes.is_exact(),
                        suffixes
                    );
                    suffixes
                }

                mod aho_corasick
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use crate::util::{
                        prefilter::PrefilterI,
                        search::{MatchKind, Span},
                    };
                    */                    
                    #[derive(Clone, Debug)]
                    pub struct AhoCorasick 
                    {
                        ac: aho_corasick::AhoCorasick,
                    }
                    
                    impl AhoCorasick {
                        pub fn new<B: AsRef<[u8]>>(
                            kind: MatchKind,
                            needles: &[B],
                        ) -> Option<AhoCorasick>
                        {
                            let ac_match_kind = match kind {
                                MatchKind::LeftmostFirst | MatchKind::All => {
                                    aho_corasick::MatchKind::LeftmostFirst
                                }
                            };
                            
                            let ac_kind = if needles.len() <= 500 {
                                aho_corasick::AhoCorasickKind::DFA
                            } else {
                                aho_corasick::AhoCorasickKind::ContiguousNFA
                            };
                            let result = aho_corasick::AhoCorasick::builder()
                                .kind(Some(ac_kind))
                                .match_kind(ac_match_kind)
                                .start_kind(aho_corasick::StartKind::Both)
                                .prefilter(false)
                                .build(needles);
                            let ac = match result {
                                Ok(ac) => ac,
                                Err(_err) => {
                                    debug!("aho-corasick prefilter failed to build: {}", _err);
                                    return None;
                                }
                            };
                            Some(AhoCorasick { ac })
                        }
                    }
                    
                    impl PrefilterI for AhoCorasick {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let input =
                                aho_corasick::Input::new(haystack).span(span.start..span.end);
                            self.ac
                                .find(input)
                                .map(|m| Span { start: m.start(), end: m.end() })
                        }
                    
                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let input = aho_corasick::Input::new(haystack)
                                .anchored(aho_corasick::Anchored::Yes)
                                .span(span.start..span.end);
                            self.ac
                                .find(input)
                                .map(|m| Span { start: m.start(), end: m.end() })
                        }
                    
                        fn memory_usage(&self) -> usize {
                            self.ac.memory_usage()
                        }
                    
                        fn is_fast(&self) -> bool {
                            false
                        }
                    }
                }
                
                mod byteset
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use crate::util::{
                        prefilter::PrefilterI,
                        search::{MatchKind, Span},
                    };
                    */
                    #[derive(Clone, Debug)]
                    pub struct ByteSet([bool; 256]);
                    
                    impl ByteSet {
                        pub fn new<B: AsRef<[u8]>>(
                            _kind: MatchKind,
                            needles: &[B],
                        ) -> Option<ByteSet> {
                            let mut set = [false; 256];
                            for needle in needles.iter() {
                                let needle = needle.as_ref();
                                if needle.len() != 1 {
                                    return None;
                                }
                                set[usize::from(needle[0])] = true;
                            }
                            Some(ByteSet(set))
                        }
                    }
                    
                    impl PrefilterI for ByteSet {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            haystack[span].iter().position(|&b| self.0[usize::from(b)]).map(|i| {
                                let start = span.start + i;
                                let end = start + 1;
                                Span { start, end }
                            })
                        }
                    
                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let b = *haystack.get(span.start)?;
                            if self.0[usize::from(b)] {
                                Some(Span { start: span.start, end: span.start + 1 })
                            } else {
                                None
                            }
                        }
                    
                        fn memory_usage(&self) -> usize {
                            0
                        }
                    
                        fn is_fast(&self) -> bool {
                            false
                        }
                    }
                }
                
                mod memchr
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use crate::util::{
                        prefilter::PrefilterI,
                        search::{MatchKind, Span},
                    };

                    */
                    pub struct Memchr(u8);
                    
                    impl Memchr {
                        pub fn new<B: AsRef<[u8]>>(
                            _kind: MatchKind,
                            needles: &[B],
                        ) -> Option<Memchr> {
                            if needles.len() != 1 {
                                return None;
                            }
                            if needles[0].as_ref().len() != 1 {
                                return None;
                            }
                            Some(Memchr(needles[0].as_ref()[0]))
                        }
                    }
                    
                    impl PrefilterI for Memchr {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            mem::chr::memchr(self.0, &haystack[span]).map(|i| {
                                let start = span.start + i;
                                let end = start + 1;
                                Span { start, end }
                            })
                        }
                    
                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let b = *haystack.get(span.start)?;
                            if self.0 == b {
                                Some(Span { start: span.start, end: span.start + 1 })
                            } else {
                                None
                            }
                        }
                    
                        fn memory_usage(&self) -> usize {
                            0
                        }
                    
                        fn is_fast(&self) -> bool {
                            true
                        }
                    }
                    
                    #[derive(Clone, Debug)]
                    pub struct Memchr2(u8, u8);
                    
                    impl Memchr2 {
                        pub fn new<B: AsRef<[u8]>>(
                            _kind: MatchKind,
                            needles: &[B],
                        ) -> Option<Memchr2> {
                            if needles.len() != 2 {
                                return None;
                            }
                            if !needles.iter().all(|n| n.as_ref().len() == 1) {
                                return None;
                            }
                            let b1 = needles[0].as_ref()[0];
                            let b2 = needles[1].as_ref()[0];
                            Some(Memchr2(b1, b2))
                        }
                    }
                    
                    impl PrefilterI for Memchr2 {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            mem::chr::memchr2(self.0, self.1, &haystack[span]).map(|i| {
                                let start = span.start + i;
                                let end = start + 1;
                                Span { start, end }
                            })
                        }
                    
                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let b = *haystack.get(span.start)?;
                            if self.0 == b || self.1 == b {
                                Some(Span { start: span.start, end: span.start + 1 })
                            } else {
                                None
                            }
                        }
                    
                        fn memory_usage(&self) -> usize {
                            0
                        }
                    
                        fn is_fast(&self) -> bool {
                            true
                        }
                    }
                    
                    #[derive(Clone, Debug)]
                    pub struct Memchr3(u8, u8, u8);
                    
                    impl Memchr3 {
                        pub fn new<B: AsRef<[u8]>>(
                            _kind: MatchKind,
                            needles: &[B],
                        ) -> Option<Memchr3> {
                            if needles.len() != 3 {
                                return None;
                            }
                            if !needles.iter().all(|n| n.as_ref().len() == 1) {
                                return None;
                            }
                            let b1 = needles[0].as_ref()[0];
                            let b2 = needles[1].as_ref()[0];
                            let b3 = needles[2].as_ref()[0];
                            Some(Memchr3(b1, b2, b3))
                        }
                    }
                    
                    impl PrefilterI for Memchr3 {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            mem::chr::memchr3(self.0, self.1, self.2, &haystack[span]).map(|i| {
                                let start = span.start + i;
                                let end = start + 1;
                                Span { start, end }
                            })
                        }
                    
                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let b = *haystack.get(span.start)?;
                            if self.0 == b || self.1 == b || self.2 == b {
                                Some(Span { start: span.start, end: span.start + 1 })
                            } else {
                                None
                            }
                        }
                    
                        fn memory_usage(&self) -> usize {
                            0
                        }
                    
                        fn is_fast(&self) -> bool {
                            true
                        }
                    }
                }
                
                mod memmem
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use crate::util::{
                        prefilter::PrefilterI,
                        search::{MatchKind, Span},
                    };
                    */
                    #[derive(Clone, Debug)]
                    pub struct Memmem {
                        finder: mem::chr::memmem::Finder<'static>,
                    }
                    
                    impl Memmem {
                        pub fn new<B: AsRef<[u8]>>(
                            _kind: MatchKind,
                            needles: &[B],
                        ) -> Option<Memmem> {
                            if needles.len() != 1 {
                                return None;
                            }
                            let needle = needles[0].as_ref();
                            let finder = mem::chr::memmem::Finder::new(needle).into_owned();
                            Some(Memmem { finder })
                        }
                    }
                    
                    impl PrefilterI for Memmem {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            self.finder.find(&haystack[span]).map(|i| {
                                let start = span.start + i;
                                let end = start + self.finder.needle().len();
                                Span { start, end }
                            })
                        }
                    
                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span> {
                            let needle = self.finder.needle();
                            if haystack[span].starts_with(needle) {
                                Some(Span { end: span.start + needle.len(), ..span })
                            } else {
                                None
                            }
                        }
                    
                        fn memory_usage(&self) -> usize {
                            self.finder.needle().len()
                        }
                    
                        fn is_fast(&self) -> bool {
                            true
                        }
                    }
                }
                
                mod teddy
                {
                    use ::
                    {
                        *,
                    };
                    /*
                    use crate::util::{
                        prefilter::PrefilterI,
                        search::{MatchKind, Span},
                    };
                    */
                    #[derive(Clone, Debug)]
                    pub struct Teddy 
                    {
                        searcher: aho_corasick::packed::Searcher,
                        /// When running an anchored search, the packed searcher can't handle it so
                        /// we defer to Aho-Corasick itself.
                        anchored_ac: aho_corasick::dfa::DFA,
                        /// The length of the smallest literal we look for.
                        minimum_len: usize,
                    }
                    
                    impl Teddy 
                    {
                        pub fn new<B: AsRef<[u8]>>
                        (
                            kind: MatchKind,
                            needles: &[B],
                        ) -> Option<Teddy>
                        {
                            let (packed_match_kind, ac_match_kind) = match kind
                            {
                                MatchKind::LeftmostFirst | MatchKind::All =>
                                (
                                    aho_corasick::packed::MatchKind::LeftmostFirst,
                                    aho_corasick::MatchKind::LeftmostFirst,
                                ),
                            };
                            
                            let minimum_len = needles
                            .iter()
                            .map
                            ( 
                                |n| 
                                n.as_ref().len()
                            )
                            .min()
                            .unwrap_or( 0 );

                            let packed = aho_corasick::packed::Config::
                            new()
                            .match_kind(packed_match_kind)
                            .builder()
                            .extend(needles)
                            .build()?;

                            let anchored_ac = aho_corasick::dfa::DFA::
                            builder()
                            .match_kind(ac_match_kind)
                            .start_kind(aho_corasick::StartKind::Anchored)
                            .prefilter(false)
                            .build(needles)
                            .ok()?;
                                
                            Some(Teddy { searcher: packed, anchored_ac, minimum_len })
                        }
                    }
                    
                    impl PrefilterI for Teddy
                    {
                        fn find(&self, haystack: &[u8], span: Span) -> Option<Span>
                        {
                            let ac_span = aho_corasick::Span { start: span.start, end: span.end };
                            self.searcher
                            .find_in(haystack, ac_span)
                            .map(|m| Span { start: m.start(), end: m.end() })
                        }
                    
                        fn prefix(&self, haystack: &[u8], span: Span) -> Option<Span>
                        {
                            use aho_corasick::automaton::Automaton;

                            let input = aho_corasick::Input::new(haystack)
                            .anchored(aho_corasick::Anchored::Yes)
                            .span(span.start..span.end);

                            self.anchored_ac
                            .try_find(&input)
                            .expect("aho-corasick DFA should never fail")
                            .map(|m| Span { start: m.start(), end: m.end() })
                        }
                    
                        fn memory_usage(&self) -> usize 
                        {
                            use aho_corasick::automaton::Automaton;
                            self.searcher.memory_usage() + self.anchored_ac.memory_usage()
                        }
                    
                        fn is_fast(&self) -> bool  { self.minimum_len >= 3 }
                    }
                }
            }

            pub mod primitives
            {
                //! Lower level primitive types that are useful in a variety of circumstances.
                use ::
                {
                    num::{ NonZeroUsize },
                    vec::{ Vec },
                    *,
                };
                /*
                use  ::num::NonZeroUsize;
                
                #[cfg(feature = "alloc")]
                use alloc::vec::Vec;
                
                use crate::util::int::{Usize, U16, U32, U64};
                */
                /// A `usize` that can never be `usize::MAX`.
                #[repr( transparent )] #[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]
                pub struct NonMaxUsize(NonZeroUsize);
                
                impl NonMaxUsize
                {
                    /// Create a new `NonMaxUsize` from the given value.
                    #[inline] pub fn new(value: usize) -> Option<NonMaxUsize>
                    { NonZeroUsize::new(value.wrapping_add(1)).map(NonMaxUsize) }
                    /// Return the underlying `usize` value.
                    #[inline] pub fn get(self) -> usize { self.0.get().wrapping_sub(1) }
                }
                
                impl ::fmt::Debug for NonMaxUsize 
                {
                    fn fmt(&self, f: &mut  ::fmt::Formatter) ->  ::fmt::Result 
                    { write!(f, "{:?}", self.get()) }
                }
                /// A type that represents a "small" index.
                #[repr( transparent )] 
                #[derive( Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord )]
                pub struct SmallIndex(u32);
                
                impl SmallIndex
                {
                    /// The maximum index value.
                    #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
                    pub const MAX: SmallIndex = SmallIndex::new_unchecked( ::i32::MAX as usize - 1);
                    /// The maximum index value.
                    #[cfg(target_pointer_width = "16")]
                    pub const MAX: SmallIndex = SmallIndex::new_unchecked( ::isize::MAX - 1);
                    /// The total number of values that can be represented as a small index.
                    pub const LIMIT: usize = SmallIndex::MAX.as_usize() + 1;
                    /// The zero index value.
                    pub const ZERO: SmallIndex = SmallIndex::new_unchecked(0);
                    /// The number of bytes that a single small index uses in memory.
                    pub const SIZE: usize =  ::mem::size_of::<SmallIndex>();
                    /// Create a new small index.
                    #[inline] pub fn new(index: usize) -> Result<SmallIndex, SmallIndexError> { SmallIndex::try_from(index) }
                    /// Create a new small index without checking whether the given value exceeds [`SmallIndex::MAX`].
                    #[inline] pub const fn new_unchecked(index: usize) -> SmallIndex 
                    { SmallIndex(index as u32) }
                    /// Like [`SmallIndex::new`], but panics if the given index is not valid.
                    #[inline] pub fn must(index: usize) -> SmallIndex 
                    { SmallIndex::new(index).expect("invalid small index") }
                    /// Return this small index as a `usize`.
                    #[inline] pub const fn as_usize(&self) -> usize { self.0 as usize }
                    /// Return this small index as a `u64`.
                    #[inline] pub const fn as_u64(&self) -> u64 { self.0 as u64 }
                    /// Return the internal `u32` of this small index.
                    #[inline] pub const fn as_u32(&self) -> u32 { self.0 }
                    /// Return the internal `u32` of this small index represented as an `i32`.
                    #[inline] pub const fn as_i32(&self) -> i32 { self.0 as i32 }
                    /// Returns one more than this small index as a usize.
                    #[inline] pub fn one_more(&self) -> usize { self.as_usize() + 1 }
                    /// Decode this small index from the bytes given using the native endian byte order for the current target.
                    #[inline] pub fn from_ne_bytes
                    (
                        bytes: [u8; 4],
                    ) -> Result<SmallIndex, SmallIndexError> 
                    {
                        let id = u32::from_ne_bytes(bytes);

                        if id > SmallIndex::MAX.as_u32()
                        { return Err(SmallIndexError { attempted: u64::from(id) }); }
                        
                        Ok(SmallIndex::new_unchecked(id.as_usize()))
                    }
                    /// Decode this small index from the bytes given using the native endian byte order for the current target
                    #[inline] pub fn from_ne_bytes_unchecked(bytes: [u8; 4]) -> SmallIndex 
                    { SmallIndex::new_unchecked(u32::from_ne_bytes(bytes).as_usize()) }
                    /// Return the underlying small index integer as raw bytes in native endian format.
                    #[inline] pub fn to_ne_bytes(&self) -> [u8; 4] { self.0.to_ne_bytes() }
                }
                
                impl<T>  ::ops::Index<SmallIndex> for [T]
                {
                    type Output = T;                
                    #[inline] fn index(&self, index: SmallIndex) -> &T { &self[index.as_usize()] }
                }
                
                impl<T>  ::ops::IndexMut<SmallIndex> for [T]
                {
                    #[inline] fn index_mut(&mut self, index: SmallIndex) -> &mut T
                    { &mut self[index.as_usize()] }
                }
                
                impl<T>  ::ops::Index<SmallIndex> for Vec<T>
                {
                    type Output = T;                
                    #[inline] fn index(&self, index: SmallIndex) -> &T { &self[index.as_usize()] }
                }
                
                impl<T>  ::ops::IndexMut<SmallIndex> for Vec<T>
                {
                    #[inline] fn index_mut(&mut self, index: SmallIndex) -> &mut T {  &mut self[index.as_usize()] }
                }
                
                impl From<u8> for SmallIndex
                {
                    fn from(index: u8) -> SmallIndex { SmallIndex::new_unchecked(usize::from(index)) }
                }
                
                impl TryFrom<u16> for SmallIndex
                {
                    type Error = SmallIndexError;                
                    fn try_from(index: u16) -> Result<SmallIndex, SmallIndexError>
                    {
                        if u32::from(index) > SmallIndex::MAX.as_u32()
                        { return Err(SmallIndexError { attempted: u64::from(index) }); }
                        
                        Ok(SmallIndex::new_unchecked(index.as_usize()))
                    }
                }
                
                impl TryFrom<u32> for SmallIndex
                {
                    type Error = SmallIndexError;                
                    fn try_from(index: u32) -> Result<SmallIndex, SmallIndexError>
                    {
                        if index > SmallIndex::MAX.as_u32()
                        { return Err(SmallIndexError { attempted: u64::from(index) }); }
                        
                        Ok(SmallIndex::new_unchecked(index.as_usize()))
                    }
                }
                
                impl TryFrom<u64> for SmallIndex
                {
                    type Error = SmallIndexError;                
                    fn try_from(index: u64) -> Result<SmallIndex, SmallIndexError>
                    {
                        if index > SmallIndex::MAX.as_u64() 
                        { return Err(SmallIndexError { attempted: index }); }
                        
                        Ok(SmallIndex::new_unchecked(index.as_usize()))
                    }
                }
                
                impl TryFrom<usize> for SmallIndex
                {
                    type Error = SmallIndexError;                
                    fn try_from(index: usize) -> Result<SmallIndex, SmallIndexError>
                    {
                        if index > SmallIndex::MAX.as_usize() 
                        { return Err( SmallIndexError { attempted: index.as_u64() } ); }
                        
                        Ok(SmallIndex::new_unchecked(index))
                    }
                }
                /// This error occurs when a small index could not be constructed.
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub struct SmallIndexError
                {
                    attempted: u64,
                }
                
                impl SmallIndexError 
                {
                    /// Returns the value that could not be converted to a small index.
                    pub fn attempted(&self) -> u64 { self.attempted }
                }
                
                impl ::error::Error for SmallIndexError {}
                
                impl ::fmt::Display for SmallIndexError
                {
                    fn fmt(&self, f: &mut  ::fmt::Formatter) ->  ::fmt::Result
                    {
                        write!
                        (
                            f,
                            "failed to create small index from {:?}, which exceeds {:?}",
                            self.attempted(),
                            SmallIndex::MAX,
                        )
                    }
                }
                
                #[derive(Clone, Debug)]
                pub struct SmallIndexIter
                {
                    rng:  ::ops::Range<usize>,
                }
                
                impl Iterator for SmallIndexIter
                {
                    type Item = SmallIndex;                
                    fn next(&mut self) -> Option<SmallIndex>
                    {
                        if self.rng.start >= self.rng.end { return None; }
                        
                        let next_id = self.rng.start + 1;
                        let id =  ::mem::replace(&mut self.rng.start, next_id);
                        Some(SmallIndex::new_unchecked(id))
                    }
                }
                
                macro_rules! index_type_impls 
                {
                    ($name:ident, $err:ident, $iter:ident, $withiter:ident) => 
                    {
                        impl $name 
                        {
                            /// The maximum value.
                            pub const MAX: $name = $name(SmallIndex::MAX);
                
                            /// The total number of values that can be represented.
                            pub const LIMIT: usize = SmallIndex::LIMIT;
                
                            /// The zero value.
                            pub const ZERO: $name = $name(SmallIndex::ZERO);
                
                            /// The number of bytes that a single value uses in memory.
                            pub const SIZE: usize = SmallIndex::SIZE;
                
                            /// Create a new value that is represented by a "small index."
                            ///
                            /// If the given index exceeds the maximum allowed value, then this
                            /// returns an error.
                            #[inline] pub fn new(value: usize) -> Result<$name, $err> 
                            { SmallIndex::new(value).map($name).map_err($err) }
                            /// Create a new value without checking whether the given argument
                            /// exceeds the maximum.
                            #[inline] pub const fn new_unchecked(value: usize) -> $name 
                            { $name(SmallIndex::new_unchecked(value)) }
                            /// Like `new`, but panics if the given value is not valid.
                            #[inline] pub fn must(value: usize) -> $name
                            {
                                $name::new(value).expect(concat!
                                (
                                    "invalid ",
                                    stringify!($name),
                                    " value"
                                ))
                            }
                            /// Return the internal value as a `usize`.
                            #[inline]
                            pub const fn as_usize(&self) -> usize { self.0.as_usize() }
                            /// Return the internal value as a `u64`. This is guaranteed to never overflow.
                            #[inline]
                            pub const fn as_u64(&self) -> u64 { self.0.as_u64() }                
                            /// Return the internal value as a `u32`.
                            #[inline] pub const fn as_u32(&self) -> u32 { self.0.as_u32() }
                            /// Return the internal value as a i32`.
                            #[inline] pub const fn as_i32(&self) -> i32 { self.0.as_i32() }
                            /// Returns one more than this value as a usize.
                            #[inline] pub fn one_more(&self) -> usize { self.0.one_more() }
                            /// Decode this value from the bytes given using the native endian byte order for the current target.
                            #[inline] pub fn from_ne_bytes(bytes: [u8; 4]) -> Result<$name, $err> 
                            { SmallIndex::from_ne_bytes(bytes).map($name).map_err($err) }
                            /// Decode this value from the bytes given using the native endian byte order for the current target.
                            #[inline] pub fn from_ne_bytes_unchecked(bytes: [u8; 4]) -> $name 
                            { $name(SmallIndex::from_ne_bytes_unchecked(bytes)) }
                            /// Return the underlying integer as raw bytes in native endian format.
                            #[inline] pub fn to_ne_bytes(&self) -> [u8; 4] { self.0.to_ne_bytes() }
                            /// Returns an iterator over all values from 0 up to and not including the given length.
                            pub fn iter(len: usize) -> $iter { $iter::new(len) }
                        }
                        
                        impl ::fmt::Debug for $name
                        {
                            fn fmt(&self, f: &mut  ::fmt::Formatter) ->  ::fmt::Result
                            { f.debug_tuple(stringify!($name)).field(&self.as_u32()).finish() }
                        }
                
                        impl<T>  ::ops::Index<$name> for [T]
                        {
                            type Output = T;
                            #[inline] fn index(&self, index: $name) -> &T { &self[index.as_usize()] }
                        }
                
                        impl<T>  ::ops::IndexMut<$name> for [T]
                        {
                            #[inline] fn index_mut(&mut self, index: $name) -> &mut T { &mut self[index.as_usize()] }
                        }
                        
                        impl<T>  ::ops::Index<$name> for Vec<T>
                        {
                            type Output = T;                
                            #[inline] fn index(&self, index: $name) -> &T { &self[index.as_usize()] }
                        }

                        impl<T>  ::ops::IndexMut<$name> for Vec<T>
                        {
                            #[inline] fn index_mut(&mut self, index: $name) -> &mut T { &mut self[index.as_usize()] }
                        }
                
                        impl From<u8> for $name 
                        {
                            fn from(value: u8) -> $name { $name(SmallIndex::from(value)) }
                        }
                
                        impl TryFrom<u16> for $name
                        {
                            type Error = $err;                
                            fn try_from(value: u16) -> Result<$name, $err> { SmallIndex::try_from(value).map($name).map_err($err) }
                        }
                
                        impl TryFrom<u32> for $name
                        {
                            type Error = $err;                
                            fn try_from(value: u32) -> Result<$name, $err> { SmallIndex::try_from(value).map($name).map_err($err) }
                        }
                
                        impl TryFrom<u64> for $name
                        {
                            type Error = $err;                
                            fn try_from(value: u64) -> Result<$name, $err> { SmallIndex::try_from(value).map($name).map_err($err) }
                        }
                
                        impl TryFrom<usize> for $name 
                        {
                            type Error = $err;                
                            fn try_from(value: usize) -> Result<$name, $err> { SmallIndex::try_from(value).map($name).map_err($err) }
                        }
                        /// This error occurs when a value could not be constructed.
                        #[derive(Clone, Debug, Eq, PartialEq)]
                        pub struct $err(SmallIndexError);
                
                        impl $err 
                        {
                            /// Returns the value that could not be converted to an ID.
                            pub fn attempted(&self) -> u64 { self.0.attempted() }
                        }
                        
                        impl ::error::Error for $err {}
                
                        impl ::fmt::Display for $err
                        {
                            fn fmt(&self, f: &mut  ::fmt::Formatter) ->  ::fmt::Result
                            {
                                write!
                                (
                                    f,
                                    "failed to create {} from {:?}, which exceeds {:?}",
                                    stringify!($name),
                                    self.attempted(),
                                    $name::MAX,
                                )
                            }
                        }
                
                        #[derive(Clone, Debug)]
                        pub struct $iter(SmallIndexIter);
                
                        impl $iter
                        {
                            fn new(len: usize) -> $iter
                            {
                                assert!
                                (
                                    len <= $name::LIMIT,
                                    "cannot create iterator for {} when number of \
                                     elements exceed {:?}",
                                    stringify!($name),
                                    $name::LIMIT,
                                );
                                
                                $iter(SmallIndexIter { rng: 0..len })
                            }
                        }
                
                        impl Iterator for $iter 
                        {
                            type Item = $name;                
                            fn next(&mut self) -> Option<$name> { self.0.next().map($name) }
                        }                
                        /// An iterator adapter that is like  ::iter::Enumerate, but attaches
                        /// small index values instead.
                        #[derive(Clone, Debug)]
                        pub struct $withiter<I>
                        {
                            it: I,
                            ids: $iter,
                        }
                
                        impl<I: Iterator + ExactSizeIterator> $withiter<I>
                        {
                            fn new(it: I) -> $withiter<I>
                            {
                                let ids = $name::iter(it.len());
                                $withiter { it, ids }
                            }
                        }
                
                        impl<I: Iterator + ExactSizeIterator> Iterator for $withiter<I>
                        {
                            type Item = ($name, I::Item);                
                            fn next(&mut self) -> Option<($name, I::Item)> 
                            {
                                let item = self.it.next()?;
                                let id = self.ids.next().unwrap();
                                Some((id, item))
                            }
                        }
                    };
                }
                /// The identifier of a regex pattern, represented by a [`SmallIndex`].
                #[repr( transparent )] #[derive( Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord )]
                pub struct PatternID(SmallIndex);
                /// The identifier of a finite automaton state, represented by a [`SmallIndex`].
                #[repr( transparent )] #[derive( Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord )]
                pub struct StateID(SmallIndex);
                
                index_type_impls!(PatternID, PatternIDError, PatternIDIter, WithPatternIDIter);
                index_type_impls!(StateID, StateIDError, StateIDIter, WithStateIDIter);
                
                /// A utility trait that defines a couple of adapters for making it convenient to access indices as "small index" types.
                pub trait IteratorIndexExt: Iterator
                {
                    fn with_pattern_ids(self) -> WithPatternIDIter<Self> where
                    Self: Sized + ExactSizeIterator
                    { WithPatternIDIter::new(self) }
                
                    fn with_state_ids(self) -> WithStateIDIter<Self> where
                    Self: Sized + ExactSizeIterator
                    { WithStateIDIter::new(self) }
                }
                
                impl<I: Iterator> IteratorIndexExt for I {}
            }

            pub mod start
            {
                //! Provides helpers for dealing with start state configurations in DFAs.
                use ::
                {
                    *,
                };
                /*
                use crate::util::{
                    look::LookMatcher,
                    search::{Anchored, Input},
                    wire::{self, DeserializeError, SerializeError},
                };
                */
                /// A DFA has a single starting state in the typical textbook description.
                #[derive(Clone, Debug)]
                pub struct Config 
                {
                    look_behind: Option<u8>,
                    anchored: Anchored,
                }
                
                impl Config 
                {
                    /// Create a new default start configuration.
                    pub fn new() -> Config 
                    {
                        Config { anchored: Anchored::No, look_behind: None }
                    }
                    /// A convenience routine for building a start configuration from an [`Input`] for a forward search.
                    pub fn from_input_forward(input: &Input<'_>) -> Config 
                    {
                        let look_behind = input
                        .start()
                        .checked_sub(1)
                        .and_then(|i| input.haystack().get(i).copied());
                            
                        Config { look_behind, anchored: input.get_anchored() }
                    }
                    /// A convenience routine for building a start configuration from an [`Input`] for a reverse search.
                    pub fn from_input_reverse(input: &Input<'_>) -> Config 
                    {
                        let look_behind = input.haystack().get(input.end()).copied();
                        Config { look_behind, anchored: input.get_anchored() }
                    }
                    /// Set the look-behind byte at the start of a search.
                    pub fn look_behind(mut self, byte: Option<u8>) -> Config 
                    {
                        self.look_behind = byte;
                        self
                    }
                    /// Set the anchored mode of a search.
                    pub fn anchored(mut self, mode: Anchored) -> Config 
                    {
                        self.anchored = mode;
                        self
                    }
                    /// Return the look-behind byte in this configuration, if one exists.
                    pub fn get_look_behind(&self) -> Option<u8> { self.look_behind }
                    /// Return the anchored mode in this configuration.
                    pub fn get_anchored(&self) -> Anchored { self.anchored }
                }
                /// A map from every possible byte value to its corresponding starting configuration.
                #[derive(Clone)] 
                pub struct StartByteMap 
                {
                    map: [Start; 256],
                }
                
                impl StartByteMap 
                {
                    /// Create a new map from byte values to their corresponding starting
                    /// configurations.
                    pub fn new(lookm: &LookMatcher) -> StartByteMap 
                    {
                        let mut map = [Start::NonWordByte; 256];
                        map[usize::from(b'\n')] = Start::LineLF;
                        map[usize::from(b'\r')] = Start::LineCR;
                        map[usize::from(b'_')] = Start::WordByte;
                
                        let mut byte = b'0';

                        while byte <= b'9' 
                        {
                            map[usize::from(byte)] = Start::WordByte;
                            byte += 1;
                        }

                        byte = b'A';

                        while byte <= b'Z' 
                        {
                            map[usize::from(byte)] = Start::WordByte;
                            byte += 1;
                        }

                        byte = b'a';

                        while byte <= b'z' 
                        {
                            map[usize::from(byte)] = Start::WordByte;
                            byte += 1;
                        }
                
                        let lineterm = lookm.get_line_terminator();
                        
                        if lineterm != b'\r' && lineterm != b'\n'
                        { map[usize::from(lineterm)] = Start::CustomLineTerminator; }
                        
                        StartByteMap { map }
                    }
                    /// Return the starting configuration for the given look-behind byte.
                    #[inline(always)] pub fn get(&self, byte: u8) -> Start { self.map[usize::from(byte)] }
                    /// Deserializes a byte class map from the given slice.
                    pub fn from_bytes
                    (
                        slice: &[u8],
                    ) -> Result<(StartByteMap, usize), DeserializeError> 
                    {
                        wire::check_slice_len(slice, 256, "start byte map")?;
                        let mut map = [Start::NonWordByte; 256];

                        for (i, &repr) in slice[..256].iter().enumerate() 
                        {
                            map[i] = match Start::from_usize(usize::from(repr)) 
                            {
                                Some(start) => start,
                                None => 
                                {
                                    return Err(DeserializeError::generic( "found invalid starting configuration" ))
                                }
                            };
                        }
                        Ok((StartByteMap { map }, 256))
                    }
                    /// Writes this map to the given byte buffer.
                    pub fn write_to( &self, dst: &mut [u8] ) -> Result<usize, SerializeError> 
                    {
                        let nwrite = self.write_to_len();

                        if dst.len() < nwrite { return Err(SerializeError::buffer_too_small("start byte map")); }

                        for (i, &start) in self.map.iter().enumerate() 
                        {
                            dst[i] = start.as_u8();
                        }
                        
                        Ok(nwrite)
                    }
                    /// Returns the total number of bytes written by `write_to`.
                    pub fn write_to_len(&self) -> usize { 256 }
                }
                
                impl ::fmt::Debug for StartByteMap 
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result
                    {
                        use ::util::escape::DebugByte;
                
                        write!(f, "StartByteMap{{")?;

                        for byte in 0..=255 
                        {
                            if byte > 0 { write!(f, ", ")?; }

                            let start = self.map[usize::from(byte)];
                            write!(f, "{:?} => {:?}", DebugByte(byte), start)?;
                        }
                        
                        write!(f, "}}")?;
                        Ok(())
                    }
                }
                /// Represents the six possible starting configurations of a DFA search.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                pub enum Start 
                {
                    /// This occurs when the starting position is not any of the ones below.
                    NonWordByte = 0,
                    /// This occurs when the byte immediately preceding the start of the search is an ASCII word byte.
                    WordByte = 1,
                    /// This occurs when the starting position of the search corresponds to the beginning of the haystack.
                    Text = 2,
                    /// This occurs when the byte immediately preceding the start of the search is a line terminator.
                    LineLF = 3,
                    /// This occurs when the byte immediately preceding the start of the search is a line terminator.
                    LineCR = 4,
                    /// This occurs when a custom line terminator has been set via a `LookMatcher`,
                    /// and when that line terminator is neither a `\r` or a `\n`.
                    CustomLineTerminator = 5,
                }
                
                impl Start 
                {
                    /// Return the starting state corresponding to the given integer.
                    pub fn from_usize(n: usize) -> Option<Start>
                    {
                        match n 
                        {
                            0 => Some(Start::NonWordByte),
                            1 => Some(Start::WordByte),
                            2 => Some(Start::Text),
                            3 => Some(Start::LineLF),
                            4 => Some(Start::LineCR),
                            5 => Some(Start::CustomLineTerminator),
                            _ => None,
                        }
                    }
                    /// Returns the total number of starting state configurations.
                    pub fn len() -> usize { 6 }
                    /// Return this starting configuration as `u8` integer.
                    pub fn as_u8(&self) -> u8 { *self as u8 }                
                    /// Return this starting configuration as a `usize` integer.guaranteed to be less than `Start::len()`.
                    pub fn as_usize(&self) -> usize { usize::from(self.as_u8()) }
                }
            }

            pub mod wire
            {
                //! Types and routines that support the wire format of finite automata.
                use ::
                {
                    mem::size_of,
                    vec::{ self, Vec },
                    *,
                };
                /*                
                use crate::util::{
                    int::Pointer,
                    primitives::{PatternID, PatternIDError, StateID, StateIDError},
                };
                */
                /// A hack to align a smaller type `B` with a bigger type `T`.
                #[repr(C)] #[derive(Debug)]
                pub struct AlignAs<B: ?Sized, T> 
                {
                    /// A zero-sized field indicating the alignment we want.
                    pub _align: [T; 0],
                    /// A possibly non-sized field containing a sequence of bytes.
                    pub bytes: B,
                }
                /// An error that occurs when serializing an object from this crate.
                #[derive(Debug)]
                pub struct SerializeError 
                {
                    /// The name of the thing that a buffer is too small for.
                    what: &'static str,
                }
                
                impl SerializeError 
                {
                    pub fn buffer_too_small(what: &'static str) -> SerializeError { SerializeError { what } }
                }
                
                impl ::fmt::Display for SerializeError {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(f, "destination buffer is too small to write {}", self.what)
                    }
                }
                
                impl ::error::Error for SerializeError {}
                /// An error that occurs when deserializing an object defined in this crate.
                #[derive(Debug)]
                pub struct DeserializeError(DeserializeErrorKind);
                
                #[derive(Debug)]
                enum DeserializeErrorKind 
                {
                    Generic { msg: &'static str },
                    BufferTooSmall { what: &'static str },
                    InvalidUsize { what: &'static str },
                    VersionMismatch { expected: u32, found: u32 },
                    EndianMismatch { expected: u32, found: u32 },
                    AlignmentMismatch { alignment: usize, address: usize },
                    LabelMismatch { expected: &'static str },
                    ArithmeticOverflow { what: &'static str },
                    PatternID { err: PatternIDError, what: &'static str },
                    StateID { err: StateIDError, what: &'static str },
                }
                
                impl DeserializeError 
                {
                    pub fn generic(msg: &'static str) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::Generic { msg })
                    }
                
                    pub fn buffer_too_small(what: &'static str) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::BufferTooSmall { what })
                    }
                
                    fn invalid_usize(what: &'static str) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::InvalidUsize { what })
                    }
                
                    fn version_mismatch(expected: u32, found: u32) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::VersionMismatch {
                            expected,
                            found,
                        })
                    }
                
                    fn endian_mismatch(expected: u32, found: u32) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::EndianMismatch {
                            expected,
                            found,
                        })
                    }
                
                    fn alignment_mismatch(
                        alignment: usize,
                        address: usize,
                    ) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::AlignmentMismatch {
                            alignment,
                            address,
                        })
                    }
                
                    fn label_mismatch(expected: &'static str) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::LabelMismatch { expected })
                    }
                
                    fn arithmetic_overflow(what: &'static str) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::ArithmeticOverflow { what })
                    }
                
                    fn pattern_id_error(
                        err: PatternIDError,
                        what: &'static str,
                    ) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::PatternID { err, what })
                    }
                
                    pub fn state_id_error(
                        err: StateIDError,
                        what: &'static str,
                    ) -> DeserializeError {
                        DeserializeError(DeserializeErrorKind::StateID { err, what })
                    }
                }
                
                impl ::error::Error for DeserializeError {}
                
                impl ::fmt::Display for DeserializeError 
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        use self::DeserializeErrorKind::*;
                
                        match self.0 {
                            Generic { msg } => write!(f, "{}", msg),
                            BufferTooSmall { what } => {
                                write!(f, "buffer is too small to read {}", what)
                            }
                            InvalidUsize { what } => {
                                write!(f, "{} is too big to fit in a usize", what)
                            }
                            VersionMismatch { expected, found } => write!(
                                f,
                                "unsupported version: \
                                 expected version {} but found version {}",
                                expected, found,
                            ),
                            EndianMismatch { expected, found } => write!(
                                f,
                                "endianness mismatch: expected 0x{:X} but got 0x{:X}. \
                                 (Are you trying to load an object serialized with a \
                                 different endianness?)",
                                expected, found,
                            ),
                            AlignmentMismatch { alignment, address } => write!(
                                f,
                                "alignment mismatch: slice starts at address \
                                 0x{:X}, which is not aligned to a {} byte boundary",
                                address, alignment,
                            ),
                            LabelMismatch { expected } => write!(
                                f,
                                "label mismatch: start of serialized object should \
                                 contain a NUL terminated {:?} label, but a different \
                                 label was found",
                                expected,
                            ),
                            ArithmeticOverflow { what } => {
                                write!(f, "arithmetic overflow for {}", what)
                            }
                            PatternID { ref err, what } => {
                                write!(f, "failed to read pattern ID for {}: {}", what, err)
                            }
                            StateID { ref err, what } => {
                                write!(f, "failed to read state ID for {}: {}", what, err)
                            }
                        }
                    }
                }
                /// Safely converts a `&[u32]` to `&[StateID]` with zero cost.
                pub fn u32s_to_state_ids(slice: &[u32]) -> &[StateID] 
                {
                    unsafe {
                        ::slice::from_raw_parts(
                            slice.as_ptr().cast::<StateID>(),
                            slice.len(),
                        )
                    }
                }
                /// Safely converts a `&mut [u32]` to `&mut [StateID]` with zero cost.
                pub fn u32s_to_state_ids_mut(slice: &mut [u32]) -> &mut [StateID] 
                {
                    unsafe {
                        ::slice::from_raw_parts_mut(
                            slice.as_mut_ptr().cast::<StateID>(),
                            slice.len(),
                        )
                    }
                }
                
                /// Safely converts a `&[u32]` to `&[PatternID]` with zero cost.
                pub fn u32s_to_pattern_ids(slice: &[u32]) -> &[PatternID] 
                {
                    unsafe {
                        ::slice::from_raw_parts(
                            slice.as_ptr().cast::<PatternID>(),
                            slice.len(),
                        )
                    }
                }
                
                /// Checks that the given slice has an alignment that matches `T`.
                pub fn check_alignment<T>(
                    slice: &[u8],
                ) -> Result<(), DeserializeError> {
                    let alignment = ::mem::align_of::<T>();
                    let address = slice.as_ptr().as_usize();
                    if address % alignment == 0 {
                        return Ok(());
                    }
                    Err(DeserializeError::alignment_mismatch(alignment, address))
                }                
                /// Reads a possibly empty amount of padding, up to 7 bytes, from the beginning
                /// of the given slice.
                pub fn skip_initial_padding(slice: &[u8]) -> usize {
                    let mut nread = 0;
                    while nread < 7 && nread < slice.len() && slice[nread] == 0 {
                        nread += 1;
                    }
                    nread
                }                
                /// Allocate a byte buffer of the given size, along with some initial padding
                /// such that `buf[padding..]` has the same alignment as `T`, where the
                /// alignment of `T` must be at most `8`.
                pub fn alloc_aligned_buffer<T>(size: usize) -> (Vec<u8>, usize) 
                {
                    let buf = vec![0; size];
                    let align = ::mem::align_of::<T>();
                    let address = buf.as_ptr().as_usize();
                    if address % align == 0 {
                        return (buf, 0);
                    }
                    
                    let extra = align - 1;
                    let mut buf = vec![0; size + extra];
                    let address = buf.as_ptr().as_usize();
                    
                    if address % align == 0 {
                        buf.truncate(size);
                        return (buf, 0);
                    }
                    let padding = ((address & !(align - 1)).checked_add(align).unwrap())
                        .checked_sub(address)
                        .unwrap();
                    assert!(padding <= 7, "padding of {} is bigger than 7", padding);
                    assert!(
                        padding <= extra,
                        "padding of {} is bigger than extra {} bytes",
                        padding,
                        extra
                    );
                    buf.truncate(size + padding);
                    assert_eq!(size + padding, buf.len());
                    assert_eq!(
                        0,
                        buf[padding..].as_ptr().as_usize() % align,
                        "expected end of initial padding to be aligned to {}",
                        align,
                    );
                    (buf, padding)
                }                
                /// Reads a NUL terminated label starting at the beginning of the given slice.
                pub fn read_label(
                    slice: &[u8],
                    expected_label: &'static str,
                ) -> Result<usize, DeserializeError> 
                {
                    let first_nul =
                        slice[..cmp::min(slice.len(), 256)].iter().position(|&b| b == 0);
                    let first_nul = match first_nul {
                        Some(first_nul) => first_nul,
                        None => {
                            return Err(DeserializeError::generic(
                                "could not find NUL terminated label \
                                 at start of serialized object",
                            ));
                        }
                    };
                    let len = first_nul + padding_len(first_nul);
                    if slice.len() < len {
                        return Err(DeserializeError::generic(
                            "could not find properly sized label at start of serialized object"
                        ));
                    }
                    if expected_label.as_bytes() != &slice[..first_nul] {
                        return Err(DeserializeError::label_mismatch(expected_label));
                    }
                    Ok(len)
                }                
                /// Writes the given label to the buffer as a NUL terminated string.
                pub fn write_label(
                    label: &str,
                    dst: &mut [u8],
                ) -> Result<usize, SerializeError> {
                    let nwrite = write_label_len(label);
                    if dst.len() < nwrite {
                        return Err(SerializeError::buffer_too_small("label"));
                    }
                    dst[..label.len()].copy_from_slice(label.as_bytes());
                    for i in 0..(nwrite - label.len()) {
                        dst[label.len() + i] = 0;
                    }
                    assert_eq!(nwrite % 4, 0);
                    Ok(nwrite)
                }                
                /// Returns the total number of bytes (including padding) that would be written
                /// for the given label
                pub fn write_label_len(label: &str) -> usize {
                    if label.len() > 255 {
                        panic!("label must not be longer than 255 bytes");
                    }
                    if label.as_bytes().iter().position(|&b| b == 0).is_some() {
                        panic!("label must not contain NUL bytes");
                    }
                    let label_len = label.len() + 1; // +1 for the NUL terminator
                    label_len + padding_len(label_len)
                }
                
                /// Reads the endianness check from the beginning of the given slice and
                /// confirms that the endianness of the serialized object matches the expected
                /// endianness.
                pub fn read_endianness_check(
                    slice: &[u8],
                ) -> Result<usize, DeserializeError> {
                    let (n, nr) = try_read_u32(slice, "endianness check")?;
                    assert_eq!(nr, write_endianness_check_len());
                    if n != 0xFEFF {
                        return Err(DeserializeError::endian_mismatch(0xFEFF, n));
                    }
                    Ok(nr)
                }                
                /// Writes 0xFEFF as an integer using the given endianness.
                pub fn write_endianness_check<E: Endian>(
                    dst: &mut [u8],
                ) -> Result<usize, SerializeError> {
                    let nwrite = write_endianness_check_len();
                    if dst.len() < nwrite {
                        return Err(SerializeError::buffer_too_small("endianness check"));
                    }
                    E::write_u32(0xFEFF, dst);
                    Ok(nwrite)
                }                
                /// Returns the number of bytes written by the endianness check.
                pub fn write_endianness_check_len() -> usize {
                    size_of::<u32>()
                }                
                /// Reads a version number from the beginning of the given slice and confirms
                /// that is matches the expected version number given.
                pub fn read_version(
                    slice: &[u8],
                    expected_version: u32,
                ) -> Result<usize, DeserializeError> {
                    let (n, nr) = try_read_u32(slice, "version")?;
                    assert_eq!(nr, write_version_len());
                    if n != expected_version {
                        return Err(DeserializeError::version_mismatch(expected_version, n));
                    }
                    Ok(nr)
                }                
                /// Writes the given version number to the beginning of the given slice.
                pub fn write_version<E: Endian>(
                    version: u32,
                    dst: &mut [u8],
                ) -> Result<usize, SerializeError> {
                    let nwrite = write_version_len();
                    if dst.len() < nwrite {
                        return Err(SerializeError::buffer_too_small("version number"));
                    }
                    E::write_u32(version, dst);
                    Ok(nwrite)
                }                
                /// Returns the number of bytes written by writing the version number.
                pub fn write_version_len() -> usize {
                    size_of::<u32>()
                }                
                /// Reads a pattern ID from the given slice. If the slice has insufficient
                /// length, then this panics.
                pub fn read_pattern_id(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(PatternID, usize), DeserializeError> {
                    let bytes: [u8; PatternID::SIZE] =
                        slice[..PatternID::SIZE].try_into().unwrap();
                    let pid = PatternID::from_ne_bytes(bytes)
                        .map_err(|err| DeserializeError::pattern_id_error(err, what))?;
                    Ok((pid, PatternID::SIZE))
                }                
                /// Reads a pattern ID from the given slice.
                pub fn read_pattern_id_unchecked(slice: &[u8]) -> (PatternID, usize) {
                    let pid = PatternID::from_ne_bytes_unchecked(
                        slice[..PatternID::SIZE].try_into().unwrap(),
                    );
                    (pid, PatternID::SIZE)
                }                
                /// Write the given pattern ID to the beginning of the given slice of bytes
                /// using the specified endianness.
                pub fn write_pattern_id<E: Endian>(
                    pid: PatternID,
                    dst: &mut [u8],
                ) -> usize {
                    E::write_u32(pid.as_u32(), dst);
                    PatternID::SIZE
                }                
                /// Attempts to read a state ID from the given slice.
                pub fn try_read_state_id(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(StateID, usize), DeserializeError> {
                    if slice.len() < StateID::SIZE {
                        return Err(DeserializeError::buffer_too_small(what));
                    }
                    read_state_id(slice, what)
                }                
                /// Reads a state ID from the given slice.
                pub fn read_state_id(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(StateID, usize), DeserializeError> {
                    let bytes: [u8; StateID::SIZE] =
                        slice[..StateID::SIZE].try_into().unwrap();
                    let sid = StateID::from_ne_bytes(bytes)
                        .map_err(|err| DeserializeError::state_id_error(err, what))?;
                    Ok((sid, StateID::SIZE))
                }                
                /// Reads a state ID from the given slice.
                pub fn read_state_id_unchecked(slice: &[u8]) -> (StateID, usize) {
                    let sid = StateID::from_ne_bytes_unchecked(
                        slice[..StateID::SIZE].try_into().unwrap(),
                    );
                    (sid, StateID::SIZE)
                }
                /// Write the given state ID to the beginning of the given slice of bytes
                /// using the specified endianness.
                pub fn write_state_id<E: Endian>(
                    sid: StateID,
                    dst: &mut [u8],
                ) -> usize {
                    E::write_u32(sid.as_u32(), dst);
                    StateID::SIZE
                }                
                /// Try to read a u16 as a usize from the beginning of the given slice in
                /// native endian format.
                pub fn try_read_u16_as_usize(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(usize, usize), DeserializeError> {
                    try_read_u16(slice, what).and_then(|(n, nr)| {
                        usize::try_from(n)
                            .map(|n| (n, nr))
                            .map_err(|_| DeserializeError::invalid_usize(what))
                    })
                }                
                /// Try to read a u32 as a usize from the beginning of the given slice in
                /// native endian format.
                pub fn try_read_u32_as_usize(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(usize, usize), DeserializeError> {
                    try_read_u32(slice, what).and_then(|(n, nr)| {
                        usize::try_from(n)
                            .map(|n| (n, nr))
                            .map_err(|_| DeserializeError::invalid_usize(what))
                    })
                }                
                /// Try to read a u16 from the beginning of the given slice in native endian
                /// format.
                pub fn try_read_u16(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(u16, usize), DeserializeError> {
                    check_slice_len(slice, size_of::<u16>(), what)?;
                    Ok((read_u16(slice), size_of::<u16>()))
                }
                
                /// Try to read a u32 from the beginning of the given slice in native endian
                /// format.
                pub fn try_read_u32(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(u32, usize), DeserializeError> {
                    check_slice_len(slice, size_of::<u32>(), what)?;
                    Ok((read_u32(slice), size_of::<u32>()))
                }                
                /// Try to read a u128 from the beginning of the given slice in native endian
                /// format.
                pub fn try_read_u128(
                    slice: &[u8],
                    what: &'static str,
                ) -> Result<(u128, usize), DeserializeError> {
                    check_slice_len(slice, size_of::<u128>(), what)?;
                    Ok((read_u128(slice), size_of::<u128>()))
                }                
                /// Read a u16 from the beginning of the given slice in native endian format.
                pub fn read_u16(slice: &[u8]) -> u16 {
                    let bytes: [u8; 2] = slice[..size_of::<u16>()].try_into().unwrap();
                    u16::from_ne_bytes(bytes)
                }                
                /// Read a u32 from the beginning of the given slice in native endian format.
                pub fn read_u32(slice: &[u8]) -> u32 {
                    let bytes: [u8; 4] = slice[..size_of::<u32>()].try_into().unwrap();
                    u32::from_ne_bytes(bytes)
                }                
                /// Read a u128 from the beginning of the given slice in native endian format.
                pub fn read_u128(slice: &[u8]) -> u128 {
                    let bytes: [u8; 16] = slice[..size_of::<u128>()].try_into().unwrap();
                    u128::from_ne_bytes(bytes)
                }                
                /// Checks that the given slice has some minimal length.
                pub fn check_slice_len<T>(
                    slice: &[T],
                    at_least_len: usize,
                    what: &'static str,
                ) -> Result<(), DeserializeError> {
                    if slice.len() < at_least_len {
                        return Err(DeserializeError::buffer_too_small(what));
                    }
                    Ok(())
                }                
                /// Multiply the given numbers, and on overflow, return an error that includes 'what' in the error message.
                pub fn mul(
                    a: usize,
                    b: usize,
                    what: &'static str,
                ) -> Result<usize, DeserializeError> 
                {
                    match a.checked_mul(b) {
                        Some(c) => Ok(c),
                        None => Err(DeserializeError::arithmetic_overflow(what)),
                    }
                }                
                /// Add the given numbers, and on overflow, return an error that includes 'what' in the error message.
                pub fn add(
                    a: usize,
                    b: usize,
                    what: &'static str,
                ) -> Result<usize, DeserializeError> {
                    match a.checked_add(b) {
                        Some(c) => Ok(c),
                        None => Err(DeserializeError::arithmetic_overflow(what)),
                    }
                }                
                /// Shift `a` left by `b`, and on overflow, return an error that includes
                /// 'what' in the error message.
                pub fn shl(
                    a: usize,
                    b: usize,
                    what: &'static str,
                ) -> Result<usize, DeserializeError> {
                    let amount = u32::try_from(b)
                        .map_err(|_| DeserializeError::arithmetic_overflow(what))?;
                    match a.checked_shl(amount) {
                        Some(c) => Ok(c),
                        None => Err(DeserializeError::arithmetic_overflow(what)),
                    }
                }                
                /// Returns the number of additional bytes required to add to the given length
                /// in order to make the total length a multiple of 4.
                pub fn padding_len(non_padding_len: usize) -> usize {
                    (4 - (non_padding_len & 0b11)) & 0b11
                }                
                /// A simple trait for writing code generic over endianness.
                pub trait Endian {
                    /// Writes a u16 to the given destination buffer in a particular
                    /// endianness.
                    fn write_u16(n: u16, dst: &mut [u8]);
                
                    /// Writes a u32 to the given destination buffer in a particular
                    /// endianness.
                    fn write_u32(n: u32, dst: &mut [u8]);
                
                    /// Writes a u128 to the given destination buffer in a particular
                    /// endianness.
                    fn write_u128(n: u128, dst: &mut [u8]);
                }
                
                /// Little endian writing.
                pub enum LE {}
                /// Big endian writing.
                pub enum BE {}
                
                #[cfg(target_endian = "little")]
                pub type NE = LE;
                #[cfg(target_endian = "big")]
                pub type NE = BE;
                
                impl Endian for LE {
                    fn write_u16(n: u16, dst: &mut [u8]) {
                        dst[..2].copy_from_slice(&n.to_le_bytes());
                    }
                
                    fn write_u32(n: u32, dst: &mut [u8]) {
                        dst[..4].copy_from_slice(&n.to_le_bytes());
                    }
                
                    fn write_u128(n: u128, dst: &mut [u8]) {
                        dst[..16].copy_from_slice(&n.to_le_bytes());
                    }
                }
                
                impl Endian for BE {
                    fn write_u16(n: u16, dst: &mut [u8]) {
                        dst[..2].copy_from_slice(&n.to_be_bytes());
                    }
                
                    fn write_u32(n: u32, dst: &mut [u8]) {
                        dst[..4].copy_from_slice(&n.to_be_bytes());
                    }
                
                    fn write_u128(n: u128, dst: &mut [u8]) {
                        dst[..16].copy_from_slice(&n.to_be_bytes());
                    }
                }
            }

            pub mod empty
            {
                //! This module provides helper routines for dealing with zero-width matches.
                use ::
                {
                    *,
                };
                /*
                use crate::util::search::{Input, MatchError};
                */
                #[cold]
                #[inline(never)]
                pub fn skip_splits_fwd<T, F>(
                    input: &Input<'_>,
                    init_value: T,
                    match_offset: usize,
                    find: F,
                ) -> Result<Option<T>, MatchError>
                where
                    F: FnMut(&Input<'_>) -> Result<Option<(T, usize)>, MatchError>,
                {
                    skip_splits(true, input, init_value, match_offset, find)
                }
                
                #[cold]
                #[inline(never)]
                pub fn skip_splits_rev<T, F>(
                    input: &Input<'_>,
                    init_value: T,
                    match_offset: usize,
                    find: F,
                ) -> Result<Option<T>, MatchError>
                where
                    F: FnMut(&Input<'_>) -> Result<Option<(T, usize)>, MatchError>,
                {
                    skip_splits(false, input, init_value, match_offset, find)
                }
                
                fn skip_splits<T, F>(
                    forward: bool,
                    input: &Input<'_>,
                    init_value: T,
                    mut match_offset: usize,
                    mut find: F,
                ) -> Result<Option<T>, MatchError>
                where
                    F: FnMut(&Input<'_>) -> Result<Option<(T, usize)>, MatchError>,
                {
                    if input.get_anchored().is_anchored() {
                        return Ok(if input.is_char_boundary(match_offset) {
                            Some(init_value)
                        } else {
                            None
                        });
                    }
                    
                    let mut value = init_value;
                    let mut input = input.clone();
                    while !input.is_char_boundary(match_offset) {
                        if forward {
                            input.set_start(input.start().checked_add(1).unwrap());
                        } else {
                            input.set_end(match input.end().checked_sub(1) {
                                None => return Ok(None),
                                Some(end) => end,
                            });
                        }
                        match find(&input)? {
                            None => return Ok(None),
                            Some((new_value, new_match_end)) => {
                                value = new_value;
                                match_offset = new_match_end;
                            }
                        }
                    }
                    Ok(Some(value))
                }
            }

            pub mod int
            {
                //! This module provides several integer oriented traits for converting between both 
                //! fixed size integers and integers whose size varies based on the target.
                use ::
                {
                    *,
                };
                /*
                */
                pub trait U8 {
                    fn as_usize(self) -> usize;
                }
                
                impl U8 for u8 {
                    fn as_usize(self) -> usize {
                        usize::from(self)
                    }
                }
                
                pub trait U16 {
                    fn as_usize(self) -> usize;
                    fn low_u8(self) -> u8;
                    fn high_u8(self) -> u8;
                }
                
                impl U16 for u16 {
                    fn as_usize(self) -> usize {
                        usize::from(self)
                    }
                
                    fn low_u8(self) -> u8 {
                        self as u8
                    }
                
                    fn high_u8(self) -> u8 {
                        (self >> 8) as u8
                    }
                }
                
                pub trait U32 {
                    fn as_usize(self) -> usize;
                    fn low_u8(self) -> u8;
                    fn low_u16(self) -> u16;
                    fn high_u16(self) -> u16;
                }
                
                impl U32 for u32 {
                    fn as_usize(self) -> usize {
                        self as usize
                    }
                
                    fn low_u8(self) -> u8 {
                        self as u8
                    }
                
                    fn low_u16(self) -> u16 {
                        self as u16
                    }
                
                    fn high_u16(self) -> u16 {
                        (self >> 16) as u16
                    }
                }
                
                pub trait U64 {
                    fn as_usize(self) -> usize;
                    fn low_u8(self) -> u8;
                    fn low_u16(self) -> u16;
                    fn low_u32(self) -> u32;
                    fn high_u32(self) -> u32;
                }
                
                impl U64 for u64 {
                    fn as_usize(self) -> usize {
                        self as usize
                    }
                
                    fn low_u8(self) -> u8 {
                        self as u8
                    }
                
                    fn low_u16(self) -> u16 {
                        self as u16
                    }
                
                    fn low_u32(self) -> u32 {
                        self as u32
                    }
                
                    fn high_u32(self) -> u32 {
                        (self >> 32) as u32
                    }
                }
                
                pub trait I32 {
                    fn as_usize(self) -> usize;
                    fn to_bits(self) -> u32;
                    fn from_bits(n: u32) -> i32;
                }
                
                impl I32 for i32 {
                    fn as_usize(self) -> usize {
                        self as usize
                    }
                
                    fn to_bits(self) -> u32 {
                        self as u32
                    }
                
                    fn from_bits(n: u32) -> i32 {
                        n as i32
                    }
                }
                
                pub trait Usize {
                    fn as_u8(self) -> u8;
                    fn as_u16(self) -> u16;
                    fn as_u32(self) -> u32;
                    fn as_u64(self) -> u64;
                }
                
                impl Usize for usize {
                    fn as_u8(self) -> u8 {
                        self as u8
                    }
                
                    fn as_u16(self) -> u16 {
                        self as u16
                    }
                
                    fn as_u32(self) -> u32 {
                        self as u32
                    }
                
                    fn as_u64(self) -> u64 {
                        self as u64
                    }
                }
                
                pub trait Pointer {
                    fn as_usize(self) -> usize;
                }
                
                impl<T> Pointer for *const T {
                    fn as_usize(self) -> usize {
                        self as usize
                    }
                }
            }

            pub mod memchr
            {
                //! This module defines simple wrapper routines for the memchr functions from the `memchr` crate.
                use ::
                {
                    *,
                };
                /*
                */
                pub use self::inner::*;
                
                pub mod inner 
                {
                    #[inline(always)]
                    pub fn memchr(n1: u8, haystack: &[u8]) -> Option<usize> {
                        ::mem::chr::memchr(n1, haystack)
                    }
                
                    #[inline(always)]
                    pub fn memchr2(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
                        ::mem::chr::memchr2(n1, n2, haystack)
                    }
                
                    #[inline(always)]
                    pub fn memchr3(
                        n1: u8,
                        n2: u8,
                        n3: u8,
                        haystack: &[u8],
                    ) -> Option<usize> {
                        ::mem::chr::memchr3(n1, n2, n3, haystack)
                    }
                
                    #[inline(always)]
                    pub fn memrchr(n1: u8, haystack: &[u8]) -> Option<usize> {
                        ::mem::chr::memrchr(n1, haystack)
                    }
                
                    #[inline(always)]
                    pub fn memrchr2(n1: u8, n2: u8, haystack: &[u8]) -> Option<usize> {
                        ::mem::chr::memrchr2(n1, n2, haystack)
                    }
                
                    #[inline(always)]
                    pub fn memrchr3(
                        n1: u8,
                        n2: u8,
                        n3: u8,
                        haystack: &[u8],
                    ) -> Option<usize> {
                        ::mem::chr::memrchr3(n1, n2, n3, haystack)
                    }
                }
            }

            pub mod search
            {
                //! Types and routines that support the search APIs of most regex engines.
                use ::
                {
                    ops::{Range, RangeBounds},
                    *,
                };
                /*
                use crate::util::{escape::DebugByte, primitives::PatternID, utf8};
                */
                /// The parameters for a regex search including the haystack to search.
                #[derive(Clone)]
                pub struct Input<'h> {
                    haystack: &'h [u8],
                    span: Span,
                    anchored: Anchored,
                    earliest: bool,
                }
                
                impl<'h> Input<'h> {
                    /// Create a new search configuration for the given haystack.
                    #[inline]
                    pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {
                        let haystack = haystack.as_ref();
                        Input {
                            haystack,
                            span: Span { start: 0, end: haystack.len() },
                            anchored: Anchored::No,
                            earliest: false,
                        }
                    }
                
                    /// Set the span for this search.
                    #[inline]
                    pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {
                        self.set_span(span);
                        self
                    }
                
                    /// Like `Input::span`, but accepts any range instead.
                    #[inline]
                    pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {
                        self.set_range(range);
                        self
                    }
                
                    /// Sets the anchor mode of a search.
                    #[inline]
                    pub fn anchored(mut self, mode: Anchored) -> Input<'h> {
                        self.set_anchored(mode);
                        self
                    }
                
                    /// Whether to execute an "earliest" search or not.
                    #[inline]
                    pub fn earliest(mut self, yes: bool) -> Input<'h> {
                        self.set_earliest(yes);
                        self
                    }
                
                    /// Set the span for this search configuration.
                    #[inline]
                    pub fn set_span<S: Into<Span>>(&mut self, span: S) {
                        let span = span.into();
                        assert!(
                            span.end <= self.haystack.len()
                                && span.start <= span.end.wrapping_add(1),
                            "invalid span {:?} for haystack of length {}",
                            span,
                            self.haystack.len(),
                        );
                        self.span = span;
                    }
                
                    /// Set the span for this search configuration given any range.
                    #[inline]
                    pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {
                        use ::ops::Bound;
                        
                        let start = match range.start_bound() {
                            Bound::Included(&i) => i,
                            Bound::Excluded(&i) => i.checked_add(1).unwrap(),
                            Bound::Unbounded => 0,
                        };
                        let end = match range.end_bound() {
                            Bound::Included(&i) => i.checked_add(1).unwrap(),
                            Bound::Excluded(&i) => i,
                            Bound::Unbounded => self.haystack().len(),
                        };
                        self.set_span(Span { start, end });
                    }
                
                    /// Set the starting offset for the span for this search configuration.
                    #[inline]
                    pub fn set_start(&mut self, start: usize) {
                        self.set_span(Span { start, ..self.get_span() });
                    }
                
                    /// Set the ending offset for the span for this search configuration.
                    #[inline]
                    pub fn set_end(&mut self, end: usize) {
                        self.set_span(Span { end, ..self.get_span() });
                    }
                
                    /// Set the anchor mode of a search.
                    #[inline]
                    pub fn set_anchored(&mut self, mode: Anchored) {
                        self.anchored = mode;
                    }
                
                    /// Set whether the search should execute in "earliest" mode or not.
                    #[inline]
                    pub fn set_earliest(&mut self, yes: bool) {
                        self.earliest = yes;
                    }
                
                    /// Return a borrow of the underlying haystack as a slice of bytes.
                    #[inline]
                    pub fn haystack(&self) -> &[u8] {
                        self.haystack
                    }
                
                    /// Return the start position of this search.
                    #[inline]
                    pub fn start(&self) -> usize {
                        self.get_span().start
                    }
                
                    /// Return the end position of this search.
                    #[inline]
                    pub fn end(&self) -> usize {
                        self.get_span().end
                    }
                
                    /// Return the span for this search configuration.
                    #[inline]
                    pub fn get_span(&self) -> Span {
                        self.span
                    }
                
                    /// Return the span as a range for this search configuration.
                    #[inline]
                    pub fn get_range(&self) -> Range<usize> {
                        self.get_span().range()
                    }
                
                    /// Return the anchored mode for this search configuration.
                    #[inline]
                    pub fn get_anchored(&self) -> Anchored {
                        self.anchored
                    }
                
                    /// Return whether this search should execute in "earliest" mode.
                    #[inline]
                    pub fn get_earliest(&self) -> bool {
                        self.earliest
                    }
                
                    /// Return true if and only if this search can never return any other
                    /// matches.
                    #[inline]
                    pub fn is_done(&self) -> bool {
                        self.get_span().start > self.get_span().end
                    }
                
                    /// Returns true if and only if the given offset in this search's haystack
                    /// falls on a valid UTF-8 encoded codepoint boundary.
                    #[inline]
                    pub fn is_char_boundary(&self, offset: usize) -> bool {
                        utf8::is_boundary(self.haystack(), offset)
                    }
                }
                
                impl<'h> ::fmt::Debug for Input<'h> {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        use ::util::escape::DebugHaystack;
                
                        f.debug_struct("Input")
                            .field("haystack", &DebugHaystack(self.haystack()))
                            .field("span", &self.span)
                            .field("anchored", &self.anchored)
                            .field("earliest", &self.earliest)
                            .finish()
                    }
                }
                
                impl<'h, H: ?Sized + AsRef<[u8]>> From<&'h H> for Input<'h> {
                    fn from(haystack: &'h H) -> Input<'h> {
                        Input::new(haystack)
                    }
                }
                
                /// A representation of a span reported by a regex engine.
                #[derive(Clone, Copy, Eq, Hash, PartialEq)]
                pub struct Span {
                    /// The start offset of the span, inclusive.
                    pub start: usize,
                    /// The end offset of the span, exclusive.
                    pub end: usize,
                }
                
                impl Span {
                    /// Returns this span as a range.
                    #[inline]
                    pub fn range(&self) -> Range<usize> {
                        Range::from(*self)
                    }
                
                    /// Returns true when this span is empty. That is, when `start >= end`.
                    #[inline]
                    pub fn is_empty(&self) -> bool {
                        self.start >= self.end
                    }
                
                    /// Returns the length of this span.
                    #[inline]
                    pub fn len(&self) -> usize {
                        self.end.saturating_sub(self.start)
                    }
                
                    /// Returns true when the given offset is contained within this span.
                    #[inline]
                    pub fn contains(&self, offset: usize) -> bool {
                        !self.is_empty() && self.start <= offset && offset <= self.end
                    }
                
                    /// Returns a new span with `offset` added to this span's `start` and `end`
                    /// values.
                    #[inline]
                    pub fn offset(&self, offset: usize) -> Span {
                        Span { start: self.start + offset, end: self.end + offset }
                    }
                }
                
                impl ::fmt::Debug for Span {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(f, "{}..{}", self.start, self.end)
                    }
                }
                
                impl ::ops::Index<Span> for [u8] {
                    type Output = [u8];
                
                    #[inline]
                    fn index(&self, index: Span) -> &[u8] {
                        &self[index.range()]
                    }
                }
                
                impl ::ops::IndexMut<Span> for [u8] {
                    #[inline]
                    fn index_mut(&mut self, index: Span) -> &mut [u8] {
                        &mut self[index.range()]
                    }
                }
                
                impl ::ops::Index<Span> for str {
                    type Output = str;
                
                    #[inline]
                    fn index(&self, index: Span) -> &str {
                        &self[index.range()]
                    }
                }
                
                impl From<Range<usize>> for Span {
                    #[inline]
                    fn from(range: Range<usize>) -> Span {
                        Span { start: range.start, end: range.end }
                    }
                }
                
                impl From<Span> for Range<usize> {
                    #[inline]
                    fn from(span: Span) -> Range<usize> {
                        Range { start: span.start, end: span.end }
                    }
                }
                
                impl PartialEq<Range<usize>> for Span {
                    #[inline]
                    fn eq(&self, range: &Range<usize>) -> bool {
                        self.start == range.start && self.end == range.end
                    }
                }
                
                impl PartialEq<Span> for Range<usize> {
                    #[inline]
                    fn eq(&self, span: &Span) -> bool {
                        self.start == span.start && self.end == span.end
                    }
                }
                
                /// A representation of "half" of a match reported by a DFA.
                #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
                pub struct HalfMatch {
                    /// The pattern ID.
                    pattern: PatternID,
                    /// The offset of the match.
                    offset: usize,
                }
                
                impl HalfMatch {
                    /// Create a new half match from a pattern ID and a byte offset.
                    #[inline]
                    pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {
                        HalfMatch { pattern, offset }
                    }
                
                    /// Create a new half match from a pattern ID and a byte offset.
                    #[inline]
                    pub fn must(pattern: usize, offset: usize) -> HalfMatch {
                        HalfMatch::new(PatternID::new(pattern).unwrap(), offset)
                    }
                
                    /// Returns the ID of the pattern that matched.
                    #[inline]
                    pub fn pattern(&self) -> PatternID {
                        self.pattern
                    }
                
                    /// The position of the match.
                    #[inline]
                    pub fn offset(&self) -> usize {
                        self.offset
                    }
                }
                
                /// A representation of a match reported by a regex engine.
                #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
                pub struct Match {
                    /// The pattern ID.
                    pattern: PatternID,
                    /// The underlying match span.
                    span: Span,
                }
                
                impl Match {
                    /// Create a new match from a pattern ID and a span.
                    #[inline]
                    pub fn new<S: Into<Span>>(pattern: PatternID, span: S) -> Match {
                        let span: Span = span.into();
                        assert!(span.start <= span.end, "invalid match span");
                        Match { pattern, span }
                    }
                
                    /// Create a new match from a pattern ID and a byte offset span.
                    #[inline]
                    pub fn must<S: Into<Span>>(pattern: usize, span: S) -> Match {
                        Match::new(PatternID::must(pattern), span)
                    }
                
                    /// Returns the ID of the pattern that matched.
                    #[inline]
                    pub fn pattern(&self) -> PatternID {
                        self.pattern
                    }
                
                    /// The starting position of the match.
                    #[inline]
                    pub fn start(&self) -> usize {
                        self.span().start
                    }
                
                    /// The ending position of the match.
                    #[inline]
                    pub fn end(&self) -> usize {
                        self.span().end
                    }
                
                    /// Returns the match span as a range.
                    #[inline]
                    pub fn range(&self) -> ::ops::Range<usize> {
                        self.span().range()
                    }
                
                    /// Returns the span for this match.
                    #[inline]
                    pub fn span(&self) -> Span {
                        self.span
                    }
                
                    /// Returns true when the span in this match is empty.
                    #[inline]
                    pub fn is_empty(&self) -> bool {
                        self.span().is_empty()
                    }
                
                    /// Returns the length of this match.
                    #[inline]
                    pub fn len(&self) -> usize {
                        self.span().len()
                    }
                }                
                /// A set of `PatternID`s.
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub struct PatternSet 
                {
                    /// The number of patterns set to 'true' in this set.
                    len: usize,
                    /// A map from PatternID to boolean of whether a pattern matches or not.
                    which: ::boxed::Box<[bool]>,
                }
                
                impl PatternSet {
                    /// Create a new set of pattern identifiers with the given capacity.
                    pub fn new(capacity: usize) -> PatternSet {
                        assert!(
                            capacity <= PatternID::LIMIT,
                            "pattern set capacity exceeds limit of {}",
                            PatternID::LIMIT,
                        );
                        PatternSet {
                            len: 0,
                            which: vec![false; capacity].into_boxed_slice(),
                        }
                    }
                
                    /// Clear this set such that it contains no pattern IDs.
                    pub fn clear(&mut self) {
                        self.len = 0;
                        for matched in self.which.iter_mut() {
                            *matched = false;
                        }
                    }
                
                    /// Return true if and only if the given pattern identifier is in this set.
                    pub fn contains(&self, pid: PatternID) -> bool {
                        pid.as_usize() < self.capacity() && self.which[pid]
                    }
                
                    /// Insert the given pattern identifier into this set and return `true` if
                    /// the given pattern ID was not previously in this set.
                    pub fn insert(&mut self, pid: PatternID) -> bool {
                        self.try_insert(pid)
                            .expect("PatternSet should have sufficient capacity")
                    }
                
                    /// Insert the given pattern identifier into this set and return `true` if
                    /// the given pattern ID was not previously in this set.
                    pub fn try_insert(
                        &mut self,
                        pid: PatternID,
                    ) -> Result<bool, PatternSetInsertError> {
                        if pid.as_usize() >= self.capacity() {
                            return Err(PatternSetInsertError {
                                attempted: pid,
                                capacity: self.capacity(),
                            });
                        }
                        if self.which[pid] {
                            return Ok(false);
                        }
                        self.len += 1;
                        self.which[pid] = true;
                        Ok(true)
                    }
                
                    /// Return true if and only if this set has no pattern identifiers in it.
                    pub fn is_empty(&self) -> bool {
                        self.len() == 0
                    }
                
                    /// Return true if and only if this set has the maximum number of pattern
                    /// identifiers in the set.
                    pub fn is_full(&self) -> bool {
                        self.len() == self.capacity()
                    }
                
                    /// Returns the total number of pattern identifiers in this set.
                    pub fn len(&self) -> usize {
                        self.len
                    }
                
                    /// Returns the total number of pattern identifiers that may be stored
                    /// in this set.
                    pub fn capacity(&self) -> usize {
                        self.which.len()
                    }
                
                    /// Returns an iterator over all pattern identifiers in this set.
                    pub fn iter(&self) -> PatternSetIter<'_> {
                        PatternSetIter { it: self.which.iter().enumerate() }
                    }
                }
                
                /// An error that occurs when a `PatternID` failed to insert into a
                /// `PatternSet`.
                #[derive(Clone, Debug)]
                pub struct PatternSetInsertError {
                    attempted: PatternID,
                    capacity: usize,
                }
                
                impl ::error::Error for PatternSetInsertError {}
                
                impl ::fmt::Display for PatternSetInsertError {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        write!(
                            f,
                            "failed to insert pattern ID {} into pattern set \
                             with insufficiet capacity of {}",
                            self.attempted.as_usize(),
                            self.capacity,
                        )
                    }
                }
                
                /// An iterator over all pattern identifiers in a [`PatternSet`].
                #[derive(Clone, Debug)]
                pub struct PatternSetIter<'a> {
                    it: ::iter::Enumerate<::slice::Iter<'a, bool>>,
                }
                
                impl<'a> Iterator for PatternSetIter<'a> {
                    type Item = PatternID;
                
                    fn next(&mut self) -> Option<PatternID> {
                        while let Some((index, &yes)) = self.it.next() {
                            if yes {
                                return Some(PatternID::new_unchecked(index));
                            }
                        }
                        None
                    }
                
                    fn size_hint(&self) -> (usize, Option<usize>) {
                        self.it.size_hint()
                    }
                }
                
                impl<'a> DoubleEndedIterator for PatternSetIter<'a> {
                    fn next_back(&mut self) -> Option<PatternID> {
                        while let Some((index, &yes)) = self.it.next_back() {
                            if yes {
                                return Some(PatternID::new_unchecked(index));
                            }
                        }
                        None
                    }
                }
                /// The type of anchored search to perform.
                #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                pub enum Anchored 
                {
                    /// Run an unanchored search.
                    ///
                    /// This search can return a match for any pattern in the regex.
                    No,
                    /// Run an anchored search.
                    ///
                    /// This search can return a match for any pattern in the regex.
                    Yes,
                    /// Run an anchored search for a specific pattern.
                    Pattern(PatternID),
                }
                
                impl Anchored 
                {
                    /// Returns true if and only if this anchor mode corresponds to any kind of anchored search.
                    #[inline] pub fn is_anchored(&self) -> bool 
                    {
                        matches!(*self, Anchored::Yes | Anchored::Pattern(_))
                    }
                    /// Returns the pattern ID associated with this configuration if it is an anchored search for a specific pattern.
                    #[inline]
                    pub fn pattern(&self) -> Option<PatternID>
                    {
                        match *self {
                            Anchored::Pattern(pid) => Some(pid),
                            _ => None,
                        }
                    }
                }
                /// The kind of match semantics to use for a regex pattern.
                #[non_exhaustive] #[derive(Clone, Copy, Debug, Eq, PartialEq)]
                pub enum MatchKind 
                {
                    /// Report all possible matches.
                    All,
                    /// Report only the leftmost matches.
                    LeftmostFirst,
                }
                
                impl MatchKind {
                    pub fn continue_past_first_match(&self) -> bool {
                        *self == MatchKind::All
                    }
                }
                
                impl Default for MatchKind {
                    fn default() -> MatchKind {
                        MatchKind::LeftmostFirst
                    }
                }
                /// An error indicating that a search stopped before reporting whether a match exists or not.
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub struct MatchError( ::boxed::Box<MatchErrorKind> );
                
                impl MatchError {
                    /// Create a new error value with the given kind.
                    pub fn new(kind: MatchErrorKind) -> MatchError {
                        MatchError( ::boxed::Box::new(kind) )
                    }
                
                    /// Returns a reference to the underlying error kind.
                    pub fn kind(&self) -> &MatchErrorKind {
                        &self.0
                    }
                
                    /// Create a new "quit" error.
                    pub fn quit(byte: u8, offset: usize) -> MatchError {
                        MatchError::new(MatchErrorKind::Quit { byte, offset })
                    }
                
                    /// Create a new "gave up" error.
                    pub fn gave_up(offset: usize) -> MatchError {
                        MatchError::new(MatchErrorKind::GaveUp { offset })
                    }
                
                    /// Create a new "haystack too long" error.
                    pub fn haystack_too_long(len: usize) -> MatchError {
                        MatchError::new(MatchErrorKind::HaystackTooLong { len })
                    }
                
                    /// Create a new "unsupported anchored" error.
                    pub fn unsupported_anchored(mode: Anchored) -> MatchError {
                        MatchError::new(MatchErrorKind::UnsupportedAnchored { mode })
                    }
                }
                
                /// The underlying kind of a [`MatchError`].
                #[non_exhaustive]
                #[derive(Clone, Debug, Eq, PartialEq)]
                pub enum MatchErrorKind {
                    /// The search saw a "quit" byte at which it was instructed to stop
                    /// searching.
                    Quit {
                        /// The "quit" byte that was observed that caused the search to stop.
                        byte: u8,
                        /// The offset at which the quit byte was observed.
                        offset: usize,
                    },
                    /// The search, based on heuristics, determined that it would be better
                    /// to stop, typically to provide the caller an opportunity to use an
                    /// alternative regex engine.
                    GaveUp {
                        /// The offset at which the search stopped.
                        offset: usize,
                    },
                    /// This error occurs if the haystack given to the regex engine was too
                    /// long to be searched.
                    HaystackTooLong {
                        /// The length of the haystack that exceeded the limit.
                        len: usize,
                    },
                    /// An error indicating that a particular type of anchored search was
                    /// requested, but that the regex engine does not support it.
                    UnsupportedAnchored {
                        /// The anchored mode given that is unsupported.
                        mode: Anchored,
                    },
                }
                
                impl ::error::Error for MatchError {}
                
                impl ::fmt::Display for MatchError 
                {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        match *self.kind() 
                        {
                            MatchErrorKind::Quit { byte, offset } => write!
                            (
                                f,
                                "quit search after observing byte {:?} at offset {}",
                                DebugByte(byte),
                                offset,
                            ),
                            MatchErrorKind::GaveUp { offset } => {
                                write!(f, "gave up searching at offset {}", offset)
                            }
                            MatchErrorKind::HaystackTooLong { len } => {
                                write!(f, "haystack of length {} is too long", len)
                            }
                            MatchErrorKind::UnsupportedAnchored { mode: Anchored::Yes } => {
                                write!(f, "anchored searches are not supported or enabled")
                            }
                            MatchErrorKind::UnsupportedAnchored { mode: Anchored::No } => {
                                write!(f, "unanchored searches are not supported or enabled")
                            }
                            MatchErrorKind::UnsupportedAnchored {
                                mode: Anchored::Pattern(pid),
                            } => 
                            {
                                write!
                                (
                                    f,
                                    "anchored searches for a specific pattern ({}) are not supported or enabled",
                                    pid.as_usize(),
                                )
                            }
                        }
                    }
                }
            }

            pub mod sparse_set
            {
                //1 This module defines a sparse set data structure.
                use ::
                {
                    *,
                };
                /*
                use alloc::{vec, vec::Vec};
                
                use crate::util::primitives::StateID;
                */
                /// A pairse of sparse sets.
                #[derive(Clone, Debug)]
                pub struct SparseSets {
                    pub set1: SparseSet,
                    pub set2: SparseSet,
                }
                
                impl SparseSets {
                    /// Create a new pair of sparse sets where each set has the given capacity.
                    pub fn new(capacity: usize) -> SparseSets {
                        SparseSets {
                            set1: SparseSet::new(capacity),
                            set2: SparseSet::new(capacity),
                        }
                    }
                
                    /// Resizes these sparse sets to have the new capacity given.
                    #[inline]
                    pub fn resize(&mut self, new_capacity: usize) {
                        self.set1.resize(new_capacity);
                        self.set2.resize(new_capacity);
                    }
                
                    /// Clear both sparse sets.
                    pub fn clear(&mut self) {
                        self.set1.clear();
                        self.set2.clear();
                    }
                
                    /// Swap set1 with set2.
                    pub fn swap(&mut self) {
                        ::mem::swap(&mut self.set1, &mut self.set2);
                    }
                
                    /// Returns the memory usage, in bytes, used by this pair of sparse sets.
                    pub fn memory_usage(&self) -> usize {
                        self.set1.memory_usage() + self.set2.memory_usage()
                    }
                }
                
                /// A sparse set used for representing ordered NFA states.
                #[derive(Clone)]
                pub struct SparseSet {
                    /// The number of elements currently in this set.
                    len: usize,
                    /// Dense contains the ids in the order in which they were inserted.
                    dense: Vec<StateID>,
                    /// Sparse maps ids to their location in dense.
                    sparse: Vec<StateID>,
                }
                
                impl SparseSet {
                    /// Create a new sparse set with the given capacity.
                    #[inline]
                    pub fn new(capacity: usize) -> SparseSet {
                        let mut set = SparseSet { len: 0, dense: vec![], sparse: vec![] };
                        set.resize(capacity);
                        set
                    }
                
                    /// Resizes this sparse set to have the new capacity given.
                    #[inline]
                    pub fn resize(&mut self, new_capacity: usize) {
                        assert!(
                            new_capacity <= StateID::LIMIT,
                            "sparse set capacity cannot excced {:?}",
                            StateID::LIMIT
                        );
                        self.clear();
                        self.dense.resize(new_capacity, StateID::ZERO);
                        self.sparse.resize(new_capacity, StateID::ZERO);
                    }
                
                    /// Returns the capacity of this set.
                    #[inline]
                    pub fn capacity(&self) -> usize {
                        self.dense.len()
                    }
                
                    /// Returns the number of elements in this set.
                    #[inline]
                    pub fn len(&self) -> usize {
                        self.len
                    }
                
                    /// Returns true if and only if this set is empty.
                    #[inline]
                    pub fn is_empty(&self) -> bool {
                        self.len() == 0
                    }
                
                    /// Insert the state ID value into this set and return true if the given
                    /// state ID was not previously in this set.
                    #[inline( always )]
                    pub fn insert(&mut self, id: StateID) -> bool {
                        if self.contains(id) {
                            return false;
                        }
                
                        let i = self.len();
                        assert!(
                            i < self.capacity(),
                            "{:?} exceeds capacity of {:?} when inserting {:?}",
                            i,
                            self.capacity(),
                            id,
                        );
                        // OK since i < self.capacity() and self.capacity() is guaranteed to
                        // be <= StateID::LIMIT.
                        let index = StateID::new_unchecked(i);
                        self.dense[index] = id;
                        self.sparse[id] = index;
                        self.len += 1;
                        true
                    }
                
                    /// Returns true if and only if this set contains the given value.
                    #[inline]
                    pub fn contains(&self, id: StateID) -> bool {
                        let index = self.sparse[id];
                        index.as_usize() < self.len() && self.dense[index] == id
                    }
                
                    /// Clear this set such that it has no members.
                    #[inline]
                    pub fn clear(&mut self) {
                        self.len = 0;
                    }
                
                    #[inline]
                    pub fn iter(&self) -> SparseSetIter<'_> {
                        SparseSetIter(self.dense[..self.len()].iter())
                    }
                
                    /// Returns the heap memory usage, in bytes, used by this sparse set.
                    #[inline]
                    pub fn memory_usage(&self) -> usize {
                        self.dense.len() * StateID::SIZE + self.sparse.len() * StateID::SIZE
                    }
                }
                
                impl ::fmt::Debug for SparseSet {
                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        let elements: Vec<StateID> = self.iter().collect();
                        f.debug_tuple("SparseSet").field(&elements).finish()
                    }
                }
                
                /// An iterator over all elements in a sparse set.
                #[derive(Debug)]
                pub struct SparseSetIter<'a>(::slice::Iter<'a, StateID>);
                
                impl<'a> Iterator for SparseSetIter<'a> {
                    type Item = StateID;
                
                    #[inline( always )]
                    fn next(&mut self) -> Option<StateID> {
                        self.0.next().map(|&id| id)
                    }
                }
            }

            pub mod utf8
            {
                //! Utilities for dealing with UTF-8.
                use ::
                {
                    *,
                };
                /*
                */
                /// Returns true if and only if the given byte is considered a word character.
                pub fn is_word_byte(b: u8) -> bool {
                    const fn mkwordset() -> [bool; 256] {
                        let mut set = [false; 256];
                        set[b'_' as usize] = true;
                
                        let mut byte = b'0';
                        while byte <= b'9' {
                            set[byte as usize] = true;
                            byte += 1;
                        }
                        byte = b'A';
                        while byte <= b'Z' {
                            set[byte as usize] = true;
                            byte += 1;
                        }
                        byte = b'a';
                        while byte <= b'z' {
                            set[byte as usize] = true;
                            byte += 1;
                        }
                        set
                    }
                    const WORD: [bool; 256] = mkwordset();
                    WORD[b as usize]
                }
                
                /// Decodes the next UTF-8 encoded codepoint from the given byte slice.
                pub fn decode(bytes: &[u8]) -> Option<Result<char, u8>> {
                    if bytes.is_empty() {
                        return None;
                    }
                    let len = match len(bytes[0]) {
                        None => return Some(Err(bytes[0])),
                        Some(len) if len > bytes.len() => return Some(Err(bytes[0])),
                        Some(1) => return Some(Ok(char::from(bytes[0]))),
                        Some(len) => len,
                    };
                    match ::str::from_utf8(&bytes[..len]) {
                        Ok(s) => Some(Ok(s.chars().next().unwrap())),
                        Err(_) => Some(Err(bytes[0])),
                    }
                }
                
                /// Decodes the last UTF-8 encoded codepoint from the given byte slice.
                pub fn decode_last(bytes: &[u8]) -> Option<Result<char, u8>> {
                    if bytes.is_empty() {
                        return None;
                    }
                    let mut start = bytes.len() - 1;
                    let limit = bytes.len().saturating_sub(4);
                    while start > limit && !is_leading_or_invalid_byte(bytes[start]) {
                        start -= 1;
                    }
                    match decode(&bytes[start..]) {
                        None => None,
                        Some(Ok(ch)) => Some(Ok(ch)),
                        Some(Err(_)) => Some(Err(bytes[bytes.len() - 1])),
                    }
                }
                
                /// Given a UTF-8 leading byte, this returns the total number of code units
                /// in the following encoded codepoint.
                fn len(byte: u8) -> Option<usize> {
                    if byte <= 0x7F {
                        return Some(1);
                    } else if byte & 0b1100_0000 == 0b1000_0000 {
                        return None;
                    } else if byte <= 0b1101_1111 {
                        Some(2)
                    } else if byte <= 0b1110_1111 {
                        Some(3)
                    } else if byte <= 0b1111_0111 {
                        Some(4)
                    } else {
                        None
                    }
                }
                
                /// Returns true if and only if the given offset in the given bytes falls on a
                /// valid UTF-8 encoded codepoint boundary.
                pub fn is_boundary(bytes: &[u8], i: usize) -> bool {
                    match bytes.get(i) {
                        None => i == bytes.len(),
                        Some(&b) => b <= 0b0111_1111 || b >= 0b1100_0000,
                    }
                }
                
                /// Returns true if and only if the given byte is either a valid leading UTF-8
                /// byte, or is otherwise an invalid byte that can never appear anywhere in a
                /// valid UTF-8 sequence.
                fn is_leading_or_invalid_byte(b: u8) -> bool {
                    (b & 0b1100_0000) != 0b1000_0000
                }
            }
        }
    }
    
    mod builders
    {
        //! This module defines an internal builder that encapsulates all interaction with 
        //! meta::Regex construction, and then 4 public API builders that wrap around it.
        use ::
        {
            *,
        };
        /*
        use ::{
            string::{String, ToString},
            sync::Arc,
            vec,
            vec::Vec,
        };
        
        use regex_automata::{
            meta, nfa::thompson::WhichCaptures, util::syntax, MatchKind,
        };
        
        use crate::error::Error;
        */
        /// A builder for constructing a `Regex`, `bytes::Regex`, `RegexSet` or a
        /// `bytes::RegexSet`.
        #[derive(Clone, Debug)]
        struct Builder {
            pats: Vec<String>,
            metac: meta::Config,
            syntaxc: syntax::Config,
        }
        
        impl Default for Builder {
            fn default() -> Builder {
                let metac = meta::Config::new()
                    .nfa_size_limit(Some(10 * (1 << 20)))
                    .hybrid_cache_capacity(2 * (1 << 20));
                Builder { pats: vec![], metac, syntaxc: syntax::Config::default() }
            }
        }
        
        impl Builder {
            fn new<I, S>(patterns: I) -> Builder
            where
                S: AsRef<str>,
                I: IntoIterator<Item = S>,
            {
                let mut b = Builder::default();
                b.pats.extend(patterns.into_iter().map(|p| p.as_ref().to_string()));
                b
            }
        
            fn build_one_string(&self) -> Result<crate::Regex, Error> {
                assert_eq!(1, self.pats.len());
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::LeftmostFirst)
                    .utf8_empty(true);
                let syntaxc = self.syntaxc.clone().utf8(true);
                let pattern = Arc::from(self.pats[0].as_str());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build(&pattern)
                    .map(|meta| crate::Regex { meta, pattern })
                    .map_err(Error::from_meta_build_error)
            }
        
            fn build_one_bytes(&self) -> Result<crate::bytes::Regex, Error> {
                assert_eq!(1, self.pats.len());
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::LeftmostFirst)
                    .utf8_empty(false);
                let syntaxc = self.syntaxc.clone().utf8(false);
                let pattern = Arc::from(self.pats[0].as_str());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build(&pattern)
                    .map(|meta| crate::bytes::Regex { meta, pattern })
                    .map_err(Error::from_meta_build_error)
            }
        
            fn build_many_string(&self) -> Result<crate::RegexSet, Error> {
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::All)
                    .utf8_empty(true)
                    .which_captures(WhichCaptures::None);
                let syntaxc = self.syntaxc.clone().utf8(true);
                let patterns = Arc::from(self.pats.as_slice());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build_many(&patterns)
                    .map(|meta| crate::RegexSet { meta, patterns })
                    .map_err(Error::from_meta_build_error)
            }
        
            fn build_many_bytes(&self) -> Result<crate::bytes::RegexSet, Error> {
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::All)
                    .utf8_empty(false)
                    .which_captures(WhichCaptures::None);
                let syntaxc = self.syntaxc.clone().utf8(false);
                let patterns = Arc::from(self.pats.as_slice());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build_many(&patterns)
                    .map(|meta| crate::bytes::RegexSet { meta, patterns })
                    .map_err(Error::from_meta_build_error)
            }
        
            fn case_insensitive(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.case_insensitive(yes);
                self
            }
        
            fn multi_line(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.multi_line(yes);
                self
            }
        
            fn dot_matches_new_line(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.dot_matches_new_line(yes);
                self
            }
        
            fn crlf(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.crlf(yes);
                self
            }
        
            fn line_terminator(&mut self, byte: u8) -> &mut Builder {
                self.metac = self.metac.clone().line_terminator(byte);
                self.syntaxc = self.syntaxc.line_terminator(byte);
                self
            }
        
            fn swap_greed(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.swap_greed(yes);
                self
            }
        
            fn ignore_whitespace(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.ignore_whitespace(yes);
                self
            }
        
            fn unicode(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.unicode(yes);
                self
            }
        
            fn octal(&mut self, yes: bool) -> &mut Builder {
                self.syntaxc = self.syntaxc.octal(yes);
                self
            }
        
            fn size_limit(&mut self, limit: usize) -> &mut Builder {
                self.metac = self.metac.clone().nfa_size_limit(Some(limit));
                self
            }
        
            fn dfa_size_limit(&mut self, limit: usize) -> &mut Builder {
                self.metac = self.metac.clone().hybrid_cache_capacity(limit);
                self
            }
        
            fn nest_limit(&mut self, limit: u32) -> &mut Builder {
                self.syntaxc = self.syntaxc.nest_limit(limit);
                self
            }
        }
        
        pub mod string
        {
            use crate::{error::Error, Regex, RegexSet};
        
            use super::Builder;
        
            /// A configurable builder for a [`Regex`].
            #[derive(Clone, Debug)]
            pub struct RegexBuilder {
                builder: Builder,
            }
        
            impl RegexBuilder {
                /// Create a new builder with a default configuration for the given
                /// pattern.
                pub fn new(pattern: &str) -> RegexBuilder {
                    RegexBuilder { builder: Builder::new([pattern]) }
                }
        
                /// Compiles the pattern given to `RegexBuilder::new` with the
                /// configuration set on this builder.
                pub fn build(&self) -> Result<Regex, Error> {
                    self.builder.build_one_string()
                }
        
                /// This configures Unicode mode for the entire pattern.
                pub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.unicode(yes);
                    self
                }
        
                /// This configures whether to enable case insensitive matching for the
                /// entire pattern.
                pub fn case_insensitive(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.case_insensitive(yes);
                    self
                }
        
                /// This configures multi-line mode for the entire pattern.
                pub fn multi_line(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.multi_line(yes);
                    self
                }
        
                /// This configures dot-matches-new-line mode for the entire pattern.
                pub fn dot_matches_new_line(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexBuilder {
                    self.builder.dot_matches_new_line(yes);
                    self
                }
        
                /// This configures CRLF mode for the entire pattern.
                pub fn crlf(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.crlf(yes);
                    self
                }
        
                /// Configures the line terminator to be used by the regex.
                pub fn line_terminator(&mut self, byte: u8) -> &mut RegexBuilder {
                    self.builder.line_terminator(byte);
                    self
                }
        
                /// This configures swap-greed mode for the entire pattern.
                pub fn swap_greed(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.swap_greed(yes);
                    self
                }
        
                /// This configures verbose mode for the entire pattern.
                pub fn ignore_whitespace(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.ignore_whitespace(yes);
                    self
                }
        
                /// This configures octal mode for the entire pattern.
                pub fn octal(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.octal(yes);
                    self
                }
        
                /// Sets the approximate size limit, in bytes, of the compiled regex.
                pub fn size_limit(&mut self, bytes: usize) -> &mut RegexBuilder {
                    self.builder.size_limit(bytes);
                    self
                }
        
                /// Set the approximate capacity, in bytes, of the cache of transitions
                /// used by the lazy DFA.
                pub fn dfa_size_limit(&mut self, bytes: usize) -> &mut RegexBuilder {
                    self.builder.dfa_size_limit(bytes);
                    self
                }
        
                /// Set the nesting limit for this parser.
                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexBuilder {
                    self.builder.nest_limit(limit);
                    self
                }
            }
        
            /// A configurable builder for a [`RegexSet`].
            #[derive(Clone, Debug)]
            pub struct RegexSetBuilder {
                builder: Builder,
            }
        
            impl RegexSetBuilder {
                /// Create a new builder with a default configuration for the given
                /// patterns.
                pub fn new<I, S>(patterns: I) -> RegexSetBuilder
                where
                    I: IntoIterator<Item = S>,
                    S: AsRef<str>,
                {
                    RegexSetBuilder { builder: Builder::new(patterns) }
                }
        
                /// Compiles the patterns given to `RegexSetBuilder::new` with the
                /// configuration set on this builder.
                pub fn build(&self) -> Result<RegexSet, Error> {
                    self.builder.build_many_string()
                }
        
                /// This configures Unicode mode for the all of the patterns.
                pub fn unicode(&mut self, yes: bool) -> &mut RegexSetBuilder {
                    self.builder.unicode(yes);
                    self
                }
        
                /// This configures whether to enable case insensitive matching for all
                /// of the patterns.
                pub fn case_insensitive(&mut self, yes: bool) -> &mut RegexSetBuilder {
                    self.builder.case_insensitive(yes);
                    self
                }
        
                /// This configures multi-line mode for all of the patterns.
                pub fn multi_line(&mut self, yes: bool) -> &mut RegexSetBuilder {
                    self.builder.multi_line(yes);
                    self
                }
        
                /// This configures dot-matches-new-line mode for the entire pattern.
                pub fn dot_matches_new_line(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder {
                    self.builder.dot_matches_new_line(yes);
                    self
                }
        
                /// This configures CRLF mode for all of the patterns.
                pub fn crlf(&mut self, yes: bool) -> &mut RegexSetBuilder {
                    self.builder.crlf(yes);
                    self
                }
        
                /// Configures the line terminator to be used by the regex.
                pub fn line_terminator(&mut self, byte: u8) -> &mut RegexSetBuilder {
                    self.builder.line_terminator(byte);
                    self
                }
        
                /// This configures swap-greed mode for all of the patterns.
                pub fn swap_greed(&mut self, yes: bool) -> &mut RegexSetBuilder {
                    self.builder.swap_greed(yes);
                    self
                }
        
                /// This configures verbose mode for all of the patterns.
                pub fn ignore_whitespace(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder {
                    self.builder.ignore_whitespace(yes);
                    self
                }
        
                /// This configures octal mode for all of the patterns.
                pub fn octal(&mut self, yes: bool) -> &mut RegexSetBuilder {
                    self.builder.octal(yes);
                    self
                }
        
                /// Sets the approximate size limit, in bytes, of the compiled regex.
                pub fn size_limit(&mut self, bytes: usize) -> &mut RegexSetBuilder {
                    self.builder.size_limit(bytes);
                    self
                }
        
                /// Set the approximate capacity, in bytes, of the cache of transitions
                /// used by the lazy DFA.
                pub fn dfa_size_limit(
                    &mut self,
                    bytes: usize,
                ) -> &mut RegexSetBuilder {
                    self.builder.dfa_size_limit(bytes);
                    self
                }
        
                /// Set the nesting limit for this parser.
                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexSetBuilder {
                    self.builder.nest_limit(limit);
                    self
                }
            }
        }
        
        pub mod bytes 
        {
            use crate::{
                bytes::{Regex, RegexSet},
                error::Error,
            };
        
            use super::Builder;
        
            /// A configurable builder for a [`Regex`].
            #[derive(Clone, Debug)]
            pub struct RegexBuilder {
                builder: Builder,
            }
        
            impl RegexBuilder {
                /// Create a new builder with a default configuration for the given
                /// pattern.
                pub fn new(pattern: &str) -> RegexBuilder {
                    RegexBuilder { builder: Builder::new([pattern]) }
                }
        
                /// Compiles the pattern given to `RegexBuilder::new` with the
                /// configuration set on this builder.
                pub fn build(&self) -> Result<Regex, Error> {
                    self.builder.build_one_bytes()
                }
        
                /// This configures Unicode mode for the entire pattern.
                pub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.unicode(yes);
                    self
                }
        
                /// This configures whether to enable case insensitive matching for the
                /// entire pattern.
                pub fn case_insensitive(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.case_insensitive(yes);
                    self
                }
        
                /// This configures multi-line mode for the entire pattern.
                pub fn multi_line(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.multi_line(yes);
                    self
                }
        
                /// This configures dot-matches-new-line mode for the entire pattern.
                pub fn dot_matches_new_line(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexBuilder {
                    self.builder.dot_matches_new_line(yes);
                    self
                }
        
                /// This configures CRLF mode for the entire pattern.
                pub fn crlf(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.crlf(yes);
                    self
                }
        
                /// Configures the line terminator to be used by the regex.
                pub fn line_terminator(&mut self, byte: u8) -> &mut RegexBuilder {
                    self.builder.line_terminator(byte);
                    self
                }
        
                /// This configures swap-greed mode for the entire pattern.
                pub fn swap_greed(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.swap_greed(yes);
                    self
                }
        
                /// This configures verbose mode for the entire pattern.
                pub fn ignore_whitespace(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.ignore_whitespace(yes);
                    self
                }
        
                /// This configures octal mode for the entire pattern.
                pub fn octal(&mut self, yes: bool) -> &mut RegexBuilder {
                    self.builder.octal(yes);
                    self
                }
        
                /// Sets the approximate size limit, in bytes, of the compiled regex.
                pub fn size_limit(&mut self, bytes: usize) -> &mut RegexBuilder {
                    self.builder.size_limit(bytes);
                    self
                }
        
                /// Set the approximate capacity, in bytes, of the cache of transitions
                /// used by the lazy DFA.
                pub fn dfa_size_limit(&mut self, bytes: usize) -> &mut RegexBuilder {
                    self.builder.dfa_size_limit(bytes);
                    self
                }
        
                /// Set the nesting limit for this parser.
                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexBuilder {
                    self.builder.nest_limit(limit);
                    self
                }
            }
        
            /// A configurable builder for a [`RegexSet`].
            #[derive(Clone, Debug)]
            pub struct RegexSetBuilder {
                builder: Builder,
            }
        
            impl RegexSetBuilder {
                /// Create a new builder with a default configuration for the given
                /// patterns.
                pub fn new<I, S>(patterns: I) -> RegexSetBuilder
                where
                    I: IntoIterator<Item = S>,
                    S: AsRef<str>,
                {
                    RegexSetBuilder { builder: Builder::new(patterns) }
                }
        
                /// Compiles the patterns given to `RegexSetBuilder::new` with the
                /// configuration set on this builder.
                pub fn build(&self) -> Result<RegexSet, Error> {
                    self.builder.build_many_bytes()
                }
        
                /// This configures Unicode mode for the all of the patterns.
                pub fn unicode(&mut self, yes: bool) -> &mut RegexSetBuilder {
                    self.builder.unicode(yes);
                    self
                }
        
                /// This configures whether to enable case insensitive matching for all
                /// of the patterns.
                pub fn case_insensitive(&mut self, yes: bool) -> &mut RegexSetBuilder {
                    self.builder.case_insensitive(yes);
                    self
                }
        
                /// This configures multi-line mode for all of the patterns.
                pub fn multi_line(&mut self, yes: bool) -> &mut RegexSetBuilder {
                    self.builder.multi_line(yes);
                    self
                }
        
                /// This configures dot-matches-new-line mode for the entire pattern.
                pub fn dot_matches_new_line(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder {
                    self.builder.dot_matches_new_line(yes);
                    self
                }
        
                /// This configures CRLF mode for all of the patterns.
                pub fn crlf(&mut self, yes: bool) -> &mut RegexSetBuilder {
                    self.builder.crlf(yes);
                    self
                }
        
                /// Configures the line terminator to be used by the regex.
                pub fn dfa_size_limit(
                    &mut self,
                    bytes: usize,
                ) -> &mut RegexSetBuilder {
                    self.builder.dfa_size_limit(bytes);
                    self
                }
        
                /// Set the nesting limit for this parser.
                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexSetBuilder {
                    self.builder.nest_limit(limit);
                    self
                }
            }
        }
    }
    
    pub mod bytes
    {
        //! Search for regex matches in `&[u8]` haystacks.
        use ::
        {
            *,
        };
        /*
        pub use crate::{builders::bytes::*, regex::bytes::*, regexset::bytes::*};
        */
    }
    
    mod error
    {
        use ::
        {
            *,
        };
        /*
        use ::string::{String, ToString};
        
        use regex_automata::meta;
        */
        /// An error that occurred during parsing or compiling a regular expression.
        #[non_exhaustive]
        #[derive(Clone, PartialEq)]
        pub enum Error {
            /// A syntax error.
            Syntax(String),
            /// The compiled program exceeded the set size
            /// limit.
            CompiledTooBig(usize),
        }
        
        impl Error {
            pub fn from_meta_build_error(err: meta::BuildError) -> Error {
                if let Some(size_limit) = err.size_limit() {
                    Error::CompiledTooBig(size_limit)
                } else if let Some(ref err) = err.syntax_error() {
                    Error::Syntax(err.to_string())
                } else {
                    Error::Syntax(err.to_string())
                }
            }
        }
        
        impl ::error::Error for Error {
            #[allow(deprecated)]
            fn description(&self) -> &str {
                match *self {
                    Error::Syntax(ref err) => err,
                    Error::CompiledTooBig(_) => "compiled program too big",
                }
            }
        }
        
        impl ::fmt::Display for Error {
            fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                match *self {
                    Error::Syntax(ref err) => err.fmt(f),
                    Error::CompiledTooBig(limit) => write!(
                        f,
                        "Compiled regex exceeds size limit of {} bytes.",
                        limit
                    ),
                }
            }
        }
        
        impl ::fmt::Debug for Error {
            fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                match *self {
                    Error::Syntax(ref err) => {
                        let hr: String = ::iter::repeat('~').take(79).collect();
                        writeln!(f, "Syntax(")?;
                        writeln!(f, "{}", hr)?;
                        writeln!(f, "{}", err)?;
                        writeln!(f, "{}", hr)?;
                        write!(f, ")")?;
                        Ok(())
                    }
                    Error::CompiledTooBig(limit) => {
                        f.debug_tuple("CompiledTooBig").field(&limit).finish()
                    }
                }
            }
        }
    }
    
    mod find_byte
    {
        use ::
        {
            *,
        };
        /*
        */
        /// Searches for the given needle in the given haystack.
        pub fn find_byte(needle: u8, haystack: &[u8]) -> Option<usize>
        {
            fn imp(needle: u8, haystack: &[u8]) -> Option<usize> {
                haystack.iter().position(|&b| b == needle)
            }
        
            imp(needle, haystack)
        }

    }
    
    mod regex
    {
        use ::
        {
            *,
        };
        /*
        */
        pub mod bytes
        {
            use ::
            {
                *,
            };
            /*
            use ::{borrow::Cow, string::String, sync::Arc, vec::Vec};
            
            use regex_automata::{meta, util::captures, Input, PatternID};
            
            use crate::{bytes::RegexBuilder, error::Error};
            */
            /// A compiled regular expression for searching Unicode haystacks.
            #[derive(Clone)]
            pub struct Regex {
                pub meta: meta::Regex,
                pub pattern: Arc<str>,
            }
            
            impl ::fmt::Display for Regex {
                /// Shows the original regular expression.
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "{}", self.as_str())
                }
            }
            
            impl ::fmt::Debug for Regex {
                /// Shows the original regular expression.
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    f.debug_tuple("Regex").field(&self.as_str()).finish()
                }
            }
            
            impl ::str::FromStr for Regex {
                type Err = Error;
            
                /// Attempts to parse a string into a regular expression
                fn from_str(s: &str) -> Result<Regex, Error> {
                    Regex::new(s)
                }
            }
            
            impl TryFrom<&str> for Regex {
                type Error = Error;
            
                /// Attempts to parse a string into a regular expression
                fn try_from(s: &str) -> Result<Regex, Error> {
                    Regex::new(s)
                }
            }
            
            impl TryFrom<String> for Regex {
                type Error = Error;
            
                /// Attempts to parse a string into a regular expression
                fn try_from(s: String) -> Result<Regex, Error> {
                    Regex::new(&s)
                }
            }
            
            /// Core regular expression methods.
            impl Regex {
                /// Compiles a regular expression.
                pub fn new(re: &str) -> Result<Regex, Error> {
                    RegexBuilder::new(re).build()
                }
            
                /// Returns true if and only if there is a match for the regex anywhere
                /// in the haystack given.
                #[inline]
                pub fn is_match(&self, haystack: &[u8]) -> bool {
                    self.is_match_at(haystack, 0)
                }
            
                /// This routine searches for the first match of this regex in the
                /// haystack given, and if found, returns a [`Match`].
                #[inline]
                pub fn find<'h>(&self, haystack: &'h [u8]) -> Option<Match<'h>> {
                    self.find_at(haystack, 0)
                }
            
                /// Returns an iterator that yields successive non-overlapping matches in
                /// the given haystack.
                #[inline]
                pub fn find_iter<'r, 'h>(&'r self, haystack: &'h [u8]) -> Matches<'r, 'h> {
                    Matches { haystack, it: self.meta.find_iter(haystack) }
                }
            
                /// This routine searches for the first match of this regex in the haystack
                /// given, and if found, returns not only the overall match but also the
                /// matches of each capture group in the regex.
                #[inline]
                pub fn captures<'h>(&self, haystack: &'h [u8]) -> Option<Captures<'h>> {
                    self.captures_at(haystack, 0)
                }
            
                /// Returns an iterator that yields successive non-overlapping matches in
                /// the given haystack.
                #[inline]
                pub fn captures_iter<'r, 'h>(
                    &'r self,
                    haystack: &'h [u8],
                ) -> CaptureMatches<'r, 'h> {
                    CaptureMatches { haystack, it: self.meta.captures_iter(haystack) }
                }
            
                /// Returns an iterator of substrings of the haystack given, delimited by a
                /// match of the regex.
                #[inline]
                pub fn split<'r, 'h>(&'r self, haystack: &'h [u8]) -> Split<'r, 'h> {
                    Split { haystack, it: self.meta.split(haystack) }
                }
            
                /// Returns an iterator of at most `limit` substrings of the haystack
                /// given, delimited by a match of the regex.
                #[inline]
                pub fn splitn<'r, 'h>(
                    &'r self,
                    haystack: &'h [u8],
                    limit: usize,
                ) -> SplitN<'r, 'h> {
                    SplitN { haystack, it: self.meta.splitn(haystack, limit) }
                }
            
                /// Replaces the leftmost-first match in the given haystack with the
                /// replacement provided.
                #[inline]
                pub fn replace<'h, R: Replacer>(
                    &self,
                    haystack: &'h [u8],
                    rep: R,
                ) -> Cow<'h, [u8]> {
                    self.replacen(haystack, 1, rep)
                }
            
                /// Replaces all non-overlapping matches in the haystack with the
                /// replacement provided.
                #[inline]
                pub fn replace_all<'h, R: Replacer>(
                    &self,
                    haystack: &'h [u8],
                    rep: R,
                ) -> Cow<'h, [u8]> {
                    self.replacen(haystack, 0, rep)
                }
            
                /// Replaces at most `limit` non-overlapping matches in the haystack with
                /// the replacement provided.
                #[inline]
                pub fn replacen<'h, R: Replacer>(
                    &self,
                    haystack: &'h [u8],
                    limit: usize,
                    mut rep: R,
                ) -> Cow<'h, [u8]> {
                    if let Some(rep) = rep.no_expansion() {
                        let mut it = self.find_iter(haystack).enumerate().peekable();
                        if it.peek().is_none() {
                            return Cow::Borrowed(haystack);
                        }
                        let mut new = Vec::with_capacity(haystack.len());
                        let mut last_match = 0;
                        for (i, m) in it {
                            new.extend_from_slice(&haystack[last_match..m.start()]);
                            new.extend_from_slice(&rep);
                            last_match = m.end();
                            if limit > 0 && i >= limit - 1 {
                                break;
                            }
                        }
                        new.extend_from_slice(&haystack[last_match..]);
                        return Cow::Owned(new);
                    }
                    
                    let mut it = self.captures_iter(haystack).enumerate().peekable();
                    if it.peek().is_none() {
                        return Cow::Borrowed(haystack);
                    }
                    let mut new = Vec::with_capacity(haystack.len());
                    let mut last_match = 0;
                    for (i, cap) in it {
                        // unwrap on 0 is OK because captures only reports matches
                        let m = cap.get(0).unwrap();
                        new.extend_from_slice(&haystack[last_match..m.start()]);
                        rep.replace_append(&cap, &mut new);
                        last_match = m.end();
                        if limit > 0 && i >= limit - 1 {
                            break;
                        }
                    }
                    new.extend_from_slice(&haystack[last_match..]);
                    Cow::Owned(new)
                }
            }
            
            /// A group of advanced or "lower level" search methods.
            impl Regex {
                /// Returns the end byte offset of the first match in the haystack given.
                #[inline]
                pub fn shortest_match(&self, haystack: &[u8]) -> Option<usize> {
                    self.shortest_match_at(haystack, 0)
                }
            
                /// Returns the same as `shortest_match`, but starts the search at the
                /// given offset.
                #[inline]
                pub fn shortest_match_at(
                    &self,
                    haystack: &[u8],
                    start: usize,
                ) -> Option<usize> {
                    let input =
                        Input::new(haystack).earliest(true).span(start..haystack.len());
                    self.meta.search_half(&input).map(|hm| hm.offset())
                }
            
                /// Returns the same as [`Regex::is_match`], but starts the search at the
                /// given offset.
                #[inline]
                pub fn is_match_at(&self, haystack: &[u8], start: usize) -> bool {
                    self.meta.is_match(Input::new(haystack).span(start..haystack.len()))
                }
            
                /// Returns the same as [`Regex::find`], but starts the search at the given
                /// offset.
                #[inline]
                pub fn find_at<'h>(
                    &self,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Match<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta.find(input).map(|m| Match::new(haystack, m.start(), m.end()))
                }
            
                /// Returns the same as [`Regex::captures`], but starts the search at the
                /// given offset.
                #[inline]
                pub fn captures_at<'h>(
                    &self,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Captures<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    let mut caps = self.meta.create_captures();
                    self.meta.captures(input, &mut caps);
                    if caps.is_match() {
                        let static_captures_len = self.static_captures_len();
                        Some(Captures { haystack, caps, static_captures_len })
                    } else {
                        None
                    }
                }
            
                /// This is like [`Regex::captures`], but writes the byte offsets of each
                /// capture group match into the locations given.
                #[inline]
                pub fn captures_read<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h [u8],
                ) -> Option<Match<'h>> {
                    self.captures_read_at(locs, haystack, 0)
                }
            
                /// Returns the same as [`Regex::captures_read`], but starts the search at
                /// the given offset.
                #[inline]
                pub fn captures_read_at<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Match<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta.search_captures(&input, &mut locs.0);
                    locs.0.get_match().map(|m| Match::new(haystack, m.start(), m.end()))
                }
            
                /// An undocumented alias for `captures_read_at`.
                #[doc(hidden)]
                #[inline]
                pub fn read_captures_at<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Match<'h>> {
                    self.captures_read_at(locs, haystack, start)
                }
            }
            
            /// Auxiliary methods.
            impl Regex {
                /// Returns the original string of this regex.
                #[inline]
                pub fn as_str(&self) -> &str {
                    &self.pattern
                }
            
                /// Returns an iterator over the capture names in this regex.
                #[inline]
                pub fn capture_names(&self) -> CaptureNames<'_> {
                    CaptureNames(self.meta.group_info().pattern_names(PatternID::ZERO))
                }
            
                /// Returns the number of captures groups in this regex.
                #[inline]
                pub fn captures_len(&self) -> usize {
                    self.meta.group_info().group_len(PatternID::ZERO)
                }
            
                /// Returns the total number of capturing groups that appear in every
                /// possible match.
                #[inline]
                pub fn static_captures_len(&self) -> Option<usize> {
                    self.meta.static_captures_len()
                }
            
                /// Returns a fresh allocated set of capture locations that can
                /// be reused in multiple calls to [`Regex::captures_read`] or
                /// [`Regex::captures_read_at`].
                #[inline]
                pub fn capture_locations(&self) -> CaptureLocations {
                    CaptureLocations(self.meta.create_captures())
                }
            
                /// An alias for `capture_locations` to preserve backward compatibility.
                #[doc(hidden)]
                #[inline]
                pub fn locations(&self) -> CaptureLocations {
                    self.capture_locations()
                }
            }
            
            /// Represents a single match of a regex in a haystack.
            #[derive(Copy, Clone, Eq, PartialEq)]
            pub struct Match<'h> {
                haystack: &'h [u8],
                start: usize,
                end: usize,
            }
            
            impl<'h> Match<'h> {
                /// Returns the byte offset of the start of the match in the haystack.
                #[inline]
                pub fn start(&self) -> usize {
                    self.start
                }
            
                /// Returns the byte offset of the end of the match in the haystack.
                #[inline]
                pub fn end(&self) -> usize {
                    self.end
                }
            
                /// Returns true if and only if this match has a length of zero.
                #[inline]
                pub fn is_empty(&self) -> bool {
                    self.start == self.end
                }
            
                /// Returns the length, in bytes, of this match.
                #[inline]
                pub fn len(&self) -> usize {
                    self.end - self.start
                }
            
                /// Returns the range over the starting and ending byte offsets of the
                /// match in the haystack.
                #[inline]
                pub fn range(&self) -> ::ops::Range<usize> {
                    self.start..self.end
                }
            
                /// Returns the substring of the haystack that matched.
                #[inline]
                pub fn as_bytes(&self) -> &'h [u8] {
                    &self.haystack[self.range()]
                }
            
                /// Creates a new match from the given haystack and byte offsets.
                #[inline]
                fn new(haystack: &'h [u8], start: usize, end: usize) -> Match<'h> {
                    Match { haystack, start, end }
                }
            }
            
            impl<'h> ::fmt::Debug for Match<'h> {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    use regex_automata::util::escape::DebugHaystack;
            
                    let mut fmt = f.debug_struct("Match");
                    fmt.field("start", &self.start)
                        .field("end", &self.end)
                        .field("bytes", &DebugHaystack(&self.as_bytes()));
            
                    fmt.finish()
                }
            }
            
            impl<'h> From<Match<'h>> for &'h [u8] {
                fn from(m: Match<'h>) -> &'h [u8] {
                    m.as_bytes()
                }
            }
            
            impl<'h> From<Match<'h>> for ::ops::Range<usize> {
                fn from(m: Match<'h>) -> ::ops::Range<usize> {
                    m.range()
                }
            }
            
            /// Represents the capture groups for a single match.
            pub struct Captures<'h> {
                haystack: &'h [u8],
                caps: captures::Captures,
                static_captures_len: Option<usize>,
            }
            
            impl<'h> Captures<'h> {
                /// Returns the `Match` associated with the capture group at index `i`.
                #[inline]
                pub fn get(&self, i: usize) -> Option<Match<'h>> {
                    self.caps
                        .get_group(i)
                        .map(|sp| Match::new(self.haystack, sp.start, sp.end))
                }
            
                /// Returns the `Match` associated with the capture group named `name`.
                #[inline]
                pub fn name(&self, name: &str) -> Option<Match<'h>> {
                    self.caps
                        .get_group_by_name(name)
                        .map(|sp| Match::new(self.haystack, sp.start, sp.end))
                }
            
                /// This is a convenience routine for extracting the substrings
                /// corresponding to matching capture groups.
                pub fn extract<const N: usize>(&self) -> (&'h [u8], [&'h [u8]; N]) {
                    let len = self
                        .static_captures_len
                        .expect("number of capture groups can vary in a match")
                        .checked_sub(1)
                        .expect("number of groups is always greater than zero");
                    assert_eq!(N, len, "asked for {} groups, but must ask for {}", N, len);
                    self.caps.extract_bytes(self.haystack)
                }
            
                /// Expands all instances of `$ref` in `replacement` to the corresponding
                /// capture group, and writes them to the `dst` buffer given.
                #[inline]
                pub fn expand(&self, replacement: &[u8], dst: &mut Vec<u8>) {
                    self.caps.interpolate_bytes_into(self.haystack, replacement, dst);
                }
            
                /// Returns an iterator over all capture groups. This includes both
                /// matching and non-matching groups.
                #[inline]
                pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 'h> {
                    SubCaptureMatches { haystack: self.haystack, it: self.caps.iter() }
                }
            
                /// Returns the total number of capture groups. This includes both
                /// matching and non-matching groups.
                #[inline]
                pub fn len(&self) -> usize {
                    self.caps.group_len()
                }
            }
            
            impl<'h> ::fmt::Debug for Captures<'h> {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    /// A little helper type to provide a nice map-like debug
                    /// representation for our capturing group spans.
                    struct CapturesDebugMap<'a> {
                        caps: &'a Captures<'a>,
                    }
            
                    impl<'a> ::fmt::Debug for CapturesDebugMap<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            let mut map = f.debug_map();
                            let names =
                                self.caps.caps.group_info().pattern_names(PatternID::ZERO);
                            for (group_index, maybe_name) in names.enumerate() {
                                let key = Key(group_index, maybe_name);
                                match self.caps.get(group_index) {
                                    None => map.entry(&key, &None::<()>),
                                    Some(mat) => map.entry(&key, &Value(mat)),
                                };
                            }
                            map.finish()
                        }
                    }
            
                    struct Key<'a>(usize, Option<&'a str>);
            
                    impl<'a> ::fmt::Debug for Key<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(f, "{}", self.0)?;
                            if let Some(name) = self.1 {
                                write!(f, "/{:?}", name)?;
                            }
                            Ok(())
                        }
                    }
            
                    struct Value<'a>(Match<'a>);
            
                    impl<'a> ::fmt::Debug for Value<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            use regex_automata::util::escape::DebugHaystack;
            
                            write!(
                                f,
                                "{}..{}/{:?}",
                                self.0.start(),
                                self.0.end(),
                                DebugHaystack(self.0.as_bytes())
                            )
                        }
                    }
            
                    f.debug_tuple("Captures")
                        .field(&CapturesDebugMap { caps: self })
                        .finish()
                }
            }
            
            /// Get a matching capture group's haystack substring by index.
            impl<'h> ::ops::Index<usize> for Captures<'h> {
                type Output = [u8];
                fn index<'a>(&'a self, i: usize) -> &'a [u8] {
                    self.get(i)
                        .map(|m| m.as_bytes())
                        .unwrap_or_else(|| panic!("no group at index '{}'", i))
                }
            }
            
            /// Get a matching capture group's haystack substring by name.
            impl<'h, 'n> ::ops::Index<&'n str> for Captures<'h> {
                type Output = [u8];
            
                fn index<'a>(&'a self, name: &'n str) -> &'a [u8] {
                    self.name(name)
                        .map(|m| m.as_bytes())
                        .unwrap_or_else(|| panic!("no group named '{}'", name))
                }
            }
            
            /// A low level representation of the byte offsets of each capture group.
            #[derive(Clone, Debug)]
            pub struct CaptureLocations(captures::Captures);
            
            /// A type alias for `CaptureLocations` for backwards compatibility.
            #[doc(hidden)]
            pub type Locations = CaptureLocations;
            
            impl CaptureLocations {
                /// Returns the start and end byte offsets of the capture group at index
                /// `i`.
                #[inline]
                pub fn get(&self, i: usize) -> Option<(usize, usize)> {
                    self.0.get_group(i).map(|sp| (sp.start, sp.end))
                }
            
                /// Returns the total number of capture groups (even if they didn't match).
                #[inline]
                pub fn len(&self) -> usize {
                    self.0.group_info().group_len(PatternID::ZERO)
                }
            
                /// An alias for the `get` method for backwards compatibility.
                #[doc(hidden)]
                #[inline]
                pub fn pos(&self, i: usize) -> Option<(usize, usize)> {
                    self.get(i)
                }
            }
            
            /// An iterator over all non-overlapping matches in a haystack.
            #[derive(Debug)]
            pub struct Matches<'r, 'h> {
                haystack: &'h [u8],
                it: meta::FindMatches<'r, 'h>,
            }
            
            impl<'r, 'h> Iterator for Matches<'r, 'h> {
                type Item = Match<'h>;
            
                #[inline]
                fn next(&mut self) -> Option<Match<'h>> {
                    self.it
                        .next()
                        .map(|sp| Match::new(self.haystack, sp.start(), sp.end()))
                }
            
                #[inline]
                fn count(self) -> usize {
                    self.it.count()
                }
            }
            
            impl<'r, 'h> ::iter::FusedIterator for Matches<'r, 'h> {}
            
            /// An iterator over all non-overlapping capture matches in a haystack.
            #[derive(Debug)]
            pub struct CaptureMatches<'r, 'h> {
                haystack: &'h [u8],
                it: meta::CapturesMatches<'r, 'h>,
            }
            
            impl<'r, 'h> Iterator for CaptureMatches<'r, 'h> {
                type Item = Captures<'h>;
            
                #[inline]
                fn next(&mut self) -> Option<Captures<'h>> {
                    let static_captures_len = self.it.regex().static_captures_len();
                    self.it.next().map(|caps| Captures {
                        haystack: self.haystack,
                        caps,
                        static_captures_len,
                    })
                }
            
                #[inline]
                fn count(self) -> usize {
                    self.it.count()
                }
            }
            
            impl<'r, 'h> ::iter::FusedIterator for CaptureMatches<'r, 'h> {}
            
            /// An iterator over all substrings delimited by a regex match.
            #[derive(Debug)]
            pub struct Split<'r, 'h> {
                haystack: &'h [u8],
                it: meta::Split<'r, 'h>,
            }
            
            impl<'r, 'h> Iterator for Split<'r, 'h> {
                type Item = &'h [u8];
            
                #[inline]
                fn next(&mut self) -> Option<&'h [u8]> {
                    self.it.next().map(|span| &self.haystack[span])
                }
            }
            
            impl<'r, 'h> ::iter::FusedIterator for Split<'r, 'h> {}
            
            /// An iterator over at most `N` substrings delimited by a regex match.
            #[derive(Debug)]
            pub struct SplitN<'r, 'h> {
                haystack: &'h [u8],
                it: meta::SplitN<'r, 'h>,
            }
            
            impl<'r, 'h> Iterator for SplitN<'r, 'h> {
                type Item = &'h [u8];
            
                #[inline]
                fn next(&mut self) -> Option<&'h [u8]> {
                    self.it.next().map(|span| &self.haystack[span])
                }
            
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            }
            
            impl<'r, 'h> ::iter::FusedIterator for SplitN<'r, 'h> {}
            
            /// An iterator over the names of all capture groups in a regex.
            #[derive(Clone, Debug)]
            pub struct CaptureNames<'r>(captures::GroupInfoPatternNames<'r>);
            
            impl<'r> Iterator for CaptureNames<'r> {
                type Item = Option<&'r str>;
            
                #[inline]
                fn next(&mut self) -> Option<Option<&'r str>> {
                    self.0.next()
                }
            
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.0.size_hint()
                }
            
                #[inline]
                fn count(self) -> usize {
                    self.0.count()
                }
            }
            
            impl<'r> ExactSizeIterator for CaptureNames<'r> {}
            
            impl<'r> ::iter::FusedIterator for CaptureNames<'r> {}
            
            /// An iterator over all group matches in a [`Captures`] value.
            #[derive(Clone, Debug)]
            pub struct SubCaptureMatches<'c, 'h> {
                haystack: &'h [u8],
                it: captures::CapturesPatternIter<'c>,
            }
            
            impl<'c, 'h> Iterator for SubCaptureMatches<'c, 'h> {
                type Item = Option<Match<'h>>;
            
                #[inline]
                fn next(&mut self) -> Option<Option<Match<'h>>> {
                    self.it.next().map(|group| {
                        group.map(|sp| Match::new(self.haystack, sp.start, sp.end))
                    })
                }
            
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            
                #[inline]
                fn count(self) -> usize {
                    self.it.count()
                }
            }
            
            impl<'c, 'h> ExactSizeIterator for SubCaptureMatches<'c, 'h> {}
            
            impl<'c, 'h> ::iter::FusedIterator for SubCaptureMatches<'c, 'h> {}
            
            /// A trait for types that can be used to replace matches in a haystack.
            pub trait Replacer {
                /// Appends possibly empty data to `dst` to replace the current match.
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>);
            
                /// Return a fixed unchanging replacement byte string.
                fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>> {
                    None
                }
            
                /// Returns a type that implements `Replacer`, but that borrows and wraps
                /// this `Replacer`.
                fn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self> {
                    ReplacerRef(self)
                }
            }
            
            impl<'a, const N: usize> Replacer for &'a [u8; N] {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(&**self, dst);
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }
            
            impl<const N: usize> Replacer for [u8; N] {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(&*self, dst);
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }
            
            impl<'a> Replacer for &'a [u8] {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(*self, dst);
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }
            
            impl<'a> Replacer for &'a Vec<u8> {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(*self, dst);
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }
            
            impl Replacer for Vec<u8> {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(self, dst);
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }
            
            impl<'a> Replacer for Cow<'a, [u8]> {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(self.as_ref(), dst);
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }
            
            impl<'a> Replacer for &'a Cow<'a, [u8]> {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(self.as_ref(), dst);
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    no_expansion(self)
                }
            }
            
            impl<F, T> Replacer for F
            where
                F: FnMut(&Captures<'_>) -> T,
                T: AsRef<[u8]>,
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    dst.extend_from_slice((*self)(caps).as_ref());
                }
            }
            
            /// A by-reference adaptor for a [`Replacer`].
            #[derive(Debug)]
            pub struct ReplacerRef<'a, R: ?Sized>(&'a mut R);
            
            impl<'a, R: Replacer + ?Sized + 'a> Replacer for ReplacerRef<'a, R> {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    self.0.replace_append(caps, dst)
                }
            
                fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>> {
                    self.0.no_expansion()
                }
            }
            
            /// A helper type for forcing literal string replacement.
            #[derive(Clone, Debug)]
            pub struct NoExpand<'s>(pub &'s [u8]);
            
            impl<'s> Replacer for NoExpand<'s> {
                fn replace_append(&mut self, _: &Captures<'_>, dst: &mut Vec<u8>) {
                    dst.extend_from_slice(self.0);
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {
                    Some(Cow::Borrowed(self.0))
                }
            }
            
            /// Quickly checks the given replacement string for whether interpolation
            /// should be done on it.
            fn no_expansion<T: AsRef<[u8]>>(replacement: &T) -> Option<Cow<'_, [u8]>> {
                let replacement = replacement.as_ref();
                match crate::find_byte::find_byte(b'$', replacement) {
                    Some(_) => None,
                    None => Some(Cow::Borrowed(replacement)),
                }
            }
        }
        
        pub mod string
        {
            use ::
            {
                *,
            };
            /*
            use ::{borrow::Cow, string::String, sync::Arc};
            
            use regex_automata::{meta, util::captures, Input, PatternID};
            
            use crate::{error::Error, RegexBuilder};
            */
            /// A compiled regular expression for searching Unicode haystacks.
            #[derive(Clone)]
            pub struct Regex {
                pub meta: meta::Regex,
                pub pattern: Arc<str>,
            }
            
            impl ::fmt::Display for Regex {
                /// Shows the original regular expression.
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "{}", self.as_str())
                }
            }
            
            impl ::fmt::Debug for Regex {
                /// Shows the original regular expression.
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    f.debug_tuple("Regex").field(&self.as_str()).finish()
                }
            }
            
            impl ::str::FromStr for Regex {
                type Err = Error;
            
                /// Attempts to parse a string into a regular expression
                fn from_str(s: &str) -> Result<Regex, Error> {
                    Regex::new(s)
                }
            }
            
            impl TryFrom<&str> for Regex {
                type Error = Error;
            
                /// Attempts to parse a string into a regular expression
                fn try_from(s: &str) -> Result<Regex, Error> {
                    Regex::new(s)
                }
            }
            
            impl TryFrom<String> for Regex {
                type Error = Error;
            
                /// Attempts to parse a string into a regular expression
                fn try_from(s: String) -> Result<Regex, Error> {
                    Regex::new(&s)
                }
            }
            
            /// Core regular expression methods.
            impl Regex {
                /// Compiles a regular expression.
                pub fn new(re: &str) -> Result<Regex, Error> {
                    RegexBuilder::new(re).build()
                }
            
                /// Returns true if and only if there is a match for the regex anywhere
                /// in the haystack given.
                #[inline]
                pub fn is_match(&self, haystack: &str) -> bool {
                    self.is_match_at(haystack, 0)
                }
            
                /// This routine searches for the first match of this regex in the
                /// haystack given, and if found, returns a [`Match`].
                #[inline]
                pub fn find<'h>(&self, haystack: &'h str) -> Option<Match<'h>> {
                    self.find_at(haystack, 0)
                }
            
                /// Returns an iterator that yields successive non-overlapping matches in
                /// the given haystack.
                #[inline]
                pub fn find_iter<'r, 'h>(&'r self, haystack: &'h str) -> Matches<'r, 'h> {
                    Matches { haystack, it: self.meta.find_iter(haystack) }
                }
            
                /// This routine searches for the first match of this regex in the haystack
                /// given, and if found, returns not only the overall match but also the
                /// matches of each capture group in the regex.
                #[inline]
                pub fn captures<'h>(&self, haystack: &'h str) -> Option<Captures<'h>> {
                    self.captures_at(haystack, 0)
                }
            
                /// Returns an iterator that yields successive non-overlapping matches in
                /// the given haystack.
                #[inline]
                pub fn captures_iter<'r, 'h>(
                    &'r self,
                    haystack: &'h str,
                ) -> CaptureMatches<'r, 'h> {
                    CaptureMatches { haystack, it: self.meta.captures_iter(haystack) }
                }
            
                /// Returns an iterator of substrings of the haystack given, delimited by a
                /// match of the regex.
                #[inline]
                pub fn split<'r, 'h>(&'r self, haystack: &'h str) -> Split<'r, 'h> {
                    Split { haystack, it: self.meta.split(haystack) }
                }
            
                /// Returns an iterator of at most `limit` substrings of the haystack
                /// given, delimited by a match of the regex.
                #[inline]
                pub fn splitn<'r, 'h>(
                    &'r self,
                    haystack: &'h str,
                    limit: usize,
                ) -> SplitN<'r, 'h> {
                    SplitN { haystack, it: self.meta.splitn(haystack, limit) }
                }
            
                /// Replaces the leftmost-first match in the given haystack with the
                /// replacement provided.
                #[inline]
                pub fn replace<'h, R: Replacer>(
                    &self,
                    haystack: &'h str,
                    rep: R,
                ) -> Cow<'h, str> {
                    self.replacen(haystack, 1, rep)
                }
            
                /// Replaces all non-overlapping matches in the haystack with the
                /// replacement provided.
                #[inline]
                pub fn replace_all<'h, R: Replacer>(
                    &self,
                    haystack: &'h str,
                    rep: R,
                ) -> Cow<'h, str> {
                    self.replacen(haystack, 0, rep)
                }
            
                /// Replaces at most `limit` non-overlapping matches in the haystack with
                /// the replacement provided.
                #[inline]
                pub fn replacen<'h, R: Replacer>(
                    &self,
                    haystack: &'h str,
                    limit: usize,
                    mut rep: R,
                ) -> Cow<'h, str> {
                    if let Some(rep) = rep.no_expansion() {
                        let mut it = self.find_iter(haystack).enumerate().peekable();
                        if it.peek().is_none() {
                            return Cow::Borrowed(haystack);
                        }
                        let mut new = String::with_capacity(haystack.len());
                        let mut last_match = 0;
                        for (i, m) in it {
                            new.push_str(&haystack[last_match..m.start()]);
                            new.push_str(&rep);
                            last_match = m.end();
                            if limit > 0 && i >= limit - 1 {
                                break;
                            }
                        }
                        new.push_str(&haystack[last_match..]);
                        return Cow::Owned(new);
                    }
                    
                    let mut it = self.captures_iter(haystack).enumerate().peekable();
                    if it.peek().is_none() {
                        return Cow::Borrowed(haystack);
                    }
                    let mut new = String::with_capacity(haystack.len());
                    let mut last_match = 0;
                    for (i, cap) in it {
                        let m = cap.get(0).unwrap();
                        new.push_str(&haystack[last_match..m.start()]);
                        rep.replace_append(&cap, &mut new);
                        last_match = m.end();
                        if limit > 0 && i >= limit - 1 {
                            break;
                        }
                    }
                    new.push_str(&haystack[last_match..]);
                    Cow::Owned(new)
                }
            }
            
            /// A group of advanced or "lower level" search methods.
            impl Regex {
                /// Returns the end byte offset of the first match in the haystack given.
                #[inline]
                pub fn shortest_match(&self, haystack: &str) -> Option<usize> {
                    self.shortest_match_at(haystack, 0)
                }
            
                /// Returns the same as [`Regex::shortest_match`], but starts the search at
                /// the given offset.
                #[inline]
                pub fn shortest_match_at(
                    &self,
                    haystack: &str,
                    start: usize,
                ) -> Option<usize> {
                    let input =
                        Input::new(haystack).earliest(true).span(start..haystack.len());
                    self.meta.search_half(&input).map(|hm| hm.offset())
                }
            
                /// Returns the same as [`Regex::is_match`], but starts the search at the
                /// given offset.
                #[inline]
                pub fn is_match_at(&self, haystack: &str, start: usize) -> bool {
                    let input =
                        Input::new(haystack).earliest(true).span(start..haystack.len());
                    self.meta.search_half(&input).is_some()
                }
            
                /// Returns the same as [`Regex::find`], but starts the search at the given
                /// offset.
                #[inline]
                pub fn find_at<'h>(
                    &self,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Match<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta
                        .search(&input)
                        .map(|m| Match::new(haystack, m.start(), m.end()))
                }
            
                /// Returns the same as [`Regex::captures`], but starts the search at the
                /// given offset.
                #[inline]
                pub fn captures_at<'h>(
                    &self,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Captures<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    let mut caps = self.meta.create_captures();
                    self.meta.search_captures(&input, &mut caps);
                    if caps.is_match() {
                        let static_captures_len = self.static_captures_len();
                        Some(Captures { haystack, caps, static_captures_len })
                    } else {
                        None
                    }
                }
            
                /// This is like [`Regex::captures`], but writes the byte offsets of each
                /// capture group match into the locations given.
                #[inline]
                pub fn captures_read<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h str,
                ) -> Option<Match<'h>> {
                    self.captures_read_at(locs, haystack, 0)
                }
            
                /// Returns the same as [`Regex::captures_read`], but starts the search at
                /// the given offset.
                #[inline]
                pub fn captures_read_at<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Match<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta.search_captures(&input, &mut locs.0);
                    locs.0.get_match().map(|m| Match::new(haystack, m.start(), m.end()))
                }
            
                /// An undocumented alias for `captures_read_at`.
                #[doc(hidden)]
                #[inline]
                pub fn read_captures_at<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Match<'h>> {
                    self.captures_read_at(locs, haystack, start)
                }
            }
            
            /// Auxiliary methods.
            impl Regex {
                /// Returns the original string of this regex.
                #[inline]
                pub fn as_str(&self) -> &str {
                    &self.pattern
                }
            
                /// Returns an iterator over the capture names in this regex.
                #[inline]
                pub fn capture_names(&self) -> CaptureNames<'_> {
                    CaptureNames(self.meta.group_info().pattern_names(PatternID::ZERO))
                }
            
                /// Returns the number of captures groups in this regex.
                #[inline]
                pub fn captures_len(&self) -> usize {
                    self.meta.group_info().group_len(PatternID::ZERO)
                }
            
                /// Returns the total number of capturing groups that appear in every
                /// possible match.
                #[inline]
                pub fn static_captures_len(&self) -> Option<usize> {
                    self.meta.static_captures_len()
                }
            
                /// Returns a fresh allocated set of capture locations that can
                /// be reused in multiple calls to [`Regex::captures_read`] or
                /// [`Regex::captures_read_at`].
                #[inline]
                pub fn capture_locations(&self) -> CaptureLocations {
                    CaptureLocations(self.meta.create_captures())
                }
            
                /// An alias for `capture_locations` to preserve backward compatibility.
                #[doc(hidden)]
                #[inline]
                pub fn locations(&self) -> CaptureLocations {
                    self.capture_locations()
                }
            }
            
            /// Represents a single match of a regex in a haystack.
            #[derive(Copy, Clone, Eq, PartialEq)]
            pub struct Match<'h> {
                haystack: &'h str,
                start: usize,
                end: usize,
            }
            
            impl<'h> Match<'h> {
                /// Returns the byte offset of the start of the match in the haystack.
                #[inline]
                pub fn start(&self) -> usize {
                    self.start
                }
            
                /// Returns the byte offset of the end of the match in the haystack.
                #[inline]
                pub fn end(&self) -> usize {
                    self.end
                }
            
                /// Returns true if and only if this match has a length of zero.
                #[inline]
                pub fn is_empty(&self) -> bool {
                    self.start == self.end
                }
            
                /// Returns the length, in bytes, of this match.
                #[inline]
                pub fn len(&self) -> usize {
                    self.end - self.start
                }
            
                /// Returns the range over the starting and ending byte offsets of the
                /// match in the haystack.
                #[inline]
                pub fn range(&self) -> ::ops::Range<usize> {
                    self.start..self.end
                }
            
                /// Returns the substring of the haystack that matched.
                #[inline]
                pub fn as_str(&self) -> &'h str {
                    &self.haystack[self.range()]
                }
            
                /// Creates a new match from the given haystack and byte offsets.
                #[inline]
                fn new(haystack: &'h str, start: usize, end: usize) -> Match<'h> {
                    Match { haystack, start, end }
                }
            }
            
            impl<'h> ::fmt::Debug for Match<'h> {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    f.debug_struct("Match")
                        .field("start", &self.start)
                        .field("end", &self.end)
                        .field("string", &self.as_str())
                        .finish()
                }
            }
            
            impl<'h> From<Match<'h>> for &'h str {
                fn from(m: Match<'h>) -> &'h str {
                    m.as_str()
                }
            }
            
            impl<'h> From<Match<'h>> for ::ops::Range<usize> {
                fn from(m: Match<'h>) -> ::ops::Range<usize> {
                    m.range()
                }
            }
            
            /// Represents the capture groups for a single match.
            pub struct Captures<'h> {
                haystack: &'h str,
                caps: captures::Captures,
                static_captures_len: Option<usize>,
            }
            
            impl<'h> Captures<'h> {
                /// Returns the `Match` associated with the capture group at index `i`.
                #[inline]
                pub fn get(&self, i: usize) -> Option<Match<'h>> {
                    self.caps
                        .get_group(i)
                        .map(|sp| Match::new(self.haystack, sp.start, sp.end))
                }
            
                /// Returns the `Match` associated with the capture group named `name`.
                #[inline]
                pub fn name(&self, name: &str) -> Option<Match<'h>> {
                    self.caps
                        .get_group_by_name(name)
                        .map(|sp| Match::new(self.haystack, sp.start, sp.end))
                }
            
                /// This is a convenience routine for extracting the substrings
                /// corresponding to matching capture groups.
                pub fn extract<const N: usize>(&self) -> (&'h str, [&'h str; N]) {
                    let len = self
                        .static_captures_len
                        .expect("number of capture groups can vary in a match")
                        .checked_sub(1)
                        .expect("number of groups is always greater than zero");
                    assert_eq!(N, len, "asked for {} groups, but must ask for {}", N, len);
                    self.caps.extract(self.haystack)
                }
            
                /// Expands all instances of `$ref` in `replacement` to the corresponding
                /// capture group, and writes them to the `dst` buffer given.
                #[inline]
                pub fn expand(&self, replacement: &str, dst: &mut String) {
                    self.caps.interpolate_string_into(self.haystack, replacement, dst);
                }
            
                /// Returns an iterator over all capture groups. This includes both
                /// matching and non-matching groups.
                #[inline]
                pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 'h> {
                    SubCaptureMatches { haystack: self.haystack, it: self.caps.iter() }
                }
            
                /// Returns the total number of capture groups. This includes both
                /// matching and non-matching groups.
                #[inline]
                pub fn len(&self) -> usize {
                    self.caps.group_len()
                }
            }
            
            impl<'h> ::fmt::Debug for Captures<'h> {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    /// A little helper type to provide a nice map-like debug
                    /// representation for our capturing group spans.
                    struct CapturesDebugMap<'a> {
                        caps: &'a Captures<'a>,
                    }
            
                    impl<'a> ::fmt::Debug for CapturesDebugMap<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            let mut map = f.debug_map();
                            let names =
                                self.caps.caps.group_info().pattern_names(PatternID::ZERO);
                            for (group_index, maybe_name) in names.enumerate() {
                                let key = Key(group_index, maybe_name);
                                match self.caps.get(group_index) {
                                    None => map.entry(&key, &None::<()>),
                                    Some(mat) => map.entry(&key, &Value(mat)),
                                };
                            }
                            map.finish()
                        }
                    }
            
                    struct Key<'a>(usize, Option<&'a str>);
            
                    impl<'a> ::fmt::Debug for Key<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(f, "{}", self.0)?;
                            if let Some(name) = self.1 {
                                write!(f, "/{:?}", name)?;
                            }
                            Ok(())
                        }
                    }
            
                    struct Value<'a>(Match<'a>);
            
                    impl<'a> ::fmt::Debug for Value<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(
                                f,
                                "{}..{}/{:?}",
                                self.0.start(),
                                self.0.end(),
                                self.0.as_str()
                            )
                        }
                    }
            
                    f.debug_tuple("Captures")
                        .field(&CapturesDebugMap { caps: self })
                        .finish()
                }
            }
            
            /// Get a matching capture group's haystack substring by index.
            impl<'h> ::ops::Index<usize> for Captures<'h> {
                type Output = str;
                fn index<'a>(&'a self, i: usize) -> &'a str {
                    self.get(i)
                        .map(|m| m.as_str())
                        .unwrap_or_else(|| panic!("no group at index '{}'", i))
                }
            }
            
            /// Get a matching capture group's haystack substring by name.
            impl<'h, 'n> ::ops::Index<&'n str> for Captures<'h> {
                type Output = str;
            
                fn index<'a>(&'a self, name: &'n str) -> &'a str {
                    self.name(name)
                        .map(|m| m.as_str())
                        .unwrap_or_else(|| panic!("no group named '{}'", name))
                }
            }
            
            /// A low level representation of the byte offsets of each capture group.
            #[derive(Clone, Debug)]
            pub struct CaptureLocations(captures::Captures);
            
            /// A type alias for `CaptureLocations` for backwards compatibility.
            #[doc(hidden)]
            pub type Locations = CaptureLocations;
            
            impl CaptureLocations {
                /// Returns the start and end byte offsets of the capture group at index
                /// `i`.
                #[inline]
                pub fn get(&self, i: usize) -> Option<(usize, usize)> {
                    self.0.get_group(i).map(|sp| (sp.start, sp.end))
                }
            
                /// Returns the total number of capture groups (even if they didn't match).
                #[inline]
                pub fn len(&self) -> usize {
                    self.0.group_info().group_len(PatternID::ZERO)
                }
            
                /// An alias for the `get` method for backwards compatibility.
                #[doc(hidden)]
                #[inline]
                pub fn pos(&self, i: usize) -> Option<(usize, usize)> {
                    self.get(i)
                }
            }
            
            /// An iterator over all non-overlapping matches in a haystack.
            #[derive(Debug)]
            pub struct Matches<'r, 'h> {
                haystack: &'h str,
                it: meta::FindMatches<'r, 'h>,
            }
            
            impl<'r, 'h> Iterator for Matches<'r, 'h> {
                type Item = Match<'h>;
            
                #[inline]
                fn next(&mut self) -> Option<Match<'h>> {
                    self.it
                        .next()
                        .map(|sp| Match::new(self.haystack, sp.start(), sp.end()))
                }
            
                #[inline]
                fn count(self) -> usize {
                    self.it.count()
                }
            }
            
            impl<'r, 'h> ::iter::FusedIterator for Matches<'r, 'h> {}
            
            /// An iterator over all non-overlapping capture matches in a haystack.
            #[derive(Debug)]
            pub struct CaptureMatches<'r, 'h> {
                haystack: &'h str,
                it: meta::CapturesMatches<'r, 'h>,
            }
            
            impl<'r, 'h> Iterator for CaptureMatches<'r, 'h> {
                type Item = Captures<'h>;
            
                #[inline]
                fn next(&mut self) -> Option<Captures<'h>> {
                    let static_captures_len = self.it.regex().static_captures_len();
                    self.it.next().map(|caps| Captures {
                        haystack: self.haystack,
                        caps,
                        static_captures_len,
                    })
                }
            
                #[inline]
                fn count(self) -> usize {
                    self.it.count()
                }
            }
            
            impl<'r, 'h> ::iter::FusedIterator for CaptureMatches<'r, 'h> {}
            
            /// An iterator over all substrings delimited by a regex match.
            #[derive(Debug)]
            pub struct Split<'r, 'h> {
                haystack: &'h str,
                it: meta::Split<'r, 'h>,
            }
            
            impl<'r, 'h> Iterator for Split<'r, 'h> {
                type Item = &'h str;
            
                #[inline]
                fn next(&mut self) -> Option<&'h str> {
                    self.it.next().map(|span| &self.haystack[span])
                }
            }
            
            impl<'r, 'h> ::iter::FusedIterator for Split<'r, 'h> {}
            
            /// An iterator over at most `N` substrings delimited by a regex match.
            #[derive(Debug)]
            pub struct SplitN<'r, 'h> {
                haystack: &'h str,
                it: meta::SplitN<'r, 'h>,
            }
            
            impl<'r, 'h> Iterator for SplitN<'r, 'h> {
                type Item = &'h str;
            
                #[inline]
                fn next(&mut self) -> Option<&'h str> {
                    self.it.next().map(|span| &self.haystack[span])
                }
            
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            }
            
            impl<'r, 'h> ::iter::FusedIterator for SplitN<'r, 'h> {}
            
            /// An iterator over the names of all capture groups in a regex.
            #[derive(Clone, Debug)]
            pub struct CaptureNames<'r>(captures::GroupInfoPatternNames<'r>);
            
            impl<'r> Iterator for CaptureNames<'r> {
                type Item = Option<&'r str>;
            
                #[inline]
                fn next(&mut self) -> Option<Option<&'r str>> {
                    self.0.next()
                }
            
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.0.size_hint()
                }
            
                #[inline]
                fn count(self) -> usize {
                    self.0.count()
                }
            }
            
            impl<'r> ExactSizeIterator for CaptureNames<'r> {}
            
            impl<'r> ::iter::FusedIterator for CaptureNames<'r> {}
            
            /// An iterator over all group matches in a [`Captures`] value.
            #[derive(Clone, Debug)]
            pub struct SubCaptureMatches<'c, 'h> {
                haystack: &'h str,
                it: captures::CapturesPatternIter<'c>,
            }
            
            impl<'c, 'h> Iterator for SubCaptureMatches<'c, 'h> {
                type Item = Option<Match<'h>>;
            
                #[inline]
                fn next(&mut self) -> Option<Option<Match<'h>>> {
                    self.it.next().map(|group| {
                        group.map(|sp| Match::new(self.haystack, sp.start, sp.end))
                    })
                }
            
                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            
                #[inline]
                fn count(self) -> usize {
                    self.it.count()
                }
            }
            
            impl<'c, 'h> ExactSizeIterator for SubCaptureMatches<'c, 'h> {}
            
            impl<'c, 'h> ::iter::FusedIterator for SubCaptureMatches<'c, 'h> {}
            
            /// A trait for types that can be used to replace matches in a haystack.
            pub trait Replacer {
                /// Appends possibly empty data to `dst` to replace the current match.
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String);
            
                /// Return a fixed unchanging replacement string.
                fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, str>> {
                    None
                }
            
                /// Returns a type that implements `Replacer`, but that borrows and wraps
                /// this `Replacer`.
                fn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self> {
                    ReplacerRef(self)
                }
            }
            
            impl<'a> Replacer for &'a str {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    caps.expand(*self, dst);
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    no_expansion(self)
                }
            }
            
            impl<'a> Replacer for &'a String {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_str().replace_append(caps, dst)
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    no_expansion(self)
                }
            }
            
            impl Replacer for String {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_str().replace_append(caps, dst)
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    no_expansion(self)
                }
            }
            
            impl<'a> Replacer for Cow<'a, str> {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_ref().replace_append(caps, dst)
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    no_expansion(self)
                }
            }
            
            impl<'a> Replacer for &'a Cow<'a, str> {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_ref().replace_append(caps, dst)
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    no_expansion(self)
                }
            }
            
            impl<F, T> Replacer for F
            where
                F: FnMut(&Captures<'_>) -> T,
                T: AsRef<str>,
            {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    dst.push_str((*self)(caps).as_ref());
                }
            }
            
            /// A by-reference adaptor for a [`Replacer`].
            #[derive(Debug)]
            pub struct ReplacerRef<'a, R: ?Sized>(&'a mut R);
            
            impl<'a, R: Replacer + ?Sized + 'a> Replacer for ReplacerRef<'a, R> {
                fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.0.replace_append(caps, dst)
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    self.0.no_expansion()
                }
            }
            
            /// A helper type for forcing literal string replacement.
            #[derive(Clone, Debug)]
            pub struct NoExpand<'s>(pub &'s str);
            
            impl<'s> Replacer for NoExpand<'s> {
                fn replace_append(&mut self, _: &Captures<'_>, dst: &mut String) {
                    dst.push_str(self.0);
                }
            
                fn no_expansion(&mut self) -> Option<Cow<'_, str>> {
                    Some(Cow::Borrowed(self.0))
                }
            }
            
            /// Quickly checks the given replacement string for whether interpolation
            /// should be done on it.
            fn no_expansion<T: AsRef<str>>(replacement: &T) -> Option<Cow<'_, str>> {
                let replacement = replacement.as_ref();
                match crate::find_byte::find_byte(b'$', replacement.as_bytes()) {
                    Some(_) => None,
                    None => Some(Cow::Borrowed(replacement)),
                }
            }
        }
    }
    
    mod regexset
    {
        use ::
        {
            *,
        };
        /*
        */
        pub mod bytes
        {
            use ::
            {
                *,
            };
            /*
            use ::string::String;
            
            use regex_automata::{meta, Input, PatternID, PatternSet, PatternSetIter};
            
            use crate::{bytes::RegexSetBuilder, Error};
            */
            /// A regex set corresponds to the union of zero or more regular expressions.
            #[derive(Clone)]
            pub struct RegexSet {
                pub meta: meta::Regex,
                pub patterns: ::sync::Arc<[String]>,
            }
            
            impl RegexSet {
                /// Create a new regex set with the given regular expressions.
                pub fn new<I, S>(exprs: I) -> Result<RegexSet, Error>
                where
                    S: AsRef<str>,
                    I: IntoIterator<Item = S>,
                {
                    RegexSetBuilder::new(exprs).build()
                }
            
                /// Create a new empty regex set.
                pub fn empty() -> RegexSet {
                    let empty: [&str; 0] = [];
                    RegexSetBuilder::new(empty).build().unwrap()
                }
            
                /// Returns true if and only if one of the regexes in this set matches
                /// the haystack given.
                #[inline]
                pub fn is_match(&self, haystack: &[u8]) -> bool {
                    self.is_match_at(haystack, 0)
                }
            
                /// Returns true if and only if one of the regexes in this set matches the
                /// haystack given, with the search starting at the offset given.
                #[inline]
                pub fn is_match_at(&self, haystack: &[u8], start: usize) -> bool {
                    self.meta.is_match(Input::new(haystack).span(start..haystack.len()))
                }
            
                /// Returns the set of regexes that match in the given haystack.
                #[inline]
                pub fn matches(&self, haystack: &[u8]) -> SetMatches {
                    self.matches_at(haystack, 0)
                }
            
                /// Returns the set of regexes that match in the given haystack.
                #[inline]
                pub fn matches_at(&self, haystack: &[u8], start: usize) -> SetMatches {
                    let input = Input::new(haystack).span(start..haystack.len());
                    let mut patset = PatternSet::new(self.meta.pattern_len());
                    self.meta.which_overlapping_matches(&input, &mut patset);
                    SetMatches(patset)
                }
            
                /// Returns the same as matches, but starts the search at the given
                /// offset and stores the matches into the slice given.
                #[doc(hidden)]
                #[inline]
                pub fn matches_read_at(
                    &self,
                    matches: &mut [bool],
                    haystack: &[u8],
                    start: usize,
                ) -> bool {
                    let mut patset = PatternSet::new(self.meta.pattern_len());
                    let mut input = Input::new(haystack);
                    input.set_start(start);
                    self.meta.which_overlapping_matches(&input, &mut patset);
                    for pid in patset.iter() {
                        matches[pid] = true;
                    }
                    !patset.is_empty()
                }
            
                /// An alias for `matches_read_at` to preserve backward compatibility.
                #[doc(hidden)]
                #[inline]
                pub fn read_matches_at(
                    &self,
                    matches: &mut [bool],
                    haystack: &[u8],
                    start: usize,
                ) -> bool {
                    self.matches_read_at(matches, haystack, start)
                }
            
                /// Returns the total number of regexes in this set.
                #[inline]
                pub fn len(&self) -> usize {
                    self.meta.pattern_len()
                }
            
                /// Returns `true` if this set contains no regexes.
                #[inline]
                pub fn is_empty(&self) -> bool {
                    self.meta.pattern_len() == 0
                }
            
                /// Returns the regex patterns that this regex set was constructed from.
                #[inline]
                pub fn patterns(&self) -> &[String] {
                    &self.patterns
                }
            }
            
            impl Default for RegexSet {
                fn default() -> Self {
                    RegexSet::empty()
                }
            }
            
            /// A set of matches returned by a regex set.
            #[derive(Clone, Debug)]
            pub struct SetMatches(PatternSet);
            
            impl SetMatches {
                /// Whether this set contains any matches.
                #[inline]
                pub fn matched_any(&self) -> bool {
                    !self.0.is_empty()
                }
            
                /// Whether all patterns in this set matched.
                pub fn matched_all(&self) -> bool {
                    self.0.is_full()
                }
            
                /// Whether the regex at the given index matched.
                #[inline]
                pub fn matched(&self, index: usize) -> bool {
                    self.0.contains(PatternID::new_unchecked(index))
                }
            
                /// The total number of regexes in the set that created these matches.
                #[inline]
                pub fn len(&self) -> usize {
                    self.0.capacity()
                }
            
                /// Returns an iterator over the indices of the regexes that matched.
                #[inline]
                pub fn iter(&self) -> SetMatchesIter<'_> {
                    SetMatchesIter(self.0.iter())
                }
            }
            
            impl IntoIterator for SetMatches {
                type IntoIter = SetMatchesIntoIter;
                type Item = usize;
            
                fn into_iter(self) -> Self::IntoIter {
                    let it = 0..self.0.capacity();
                    SetMatchesIntoIter { patset: self.0, it }
                }
            }
            
            impl<'a> IntoIterator for &'a SetMatches {
                type IntoIter = SetMatchesIter<'a>;
                type Item = usize;
            
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            
            /// An owned iterator over the set of matches from a regex set.
            #[derive(Debug)]
            pub struct SetMatchesIntoIter {
                patset: PatternSet,
                it: ::ops::Range<usize>,
            }
            
            impl Iterator for SetMatchesIntoIter {
                type Item = usize;
            
                fn next(&mut self) -> Option<usize> {
                    loop {
                        let id = self.it.next()?;
                        if self.patset.contains(PatternID::new_unchecked(id)) {
                            return Some(id);
                        }
                    }
                }
            
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            }
            
            impl DoubleEndedIterator for SetMatchesIntoIter {
                fn next_back(&mut self) -> Option<usize> {
                    loop {
                        let id = self.it.next_back()?;
                        if self.patset.contains(PatternID::new_unchecked(id)) {
                            return Some(id);
                        }
                    }
                }
            }
            
            impl ::iter::FusedIterator for SetMatchesIntoIter {}
            
            /// A borrowed iterator over the set of matches from a regex set.
            #[derive(Clone, Debug)]
            pub struct SetMatchesIter<'a>(PatternSetIter<'a>);
            
            impl<'a> Iterator for SetMatchesIter<'a> {
                type Item = usize;
            
                fn next(&mut self) -> Option<usize> {
                    self.0.next().map(|pid| pid.as_usize())
                }
            
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.0.size_hint()
                }
            }
            
            impl<'a> DoubleEndedIterator for SetMatchesIter<'a> {
                fn next_back(&mut self) -> Option<usize> {
                    self.0.next_back().map(|pid| pid.as_usize())
                }
            }
            
            impl<'a> ::iter::FusedIterator for SetMatchesIter<'a> {}
            
            impl ::fmt::Debug for RegexSet {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "RegexSet({:?})", self.patterns())
                }
            }
        }
        
        pub mod string
        {
            use ::
            {
                *,
            };
            /*
            use ::string::String;
            
            use regex_automata::{meta, Input, PatternID, PatternSet, PatternSetIter};
            
            use crate::{Error, RegexSetBuilder};
            */
            /// Match multiple, possibly overlapping, regexes in a single search.
            #[derive(Clone)]
            pub struct RegexSet {
                pub meta: meta::Regex,
                pub patterns: ::sync::Arc<[String]>,
            }
            
            impl RegexSet {
                /// Create a new regex set with the given regular expressions.
                pub fn new<I, S>(exprs: I) -> Result<RegexSet, Error>
                where
                    S: AsRef<str>,
                    I: IntoIterator<Item = S>,
                {
                    RegexSetBuilder::new(exprs).build()
                }
            
                /// Create a new empty regex set.
                pub fn empty() -> RegexSet {
                    let empty: [&str; 0] = [];
                    RegexSetBuilder::new(empty).build().unwrap()
                }
            
                /// Returns true if and only if one of the regexes in this set matches
                /// the haystack given.
                #[inline]
                pub fn is_match(&self, haystack: &str) -> bool {
                    self.is_match_at(haystack, 0)
                }
            
                /// Returns true if and only if one of the regexes in this set matches the
                /// haystack given, with the search starting at the offset given.
                #[inline]
                pub fn is_match_at(&self, haystack: &str, start: usize) -> bool {
                    self.meta.is_match(Input::new(haystack).span(start..haystack.len()))
                }
            
                /// Returns the set of regexes that match in the given haystack.
                #[inline]
                pub fn matches(&self, haystack: &str) -> SetMatches {
                    self.matches_at(haystack, 0)
                }
            
                /// Returns the set of regexes that match in the given haystack.
                #[inline]
                pub fn matches_at(&self, haystack: &str, start: usize) -> SetMatches {
                    let input = Input::new(haystack).span(start..haystack.len());
                    let mut patset = PatternSet::new(self.meta.pattern_len());
                    self.meta.which_overlapping_matches(&input, &mut patset);
                    SetMatches(patset)
                }
            
                /// Returns the same as matches, but starts the search at the given
                /// offset and stores the matches into the slice given.
                #[doc(hidden)]
                #[inline]
                pub fn matches_read_at(
                    &self,
                    matches: &mut [bool],
                    haystack: &str,
                    start: usize,
                ) -> bool {
                    let mut patset = PatternSet::new(self.meta.pattern_len());
                    let mut input = Input::new(haystack);
                    input.set_start(start);
                    self.meta.which_overlapping_matches(&input, &mut patset);
                    for pid in patset.iter() {
                        matches[pid] = true;
                    }
                    !patset.is_empty()
                }
            
                /// An alias for `matches_read_at` to preserve backward compatibility.
                #[doc(hidden)]
                #[inline]
                pub fn read_matches_at(
                    &self,
                    matches: &mut [bool],
                    haystack: &str,
                    start: usize,
                ) -> bool {
                    self.matches_read_at(matches, haystack, start)
                }
            
                /// Returns the total number of regexes in this set.
                #[inline]
                pub fn len(&self) -> usize {
                    self.meta.pattern_len()
                }
            
                /// Returns `true` if this set contains no regexes.
                #[inline]
                pub fn is_empty(&self) -> bool {
                    self.meta.pattern_len() == 0
                }
            
                /// Returns the regex patterns that this regex set was constructed from.
                #[inline]
                pub fn patterns(&self) -> &[String] {
                    &self.patterns
                }
            }
            
            impl Default for RegexSet {
                fn default() -> Self {
                    RegexSet::empty()
                }
            }
            
            /// A set of matches returned by a regex set.
            #[derive(Clone, Debug)]
            pub struct SetMatches(PatternSet);
            
            impl SetMatches {
                /// Whether this set contains any matches.
                #[inline]
                pub fn matched_any(&self) -> bool {
                    !self.0.is_empty()
                }
            
                /// Whether all patterns in this set matched.
                pub fn matched_all(&self) -> bool {
                    self.0.is_full()
                }
            
                /// Whether the regex at the given index matched.
                #[inline]
                pub fn matched(&self, index: usize) -> bool {
                    self.0.contains(PatternID::new_unchecked(index))
                }
            
                /// The total number of regexes in the set that created these matches.
                #[inline]
                pub fn len(&self) -> usize {
                    self.0.capacity()
                }
            
                /// Returns an iterator over the indices of the regexes that matched.
                #[inline]
                pub fn iter(&self) -> SetMatchesIter<'_> {
                    SetMatchesIter(self.0.iter())
                }
            }
            
            impl IntoIterator for SetMatches {
                type IntoIter = SetMatchesIntoIter;
                type Item = usize;
            
                fn into_iter(self) -> Self::IntoIter {
                    let it = 0..self.0.capacity();
                    SetMatchesIntoIter { patset: self.0, it }
                }
            }
            
            impl<'a> IntoIterator for &'a SetMatches {
                type IntoIter = SetMatchesIter<'a>;
                type Item = usize;
            
                fn into_iter(self) -> Self::IntoIter {
                    self.iter()
                }
            }
            
            /// An owned iterator over the set of matches from a regex set.
            #[derive(Debug)]
            pub struct SetMatchesIntoIter {
                patset: PatternSet,
                it: ::ops::Range<usize>,
            }
            
            impl Iterator for SetMatchesIntoIter {
                type Item = usize;
            
                fn next(&mut self) -> Option<usize> {
                    loop {
                        let id = self.it.next()?;
                        if self.patset.contains(PatternID::new_unchecked(id)) {
                            return Some(id);
                        }
                    }
                }
            
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            }
            
            impl DoubleEndedIterator for SetMatchesIntoIter {
                fn next_back(&mut self) -> Option<usize> {
                    loop {
                        let id = self.it.next_back()?;
                        if self.patset.contains(PatternID::new_unchecked(id)) {
                            return Some(id);
                        }
                    }
                }
            }
            
            impl ::iter::FusedIterator for SetMatchesIntoIter {}
            
            /// A borrowed iterator over the set of matches from a regex set.
            #[derive(Clone, Debug)]
            pub struct SetMatchesIter<'a>(PatternSetIter<'a>);
            
            impl<'a> Iterator for SetMatchesIter<'a> {
                type Item = usize;
            
                fn next(&mut self) -> Option<usize> {
                    self.0.next().map(|pid| pid.as_usize())
                }
            
                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.0.size_hint()
                }
            }
            
            impl<'a> DoubleEndedIterator for SetMatchesIter<'a> {
                fn next_back(&mut self) -> Option<usize> {
                    self.0.next_back().map(|pid| pid.as_usize())
                }
            }
            
            impl<'a> ::iter::FusedIterator for SetMatchesIter<'a> {}
            
            impl ::fmt::Debug for RegexSet {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "RegexSet({:?})", self.patterns())
                }
            }
        }
    }
    /// Escapes all regular expression meta characters in `pattern`.
    pub fn escape(pattern: &str) -> ::string::String { regex_syntax::escape(pattern) }

}

pub mod rusqlite
{
    //! Rusqlite is an ergonomic wrapper for using SQLite from Rust.
    use ::
    {
        *,
    };
    /*
    pub use libsqlite3_sys as ffi;
    
    use ::cell::RefCell;
    use ::default::Default;
    use ::ffi::{CStr, CString};
    use ::fmt;
    use ::os::raw::{c_char, c_int};
    
    use ::path::Path;
    use ::result;
    use ::str;
    use ::sync::{Arc, Mutex};
    
    use crate::cache::StatementCache;
    use crate::inner_connection::InnerConnection;
    use crate::raw_statement::RawStatement;
    use crate::types::ValueRef;
    
    pub use crate::cache::CachedStatement;
    #[cfg(feature = "column_decltype")]
    pub use crate::column::Column;
    pub use crate::error::{to_sqlite_error, Error};
    pub use crate::ffi::ErrorCode;
    #[cfg(feature = "load_extension")]
    pub use crate::load_extension_guard::LoadExtensionGuard;
    pub use crate::params::{params_from_iter, Params, ParamsFromIter};
    pub use crate::row::{AndThenRows, Map, MappedRows, Row, RowIndex, Rows};
    pub use crate::statement::{Statement, StatementStatus};
    #[cfg(feature = "modern_sqlite")]
    pub use crate::transaction::TransactionState;
    pub use crate::transaction::{DropBehavior, Savepoint, Transaction, TransactionBehavior};
    pub use crate::types::ToSql;
    pub use crate::version::*;
    #[cfg(feature = "rusqlite-macros")]
    #[doc(hidden)]
    pub use rusqlite_macros::__bind;
    */
    /*libsqlite3-sys 0.30.0*/
    pub mod system
    {
        use ::
        {
            *,
        };
        /*
        use ::mem;
        */
        mod error
        {
            use ::
            {
                *,
            };
            /*
            use ::error;
            use ::fmt;
            use ::os::raw::c_int;
            */
            /// Error Codes
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            #[non_exhaustive]
            pub enum ErrorCode {
                /// Internal logic error in SQLite
                InternalMalfunction,
                /// Access permission denied
                PermissionDenied,
                /// Callback routine requested an abort
                OperationAborted,
                /// The database file is locked
                DatabaseBusy,
                /// A table in the database is locked
                DatabaseLocked,
                /// A malloc() failed
                OutOfMemory,
                /// Attempt to write a readonly database
                ReadOnly,
                /// Operation terminated by sqlite3_interrupt()
                OperationInterrupted,
                /// Some kind of disk I/O error occurred
                SystemIoFailure,
                /// The database disk image is malformed
                DatabaseCorrupt,
                /// Unknown opcode in sqlite3_file_control()
                NotFound,
                /// Insertion failed because database is full
                DiskFull,
                /// Unable to open the database file
                CannotOpen,
                /// Database lock protocol error
                FileLockingProtocolFailed,
                /// The database schema changed
                SchemaChanged,
                /// String or BLOB exceeds size limit
                TooBig,
                /// Abort due to constraint violation
                ConstraintViolation,
                /// Data type mismatch
                TypeMismatch,
                /// Library used incorrectly
                ApiMisuse,
                /// Uses OS features not supported on host
                NoLargeFileSupport,
                /// Authorization denied
                AuthorizationForStatementDenied,
                /// 2nd parameter to sqlite3_bind out of range
                ParameterOutOfRange,
                /// File opened that is not a database file
                NotADatabase,
                /// SQL error or missing database
                Unknown,
            }
            
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            pub struct Error {
                pub code: ErrorCode,
                pub extended_code: c_int,
            }
            
            impl Error {
                #[must_use]
                pub fn new(result_code: c_int) -> Error {
                    let code = match result_code & 0xff {
                        super::SQLITE_INTERNAL => ErrorCode::InternalMalfunction,
                        super::SQLITE_PERM => ErrorCode::PermissionDenied,
                        super::SQLITE_ABORT => ErrorCode::OperationAborted,
                        super::SQLITE_BUSY => ErrorCode::DatabaseBusy,
                        super::SQLITE_LOCKED => ErrorCode::DatabaseLocked,
                        super::SQLITE_NOMEM => ErrorCode::OutOfMemory,
                        super::SQLITE_READONLY => ErrorCode::ReadOnly,
                        super::SQLITE_INTERRUPT => ErrorCode::OperationInterrupted,
                        super::SQLITE_IOERR => ErrorCode::SystemIoFailure,
                        super::SQLITE_CORRUPT => ErrorCode::DatabaseCorrupt,
                        super::SQLITE_NOTFOUND => ErrorCode::NotFound,
                        super::SQLITE_FULL => ErrorCode::DiskFull,
                        super::SQLITE_CANTOPEN => ErrorCode::CannotOpen,
                        super::SQLITE_PROTOCOL => ErrorCode::FileLockingProtocolFailed,
                        super::SQLITE_SCHEMA => ErrorCode::SchemaChanged,
                        super::SQLITE_TOOBIG => ErrorCode::TooBig,
                        super::SQLITE_CONSTRAINT => ErrorCode::ConstraintViolation,
                        super::SQLITE_MISMATCH => ErrorCode::TypeMismatch,
                        super::SQLITE_MISUSE => ErrorCode::ApiMisuse,
                        super::SQLITE_NOLFS => ErrorCode::NoLargeFileSupport,
                        super::SQLITE_AUTH => ErrorCode::AuthorizationForStatementDenied,
                        super::SQLITE_RANGE => ErrorCode::ParameterOutOfRange,
                        super::SQLITE_NOTADB => ErrorCode::NotADatabase,
                        _ => ErrorCode::Unknown,
                    };
            
                    Error {
                        code,
                        extended_code: result_code,
                    }
                }
            }
            
            impl fmt::Display for Error {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    write!(
                        f,
                        "Error code {}: {}",
                        self.extended_code,
                        code_to_str(self.extended_code)
                    )
                }
            }
            
            impl error::Error for Error {
                fn description(&self) -> &str {
                    code_to_str(self.extended_code)
                }
            }
            
            const SQLITE_ERROR_MISSING_COLLSEQ: c_int = super::SQLITE_ERROR | (1 << 8);
            const SQLITE_ERROR_RETRY: c_int = super::SQLITE_ERROR | (2 << 8);
            const SQLITE_ERROR_SNAPSHOT: c_int = super::SQLITE_ERROR | (3 << 8);
            
            const SQLITE_IOERR_BEGIN_ATOMIC: c_int = super::SQLITE_IOERR | (29 << 8);
            const SQLITE_IOERR_COMMIT_ATOMIC: c_int = super::SQLITE_IOERR | (30 << 8);
            const SQLITE_IOERR_ROLLBACK_ATOMIC: c_int = super::SQLITE_IOERR | (31 << 8);
            const SQLITE_IOERR_DATA: c_int = super::SQLITE_IOERR | (32 << 8);
            const SQLITE_IOERR_CORRUPTFS: c_int = super::SQLITE_IOERR | (33 << 8);
            const SQLITE_IOERR_IN_PAGE: c_int = super::SQLITE_IOERR | (34 << 8);
            
            const SQLITE_LOCKED_VTAB: c_int = super::SQLITE_LOCKED | (2 << 8);
            
            const SQLITE_BUSY_TIMEOUT: c_int = super::SQLITE_BUSY | (3 << 8);
            
            const SQLITE_CANTOPEN_SYMLINK: c_int = super::SQLITE_CANTOPEN | (6 << 8);
            
            const SQLITE_CORRUPT_SEQUENCE: c_int = super::SQLITE_CORRUPT | (2 << 8);
            const SQLITE_CORRUPT_INDEX: c_int = super::SQLITE_CORRUPT | (3 << 8);
            
            const SQLITE_READONLY_CANTINIT: c_int = super::SQLITE_READONLY | (5 << 8);
            const SQLITE_READONLY_DIRECTORY: c_int = super::SQLITE_READONLY | (6 << 8);
            
            const SQLITE_CONSTRAINT_PINNED: c_int = super::SQLITE_CONSTRAINT | (11 << 8);
            const SQLITE_CONSTRAINT_DATATYPE: c_int = super::SQLITE_CONSTRAINT | (12 << 8);
            
            #[must_use]
            pub fn code_to_str(code: c_int) -> &'static str {
                match code {
                    super::SQLITE_OK        => "Successful result",
                    super::SQLITE_ERROR     => "SQL error or missing database",
                    super::SQLITE_INTERNAL  => "Internal logic error in SQLite",
                    super::SQLITE_PERM      => "Access permission denied",
                    super::SQLITE_ABORT     => "Callback routine requested an abort",
                    super::SQLITE_BUSY      => "The database file is locked",
                    super::SQLITE_LOCKED    => "A table in the database is locked",
                    super::SQLITE_NOMEM     => "A malloc() failed",
                    super::SQLITE_READONLY  => "Attempt to write a readonly database",
                    super::SQLITE_INTERRUPT => "Operation terminated by sqlite3_interrupt()",
                    super::SQLITE_IOERR     => "Some kind of disk I/O error occurred",
                    super::SQLITE_CORRUPT   => "The database disk image is malformed",
                    super::SQLITE_NOTFOUND  => "Unknown opcode in sqlite3_file_control()",
                    super::SQLITE_FULL      => "Insertion failed because database is full",
                    super::SQLITE_CANTOPEN  => "Unable to open the database file",
                    super::SQLITE_PROTOCOL  => "Database lock protocol error",
                    super::SQLITE_EMPTY     => "Database is empty",
                    super::SQLITE_SCHEMA    => "The database schema changed",
                    super::SQLITE_TOOBIG    => "String or BLOB exceeds size limit",
                    super::SQLITE_CONSTRAINT=> "Abort due to constraint violation",
                    super::SQLITE_MISMATCH  => "Data type mismatch",
                    super::SQLITE_MISUSE    => "Library used incorrectly",
                    super::SQLITE_NOLFS     => "Uses OS features not supported on host",
                    super::SQLITE_AUTH      => "Authorization denied",
                    super::SQLITE_FORMAT    => "Auxiliary database format error",
                    super::SQLITE_RANGE     => "2nd parameter to sqlite3_bind out of range",
                    super::SQLITE_NOTADB    => "File opened that is not a database file",
                    super::SQLITE_NOTICE    => "Notifications from sqlite3_log()",
                    super::SQLITE_WARNING   => "Warnings from sqlite3_log()",
                    super::SQLITE_ROW       => "sqlite3_step() has another row ready",
                    super::SQLITE_DONE      => "sqlite3_step() has finished executing",
            
                    SQLITE_ERROR_MISSING_COLLSEQ   => "SQLITE_ERROR_MISSING_COLLSEQ",
                    SQLITE_ERROR_RETRY   => "SQLITE_ERROR_RETRY",
                    SQLITE_ERROR_SNAPSHOT   => "SQLITE_ERROR_SNAPSHOT",
            
                    super::SQLITE_IOERR_READ              => "Error reading from disk",
                    super::SQLITE_IOERR_SHORT_READ        => "Unable to obtain number of requested bytes (file truncated?)",
                    super::SQLITE_IOERR_WRITE             => "Error writing to disk",
                    super::SQLITE_IOERR_FSYNC             => "Error flushing data to persistent storage (fsync)",
                    super::SQLITE_IOERR_DIR_FSYNC         => "Error calling fsync on a directory",
                    super::SQLITE_IOERR_TRUNCATE          => "Error attempting to truncate file",
                    super::SQLITE_IOERR_FSTAT             => "Error invoking fstat to get file metadata",
                    super::SQLITE_IOERR_UNLOCK            => "I/O error within xUnlock of a VFS object",
                    super::SQLITE_IOERR_RDLOCK            => "I/O error within xLock of a VFS object (trying to obtain a read lock)",
                    super::SQLITE_IOERR_DELETE            => "I/O error within xDelete of a VFS object",
                    super::SQLITE_IOERR_BLOCKED           => "SQLITE_IOERR_BLOCKED", // no longer used
                    super::SQLITE_IOERR_NOMEM             => "Out of memory in I/O layer",
                    super::SQLITE_IOERR_ACCESS            => "I/O error within xAccess of a VFS object",
                    super::SQLITE_IOERR_CHECKRESERVEDLOCK => "I/O error within then xCheckReservedLock method",
                    super::SQLITE_IOERR_LOCK              => "I/O error in the advisory file locking layer",
                    super::SQLITE_IOERR_CLOSE             => "I/O error within the xClose method",
                    super::SQLITE_IOERR_DIR_CLOSE         => "SQLITE_IOERR_DIR_CLOSE", // no longer used
                    super::SQLITE_IOERR_SHMOPEN           => "I/O error within the xShmMap method (trying to open a new shared-memory segment)",
                    super::SQLITE_IOERR_SHMSIZE           => "I/O error within the xShmMap method (trying to resize an existing shared-memory segment)",
                    super::SQLITE_IOERR_SHMLOCK           => "SQLITE_IOERR_SHMLOCK", // no longer used
                    super::SQLITE_IOERR_SHMMAP            => "I/O error within the xShmMap method (trying to map a shared-memory segment into process address space)",
                    super::SQLITE_IOERR_SEEK              => "I/O error within the xRead or xWrite (trying to seek within a file)",
                    super::SQLITE_IOERR_DELETE_NOENT      => "File being deleted does not exist",
                    super::SQLITE_IOERR_MMAP              => "I/O error while trying to map or unmap part of the database file into process address space",
                    super::SQLITE_IOERR_GETTEMPPATH       => "VFS is unable to determine a suitable directory for temporary files",
                    super::SQLITE_IOERR_CONVPATH          => "cygwin_conv_path() system call failed",
                    super::SQLITE_IOERR_VNODE             => "SQLITE_IOERR_VNODE", // not documented?
                    super::SQLITE_IOERR_AUTH              => "SQLITE_IOERR_AUTH",
                    SQLITE_IOERR_BEGIN_ATOMIC      => "SQLITE_IOERR_BEGIN_ATOMIC",
                    SQLITE_IOERR_COMMIT_ATOMIC     => "SQLITE_IOERR_COMMIT_ATOMIC",
                    SQLITE_IOERR_ROLLBACK_ATOMIC   => "SQLITE_IOERR_ROLLBACK_ATOMIC",
                    SQLITE_IOERR_DATA   => "SQLITE_IOERR_DATA",
                    SQLITE_IOERR_CORRUPTFS   => "SQLITE_IOERR_CORRUPTFS",
                    SQLITE_IOERR_IN_PAGE   => "SQLITE_IOERR_IN_PAGE",
            
                    super::SQLITE_LOCKED_SHAREDCACHE      => "Locking conflict due to another connection with a shared cache",
                    SQLITE_LOCKED_VTAB             => "SQLITE_LOCKED_VTAB",
            
                    super::SQLITE_BUSY_RECOVERY           => "Another process is recovering a WAL mode database file",
                    super::SQLITE_BUSY_SNAPSHOT           => "Cannot promote read transaction to write transaction because of writes by another connection",
                    SQLITE_BUSY_TIMEOUT           => "SQLITE_BUSY_TIMEOUT",
            
                    super::SQLITE_CANTOPEN_NOTEMPDIR      => "SQLITE_CANTOPEN_NOTEMPDIR", // no longer used
                    super::SQLITE_CANTOPEN_ISDIR          => "Attempted to open directory as file",
                    super::SQLITE_CANTOPEN_FULLPATH       => "Unable to convert filename into full pathname",
                    super::SQLITE_CANTOPEN_CONVPATH       => "cygwin_conv_path() system call failed",
                    SQLITE_CANTOPEN_SYMLINK       => "SQLITE_CANTOPEN_SYMLINK",
            
                    super::SQLITE_CORRUPT_VTAB            => "Content in the virtual table is corrupt",
                    SQLITE_CORRUPT_SEQUENCE        => "SQLITE_CORRUPT_SEQUENCE",
                    SQLITE_CORRUPT_INDEX        => "SQLITE_CORRUPT_INDEX",
            
                    super::SQLITE_READONLY_RECOVERY       => "WAL mode database file needs recovery (requires write access)",
                    super::SQLITE_READONLY_CANTLOCK       => "Shared-memory file associated with WAL mode database is read-only",
                    super::SQLITE_READONLY_ROLLBACK       => "Database has hot journal that must be rolled back (requires write access)",
                    super::SQLITE_READONLY_DBMOVED        => "Database cannot be modified because database file has moved",
                    SQLITE_READONLY_CANTINIT       => "SQLITE_READONLY_CANTINIT",
                    SQLITE_READONLY_DIRECTORY      => "SQLITE_READONLY_DIRECTORY",
            
                    super::SQLITE_ABORT_ROLLBACK          => "Transaction was rolled back",
            
                    super::SQLITE_CONSTRAINT_CHECK        => "A CHECK constraint failed",
                    super::SQLITE_CONSTRAINT_COMMITHOOK   => "Commit hook caused rollback",
                    super::SQLITE_CONSTRAINT_FOREIGNKEY   => "Foreign key constraint failed",
                    super::SQLITE_CONSTRAINT_FUNCTION     => "Error returned from extension function",
                    super::SQLITE_CONSTRAINT_NOTNULL      => "A NOT NULL constraint failed",
                    super::SQLITE_CONSTRAINT_PRIMARYKEY   => "A PRIMARY KEY constraint failed",
                    super::SQLITE_CONSTRAINT_TRIGGER      => "A RAISE function within a trigger fired",
                    super::SQLITE_CONSTRAINT_UNIQUE       => "A UNIQUE constraint failed",
                    super::SQLITE_CONSTRAINT_VTAB         => "An application-defined virtual table error occurred",
                    super::SQLITE_CONSTRAINT_ROWID        => "A non-unique rowid occurred",
                    SQLITE_CONSTRAINT_PINNED        => "SQLITE_CONSTRAINT_PINNED",
                    SQLITE_CONSTRAINT_DATATYPE        => "SQLITE_CONSTRAINT_DATATYPE",
            
                    super::SQLITE_NOTICE_RECOVER_WAL      => "A WAL mode database file was recovered",
                    super::SQLITE_NOTICE_RECOVER_ROLLBACK => "Hot journal was rolled back",
            
                    super::SQLITE_WARNING_AUTOINDEX       => "Automatic indexing used - database might benefit from additional indexes",
            
                    super::SQLITE_AUTH_USER               => "SQLITE_AUTH_USER", // not documented?
            
                    _ => "Unknown error code",
                }
            }
            
            /// Loadable extension initialization error
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            #[non_exhaustive]
            pub enum InitError {
                /// Version mismatch between the extension and the SQLite3 library
                VersionMismatch { compile_time: i32, runtime: i32 },
                /// Invalid function pointer in one of sqlite3_api_routines fields
                NullFunctionPointer,
            }
            
            impl ::fmt::Display for InitError {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    match *self {
                        InitError::VersionMismatch {
                            compile_time,
                            runtime,
                        } => {
                            write!(f, "SQLite version mismatch: {runtime} < {compile_time}")
                        }
                        InitError::NullFunctionPointer => {
                            write!(f, "Some sqlite3_api_routines fields are null")
                        }
                    }
                }
            }
            
            impl error::Error for InitError {}
        } pub use self::error::*;
        
        extern "C"
        {
            pub fn sqlite3_auto_extension(
                xEntryPoint: ::option::Option<
                    unsafe extern "C" fn(
                        db: *mut sqlite3,
                        pzErrMsg: *mut *mut ::os::raw::c_char,
                        _: *const sqlite3_api_routines,
                    ) -> ::os::raw::c_int,
                >,
            ) -> ::os::raw::c_int;
        }
        
        extern "C"
        {
            pub fn sqlite3_cancel_auto_extension(
                xEntryPoint: ::option::Option<
                    unsafe extern "C" fn(
                        db: *mut sqlite3,
                        pzErrMsg: *mut *mut ::os::raw::c_char,
                        _: *const sqlite3_api_routines,
                    ) -> ::os::raw::c_int,
                >,
            ) -> ::os::raw::c_int;
        }
        
        pub const SQLITE_VERSION: &[u8; 7] = b"3.46.0\0";
        pub const SQLITE_VERSION_NUMBER: i32 = 3046000;
        pub const SQLITE_SOURCE_ID: &[u8; 85] =
            b"2024-05-23 13:25:27 96c92aba00c8375bc32fafcdf12429c58bd8aabfcadab6683e35bbb9cdebf19e\0";
        pub const SQLITE_OK: i32 = 0;
        pub const SQLITE_ERROR: i32 = 1;
        pub const SQLITE_INTERNAL: i32 = 2;
        pub const SQLITE_PERM: i32 = 3;
        pub const SQLITE_ABORT: i32 = 4;
        pub const SQLITE_BUSY: i32 = 5;
        pub const SQLITE_LOCKED: i32 = 6;
        pub const SQLITE_NOMEM: i32 = 7;
        pub const SQLITE_READONLY: i32 = 8;
        pub const SQLITE_INTERRUPT: i32 = 9;
        pub const SQLITE_IOERR: i32 = 10;
        pub const SQLITE_CORRUPT: i32 = 11;
        pub const SQLITE_NOTFOUND: i32 = 12;
        pub const SQLITE_FULL: i32 = 13;
        pub const SQLITE_CANTOPEN: i32 = 14;
        pub const SQLITE_PROTOCOL: i32 = 15;
        pub const SQLITE_EMPTY: i32 = 16;
        pub const SQLITE_SCHEMA: i32 = 17;
        pub const SQLITE_TOOBIG: i32 = 18;
        pub const SQLITE_CONSTRAINT: i32 = 19;
        pub const SQLITE_MISMATCH: i32 = 20;
        pub const SQLITE_MISUSE: i32 = 21;
        pub const SQLITE_NOLFS: i32 = 22;
        pub const SQLITE_AUTH: i32 = 23;
        pub const SQLITE_FORMAT: i32 = 24;
        pub const SQLITE_RANGE: i32 = 25;
        pub const SQLITE_NOTADB: i32 = 26;
        pub const SQLITE_NOTICE: i32 = 27;
        pub const SQLITE_WARNING: i32 = 28;
        pub const SQLITE_ROW: i32 = 100;
        pub const SQLITE_DONE: i32 = 101;
        pub const SQLITE_ERROR_MISSING_COLLSEQ: i32 = 257;
        pub const SQLITE_ERROR_RETRY: i32 = 513;
        pub const SQLITE_ERROR_SNAPSHOT: i32 = 769;
        pub const SQLITE_IOERR_READ: i32 = 266;
        pub const SQLITE_IOERR_SHORT_READ: i32 = 522;
        pub const SQLITE_IOERR_WRITE: i32 = 778;
        pub const SQLITE_IOERR_FSYNC: i32 = 1034;
        pub const SQLITE_IOERR_DIR_FSYNC: i32 = 1290;
        pub const SQLITE_IOERR_TRUNCATE: i32 = 1546;
        pub const SQLITE_IOERR_FSTAT: i32 = 1802;
        pub const SQLITE_IOERR_UNLOCK: i32 = 2058;
        pub const SQLITE_IOERR_RDLOCK: i32 = 2314;
        pub const SQLITE_IOERR_DELETE: i32 = 2570;
        pub const SQLITE_IOERR_BLOCKED: i32 = 2826;
        pub const SQLITE_IOERR_NOMEM: i32 = 3082;
        pub const SQLITE_IOERR_ACCESS: i32 = 3338;
        pub const SQLITE_IOERR_CHECKRESERVEDLOCK: i32 = 3594;
        pub const SQLITE_IOERR_LOCK: i32 = 3850;
        pub const SQLITE_IOERR_CLOSE: i32 = 4106;
        pub const SQLITE_IOERR_DIR_CLOSE: i32 = 4362;
        pub const SQLITE_IOERR_SHMOPEN: i32 = 4618;
        pub const SQLITE_IOERR_SHMSIZE: i32 = 4874;
        pub const SQLITE_IOERR_SHMLOCK: i32 = 5130;
        pub const SQLITE_IOERR_SHMMAP: i32 = 5386;
        pub const SQLITE_IOERR_SEEK: i32 = 5642;
        pub const SQLITE_IOERR_DELETE_NOENT: i32 = 5898;
        pub const SQLITE_IOERR_MMAP: i32 = 6154;
        pub const SQLITE_IOERR_GETTEMPPATH: i32 = 6410;
        pub const SQLITE_IOERR_CONVPATH: i32 = 6666;
        pub const SQLITE_IOERR_VNODE: i32 = 6922;
        pub const SQLITE_IOERR_AUTH: i32 = 7178;
        pub const SQLITE_IOERR_BEGIN_ATOMIC: i32 = 7434;
        pub const SQLITE_IOERR_COMMIT_ATOMIC: i32 = 7690;
        pub const SQLITE_IOERR_ROLLBACK_ATOMIC: i32 = 7946;
        pub const SQLITE_IOERR_DATA: i32 = 8202;
        pub const SQLITE_IOERR_CORRUPTFS: i32 = 8458;
        pub const SQLITE_IOERR_IN_PAGE: i32 = 8714;
        pub const SQLITE_LOCKED_SHAREDCACHE: i32 = 262;
        pub const SQLITE_LOCKED_VTAB: i32 = 518;
        pub const SQLITE_BUSY_RECOVERY: i32 = 261;
        pub const SQLITE_BUSY_SNAPSHOT: i32 = 517;
        pub const SQLITE_BUSY_TIMEOUT: i32 = 773;
        pub const SQLITE_CANTOPEN_NOTEMPDIR: i32 = 270;
        pub const SQLITE_CANTOPEN_ISDIR: i32 = 526;
        pub const SQLITE_CANTOPEN_FULLPATH: i32 = 782;
        pub const SQLITE_CANTOPEN_CONVPATH: i32 = 1038;
        pub const SQLITE_CANTOPEN_DIRTYWAL: i32 = 1294;
        pub const SQLITE_CANTOPEN_SYMLINK: i32 = 1550;
        pub const SQLITE_CORRUPT_VTAB: i32 = 267;
        pub const SQLITE_CORRUPT_SEQUENCE: i32 = 523;
        pub const SQLITE_CORRUPT_INDEX: i32 = 779;
        pub const SQLITE_READONLY_RECOVERY: i32 = 264;
        pub const SQLITE_READONLY_CANTLOCK: i32 = 520;
        pub const SQLITE_READONLY_ROLLBACK: i32 = 776;
        pub const SQLITE_READONLY_DBMOVED: i32 = 1032;
        pub const SQLITE_READONLY_CANTINIT: i32 = 1288;
        pub const SQLITE_READONLY_DIRECTORY: i32 = 1544;
        pub const SQLITE_ABORT_ROLLBACK: i32 = 516;
        pub const SQLITE_CONSTRAINT_CHECK: i32 = 275;
        pub const SQLITE_CONSTRAINT_COMMITHOOK: i32 = 531;
        pub const SQLITE_CONSTRAINT_FOREIGNKEY: i32 = 787;
        pub const SQLITE_CONSTRAINT_FUNCTION: i32 = 1043;
        pub const SQLITE_CONSTRAINT_NOTNULL: i32 = 1299;
        pub const SQLITE_CONSTRAINT_PRIMARYKEY: i32 = 1555;
        pub const SQLITE_CONSTRAINT_TRIGGER: i32 = 1811;
        pub const SQLITE_CONSTRAINT_UNIQUE: i32 = 2067;
        pub const SQLITE_CONSTRAINT_VTAB: i32 = 2323;
        pub const SQLITE_CONSTRAINT_ROWID: i32 = 2579;
        pub const SQLITE_CONSTRAINT_PINNED: i32 = 2835;
        pub const SQLITE_CONSTRAINT_DATATYPE: i32 = 3091;
        pub const SQLITE_NOTICE_RECOVER_WAL: i32 = 283;
        pub const SQLITE_NOTICE_RECOVER_ROLLBACK: i32 = 539;
        pub const SQLITE_NOTICE_RBU: i32 = 795;
        pub const SQLITE_WARNING_AUTOINDEX: i32 = 284;
        pub const SQLITE_AUTH_USER: i32 = 279;
        pub const SQLITE_OK_LOAD_PERMANENTLY: i32 = 256;
        pub const SQLITE_OK_SYMLINK: i32 = 512;
        pub const SQLITE_OPEN_READONLY: i32 = 1;
        pub const SQLITE_OPEN_READWRITE: i32 = 2;
        pub const SQLITE_OPEN_CREATE: i32 = 4;
        pub const SQLITE_OPEN_DELETEONCLOSE: i32 = 8;
        pub const SQLITE_OPEN_EXCLUSIVE: i32 = 16;
        pub const SQLITE_OPEN_AUTOPROXY: i32 = 32;
        pub const SQLITE_OPEN_URI: i32 = 64;
        pub const SQLITE_OPEN_MEMORY: i32 = 128;
        pub const SQLITE_OPEN_MAIN_DB: i32 = 256;
        pub const SQLITE_OPEN_TEMP_DB: i32 = 512;
        pub const SQLITE_OPEN_TRANSIENT_DB: i32 = 1024;
        pub const SQLITE_OPEN_MAIN_JOURNAL: i32 = 2048;
        pub const SQLITE_OPEN_TEMP_JOURNAL: i32 = 4096;
        pub const SQLITE_OPEN_SUBJOURNAL: i32 = 8192;
        pub const SQLITE_OPEN_SUPER_JOURNAL: i32 = 16384;
        pub const SQLITE_OPEN_NOMUTEX: i32 = 32768;
        pub const SQLITE_OPEN_FULLMUTEX: i32 = 65536;
        pub const SQLITE_OPEN_SHAREDCACHE: i32 = 131072;
        pub const SQLITE_OPEN_PRIVATECACHE: i32 = 262144;
        pub const SQLITE_OPEN_WAL: i32 = 524288;
        pub const SQLITE_OPEN_NOFOLLOW: i32 = 16777216;
        pub const SQLITE_OPEN_EXRESCODE: i32 = 33554432;
        pub const SQLITE_OPEN_MASTER_JOURNAL: i32 = 16384;
        pub const SQLITE_IOCAP_ATOMIC: i32 = 1;
        pub const SQLITE_IOCAP_ATOMIC512: i32 = 2;
        pub const SQLITE_IOCAP_ATOMIC1K: i32 = 4;
        pub const SQLITE_IOCAP_ATOMIC2K: i32 = 8;
        pub const SQLITE_IOCAP_ATOMIC4K: i32 = 16;
        pub const SQLITE_IOCAP_ATOMIC8K: i32 = 32;
        pub const SQLITE_IOCAP_ATOMIC16K: i32 = 64;
        pub const SQLITE_IOCAP_ATOMIC32K: i32 = 128;
        pub const SQLITE_IOCAP_ATOMIC64K: i32 = 256;
        pub const SQLITE_IOCAP_SAFE_APPEND: i32 = 512;
        pub const SQLITE_IOCAP_SEQUENTIAL: i32 = 1024;
        pub const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN: i32 = 2048;
        pub const SQLITE_IOCAP_POWERSAFE_OVERWRITE: i32 = 4096;
        pub const SQLITE_IOCAP_IMMUTABLE: i32 = 8192;
        pub const SQLITE_IOCAP_BATCH_ATOMIC: i32 = 16384;
        pub const SQLITE_LOCK_NONE: i32 = 0;
        pub const SQLITE_LOCK_SHARED: i32 = 1;
        pub const SQLITE_LOCK_RESERVED: i32 = 2;
        pub const SQLITE_LOCK_PENDING: i32 = 3;
        pub const SQLITE_LOCK_EXCLUSIVE: i32 = 4;
        pub const SQLITE_SYNC_NORMAL: i32 = 2;
        pub const SQLITE_SYNC_FULL: i32 = 3;
        pub const SQLITE_SYNC_DATAONLY: i32 = 16;
        pub const SQLITE_FCNTL_LOCKSTATE: i32 = 1;
        pub const SQLITE_FCNTL_GET_LOCKPROXYFILE: i32 = 2;
        pub const SQLITE_FCNTL_SET_LOCKPROXYFILE: i32 = 3;
        pub const SQLITE_FCNTL_LAST_ERRNO: i32 = 4;
        pub const SQLITE_FCNTL_SIZE_HINT: i32 = 5;
        pub const SQLITE_FCNTL_CHUNK_SIZE: i32 = 6;
        pub const SQLITE_FCNTL_FILE_POINTER: i32 = 7;
        pub const SQLITE_FCNTL_SYNC_OMITTED: i32 = 8;
        pub const SQLITE_FCNTL_WIN32_AV_RETRY: i32 = 9;
        pub const SQLITE_FCNTL_PERSIST_WAL: i32 = 10;
        pub const SQLITE_FCNTL_OVERWRITE: i32 = 11;
        pub const SQLITE_FCNTL_VFSNAME: i32 = 12;
        pub const SQLITE_FCNTL_POWERSAFE_OVERWRITE: i32 = 13;
        pub const SQLITE_FCNTL_PRAGMA: i32 = 14;
        pub const SQLITE_FCNTL_BUSYHANDLER: i32 = 15;
        pub const SQLITE_FCNTL_TEMPFILENAME: i32 = 16;
        pub const SQLITE_FCNTL_MMAP_SIZE: i32 = 18;
        pub const SQLITE_FCNTL_TRACE: i32 = 19;
        pub const SQLITE_FCNTL_HAS_MOVED: i32 = 20;
        pub const SQLITE_FCNTL_SYNC: i32 = 21;
        pub const SQLITE_FCNTL_COMMIT_PHASETWO: i32 = 22;
        pub const SQLITE_FCNTL_WIN32_SET_HANDLE: i32 = 23;
        pub const SQLITE_FCNTL_WAL_BLOCK: i32 = 24;
        pub const SQLITE_FCNTL_ZIPVFS: i32 = 25;
        pub const SQLITE_FCNTL_RBU: i32 = 26;
        pub const SQLITE_FCNTL_VFS_POINTER: i32 = 27;
        pub const SQLITE_FCNTL_JOURNAL_POINTER: i32 = 28;
        pub const SQLITE_FCNTL_WIN32_GET_HANDLE: i32 = 29;
        pub const SQLITE_FCNTL_PDB: i32 = 30;
        pub const SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: i32 = 31;
        pub const SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: i32 = 32;
        pub const SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: i32 = 33;
        pub const SQLITE_FCNTL_LOCK_TIMEOUT: i32 = 34;
        pub const SQLITE_FCNTL_DATA_VERSION: i32 = 35;
        pub const SQLITE_FCNTL_SIZE_LIMIT: i32 = 36;
        pub const SQLITE_FCNTL_CKPT_DONE: i32 = 37;
        pub const SQLITE_FCNTL_RESERVE_BYTES: i32 = 38;
        pub const SQLITE_FCNTL_CKPT_START: i32 = 39;
        pub const SQLITE_FCNTL_EXTERNAL_READER: i32 = 40;
        pub const SQLITE_FCNTL_CKSM_FILE: i32 = 41;
        pub const SQLITE_FCNTL_RESET_CACHE: i32 = 42;
        pub const SQLITE_GET_LOCKPROXYFILE: i32 = 2;
        pub const SQLITE_SET_LOCKPROXYFILE: i32 = 3;
        pub const SQLITE_LAST_ERRNO: i32 = 4;
        pub const SQLITE_ACCESS_EXISTS: i32 = 0;
        pub const SQLITE_ACCESS_READWRITE: i32 = 1;
        pub const SQLITE_ACCESS_READ: i32 = 2;
        pub const SQLITE_SHM_UNLOCK: i32 = 1;
        pub const SQLITE_SHM_LOCK: i32 = 2;
        pub const SQLITE_SHM_SHARED: i32 = 4;
        pub const SQLITE_SHM_EXCLUSIVE: i32 = 8;
        pub const SQLITE_SHM_NLOCK: i32 = 8;
        pub const SQLITE_CONFIG_SINGLETHREAD: i32 = 1;
        pub const SQLITE_CONFIG_MULTITHREAD: i32 = 2;
        pub const SQLITE_CONFIG_SERIALIZED: i32 = 3;
        pub const SQLITE_CONFIG_MALLOC: i32 = 4;
        pub const SQLITE_CONFIG_GETMALLOC: i32 = 5;
        pub const SQLITE_CONFIG_SCRATCH: i32 = 6;
        pub const SQLITE_CONFIG_PAGECACHE: i32 = 7;
        pub const SQLITE_CONFIG_HEAP: i32 = 8;
        pub const SQLITE_CONFIG_MEMSTATUS: i32 = 9;
        pub const SQLITE_CONFIG_MUTEX: i32 = 10;
        pub const SQLITE_CONFIG_GETMUTEX: i32 = 11;
        pub const SQLITE_CONFIG_LOOKASIDE: i32 = 13;
        pub const SQLITE_CONFIG_PCACHE: i32 = 14;
        pub const SQLITE_CONFIG_GETPCACHE: i32 = 15;
        pub const SQLITE_CONFIG_LOG: i32 = 16;
        pub const SQLITE_CONFIG_URI: i32 = 17;
        pub const SQLITE_CONFIG_PCACHE2: i32 = 18;
        pub const SQLITE_CONFIG_GETPCACHE2: i32 = 19;
        pub const SQLITE_CONFIG_COVERING_INDEX_SCAN: i32 = 20;
        pub const SQLITE_CONFIG_SQLLOG: i32 = 21;
        pub const SQLITE_CONFIG_MMAP_SIZE: i32 = 22;
        pub const SQLITE_CONFIG_WIN32_HEAPSIZE: i32 = 23;
        pub const SQLITE_CONFIG_PCACHE_HDRSZ: i32 = 24;
        pub const SQLITE_CONFIG_PMASZ: i32 = 25;
        pub const SQLITE_CONFIG_STMTJRNL_SPILL: i32 = 26;
        pub const SQLITE_CONFIG_SMALL_MALLOC: i32 = 27;
        pub const SQLITE_CONFIG_SORTERREF_SIZE: i32 = 28;
        pub const SQLITE_CONFIG_MEMDB_MAXSIZE: i32 = 29;
        pub const SQLITE_CONFIG_ROWID_IN_VIEW: i32 = 30;
        pub const SQLITE_DBCONFIG_MAINDBNAME: i32 = 1000;
        pub const SQLITE_DBCONFIG_LOOKASIDE: i32 = 1001;
        pub const SQLITE_DBCONFIG_ENABLE_FKEY: i32 = 1002;
        pub const SQLITE_DBCONFIG_ENABLE_TRIGGER: i32 = 1003;
        pub const SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER: i32 = 1004;
        pub const SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION: i32 = 1005;
        pub const SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE: i32 = 1006;
        pub const SQLITE_DBCONFIG_ENABLE_QPSG: i32 = 1007;
        pub const SQLITE_DBCONFIG_TRIGGER_EQP: i32 = 1008;
        pub const SQLITE_DBCONFIG_RESET_DATABASE: i32 = 1009;
        pub const SQLITE_DBCONFIG_DEFENSIVE: i32 = 1010;
        pub const SQLITE_DBCONFIG_WRITABLE_SCHEMA: i32 = 1011;
        pub const SQLITE_DBCONFIG_LEGACY_ALTER_TABLE: i32 = 1012;
        pub const SQLITE_DBCONFIG_DQS_DML: i32 = 1013;
        pub const SQLITE_DBCONFIG_DQS_DDL: i32 = 1014;
        pub const SQLITE_DBCONFIG_ENABLE_VIEW: i32 = 1015;
        pub const SQLITE_DBCONFIG_LEGACY_FILE_FORMAT: i32 = 1016;
        pub const SQLITE_DBCONFIG_TRUSTED_SCHEMA: i32 = 1017;
        pub const SQLITE_DBCONFIG_STMT_SCANSTATUS: i32 = 1018;
        pub const SQLITE_DBCONFIG_REVERSE_SCANORDER: i32 = 1019;
        pub const SQLITE_DBCONFIG_MAX: i32 = 1019;
        pub const SQLITE_DENY: i32 = 1;
        pub const SQLITE_IGNORE: i32 = 2;
        pub const SQLITE_CREATE_INDEX: i32 = 1;
        pub const SQLITE_CREATE_TABLE: i32 = 2;
        pub const SQLITE_CREATE_TEMP_INDEX: i32 = 3;
        pub const SQLITE_CREATE_TEMP_TABLE: i32 = 4;
        pub const SQLITE_CREATE_TEMP_TRIGGER: i32 = 5;
        pub const SQLITE_CREATE_TEMP_VIEW: i32 = 6;
        pub const SQLITE_CREATE_TRIGGER: i32 = 7;
        pub const SQLITE_CREATE_VIEW: i32 = 8;
        pub const SQLITE_DELETE: i32 = 9;
        pub const SQLITE_DROP_INDEX: i32 = 10;
        pub const SQLITE_DROP_TABLE: i32 = 11;
        pub const SQLITE_DROP_TEMP_INDEX: i32 = 12;
        pub const SQLITE_DROP_TEMP_TABLE: i32 = 13;
        pub const SQLITE_DROP_TEMP_TRIGGER: i32 = 14;
        pub const SQLITE_DROP_TEMP_VIEW: i32 = 15;
        pub const SQLITE_DROP_TRIGGER: i32 = 16;
        pub const SQLITE_DROP_VIEW: i32 = 17;
        pub const SQLITE_INSERT: i32 = 18;
        pub const SQLITE_PRAGMA: i32 = 19;
        pub const SQLITE_READ: i32 = 20;
        pub const SQLITE_SELECT: i32 = 21;
        pub const SQLITE_TRANSACTION: i32 = 22;
        pub const SQLITE_UPDATE: i32 = 23;
        pub const SQLITE_ATTACH: i32 = 24;
        pub const SQLITE_DETACH: i32 = 25;
        pub const SQLITE_ALTER_TABLE: i32 = 26;
        pub const SQLITE_REINDEX: i32 = 27;
        pub const SQLITE_ANALYZE: i32 = 28;
        pub const SQLITE_CREATE_VTABLE: i32 = 29;
        pub const SQLITE_DROP_VTABLE: i32 = 30;
        pub const SQLITE_FUNCTION: i32 = 31;
        pub const SQLITE_SAVEPOINT: i32 = 32;
        pub const SQLITE_COPY: i32 = 0;
        pub const SQLITE_RECURSIVE: i32 = 33;
        pub const SQLITE_TRACE_STMT: i32 = 1;
        pub const SQLITE_TRACE_PROFILE: i32 = 2;
        pub const SQLITE_TRACE_ROW: i32 = 4;
        pub const SQLITE_TRACE_CLOSE: i32 = 8;
        pub const SQLITE_LIMIT_LENGTH: i32 = 0;
        pub const SQLITE_LIMIT_SQL_LENGTH: i32 = 1;
        pub const SQLITE_LIMIT_COLUMN: i32 = 2;
        pub const SQLITE_LIMIT_EXPR_DEPTH: i32 = 3;
        pub const SQLITE_LIMIT_COMPOUND_SELECT: i32 = 4;
        pub const SQLITE_LIMIT_VDBE_OP: i32 = 5;
        pub const SQLITE_LIMIT_FUNCTION_ARG: i32 = 6;
        pub const SQLITE_LIMIT_ATTACHED: i32 = 7;
        pub const SQLITE_LIMIT_LIKE_PATTERN_LENGTH: i32 = 8;
        pub const SQLITE_LIMIT_VARIABLE_NUMBER: i32 = 9;
        pub const SQLITE_LIMIT_TRIGGER_DEPTH: i32 = 10;
        pub const SQLITE_LIMIT_WORKER_THREADS: i32 = 11;
        pub const SQLITE_PREPARE_PERSISTENT: ::os::raw::c_uint = 1;
        pub const SQLITE_PREPARE_NORMALIZE: ::os::raw::c_uint = 2;
        pub const SQLITE_PREPARE_NO_VTAB: ::os::raw::c_uint = 4;
        pub const SQLITE_INTEGER: i32 = 1;
        pub const SQLITE_FLOAT: i32 = 2;
        pub const SQLITE_BLOB: i32 = 4;
        pub const SQLITE_NULL: i32 = 5;
        pub const SQLITE_TEXT: i32 = 3;
        pub const SQLITE3_TEXT: i32 = 3;
        pub const SQLITE_UTF8: i32 = 1;
        pub const SQLITE_UTF16LE: i32 = 2;
        pub const SQLITE_UTF16BE: i32 = 3;
        pub const SQLITE_UTF16: i32 = 4;
        pub const SQLITE_ANY: i32 = 5;
        pub const SQLITE_UTF16_ALIGNED: i32 = 8;
        pub const SQLITE_DETERMINISTIC: i32 = 2048;
        pub const SQLITE_DIRECTONLY: i32 = 524288;
        pub const SQLITE_SUBTYPE: i32 = 1048576;
        pub const SQLITE_INNOCUOUS: i32 = 2097152;
        pub const SQLITE_RESULT_SUBTYPE: i32 = 16777216;
        pub const SQLITE_WIN32_DATA_DIRECTORY_TYPE: i32 = 1;
        pub const SQLITE_WIN32_TEMP_DIRECTORY_TYPE: i32 = 2;
        pub const SQLITE_TXN_NONE: i32 = 0;
        pub const SQLITE_TXN_READ: i32 = 1;
        pub const SQLITE_TXN_WRITE: i32 = 2;
        pub const SQLITE_INDEX_SCAN_UNIQUE: i32 = 1;
        pub const SQLITE_INDEX_CONSTRAINT_EQ: i32 = 2;
        pub const SQLITE_INDEX_CONSTRAINT_GT: i32 = 4;
        pub const SQLITE_INDEX_CONSTRAINT_LE: i32 = 8;
        pub const SQLITE_INDEX_CONSTRAINT_LT: i32 = 16;
        pub const SQLITE_INDEX_CONSTRAINT_GE: i32 = 32;
        pub const SQLITE_INDEX_CONSTRAINT_MATCH: i32 = 64;
        pub const SQLITE_INDEX_CONSTRAINT_LIKE: i32 = 65;
        pub const SQLITE_INDEX_CONSTRAINT_GLOB: i32 = 66;
        pub const SQLITE_INDEX_CONSTRAINT_REGEXP: i32 = 67;
        pub const SQLITE_INDEX_CONSTRAINT_NE: i32 = 68;
        pub const SQLITE_INDEX_CONSTRAINT_ISNOT: i32 = 69;
        pub const SQLITE_INDEX_CONSTRAINT_ISNOTNULL: i32 = 70;
        pub const SQLITE_INDEX_CONSTRAINT_ISNULL: i32 = 71;
        pub const SQLITE_INDEX_CONSTRAINT_IS: i32 = 72;
        pub const SQLITE_INDEX_CONSTRAINT_LIMIT: i32 = 73;
        pub const SQLITE_INDEX_CONSTRAINT_OFFSET: i32 = 74;
        pub const SQLITE_INDEX_CONSTRAINT_FUNCTION: i32 = 150;
        pub const SQLITE_MUTEX_FAST: i32 = 0;
        pub const SQLITE_MUTEX_RECURSIVE: i32 = 1;
        pub const SQLITE_MUTEX_STATIC_MAIN: i32 = 2;
        pub const SQLITE_MUTEX_STATIC_MEM: i32 = 3;
        pub const SQLITE_MUTEX_STATIC_MEM2: i32 = 4;
        pub const SQLITE_MUTEX_STATIC_OPEN: i32 = 4;
        pub const SQLITE_MUTEX_STATIC_PRNG: i32 = 5;
        pub const SQLITE_MUTEX_STATIC_LRU: i32 = 6;
        pub const SQLITE_MUTEX_STATIC_LRU2: i32 = 7;
        pub const SQLITE_MUTEX_STATIC_PMEM: i32 = 7;
        pub const SQLITE_MUTEX_STATIC_APP1: i32 = 8;
        pub const SQLITE_MUTEX_STATIC_APP2: i32 = 9;
        pub const SQLITE_MUTEX_STATIC_APP3: i32 = 10;
        pub const SQLITE_MUTEX_STATIC_VFS1: i32 = 11;
        pub const SQLITE_MUTEX_STATIC_VFS2: i32 = 12;
        pub const SQLITE_MUTEX_STATIC_VFS3: i32 = 13;
        pub const SQLITE_MUTEX_STATIC_MASTER: i32 = 2;
        pub const SQLITE_TESTCTRL_FIRST: i32 = 5;
        pub const SQLITE_TESTCTRL_PRNG_SAVE: i32 = 5;
        pub const SQLITE_TESTCTRL_PRNG_RESTORE: i32 = 6;
        pub const SQLITE_TESTCTRL_PRNG_RESET: i32 = 7;
        pub const SQLITE_TESTCTRL_FK_NO_ACTION: i32 = 7;
        pub const SQLITE_TESTCTRL_BITVEC_TEST: i32 = 8;
        pub const SQLITE_TESTCTRL_FAULT_INSTALL: i32 = 9;
        pub const SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: i32 = 10;
        pub const SQLITE_TESTCTRL_PENDING_BYTE: i32 = 11;
        pub const SQLITE_TESTCTRL_ASSERT: i32 = 12;
        pub const SQLITE_TESTCTRL_ALWAYS: i32 = 13;
        pub const SQLITE_TESTCTRL_RESERVE: i32 = 14;
        pub const SQLITE_TESTCTRL_JSON_SELFCHECK: i32 = 14;
        pub const SQLITE_TESTCTRL_OPTIMIZATIONS: i32 = 15;
        pub const SQLITE_TESTCTRL_ISKEYWORD: i32 = 16;
        pub const SQLITE_TESTCTRL_SCRATCHMALLOC: i32 = 17;
        pub const SQLITE_TESTCTRL_INTERNAL_FUNCTIONS: i32 = 17;
        pub const SQLITE_TESTCTRL_LOCALTIME_FAULT: i32 = 18;
        pub const SQLITE_TESTCTRL_EXPLAIN_STMT: i32 = 19;
        pub const SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD: i32 = 19;
        pub const SQLITE_TESTCTRL_NEVER_CORRUPT: i32 = 20;
        pub const SQLITE_TESTCTRL_VDBE_COVERAGE: i32 = 21;
        pub const SQLITE_TESTCTRL_BYTEORDER: i32 = 22;
        pub const SQLITE_TESTCTRL_ISINIT: i32 = 23;
        pub const SQLITE_TESTCTRL_SORTER_MMAP: i32 = 24;
        pub const SQLITE_TESTCTRL_IMPOSTER: i32 = 25;
        pub const SQLITE_TESTCTRL_PARSER_COVERAGE: i32 = 26;
        pub const SQLITE_TESTCTRL_RESULT_INTREAL: i32 = 27;
        pub const SQLITE_TESTCTRL_PRNG_SEED: i32 = 28;
        pub const SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS: i32 = 29;
        pub const SQLITE_TESTCTRL_SEEK_COUNT: i32 = 30;
        pub const SQLITE_TESTCTRL_TRACEFLAGS: i32 = 31;
        pub const SQLITE_TESTCTRL_TUNE: i32 = 32;
        pub const SQLITE_TESTCTRL_LOGEST: i32 = 33;
        pub const SQLITE_TESTCTRL_USELONGDOUBLE: i32 = 34;
        pub const SQLITE_TESTCTRL_LAST: i32 = 34;
        pub const SQLITE_STATUS_MEMORY_USED: i32 = 0;
        pub const SQLITE_STATUS_PAGECACHE_USED: i32 = 1;
        pub const SQLITE_STATUS_PAGECACHE_OVERFLOW: i32 = 2;
        pub const SQLITE_STATUS_SCRATCH_USED: i32 = 3;
        pub const SQLITE_STATUS_SCRATCH_OVERFLOW: i32 = 4;
        pub const SQLITE_STATUS_MALLOC_SIZE: i32 = 5;
        pub const SQLITE_STATUS_PARSER_STACK: i32 = 6;
        pub const SQLITE_STATUS_PAGECACHE_SIZE: i32 = 7;
        pub const SQLITE_STATUS_SCRATCH_SIZE: i32 = 8;
        pub const SQLITE_STATUS_MALLOC_COUNT: i32 = 9;
        pub const SQLITE_DBSTATUS_LOOKASIDE_USED: i32 = 0;
        pub const SQLITE_DBSTATUS_CACHE_USED: i32 = 1;
        pub const SQLITE_DBSTATUS_SCHEMA_USED: i32 = 2;
        pub const SQLITE_DBSTATUS_STMT_USED: i32 = 3;
        pub const SQLITE_DBSTATUS_LOOKASIDE_HIT: i32 = 4;
        pub const SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE: i32 = 5;
        pub const SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: i32 = 6;
        pub const SQLITE_DBSTATUS_CACHE_HIT: i32 = 7;
        pub const SQLITE_DBSTATUS_CACHE_MISS: i32 = 8;
        pub const SQLITE_DBSTATUS_CACHE_WRITE: i32 = 9;
        pub const SQLITE_DBSTATUS_DEFERRED_FKS: i32 = 10;
        pub const SQLITE_DBSTATUS_CACHE_USED_SHARED: i32 = 11;
        pub const SQLITE_DBSTATUS_CACHE_SPILL: i32 = 12;
        pub const SQLITE_DBSTATUS_MAX: i32 = 12;
        pub const SQLITE_STMTSTATUS_FULLSCAN_STEP: i32 = 1;
        pub const SQLITE_STMTSTATUS_SORT: i32 = 2;
        pub const SQLITE_STMTSTATUS_AUTOINDEX: i32 = 3;
        pub const SQLITE_STMTSTATUS_VM_STEP: i32 = 4;
        pub const SQLITE_STMTSTATUS_REPREPARE: i32 = 5;
        pub const SQLITE_STMTSTATUS_RUN: i32 = 6;
        pub const SQLITE_STMTSTATUS_FILTER_MISS: i32 = 7;
        pub const SQLITE_STMTSTATUS_FILTER_HIT: i32 = 8;
        pub const SQLITE_STMTSTATUS_MEMUSED: i32 = 99;
        pub const SQLITE_CHECKPOINT_PASSIVE: i32 = 0;
        pub const SQLITE_CHECKPOINT_FULL: i32 = 1;
        pub const SQLITE_CHECKPOINT_RESTART: i32 = 2;
        pub const SQLITE_CHECKPOINT_TRUNCATE: i32 = 3;
        pub const SQLITE_VTAB_CONSTRAINT_SUPPORT: i32 = 1;
        pub const SQLITE_VTAB_INNOCUOUS: i32 = 2;
        pub const SQLITE_VTAB_DIRECTONLY: i32 = 3;
        pub const SQLITE_VTAB_USES_ALL_SCHEMAS: i32 = 4;
        pub const SQLITE_ROLLBACK: i32 = 1;
        pub const SQLITE_FAIL: i32 = 3;
        pub const SQLITE_REPLACE: i32 = 5;
        pub const SQLITE_SCANSTAT_NLOOP: i32 = 0;
        pub const SQLITE_SCANSTAT_NVISIT: i32 = 1;
        pub const SQLITE_SCANSTAT_EST: i32 = 2;
        pub const SQLITE_SCANSTAT_NAME: i32 = 3;
        pub const SQLITE_SCANSTAT_EXPLAIN: i32 = 4;
        pub const SQLITE_SCANSTAT_SELECTID: i32 = 5;
        pub const SQLITE_SCANSTAT_PARENTID: i32 = 6;
        pub const SQLITE_SCANSTAT_NCYCLE: i32 = 7;
        pub const SQLITE_SCANSTAT_COMPLEX: i32 = 1;
        pub const SQLITE_SERIALIZE_NOCOPY: ::os::raw::c_uint = 1;
        pub const SQLITE_DESERIALIZE_FREEONCLOSE: ::os::raw::c_uint = 1;
        pub const SQLITE_DESERIALIZE_RESIZEABLE: ::os::raw::c_uint = 2;
        pub const SQLITE_DESERIALIZE_READONLY: ::os::raw::c_uint = 4;
        pub const NOT_WITHIN: i32 = 0;
        pub const PARTLY_WITHIN: i32 = 1;
        pub const FULLY_WITHIN: i32 = 2;
        pub const SQLITE_SESSION_OBJCONFIG_SIZE: i32 = 1;
        pub const SQLITE_SESSION_OBJCONFIG_ROWID: i32 = 2;
        pub const SQLITE_CHANGESETSTART_INVERT: i32 = 2;
        pub const SQLITE_CHANGESETAPPLY_NOSAVEPOINT: i32 = 1;
        pub const SQLITE_CHANGESETAPPLY_INVERT: i32 = 2;
        pub const SQLITE_CHANGESETAPPLY_IGNORENOOP: i32 = 4;
        pub const SQLITE_CHANGESETAPPLY_FKNOACTION: i32 = 8;
        pub const SQLITE_CHANGESET_DATA: i32 = 1;
        pub const SQLITE_CHANGESET_NOTFOUND: i32 = 2;
        pub const SQLITE_CHANGESET_CONFLICT: i32 = 3;
        pub const SQLITE_CHANGESET_CONSTRAINT: i32 = 4;
        pub const SQLITE_CHANGESET_FOREIGN_KEY: i32 = 5;
        pub const SQLITE_CHANGESET_OMIT: i32 = 0;
        pub const SQLITE_CHANGESET_REPLACE: i32 = 1;
        pub const SQLITE_CHANGESET_ABORT: i32 = 2;
        pub const SQLITE_SESSION_CONFIG_STRMSIZE: i32 = 1;
        pub const FTS5_TOKENIZE_QUERY: i32 = 1;
        pub const FTS5_TOKENIZE_PREFIX: i32 = 2;
        pub const FTS5_TOKENIZE_DOCUMENT: i32 = 4;
        pub const FTS5_TOKENIZE_AUX: i32 = 8;
        pub const FTS5_TOKEN_COLOCATED: i32 = 1;
        extern "C" {
            pub static sqlite3_version: [:: ::os::raw::c_char; 0usize];
        }
        extern "C" {
            pub fn sqlite3_libversion() -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_sourceid() -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_libversion_number() -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_compileoption_used(
                zOptName: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_compileoption_get(N: ::os::raw::c_int) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_threadsafe() -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3 {
            _unused: [u8; 0],
        }
        pub type sqlite_int64 = ::os::raw::c_longlong;
        pub type sqlite_uint64 = ::os::raw::c_ulonglong;
        pub type sqlite3_int64 = sqlite_int64;
        pub type sqlite3_uint64 = sqlite_uint64;
        extern "C" {
            pub fn sqlite3_close(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        pub type sqlite3_callback = ::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::os::raw::c_void,
                arg2: ::os::raw::c_int,
                arg3: *mut *mut ::os::raw::c_char,
                arg4: *mut *mut ::os::raw::c_char,
            ) -> ::os::raw::c_int,
        >;
        extern "C" {
            pub fn sqlite3_exec(
                arg1: *mut sqlite3,
                sql: *const ::os::raw::c_char,
                callback: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: ::os::raw::c_int,
                        arg3: *mut *mut ::os::raw::c_char,
                        arg4: *mut *mut ::os::raw::c_char,
                    ) -> ::os::raw::c_int,
                >,
                arg2: *mut ::os::raw::c_void,
                errmsg: *mut *mut ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_file {
            pub pMethods: *const sqlite3_io_methods,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_io_methods {
            pub iVersion: ::os::raw::c_int,
            pub xClose: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_file) -> ::os::raw::c_int,
            >,
            pub xRead: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    arg2: *mut ::os::raw::c_void,
                    iAmt: ::os::raw::c_int,
                    iOfst: sqlite3_int64,
                ) -> ::os::raw::c_int,
            >,
            pub xWrite: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    arg2: *const ::os::raw::c_void,
                    iAmt: ::os::raw::c_int,
                    iOfst: sqlite3_int64,
                ) -> ::os::raw::c_int,
            >,
            pub xTruncate: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_file, size: sqlite3_int64) -> ::os::raw::c_int,
            >,
            pub xSync: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    flags: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xFileSize: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    pSize: *mut sqlite3_int64,
                ) -> ::os::raw::c_int,
            >,
            pub xLock: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    arg2: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xUnlock: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    arg2: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xCheckReservedLock: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    pResOut: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xFileControl: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    op: ::os::raw::c_int,
                    pArg: *mut ::os::raw::c_void,
                ) -> ::os::raw::c_int,
            >,
            pub xSectorSize: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_file) -> ::os::raw::c_int,
            >,
            pub xDeviceCharacteristics: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_file) -> ::os::raw::c_int,
            >,
            pub xShmMap: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    iPg: ::os::raw::c_int,
                    pgsz: ::os::raw::c_int,
                    arg2: ::os::raw::c_int,
                    arg3: *mut *mut ::os::raw::c_void,
                ) -> ::os::raw::c_int,
            >,
            pub xShmLock: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    offset: ::os::raw::c_int,
                    n: ::os::raw::c_int,
                    flags: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xShmBarrier: ::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_file)>,
            pub xShmUnmap: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    deleteFlag: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xFetch: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    iOfst: sqlite3_int64,
                    iAmt: ::os::raw::c_int,
                    pp: *mut *mut ::os::raw::c_void,
                ) -> ::os::raw::c_int,
            >,
            pub xUnfetch: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_file,
                    iOfst: sqlite3_int64,
                    p: *mut ::os::raw::c_void,
                ) -> ::os::raw::c_int,
            >,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_mutex {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_api_routines {
            _unused: [u8; 0],
        }
        pub type sqlite3_filename = *const ::os::raw::c_char;
        pub type sqlite3_syscall_ptr = ::option::Option<unsafe extern "C" fn()>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_vfs {
            pub iVersion: ::os::raw::c_int,
            pub szOsFile: ::os::raw::c_int,
            pub mxPathname: ::os::raw::c_int,
            pub pNext: *mut sqlite3_vfs,
            pub zName: *const ::os::raw::c_char,
            pub pAppData: *mut ::os::raw::c_void,
            pub xOpen: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    zName: sqlite3_filename,
                    arg2: *mut sqlite3_file,
                    flags: ::os::raw::c_int,
                    pOutFlags: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xDelete: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    zName: *const ::os::raw::c_char,
                    syncDir: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xAccess: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    zName: *const ::os::raw::c_char,
                    flags: ::os::raw::c_int,
                    pResOut: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xFullPathname: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    zName: *const ::os::raw::c_char,
                    nOut: ::os::raw::c_int,
                    zOut: *mut ::os::raw::c_char,
                ) -> ::os::raw::c_int,
            >,
            pub xDlOpen: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    zFilename: *const ::os::raw::c_char,
                ) -> *mut ::os::raw::c_void,
            >,
            pub xDlError: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    nByte: ::os::raw::c_int,
                    zErrMsg: *mut ::os::raw::c_char,
                ),
            >,
            pub xDlSym: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    arg2: *mut ::os::raw::c_void,
                    zSymbol: *const ::os::raw::c_char,
                ) -> ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_vfs,
                        arg2: *mut ::os::raw::c_void,
                        zSymbol: *const ::os::raw::c_char,
                    ),
                >,
            >,
            pub xDlClose: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_vfs, arg2: *mut ::os::raw::c_void),
            >,
            pub xRandomness: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    nByte: ::os::raw::c_int,
                    zOut: *mut ::os::raw::c_char,
                ) -> ::os::raw::c_int,
            >,
            pub xSleep: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    microseconds: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xCurrentTime: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_vfs, arg2: *mut f64) -> ::os::raw::c_int,
            >,
            pub xGetLastError: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    arg2: ::os::raw::c_int,
                    arg3: *mut ::os::raw::c_char,
                ) -> ::os::raw::c_int,
            >,
            pub xCurrentTimeInt64: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    arg2: *mut sqlite3_int64,
                ) -> ::os::raw::c_int,
            >,
            pub xSetSystemCall: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    zName: *const ::os::raw::c_char,
                    arg2: sqlite3_syscall_ptr,
                ) -> ::os::raw::c_int,
            >,
            pub xGetSystemCall: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    zName: *const ::os::raw::c_char,
                ) -> sqlite3_syscall_ptr,
            >,
            pub xNextSystemCall: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vfs,
                    zName: *const ::os::raw::c_char,
                ) -> *const ::os::raw::c_char,
            >,
        }
        extern "C" {
            pub fn sqlite3_initialize() -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_shutdown() -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_os_init() -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_os_end() -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_config(arg1: ::os::raw::c_int, ...) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_db_config(
                arg1: *mut sqlite3,
                op: ::os::raw::c_int,
                ...
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_mem_methods {
            pub xMalloc: ::option::Option<
                unsafe extern "C" fn(arg1: ::os::raw::c_int) -> *mut ::os::raw::c_void,
            >,
            pub xFree: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            pub xRealloc: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::os::raw::c_void,
                    arg2: ::os::raw::c_int,
                ) -> *mut ::os::raw::c_void,
            >,
            pub xSize: ::option::Option<
                unsafe extern "C" fn(arg1: *mut ::os::raw::c_void) -> ::os::raw::c_int,
            >,
            pub xRoundup: ::option::Option<
                unsafe extern "C" fn(arg1: ::os::raw::c_int) -> ::os::raw::c_int,
            >,
            pub xInit: ::option::Option<
                unsafe extern "C" fn(arg1: *mut ::os::raw::c_void) -> ::os::raw::c_int,
            >,
            pub xShutdown: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            pub pAppData: *mut ::os::raw::c_void,
        }
        extern "C" {
            pub fn sqlite3_extended_result_codes(
                arg1: *mut sqlite3,
                onoff: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_last_insert_rowid(arg1: *mut sqlite3) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3_set_last_insert_rowid(arg1: *mut sqlite3, arg2: sqlite3_int64);
        }
        extern "C" {
            pub fn sqlite3_changes(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_changes64(arg1: *mut sqlite3) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3_total_changes(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_total_changes64(arg1: *mut sqlite3) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3_interrupt(arg1: *mut sqlite3);
        }
        extern "C" {
            pub fn sqlite3_is_interrupted(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_complete(sql: *const ::os::raw::c_char) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_busy_handler(
                arg1: *mut sqlite3,
                arg2: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                arg3: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_busy_timeout(
                arg1: *mut sqlite3,
                ms: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_get_table(
                db: *mut sqlite3,
                zSql: *const ::os::raw::c_char,
                pazResult: *mut *mut *mut ::os::raw::c_char,
                pnRow: *mut ::os::raw::c_int,
                pnColumn: *mut ::os::raw::c_int,
                pzErrmsg: *mut *mut ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_free_table(result: *mut *mut ::os::raw::c_char);
        }
        extern "C" {
            pub fn sqlite3_mprintf(arg1: *const ::os::raw::c_char, ...)
                -> *mut ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_snprintf(
                arg1: ::os::raw::c_int,
                arg2: *mut ::os::raw::c_char,
                arg3: *const ::os::raw::c_char,
                ...
            ) -> *mut ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_malloc(arg1: ::os::raw::c_int) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_malloc64(arg1: sqlite3_uint64) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_realloc(
                arg1: *mut ::os::raw::c_void,
                arg2: ::os::raw::c_int,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_realloc64(
                arg1: *mut ::os::raw::c_void,
                arg2: sqlite3_uint64,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_free(arg1: *mut ::os::raw::c_void);
        }
        extern "C" {
            pub fn sqlite3_msize(arg1: *mut ::os::raw::c_void) -> sqlite3_uint64;
        }
        extern "C" {
            pub fn sqlite3_memory_used() -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3_memory_highwater(resetFlag: ::os::raw::c_int) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3_randomness(N: ::os::raw::c_int, P: *mut ::os::raw::c_void);
        }
        extern "C" {
            pub fn sqlite3_set_authorizer(
                arg1: *mut sqlite3,
                xAuth: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: ::os::raw::c_int,
                        arg3: *const ::os::raw::c_char,
                        arg4: *const ::os::raw::c_char,
                        arg5: *const ::os::raw::c_char,
                        arg6: *const ::os::raw::c_char,
                    ) -> ::os::raw::c_int,
                >,
                pUserData: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_trace(
                arg1: *mut sqlite3,
                xTrace: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: *const ::os::raw::c_char,
                    ),
                >,
                arg2: *mut ::os::raw::c_void,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_profile(
                arg1: *mut sqlite3,
                xProfile: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: *const ::os::raw::c_char,
                        arg3: sqlite3_uint64,
                    ),
                >,
                arg2: *mut ::os::raw::c_void,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_trace_v2(
                arg1: *mut sqlite3,
                uMask: ::os::raw::c_uint,
                xCallback: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: ::os::raw::c_uint,
                        arg2: *mut ::os::raw::c_void,
                        arg3: *mut ::os::raw::c_void,
                        arg4: *mut ::os::raw::c_void,
                    ) -> ::os::raw::c_int,
                >,
                pCtx: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_progress_handler(
                arg1: *mut sqlite3,
                arg2: ::os::raw::c_int,
                arg3: ::option::Option<
                    unsafe extern "C" fn(arg1: *mut ::os::raw::c_void) -> ::os::raw::c_int,
                >,
                arg4: *mut ::os::raw::c_void,
            );
        }
        extern "C" {
            pub fn sqlite3_open(
                filename: *const ::os::raw::c_char,
                ppDb: *mut *mut sqlite3,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_open_v2(
                filename: *const ::os::raw::c_char,
                ppDb: *mut *mut sqlite3,
                flags: ::os::raw::c_int,
                zVfs: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_uri_parameter(
                z: sqlite3_filename,
                zParam: *const ::os::raw::c_char,
            ) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_uri_boolean(
                z: sqlite3_filename,
                zParam: *const ::os::raw::c_char,
                bDefault: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_uri_int64(
                arg1: sqlite3_filename,
                arg2: *const ::os::raw::c_char,
                arg3: sqlite3_int64,
            ) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3_uri_key(
                z: sqlite3_filename,
                N: ::os::raw::c_int,
            ) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_filename_database(arg1: sqlite3_filename) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_filename_journal(arg1: sqlite3_filename) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_filename_wal(arg1: sqlite3_filename) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_database_file_object(arg1: *const ::os::raw::c_char) -> *mut sqlite3_file;
        }
        extern "C" {
            pub fn sqlite3_create_filename(
                zDatabase: *const ::os::raw::c_char,
                zJournal: *const ::os::raw::c_char,
                zWal: *const ::os::raw::c_char,
                nParam: ::os::raw::c_int,
                azParam: *mut *const ::os::raw::c_char,
            ) -> sqlite3_filename;
        }
        extern "C" {
            pub fn sqlite3_free_filename(arg1: sqlite3_filename);
        }
        extern "C" {
            pub fn sqlite3_errcode(db: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_extended_errcode(db: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_errmsg(arg1: *mut sqlite3) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_errstr(arg1: ::os::raw::c_int) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_error_offset(db: *mut sqlite3) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_stmt {
            _unused: [u8; 0],
        }
        extern "C" {
            pub fn sqlite3_limit(
                arg1: *mut sqlite3,
                id: ::os::raw::c_int,
                newVal: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_prepare_v2(
                db: *mut sqlite3,
                zSql: *const ::os::raw::c_char,
                nByte: ::os::raw::c_int,
                ppStmt: *mut *mut sqlite3_stmt,
                pzTail: *mut *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_prepare_v3(
                db: *mut sqlite3,
                zSql: *const ::os::raw::c_char,
                nByte: ::os::raw::c_int,
                prepFlags: ::os::raw::c_uint,
                ppStmt: *mut *mut sqlite3_stmt,
                pzTail: *mut *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_sql(pStmt: *mut sqlite3_stmt) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_expanded_sql(pStmt: *mut sqlite3_stmt) -> *mut ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_stmt_readonly(pStmt: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_stmt_isexplain(pStmt: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_stmt_explain(
                pStmt: *mut sqlite3_stmt,
                eMode: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_stmt_busy(arg1: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_value {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_context {
            _unused: [u8; 0],
        }
        extern "C" {
            pub fn sqlite3_bind_blob(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                arg3: *const ::os::raw::c_void,
                n: ::os::raw::c_int,
                arg4: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_blob64(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                arg3: *const ::os::raw::c_void,
                arg4: sqlite3_uint64,
                arg5: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_double(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                arg3: f64,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_int(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                arg3: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_int64(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                arg3: sqlite3_int64,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_null(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_text(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                arg3: *const ::os::raw::c_char,
                arg4: ::os::raw::c_int,
                arg5: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_text64(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                arg3: *const ::os::raw::c_char,
                arg4: sqlite3_uint64,
                arg5: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
                encoding: ::os::raw::c_uchar,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_value(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                arg3: *const sqlite3_value,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_pointer(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                arg3: *mut ::os::raw::c_void,
                arg4: *const ::os::raw::c_char,
                arg5: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_zeroblob(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                n: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_zeroblob64(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
                arg3: sqlite3_uint64,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_parameter_count(arg1: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_bind_parameter_name(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
            ) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_bind_parameter_index(
                arg1: *mut sqlite3_stmt,
                zName: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_clear_bindings(arg1: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_column_name(
                arg1: *mut sqlite3_stmt,
                N: ::os::raw::c_int,
            ) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_column_database_name(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
            ) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_column_table_name(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
            ) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_column_origin_name(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
            ) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_column_decltype(
                arg1: *mut sqlite3_stmt,
                arg2: ::os::raw::c_int,
            ) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_step(arg1: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_data_count(pStmt: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_column_blob(
                arg1: *mut sqlite3_stmt,
                iCol: ::os::raw::c_int,
            ) -> *const ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_column_double(arg1: *mut sqlite3_stmt, iCol: ::os::raw::c_int) -> f64;
        }
        extern "C" {
            pub fn sqlite3_column_int(
                arg1: *mut sqlite3_stmt,
                iCol: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_column_int64(
                arg1: *mut sqlite3_stmt,
                iCol: ::os::raw::c_int,
            ) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3_column_text(
                arg1: *mut sqlite3_stmt,
                iCol: ::os::raw::c_int,
            ) -> *const ::os::raw::c_uchar;
        }
        extern "C" {
            pub fn sqlite3_column_value(
                arg1: *mut sqlite3_stmt,
                iCol: ::os::raw::c_int,
            ) -> *mut sqlite3_value;
        }
        extern "C" {
            pub fn sqlite3_column_bytes(
                arg1: *mut sqlite3_stmt,
                iCol: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_column_type(
                arg1: *mut sqlite3_stmt,
                iCol: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_create_function_v2(
                db: *mut sqlite3,
                zFunctionName: *const ::os::raw::c_char,
                nArg: ::os::raw::c_int,
                eTextRep: ::os::raw::c_int,
                pApp: *mut ::os::raw::c_void,
                xFunc: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_context,
                        arg2: ::os::raw::c_int,
                        arg3: *mut *mut sqlite3_value,
                    ),
                >,
                xStep: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_context,
                        arg2: ::os::raw::c_int,
                        arg3: *mut *mut sqlite3_value,
                    ),
                >,
                xFinal: ::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
                xDestroy: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_create_window_function(
                db: *mut sqlite3,
                zFunctionName: *const ::os::raw::c_char,
                nArg: ::os::raw::c_int,
                eTextRep: ::os::raw::c_int,
                pApp: *mut ::os::raw::c_void,
                xStep: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_context,
                        arg2: ::os::raw::c_int,
                        arg3: *mut *mut sqlite3_value,
                    ),
                >,
                xFinal: ::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
                xValue: ::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
                xInverse: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_context,
                        arg2: ::os::raw::c_int,
                        arg3: *mut *mut sqlite3_value,
                    ),
                >,
                xDestroy: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_aggregate_count(arg1: *mut sqlite3_context) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_expired(arg1: *mut sqlite3_stmt) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_transfer_bindings(
                arg1: *mut sqlite3_stmt,
                arg2: *mut sqlite3_stmt,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_global_recover() -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_thread_cleanup();
        }
        extern "C" {
            pub fn sqlite3_memory_alarm(
                arg1: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: sqlite3_int64,
                        arg3: ::os::raw::c_int,
                    ),
                >,
                arg2: *mut ::os::raw::c_void,
                arg3: sqlite3_int64,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_value_blob(arg1: *mut sqlite3_value) -> *const ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_value_double(arg1: *mut sqlite3_value) -> f64;
        }
        extern "C" {
            pub fn sqlite3_value_int(arg1: *mut sqlite3_value) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_value_int64(arg1: *mut sqlite3_value) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3_value_pointer(
                arg1: *mut sqlite3_value,
                arg2: *const ::os::raw::c_char,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_value_text(arg1: *mut sqlite3_value) -> *const ::os::raw::c_uchar;
        }
        extern "C" {
            pub fn sqlite3_value_bytes(arg1: *mut sqlite3_value) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_value_type(arg1: *mut sqlite3_value) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_value_numeric_type(arg1: *mut sqlite3_value) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_value_nochange(arg1: *mut sqlite3_value) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_value_frombind(arg1: *mut sqlite3_value) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_value_encoding(arg1: *mut sqlite3_value) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_value_subtype(arg1: *mut sqlite3_value) -> ::os::raw::c_uint;
        }
        extern "C" {
            pub fn sqlite3_value_dup(arg1: *const sqlite3_value) -> *mut sqlite3_value;
        }
        extern "C" {
            pub fn sqlite3_value_free(arg1: *mut sqlite3_value);
        }
        extern "C" {
            pub fn sqlite3_aggregate_context(
                arg1: *mut sqlite3_context,
                nBytes: ::os::raw::c_int,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_user_data(arg1: *mut sqlite3_context) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_context_db_handle(arg1: *mut sqlite3_context) -> *mut sqlite3;
        }
        extern "C" {
            pub fn sqlite3_get_auxdata(
                arg1: *mut sqlite3_context,
                N: ::os::raw::c_int,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_set_auxdata(
                arg1: *mut sqlite3_context,
                N: ::os::raw::c_int,
                arg2: *mut ::os::raw::c_void,
                arg3: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            );
        }
        extern "C" {
            pub fn sqlite3_get_clientdata(
                arg1: *mut sqlite3,
                arg2: *const ::os::raw::c_char,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_set_clientdata(
                arg1: *mut sqlite3,
                arg2: *const ::os::raw::c_char,
                arg3: *mut ::os::raw::c_void,
                arg4: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        pub type sqlite3_destructor_type =
            ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>;
        extern "C" {
            pub fn sqlite3_result_blob(
                arg1: *mut sqlite3_context,
                arg2: *const ::os::raw::c_void,
                arg3: ::os::raw::c_int,
                arg4: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            );
        }
        extern "C" {
            pub fn sqlite3_result_blob64(
                arg1: *mut sqlite3_context,
                arg2: *const ::os::raw::c_void,
                arg3: sqlite3_uint64,
                arg4: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            );
        }
        extern "C" {
            pub fn sqlite3_result_double(arg1: *mut sqlite3_context, arg2: f64);
        }
        extern "C" {
            pub fn sqlite3_result_error(
                arg1: *mut sqlite3_context,
                arg2: *const ::os::raw::c_char,
                arg3: ::os::raw::c_int,
            );
        }
        extern "C" {
            pub fn sqlite3_result_error_toobig(arg1: *mut sqlite3_context);
        }
        extern "C" {
            pub fn sqlite3_result_error_nomem(arg1: *mut sqlite3_context);
        }
        extern "C" {
            pub fn sqlite3_result_error_code(arg1: *mut sqlite3_context, arg2: ::os::raw::c_int);
        }
        extern "C" {
            pub fn sqlite3_result_int(arg1: *mut sqlite3_context, arg2: ::os::raw::c_int);
        }
        extern "C" {
            pub fn sqlite3_result_int64(arg1: *mut sqlite3_context, arg2: sqlite3_int64);
        }
        extern "C" {
            pub fn sqlite3_result_null(arg1: *mut sqlite3_context);
        }
        extern "C" {
            pub fn sqlite3_result_text(
                arg1: *mut sqlite3_context,
                arg2: *const ::os::raw::c_char,
                arg3: ::os::raw::c_int,
                arg4: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            );
        }
        extern "C" {
            pub fn sqlite3_result_text64(
                arg1: *mut sqlite3_context,
                arg2: *const ::os::raw::c_char,
                arg3: sqlite3_uint64,
                arg4: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
                encoding: ::os::raw::c_uchar,
            );
        }
        extern "C" {
            pub fn sqlite3_result_value(arg1: *mut sqlite3_context, arg2: *mut sqlite3_value);
        }
        extern "C" {
            pub fn sqlite3_result_pointer(
                arg1: *mut sqlite3_context,
                arg2: *mut ::os::raw::c_void,
                arg3: *const ::os::raw::c_char,
                arg4: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            );
        }
        extern "C" {
            pub fn sqlite3_result_zeroblob(arg1: *mut sqlite3_context, n: ::os::raw::c_int);
        }
        extern "C" {
            pub fn sqlite3_result_zeroblob64(
                arg1: *mut sqlite3_context,
                n: sqlite3_uint64,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_result_subtype(arg1: *mut sqlite3_context, arg2: ::os::raw::c_uint);
        }
        extern "C" {
            pub fn sqlite3_create_collation_v2(
                arg1: *mut sqlite3,
                zName: *const ::os::raw::c_char,
                eTextRep: ::os::raw::c_int,
                pArg: *mut ::os::raw::c_void,
                xCompare: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: ::os::raw::c_int,
                        arg3: *const ::os::raw::c_void,
                        arg4: ::os::raw::c_int,
                        arg5: *const ::os::raw::c_void,
                    ) -> ::os::raw::c_int,
                >,
                xDestroy: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_collation_needed(
                arg1: *mut sqlite3,
                arg2: *mut ::os::raw::c_void,
                arg3: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: *mut sqlite3,
                        eTextRep: ::os::raw::c_int,
                        arg3: *const ::os::raw::c_char,
                    ),
                >,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_sleep(arg1: ::os::raw::c_int) -> ::os::raw::c_int;
        }
        extern "C" {
            pub static mut sqlite3_temp_directory: *mut ::os::raw::c_char;
        }
        extern "C" {
            pub static mut sqlite3_data_directory: *mut ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_win32_set_directory(
                type_: ::os::raw::c_ulong,
                zValue: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_win32_set_directory8(
                type_: ::os::raw::c_ulong,
                zValue: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_get_autocommit(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_db_handle(arg1: *mut sqlite3_stmt) -> *mut sqlite3;
        }
        extern "C" {
            pub fn sqlite3_db_name(
                db: *mut sqlite3,
                N: ::os::raw::c_int,
            ) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_db_filename(
                db: *mut sqlite3,
                zDbName: *const ::os::raw::c_char,
            ) -> sqlite3_filename;
        }
        extern "C" {
            pub fn sqlite3_db_readonly(
                db: *mut sqlite3,
                zDbName: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_txn_state(
                arg1: *mut sqlite3,
                zSchema: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_next_stmt(pDb: *mut sqlite3, pStmt: *mut sqlite3_stmt) -> *mut sqlite3_stmt;
        }
        extern "C" {
            pub fn sqlite3_commit_hook(
                arg1: *mut sqlite3,
                arg2: ::option::Option<
                    unsafe extern "C" fn(arg1: *mut ::os::raw::c_void) -> ::os::raw::c_int,
                >,
                arg3: *mut ::os::raw::c_void,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_rollback_hook(
                arg1: *mut sqlite3,
                arg2: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
                arg3: *mut ::os::raw::c_void,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_autovacuum_pages(
                db: *mut sqlite3,
                arg1: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: *const ::os::raw::c_char,
                        arg3: ::os::raw::c_uint,
                        arg4: ::os::raw::c_uint,
                        arg5: ::os::raw::c_uint,
                    ) -> ::os::raw::c_uint,
                >,
                arg2: *mut ::os::raw::c_void,
                arg3: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_update_hook(
                arg1: *mut sqlite3,
                arg2: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: ::os::raw::c_int,
                        arg3: *const ::os::raw::c_char,
                        arg4: *const ::os::raw::c_char,
                        arg5: sqlite3_int64,
                    ),
                >,
                arg3: *mut ::os::raw::c_void,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_enable_shared_cache(arg1: ::os::raw::c_int) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_release_memory(arg1: ::os::raw::c_int) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_db_release_memory(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_soft_heap_limit64(N: sqlite3_int64) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3_hard_heap_limit64(N: sqlite3_int64) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3_soft_heap_limit(N: ::os::raw::c_int);
        }
        extern "C" {
            pub fn sqlite3_table_column_metadata(
                db: *mut sqlite3,
                zDbName: *const ::os::raw::c_char,
                zTableName: *const ::os::raw::c_char,
                zColumnName: *const ::os::raw::c_char,
                pzDataType: *mut *const ::os::raw::c_char,
                pzCollSeq: *mut *const ::os::raw::c_char,
                pNotNull: *mut ::os::raw::c_int,
                pPrimaryKey: *mut ::os::raw::c_int,
                pAutoinc: *mut ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_load_extension(
                db: *mut sqlite3,
                zFile: *const ::os::raw::c_char,
                zProc: *const ::os::raw::c_char,
                pzErrMsg: *mut *mut ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_enable_load_extension(
                db: *mut sqlite3,
                onoff: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_reset_auto_extension();
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_module {
            pub iVersion: ::os::raw::c_int,
            pub xCreate: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3,
                    pAux: *mut ::os::raw::c_void,
                    argc: ::os::raw::c_int,
                    argv: *const *const ::os::raw::c_char,
                    ppVTab: *mut *mut sqlite3_vtab,
                    arg2: *mut *mut ::os::raw::c_char,
                ) -> ::os::raw::c_int,
            >,
            pub xConnect: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3,
                    pAux: *mut ::os::raw::c_void,
                    argc: ::os::raw::c_int,
                    argv: *const *const ::os::raw::c_char,
                    ppVTab: *mut *mut sqlite3_vtab,
                    arg2: *mut *mut ::os::raw::c_char,
                ) -> ::os::raw::c_int,
            >,
            pub xBestIndex: ::option::Option<
                unsafe extern "C" fn(
                    pVTab: *mut sqlite3_vtab,
                    arg1: *mut sqlite3_index_info,
                ) -> ::os::raw::c_int,
            >,
            pub xDisconnect: ::option::Option<
                unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::os::raw::c_int,
            >,
            pub xDestroy: ::option::Option<
                unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::os::raw::c_int,
            >,
            pub xOpen: ::option::Option<
                unsafe extern "C" fn(
                    pVTab: *mut sqlite3_vtab,
                    ppCursor: *mut *mut sqlite3_vtab_cursor,
                ) -> ::os::raw::c_int,
            >,
            pub xClose: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> ::os::raw::c_int,
            >,
            pub xFilter: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vtab_cursor,
                    idxNum: ::os::raw::c_int,
                    idxStr: *const ::os::raw::c_char,
                    argc: ::os::raw::c_int,
                    argv: *mut *mut sqlite3_value,
                ) -> ::os::raw::c_int,
            >,
            pub xNext: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> ::os::raw::c_int,
            >,
            pub xEof: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> ::os::raw::c_int,
            >,
            pub xColumn: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vtab_cursor,
                    arg2: *mut sqlite3_context,
                    arg3: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xRowid: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vtab_cursor,
                    pRowid: *mut sqlite3_int64,
                ) -> ::os::raw::c_int,
            >,
            pub xUpdate: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_vtab,
                    arg2: ::os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                    arg4: *mut sqlite3_int64,
                ) -> ::os::raw::c_int,
            >,
            pub xBegin: ::option::Option<
                unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::os::raw::c_int,
            >,
            pub xSync: ::option::Option<
                unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::os::raw::c_int,
            >,
            pub xCommit: ::option::Option<
                unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::os::raw::c_int,
            >,
            pub xRollback: ::option::Option<
                unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> ::os::raw::c_int,
            >,
            pub xFindFunction: ::option::Option<
                unsafe extern "C" fn(
                    pVtab: *mut sqlite3_vtab,
                    nArg: ::os::raw::c_int,
                    zName: *const ::os::raw::c_char,
                    pxFunc: *mut ::option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut sqlite3_context,
                            arg2: ::os::raw::c_int,
                            arg3: *mut *mut sqlite3_value,
                        ),
                    >,
                    ppArg: *mut *mut ::os::raw::c_void,
                ) -> ::os::raw::c_int,
            >,
            pub xRename: ::option::Option<
                unsafe extern "C" fn(
                    pVtab: *mut sqlite3_vtab,
                    zNew: *const ::os::raw::c_char,
                ) -> ::os::raw::c_int,
            >,
            pub xSavepoint: ::option::Option<
                unsafe extern "C" fn(
                    pVTab: *mut sqlite3_vtab,
                    arg1: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xRelease: ::option::Option<
                unsafe extern "C" fn(
                    pVTab: *mut sqlite3_vtab,
                    arg1: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xRollbackTo: ::option::Option<
                unsafe extern "C" fn(
                    pVTab: *mut sqlite3_vtab,
                    arg1: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xShadowName: ::option::Option<
                unsafe extern "C" fn(arg1: *const ::os::raw::c_char) -> ::os::raw::c_int,
            >,
            pub xIntegrity: ::option::Option<
                unsafe extern "C" fn(
                    pVTab: *mut sqlite3_vtab,
                    zSchema: *const ::os::raw::c_char,
                    zTabName: *const ::os::raw::c_char,
                    mFlags: ::os::raw::c_int,
                    pzErr: *mut *mut ::os::raw::c_char,
                ) -> ::os::raw::c_int,
            >,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_index_info {
            pub nConstraint: ::os::raw::c_int,
            pub aConstraint: *mut sqlite3_index_constraint,
            pub nOrderBy: ::os::raw::c_int,
            pub aOrderBy: *mut sqlite3_index_orderby,
            pub aConstraintUsage: *mut sqlite3_index_constraint_usage,
            pub idxNum: ::os::raw::c_int,
            pub idxStr: *mut ::os::raw::c_char,
            pub needToFreeIdxStr: ::os::raw::c_int,
            pub orderByConsumed: ::os::raw::c_int,
            pub estimatedCost: f64,
            pub estimatedRows: sqlite3_int64,
            pub idxFlags: ::os::raw::c_int,
            pub colUsed: sqlite3_uint64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_index_constraint {
            pub iColumn: ::os::raw::c_int,
            pub op: ::os::raw::c_uchar,
            pub usable: ::os::raw::c_uchar,
            pub iTermOffset: ::os::raw::c_int,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_index_orderby {
            pub iColumn: ::os::raw::c_int,
            pub desc: ::os::raw::c_uchar,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_index_constraint_usage {
            pub argvIndex: ::os::raw::c_int,
            pub omit: ::os::raw::c_uchar,
        }
        extern "C" {
            pub fn sqlite3_create_module_v2(
                db: *mut sqlite3,
                zName: *const ::os::raw::c_char,
                p: *const sqlite3_module,
                pClientData: *mut ::os::raw::c_void,
                xDestroy: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_drop_modules(
                db: *mut sqlite3,
                azKeep: *mut *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_vtab {
            pub pModule: *const sqlite3_module,
            pub nRef: ::os::raw::c_int,
            pub zErrMsg: *mut ::os::raw::c_char,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_vtab_cursor {
            pub pVtab: *mut sqlite3_vtab,
        }
        extern "C" {
            pub fn sqlite3_declare_vtab(
                arg1: *mut sqlite3,
                zSQL: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_overload_function(
                arg1: *mut sqlite3,
                zFuncName: *const ::os::raw::c_char,
                nArg: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_blob {
            _unused: [u8; 0],
        }
        extern "C" {
            pub fn sqlite3_blob_open(
                arg1: *mut sqlite3,
                zDb: *const ::os::raw::c_char,
                zTable: *const ::os::raw::c_char,
                zColumn: *const ::os::raw::c_char,
                iRow: sqlite3_int64,
                flags: ::os::raw::c_int,
                ppBlob: *mut *mut sqlite3_blob,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_blob_reopen(
                arg1: *mut sqlite3_blob,
                arg2: sqlite3_int64,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_blob_close(arg1: *mut sqlite3_blob) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_blob_bytes(arg1: *mut sqlite3_blob) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_blob_read(
                arg1: *mut sqlite3_blob,
                Z: *mut ::os::raw::c_void,
                N: ::os::raw::c_int,
                iOffset: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_blob_write(
                arg1: *mut sqlite3_blob,
                z: *const ::os::raw::c_void,
                n: ::os::raw::c_int,
                iOffset: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_vfs_find(zVfsName: *const ::os::raw::c_char) -> *mut sqlite3_vfs;
        }
        extern "C" {
            pub fn sqlite3_vfs_register(
                arg1: *mut sqlite3_vfs,
                makeDflt: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_vfs_unregister(arg1: *mut sqlite3_vfs) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_mutex_alloc(arg1: ::os::raw::c_int) -> *mut sqlite3_mutex;
        }
        extern "C" {
            pub fn sqlite3_mutex_free(arg1: *mut sqlite3_mutex);
        }
        extern "C" {
            pub fn sqlite3_mutex_enter(arg1: *mut sqlite3_mutex);
        }
        extern "C" {
            pub fn sqlite3_mutex_try(arg1: *mut sqlite3_mutex) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_mutex_leave(arg1: *mut sqlite3_mutex);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_mutex_methods {
            pub xMutexInit: ::option::Option<unsafe extern "C" fn() -> ::os::raw::c_int>,
            pub xMutexEnd: ::option::Option<unsafe extern "C" fn() -> ::os::raw::c_int>,
            pub xMutexAlloc: ::option::Option<
                unsafe extern "C" fn(arg1: ::os::raw::c_int) -> *mut sqlite3_mutex,
            >,
            pub xMutexFree: ::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
            pub xMutexEnter: ::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
            pub xMutexTry: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::os::raw::c_int,
            >,
            pub xMutexLeave: ::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
            pub xMutexHeld: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::os::raw::c_int,
            >,
            pub xMutexNotheld: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> ::os::raw::c_int,
            >,
        }
        extern "C" {
            pub fn sqlite3_mutex_held(arg1: *mut sqlite3_mutex) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_mutex_notheld(arg1: *mut sqlite3_mutex) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_db_mutex(arg1: *mut sqlite3) -> *mut sqlite3_mutex;
        }
        extern "C" {
            pub fn sqlite3_file_control(
                arg1: *mut sqlite3,
                zDbName: *const ::os::raw::c_char,
                op: ::os::raw::c_int,
                arg2: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_test_control(op: ::os::raw::c_int, ...) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_keyword_count() -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_keyword_name(
                arg1: ::os::raw::c_int,
                arg2: *mut *const ::os::raw::c_char,
                arg3: *mut ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_keyword_check(
                arg1: *const ::os::raw::c_char,
                arg2: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_str {
            _unused: [u8; 0],
        }
        extern "C" {
            pub fn sqlite3_str_new(arg1: *mut sqlite3) -> *mut sqlite3_str;
        }
        extern "C" {
            pub fn sqlite3_str_finish(arg1: *mut sqlite3_str) -> *mut ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_str_appendf(arg1: *mut sqlite3_str, zFormat: *const ::os::raw::c_char, ...);
        }
        extern "C" {
            pub fn sqlite3_str_append(
                arg1: *mut sqlite3_str,
                zIn: *const ::os::raw::c_char,
                N: ::os::raw::c_int,
            );
        }
        extern "C" {
            pub fn sqlite3_str_appendall(arg1: *mut sqlite3_str, zIn: *const ::os::raw::c_char);
        }
        extern "C" {
            pub fn sqlite3_str_appendchar(
                arg1: *mut sqlite3_str,
                N: ::os::raw::c_int,
                C: ::os::raw::c_char,
            );
        }
        extern "C" {
            pub fn sqlite3_str_reset(arg1: *mut sqlite3_str);
        }
        extern "C" {
            pub fn sqlite3_str_errcode(arg1: *mut sqlite3_str) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_str_length(arg1: *mut sqlite3_str) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_str_value(arg1: *mut sqlite3_str) -> *mut ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_status(
                op: ::os::raw::c_int,
                pCurrent: *mut ::os::raw::c_int,
                pHighwater: *mut ::os::raw::c_int,
                resetFlag: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_status64(
                op: ::os::raw::c_int,
                pCurrent: *mut sqlite3_int64,
                pHighwater: *mut sqlite3_int64,
                resetFlag: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_db_status(
                arg1: *mut sqlite3,
                op: ::os::raw::c_int,
                pCur: *mut ::os::raw::c_int,
                pHiwtr: *mut ::os::raw::c_int,
                resetFlg: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_stmt_status(
                arg1: *mut sqlite3_stmt,
                op: ::os::raw::c_int,
                resetFlg: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_pcache {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_pcache_page {
            pub pBuf: *mut ::os::raw::c_void,
            pub pExtra: *mut ::os::raw::c_void,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_pcache_methods2 {
            pub iVersion: ::os::raw::c_int,
            pub pArg: *mut ::os::raw::c_void,
            pub xInit: ::option::Option<
                unsafe extern "C" fn(arg1: *mut ::os::raw::c_void) -> ::os::raw::c_int,
            >,
            pub xShutdown: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            pub xCreate: ::option::Option<
                unsafe extern "C" fn(
                    szPage: ::os::raw::c_int,
                    szExtra: ::os::raw::c_int,
                    bPurgeable: ::os::raw::c_int,
                ) -> *mut sqlite3_pcache,
            >,
            pub xCachesize: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_pcache, nCachesize: ::os::raw::c_int),
            >,
            pub xPagecount: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_pcache) -> ::os::raw::c_int,
            >,
            pub xFetch: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_pcache,
                    key: ::os::raw::c_uint,
                    createFlag: ::os::raw::c_int,
                ) -> *mut sqlite3_pcache_page,
            >,
            pub xUnpin: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_pcache,
                    arg2: *mut sqlite3_pcache_page,
                    discard: ::os::raw::c_int,
                ),
            >,
            pub xRekey: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_pcache,
                    arg2: *mut sqlite3_pcache_page,
                    oldKey: ::os::raw::c_uint,
                    newKey: ::os::raw::c_uint,
                ),
            >,
            pub xTruncate: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_pcache, iLimit: ::os::raw::c_uint),
            >,
            pub xDestroy: ::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
            pub xShrink: ::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_pcache_methods {
            pub pArg: *mut ::os::raw::c_void,
            pub xInit: ::option::Option<
                unsafe extern "C" fn(arg1: *mut ::os::raw::c_void) -> ::os::raw::c_int,
            >,
            pub xShutdown: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            pub xCreate: ::option::Option<
                unsafe extern "C" fn(
                    szPage: ::os::raw::c_int,
                    bPurgeable: ::os::raw::c_int,
                ) -> *mut sqlite3_pcache,
            >,
            pub xCachesize: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_pcache, nCachesize: ::os::raw::c_int),
            >,
            pub xPagecount: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_pcache) -> ::os::raw::c_int,
            >,
            pub xFetch: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_pcache,
                    key: ::os::raw::c_uint,
                    createFlag: ::os::raw::c_int,
                ) -> *mut ::os::raw::c_void,
            >,
            pub xUnpin: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_pcache,
                    arg2: *mut ::os::raw::c_void,
                    discard: ::os::raw::c_int,
                ),
            >,
            pub xRekey: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut sqlite3_pcache,
                    arg2: *mut ::os::raw::c_void,
                    oldKey: ::os::raw::c_uint,
                    newKey: ::os::raw::c_uint,
                ),
            >,
            pub xTruncate: ::option::Option<
                unsafe extern "C" fn(arg1: *mut sqlite3_pcache, iLimit: ::os::raw::c_uint),
            >,
            pub xDestroy: ::option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_backup {
            _unused: [u8; 0],
        }
        extern "C" {
            pub fn sqlite3_backup_init(
                pDest: *mut sqlite3,
                zDestName: *const ::os::raw::c_char,
                pSource: *mut sqlite3,
                zSourceName: *const ::os::raw::c_char,
            ) -> *mut sqlite3_backup;
        }
        extern "C" {
            pub fn sqlite3_backup_step(
                p: *mut sqlite3_backup,
                nPage: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_backup_finish(p: *mut sqlite3_backup) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_backup_remaining(p: *mut sqlite3_backup) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_backup_pagecount(p: *mut sqlite3_backup) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_unlock_notify(
                pBlocked: *mut sqlite3,
                xNotify: ::option::Option<
                    unsafe extern "C" fn(
                        apArg: *mut *mut ::os::raw::c_void,
                        nArg: ::os::raw::c_int,
                    ),
                >,
                pNotifyArg: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_stricmp(
                arg1: *const ::os::raw::c_char,
                arg2: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_strnicmp(
                arg1: *const ::os::raw::c_char,
                arg2: *const ::os::raw::c_char,
                arg3: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_strglob(
                zGlob: *const ::os::raw::c_char,
                zStr: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_strlike(
                zGlob: *const ::os::raw::c_char,
                zStr: *const ::os::raw::c_char,
                cEsc: ::os::raw::c_uint,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_log(
                iErrCode: ::os::raw::c_int,
                zFormat: *const ::os::raw::c_char,
                ...
            );
        }
        extern "C" {
            pub fn sqlite3_wal_hook(
                arg1: *mut sqlite3,
                arg2: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::os::raw::c_void,
                        arg2: *mut sqlite3,
                        arg3: *const ::os::raw::c_char,
                        arg4: ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                arg3: *mut ::os::raw::c_void,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_wal_autocheckpoint(
                db: *mut sqlite3,
                N: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_wal_checkpoint(
                db: *mut sqlite3,
                zDb: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_wal_checkpoint_v2(
                db: *mut sqlite3,
                zDb: *const ::os::raw::c_char,
                eMode: ::os::raw::c_int,
                pnLog: *mut ::os::raw::c_int,
                pnCkpt: *mut ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_vtab_config(
                arg1: *mut sqlite3,
                op: ::os::raw::c_int,
                ...
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_vtab_on_conflict(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_vtab_nochange(arg1: *mut sqlite3_context) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_vtab_collation(
                arg1: *mut sqlite3_index_info,
                arg2: ::os::raw::c_int,
            ) -> *const ::os::raw::c_char;
        }
        extern "C" {
            pub fn sqlite3_vtab_distinct(arg1: *mut sqlite3_index_info) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_vtab_in(
                arg1: *mut sqlite3_index_info,
                iCons: ::os::raw::c_int,
                bHandle: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_vtab_in_first(
                pVal: *mut sqlite3_value,
                ppOut: *mut *mut sqlite3_value,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_vtab_in_next(
                pVal: *mut sqlite3_value,
                ppOut: *mut *mut sqlite3_value,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_vtab_rhs_value(
                arg1: *mut sqlite3_index_info,
                arg2: ::os::raw::c_int,
                ppVal: *mut *mut sqlite3_value,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_stmt_scanstatus(
                pStmt: *mut sqlite3_stmt,
                idx: ::os::raw::c_int,
                iScanStatusOp: ::os::raw::c_int,
                pOut: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_stmt_scanstatus_v2(
                pStmt: *mut sqlite3_stmt,
                idx: ::os::raw::c_int,
                iScanStatusOp: ::os::raw::c_int,
                flags: ::os::raw::c_int,
                pOut: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_stmt_scanstatus_reset(arg1: *mut sqlite3_stmt);
        }
        extern "C" {
            pub fn sqlite3_db_cacheflush(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_preupdate_hook(
                db: *mut sqlite3,
                xPreUpdate: ::option::Option<
                    unsafe extern "C" fn(
                        pCtx: *mut ::os::raw::c_void,
                        db: *mut sqlite3,
                        op: ::os::raw::c_int,
                        zDb: *const ::os::raw::c_char,
                        zName: *const ::os::raw::c_char,
                        iKey1: sqlite3_int64,
                        iKey2: sqlite3_int64,
                    ),
                >,
                arg1: *mut ::os::raw::c_void,
            ) -> *mut ::os::raw::c_void;
        }
        extern "C" {
            pub fn sqlite3_preupdate_old(
                arg1: *mut sqlite3,
                arg2: ::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_preupdate_count(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_preupdate_depth(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_preupdate_new(
                arg1: *mut sqlite3,
                arg2: ::os::raw::c_int,
                arg3: *mut *mut sqlite3_value,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_preupdate_blobwrite(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_system_errno(arg1: *mut sqlite3) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_snapshot {
            pub hidden: [:: ::os::raw::c_uchar; 48usize],
        }
        extern "C" {
            pub fn sqlite3_snapshot_get(
                db: *mut sqlite3,
                zSchema: *const ::os::raw::c_char,
                ppSnapshot: *mut *mut sqlite3_snapshot,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_snapshot_open(
                db: *mut sqlite3,
                zSchema: *const ::os::raw::c_char,
                pSnapshot: *mut sqlite3_snapshot,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_snapshot_free(arg1: *mut sqlite3_snapshot);
        }
        extern "C" {
            pub fn sqlite3_snapshot_cmp(
                p1: *mut sqlite3_snapshot,
                p2: *mut sqlite3_snapshot,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_snapshot_recover(
                db: *mut sqlite3,
                zDb: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3_serialize(
                db: *mut sqlite3,
                zSchema: *const ::os::raw::c_char,
                piSize: *mut sqlite3_int64,
                mFlags: ::os::raw::c_uint,
            ) -> *mut ::os::raw::c_uchar;
        }
        extern "C" {
            pub fn sqlite3_deserialize(
                db: *mut sqlite3,
                zSchema: *const ::os::raw::c_char,
                pData: *mut ::os::raw::c_uchar,
                szDb: sqlite3_int64,
                szBuf: sqlite3_int64,
                mFlags: ::os::raw::c_uint,
            ) -> ::os::raw::c_int;
        }
        pub type sqlite3_rtree_dbl = f64;
        extern "C" {
            pub fn sqlite3_rtree_geometry_callback(
                db: *mut sqlite3,
                zGeom: *const ::os::raw::c_char,
                xGeom: ::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_rtree_geometry,
                        arg2: ::os::raw::c_int,
                        arg3: *mut sqlite3_rtree_dbl,
                        arg4: *mut ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pContext: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_rtree_geometry {
            pub pContext: *mut ::os::raw::c_void,
            pub nParam: ::os::raw::c_int,
            pub aParam: *mut sqlite3_rtree_dbl,
            pub pUser: *mut ::os::raw::c_void,
            pub xDelUser: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
        }
        extern "C" {
            pub fn sqlite3_rtree_query_callback(
                db: *mut sqlite3,
                zQueryFunc: *const ::os::raw::c_char,
                xQueryFunc: ::option::Option<
                    unsafe extern "C" fn(arg1: *mut sqlite3_rtree_query_info) -> ::os::raw::c_int,
                >,
                pContext: *mut ::os::raw::c_void,
                xDestructor: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_rtree_query_info {
            pub pContext: *mut ::os::raw::c_void,
            pub nParam: ::os::raw::c_int,
            pub aParam: *mut sqlite3_rtree_dbl,
            pub pUser: *mut ::os::raw::c_void,
            pub xDelUser: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
            pub aCoord: *mut sqlite3_rtree_dbl,
            pub anQueue: *mut ::os::raw::c_uint,
            pub nCoord: ::os::raw::c_int,
            pub iLevel: ::os::raw::c_int,
            pub mxLevel: ::os::raw::c_int,
            pub iRowid: sqlite3_int64,
            pub rParentScore: sqlite3_rtree_dbl,
            pub eParentWithin: ::os::raw::c_int,
            pub eWithin: ::os::raw::c_int,
            pub rScore: sqlite3_rtree_dbl,
            pub apSqlParam: *mut *mut sqlite3_value,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_session {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_changeset_iter {
            _unused: [u8; 0],
        }
        extern "C" {
            pub fn sqlite3session_create(
                db: *mut sqlite3,
                zDb: *const ::os::raw::c_char,
                ppSession: *mut *mut sqlite3_session,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_delete(pSession: *mut sqlite3_session);
        }
        extern "C" {
            pub fn sqlite3session_object_config(
                arg1: *mut sqlite3_session,
                op: ::os::raw::c_int,
                pArg: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_enable(
                pSession: *mut sqlite3_session,
                bEnable: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_indirect(
                pSession: *mut sqlite3_session,
                bIndirect: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_attach(
                pSession: *mut sqlite3_session,
                zTab: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_table_filter(
                pSession: *mut sqlite3_session,
                xFilter: ::option::Option<
                    unsafe extern "C" fn(
                        pCtx: *mut ::os::raw::c_void,
                        zTab: *const ::os::raw::c_char,
                    ) -> ::os::raw::c_int,
                >,
                pCtx: *mut ::os::raw::c_void,
            );
        }
        extern "C" {
            pub fn sqlite3session_changeset(
                pSession: *mut sqlite3_session,
                pnChangeset: *mut ::os::raw::c_int,
                ppChangeset: *mut *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_changeset_size(pSession: *mut sqlite3_session) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3session_diff(
                pSession: *mut sqlite3_session,
                zFromDb: *const ::os::raw::c_char,
                zTbl: *const ::os::raw::c_char,
                pzErrMsg: *mut *mut ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_patchset(
                pSession: *mut sqlite3_session,
                pnPatchset: *mut ::os::raw::c_int,
                ppPatchset: *mut *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_isempty(pSession: *mut sqlite3_session) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_memory_used(pSession: *mut sqlite3_session) -> sqlite3_int64;
        }
        extern "C" {
            pub fn sqlite3changeset_start(
                pp: *mut *mut sqlite3_changeset_iter,
                nChangeset: ::os::raw::c_int,
                pChangeset: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_start_v2(
                pp: *mut *mut sqlite3_changeset_iter,
                nChangeset: ::os::raw::c_int,
                pChangeset: *mut ::os::raw::c_void,
                flags: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_next(pIter: *mut sqlite3_changeset_iter) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_op(
                pIter: *mut sqlite3_changeset_iter,
                pzTab: *mut *const ::os::raw::c_char,
                pnCol: *mut ::os::raw::c_int,
                pOp: *mut ::os::raw::c_int,
                pbIndirect: *mut ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_pk(
                pIter: *mut sqlite3_changeset_iter,
                pabPK: *mut *mut ::os::raw::c_uchar,
                pnCol: *mut ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_old(
                pIter: *mut sqlite3_changeset_iter,
                iVal: ::os::raw::c_int,
                ppValue: *mut *mut sqlite3_value,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_new(
                pIter: *mut sqlite3_changeset_iter,
                iVal: ::os::raw::c_int,
                ppValue: *mut *mut sqlite3_value,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_conflict(
                pIter: *mut sqlite3_changeset_iter,
                iVal: ::os::raw::c_int,
                ppValue: *mut *mut sqlite3_value,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_fk_conflicts(
                pIter: *mut sqlite3_changeset_iter,
                pnOut: *mut ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_finalize(pIter: *mut sqlite3_changeset_iter) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_invert(
                nIn: ::os::raw::c_int,
                pIn: *const ::os::raw::c_void,
                pnOut: *mut ::os::raw::c_int,
                ppOut: *mut *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_concat(
                nA: ::os::raw::c_int,
                pA: *mut ::os::raw::c_void,
                nB: ::os::raw::c_int,
                pB: *mut ::os::raw::c_void,
                pnOut: *mut ::os::raw::c_int,
                ppOut: *mut *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_upgrade(
                db: *mut sqlite3,
                zDb: *const ::os::raw::c_char,
                nIn: ::os::raw::c_int,
                pIn: *const ::os::raw::c_void,
                pnOut: *mut ::os::raw::c_int,
                ppOut: *mut *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_changegroup {
            _unused: [u8; 0],
        }
        extern "C" {
            pub fn sqlite3changegroup_new(pp: *mut *mut sqlite3_changegroup) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changegroup_schema(
                arg1: *mut sqlite3_changegroup,
                arg2: *mut sqlite3,
                zDb: *const ::os::raw::c_char,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changegroup_add(
                arg1: *mut sqlite3_changegroup,
                nData: ::os::raw::c_int,
                pData: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changegroup_add_change(
                arg1: *mut sqlite3_changegroup,
                arg2: *mut sqlite3_changeset_iter,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changegroup_output(
                arg1: *mut sqlite3_changegroup,
                pnData: *mut ::os::raw::c_int,
                ppData: *mut *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changegroup_delete(arg1: *mut sqlite3_changegroup);
        }
        extern "C" {
            pub fn sqlite3changeset_apply(
                db: *mut sqlite3,
                nChangeset: ::os::raw::c_int,
                pChangeset: *mut ::os::raw::c_void,
                xFilter: ::option::Option<
                    unsafe extern "C" fn(
                        pCtx: *mut ::os::raw::c_void,
                        zTab: *const ::os::raw::c_char,
                    ) -> ::os::raw::c_int,
                >,
                xConflict: ::option::Option<
                    unsafe extern "C" fn(
                        pCtx: *mut ::os::raw::c_void,
                        eConflict: ::os::raw::c_int,
                        p: *mut sqlite3_changeset_iter,
                    ) -> ::os::raw::c_int,
                >,
                pCtx: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_apply_v2(
                db: *mut sqlite3,
                nChangeset: ::os::raw::c_int,
                pChangeset: *mut ::os::raw::c_void,
                xFilter: ::option::Option<
                    unsafe extern "C" fn(
                        pCtx: *mut ::os::raw::c_void,
                        zTab: *const ::os::raw::c_char,
                    ) -> ::os::raw::c_int,
                >,
                xConflict: ::option::Option<
                    unsafe extern "C" fn(
                        pCtx: *mut ::os::raw::c_void,
                        eConflict: ::os::raw::c_int,
                        p: *mut sqlite3_changeset_iter,
                    ) -> ::os::raw::c_int,
                >,
                pCtx: *mut ::os::raw::c_void,
                ppRebase: *mut *mut ::os::raw::c_void,
                pnRebase: *mut ::os::raw::c_int,
                flags: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sqlite3_rebaser {
            _unused: [u8; 0],
        }
        extern "C" {
            pub fn sqlite3rebaser_create(ppNew: *mut *mut sqlite3_rebaser) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3rebaser_configure(
                arg1: *mut sqlite3_rebaser,
                nRebase: ::os::raw::c_int,
                pRebase: *const ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3rebaser_rebase(
                arg1: *mut sqlite3_rebaser,
                nIn: ::os::raw::c_int,
                pIn: *const ::os::raw::c_void,
                pnOut: *mut ::os::raw::c_int,
                ppOut: *mut *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3rebaser_delete(p: *mut sqlite3_rebaser);
        }
        extern "C" {
            pub fn sqlite3changeset_apply_strm(
                db: *mut sqlite3,
                xInput: ::option::Option<
                    unsafe extern "C" fn(
                        pIn: *mut ::os::raw::c_void,
                        pData: *mut ::os::raw::c_void,
                        pnData: *mut ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pIn: *mut ::os::raw::c_void,
                xFilter: ::option::Option<
                    unsafe extern "C" fn(
                        pCtx: *mut ::os::raw::c_void,
                        zTab: *const ::os::raw::c_char,
                    ) -> ::os::raw::c_int,
                >,
                xConflict: ::option::Option<
                    unsafe extern "C" fn(
                        pCtx: *mut ::os::raw::c_void,
                        eConflict: ::os::raw::c_int,
                        p: *mut sqlite3_changeset_iter,
                    ) -> ::os::raw::c_int,
                >,
                pCtx: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_apply_v2_strm(
                db: *mut sqlite3,
                xInput: ::option::Option<
                    unsafe extern "C" fn(
                        pIn: *mut ::os::raw::c_void,
                        pData: *mut ::os::raw::c_void,
                        pnData: *mut ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pIn: *mut ::os::raw::c_void,
                xFilter: ::option::Option<
                    unsafe extern "C" fn(
                        pCtx: *mut ::os::raw::c_void,
                        zTab: *const ::os::raw::c_char,
                    ) -> ::os::raw::c_int,
                >,
                xConflict: ::option::Option<
                    unsafe extern "C" fn(
                        pCtx: *mut ::os::raw::c_void,
                        eConflict: ::os::raw::c_int,
                        p: *mut sqlite3_changeset_iter,
                    ) -> ::os::raw::c_int,
                >,
                pCtx: *mut ::os::raw::c_void,
                ppRebase: *mut *mut ::os::raw::c_void,
                pnRebase: *mut ::os::raw::c_int,
                flags: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_concat_strm(
                xInputA: ::option::Option<
                    unsafe extern "C" fn(
                        pIn: *mut ::os::raw::c_void,
                        pData: *mut ::os::raw::c_void,
                        pnData: *mut ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pInA: *mut ::os::raw::c_void,
                xInputB: ::option::Option<
                    unsafe extern "C" fn(
                        pIn: *mut ::os::raw::c_void,
                        pData: *mut ::os::raw::c_void,
                        pnData: *mut ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pInB: *mut ::os::raw::c_void,
                xOutput: ::option::Option<
                    unsafe extern "C" fn(
                        pOut: *mut ::os::raw::c_void,
                        pData: *const ::os::raw::c_void,
                        nData: ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pOut: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_invert_strm(
                xInput: ::option::Option<
                    unsafe extern "C" fn(
                        pIn: *mut ::os::raw::c_void,
                        pData: *mut ::os::raw::c_void,
                        pnData: *mut ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pIn: *mut ::os::raw::c_void,
                xOutput: ::option::Option<
                    unsafe extern "C" fn(
                        pOut: *mut ::os::raw::c_void,
                        pData: *const ::os::raw::c_void,
                        nData: ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pOut: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_start_strm(
                pp: *mut *mut sqlite3_changeset_iter,
                xInput: ::option::Option<
                    unsafe extern "C" fn(
                        pIn: *mut ::os::raw::c_void,
                        pData: *mut ::os::raw::c_void,
                        pnData: *mut ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pIn: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changeset_start_v2_strm(
                pp: *mut *mut sqlite3_changeset_iter,
                xInput: ::option::Option<
                    unsafe extern "C" fn(
                        pIn: *mut ::os::raw::c_void,
                        pData: *mut ::os::raw::c_void,
                        pnData: *mut ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pIn: *mut ::os::raw::c_void,
                flags: ::os::raw::c_int,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_changeset_strm(
                pSession: *mut sqlite3_session,
                xOutput: ::option::Option<
                    unsafe extern "C" fn(
                        pOut: *mut ::os::raw::c_void,
                        pData: *const ::os::raw::c_void,
                        nData: ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pOut: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_patchset_strm(
                pSession: *mut sqlite3_session,
                xOutput: ::option::Option<
                    unsafe extern "C" fn(
                        pOut: *mut ::os::raw::c_void,
                        pData: *const ::os::raw::c_void,
                        nData: ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pOut: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changegroup_add_strm(
                arg1: *mut sqlite3_changegroup,
                xInput: ::option::Option<
                    unsafe extern "C" fn(
                        pIn: *mut ::os::raw::c_void,
                        pData: *mut ::os::raw::c_void,
                        pnData: *mut ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pIn: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3changegroup_output_strm(
                arg1: *mut sqlite3_changegroup,
                xOutput: ::option::Option<
                    unsafe extern "C" fn(
                        pOut: *mut ::os::raw::c_void,
                        pData: *const ::os::raw::c_void,
                        nData: ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pOut: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3rebaser_rebase_strm(
                pRebaser: *mut sqlite3_rebaser,
                xInput: ::option::Option<
                    unsafe extern "C" fn(
                        pIn: *mut ::os::raw::c_void,
                        pData: *mut ::os::raw::c_void,
                        pnData: *mut ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pIn: *mut ::os::raw::c_void,
                xOutput: ::option::Option<
                    unsafe extern "C" fn(
                        pOut: *mut ::os::raw::c_void,
                        pData: *const ::os::raw::c_void,
                        nData: ::os::raw::c_int,
                    ) -> ::os::raw::c_int,
                >,
                pOut: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        extern "C" {
            pub fn sqlite3session_config(
                op: ::os::raw::c_int,
                pArg: *mut ::os::raw::c_void,
            ) -> ::os::raw::c_int;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Fts5Context {
            _unused: [u8; 0],
        }
        pub type fts5_extension_function = ::option::Option<
            unsafe extern "C" fn(
                pApi: *const Fts5ExtensionApi,
                pFts: *mut Fts5Context,
                pCtx: *mut sqlite3_context,
                nVal: ::os::raw::c_int,
                apVal: *mut *mut sqlite3_value,
            ),
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Fts5PhraseIter {
            pub a: *const ::os::raw::c_uchar,
            pub b: *const ::os::raw::c_uchar,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Fts5ExtensionApi {
            pub iVersion: ::os::raw::c_int,
            pub xUserData: ::option::Option<
                unsafe extern "C" fn(arg1: *mut Fts5Context) -> *mut ::os::raw::c_void,
            >,
            pub xColumnCount: ::option::Option<
                unsafe extern "C" fn(arg1: *mut Fts5Context) -> ::os::raw::c_int,
            >,
            pub xRowCount: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    pnRow: *mut sqlite3_int64,
                ) -> ::os::raw::c_int,
            >,
            pub xColumnTotalSize: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    iCol: ::os::raw::c_int,
                    pnToken: *mut sqlite3_int64,
                ) -> ::os::raw::c_int,
            >,
            pub xTokenize: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    pText: *const ::os::raw::c_char,
                    nText: ::os::raw::c_int,
                    pCtx: *mut ::os::raw::c_void,
                    xToken: ::option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut ::os::raw::c_void,
                            arg2: ::os::raw::c_int,
                            arg3: *const ::os::raw::c_char,
                            arg4: ::os::raw::c_int,
                            arg5: ::os::raw::c_int,
                            arg6: ::os::raw::c_int,
                        ) -> ::os::raw::c_int,
                    >,
                ) -> ::os::raw::c_int,
            >,
            pub xPhraseCount: ::option::Option<
                unsafe extern "C" fn(arg1: *mut Fts5Context) -> ::os::raw::c_int,
            >,
            pub xPhraseSize: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    iPhrase: ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xInstCount: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    pnInst: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xInst: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    iIdx: ::os::raw::c_int,
                    piPhrase: *mut ::os::raw::c_int,
                    piCol: *mut ::os::raw::c_int,
                    piOff: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xRowid:
                ::option::Option<unsafe extern "C" fn(arg1: *mut Fts5Context) -> sqlite3_int64>,
            pub xColumnText: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    iCol: ::os::raw::c_int,
                    pz: *mut *const ::os::raw::c_char,
                    pn: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xColumnSize: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    iCol: ::os::raw::c_int,
                    pnToken: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xQueryPhrase: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    iPhrase: ::os::raw::c_int,
                    pUserData: *mut ::os::raw::c_void,
                    arg2: ::option::Option<
                        unsafe extern "C" fn(
                            arg1: *const Fts5ExtensionApi,
                            arg2: *mut Fts5Context,
                            arg3: *mut ::os::raw::c_void,
                        ) -> ::os::raw::c_int,
                    >,
                ) -> ::os::raw::c_int,
            >,
            pub xSetAuxdata: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    pAux: *mut ::os::raw::c_void,
                    xDelete: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
                ) -> ::os::raw::c_int,
            >,
            pub xGetAuxdata: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    bClear: ::os::raw::c_int,
                ) -> *mut ::os::raw::c_void,
            >,
            pub xPhraseFirst: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    iPhrase: ::os::raw::c_int,
                    arg2: *mut Fts5PhraseIter,
                    arg3: *mut ::os::raw::c_int,
                    arg4: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xPhraseNext: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    arg2: *mut Fts5PhraseIter,
                    piCol: *mut ::os::raw::c_int,
                    piOff: *mut ::os::raw::c_int,
                ),
            >,
            pub xPhraseFirstColumn: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    iPhrase: ::os::raw::c_int,
                    arg2: *mut Fts5PhraseIter,
                    arg3: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xPhraseNextColumn: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    arg2: *mut Fts5PhraseIter,
                    piCol: *mut ::os::raw::c_int,
                ),
            >,
            pub xQueryToken: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    iPhrase: ::os::raw::c_int,
                    iToken: ::os::raw::c_int,
                    ppToken: *mut *const ::os::raw::c_char,
                    pnToken: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
            pub xInstToken: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Context,
                    iIdx: ::os::raw::c_int,
                    iToken: ::os::raw::c_int,
                    arg2: *mut *const ::os::raw::c_char,
                    arg3: *mut ::os::raw::c_int,
                ) -> ::os::raw::c_int,
            >,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Fts5Tokenizer {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct fts5_tokenizer {
            pub xCreate: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::os::raw::c_void,
                    azArg: *mut *const ::os::raw::c_char,
                    nArg: ::os::raw::c_int,
                    ppOut: *mut *mut Fts5Tokenizer,
                ) -> ::os::raw::c_int,
            >,
            pub xDelete: ::option::Option<unsafe extern "C" fn(arg1: *mut Fts5Tokenizer)>,
            pub xTokenize: ::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut Fts5Tokenizer,
                    pCtx: *mut ::os::raw::c_void,
                    flags: ::os::raw::c_int,
                    pText: *const ::os::raw::c_char,
                    nText: ::os::raw::c_int,
                    xToken: ::option::Option<
                        unsafe extern "C" fn(
                            pCtx: *mut ::os::raw::c_void,
                            tflags: ::os::raw::c_int,
                            pToken: *const ::os::raw::c_char,
                            nToken: ::os::raw::c_int,
                            iStart: ::os::raw::c_int,
                            iEnd: ::os::raw::c_int,
                        ) -> ::os::raw::c_int,
                    >,
                ) -> ::os::raw::c_int,
            >,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct fts5_api {
            pub iVersion: ::os::raw::c_int,
            pub xCreateTokenizer: ::option::Option<
                unsafe extern "C" fn(
                    pApi: *mut fts5_api,
                    zName: *const ::os::raw::c_char,
                    pUserData: *mut ::os::raw::c_void,
                    pTokenizer: *mut fts5_tokenizer,
                    xDestroy: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
                ) -> ::os::raw::c_int,
            >,
            pub xFindTokenizer: ::option::Option<
                unsafe extern "C" fn(
                    pApi: *mut fts5_api,
                    zName: *const ::os::raw::c_char,
                    ppUserData: *mut *mut ::os::raw::c_void,
                    pTokenizer: *mut fts5_tokenizer,
                ) -> ::os::raw::c_int,
            >,
            pub xCreateFunction: ::option::Option<
                unsafe extern "C" fn(
                    pApi: *mut fts5_api,
                    zName: *const ::os::raw::c_char,
                    pUserData: *mut ::os::raw::c_void,
                    xFunction: fts5_extension_function,
                    xDestroy: ::option::Option<unsafe extern "C" fn(arg1: *mut ::os::raw::c_void)>,
                ) -> ::os::raw::c_int,
            >,
        }
        
        #[must_use]
        pub fn SQLITE_STATIC() -> sqlite3_destructor_type {
            None
        }
        
        #[must_use]
        pub fn SQLITE_TRANSIENT() -> sqlite3_destructor_type {
            Some(unsafe { mem::transmute::<isize, unsafe extern "C" fn(*mut ::ffi::c_void)>(-1_isize) })
        }
        
        #[allow(clippy::all)]
        mod bindings {
            include!(concat!(env!("OUT_DIR"), "/bindgen.rs"));
        }
        pub use bindings::*;
        
        impl Default for sqlite3_vtab {
            fn default() -> Self {
                unsafe { mem::zeroed() }
            }
        }
        
        impl Default for sqlite3_vtab_cursor {
            fn default() -> Self {
                unsafe { mem::zeroed() }
            }
        }

    }

    mod error
    {
        use ::
        {
            *,
        };
        /*
        use crate::types::FromSqlError;
        use crate::types::Type;
        use crate::{errmsg_to_string, ffi, Result};
        use ::error;
        use ::fmt;
        use ::os::raw::c_int;
        use ::path::PathBuf;
        use ::str;
        */
        /// Enum listing possible errors from rusqlite.
        #[derive(Debug)]
        #[allow(clippy::enum_variant_names)]
        #[non_exhaustive]
        pub enum Error {
            /// An error from an underlying SQLite call.
            SqliteFailure(ffi::Error, Option<String>),
        
            /// Error reported when attempting to open a connection when SQLite was
            /// configured to allow single-threaded use only.
            SqliteSingleThreadedMode,
        
            /// Error when the value of a particular column is requested, but it cannot
            /// be converted to the requested Rust type.
            FromSqlConversionFailure(usize, Type, Box<dyn error::Error + Send + Sync + 'static>),
        
            /// Error when SQLite gives us an integral value outside the range of the
            /// requested type (e.g., trying to get the value 1000 into a `u8`).
            IntegralValueOutOfRange(usize, i64),
        
            /// Error converting a string to UTF-8.
            Utf8Error(str::Utf8Error),
        
            /// Error converting a string to a C-compatible string because it contained
            /// an embedded nul.
            NulError( ::ffi::NulError),
        
            /// Error when using SQL named parameters and passing a parameter name not
            /// present in the SQL.
            InvalidParameterName(String),
        
            /// Error converting a file path to a string.
            InvalidPath(PathBuf),
        
            /// Error returned when an [`execute`](crate::Connection::execute) call
            /// returns rows.
            ExecuteReturnedResults,
        
            /// Error when a query that was expected to return at least one row (e.g.,
            /// for [`query_row`](crate::Connection::query_row)) did not return any.
            QueryReturnedNoRows,
        
            /// Error when the value of a particular column is requested, but the index
            /// is out of range for the statement.
            InvalidColumnIndex(usize),
        
            /// Error when the value of a named column is requested, but no column
            /// matches the name for the statement.
            InvalidColumnName(String),
        
            /// Error when the value of a particular column is requested, but the type
            /// of the result in that column cannot be converted to the requested
            /// Rust type.
            InvalidColumnType(usize, String, Type),
        
            /// Error when a query that was expected to insert one row did not insert
            /// any or insert many.
            StatementChangedRows(usize),
        
            /// Error available for the implementors of the
            /// [`ToSql`](crate::types::ToSql) trait.
            ToSqlConversionFailure(Box<dyn error::Error + Send + Sync + 'static>),
        
            /// Error when the SQL is not a `SELECT`, is not read-only.
            InvalidQuery,
        
            /// An unwinding panic occurs in a UDF (user-defined function).
            UnwindingPanic,
        
            /// Error when the SQL contains multiple statements.
            MultipleStatement,
            /// Error when the number of bound parameters does not match the number of
            /// parameters in the query.
            InvalidParameterCount(usize, usize),
        }
        
        impl PartialEq for Error {
            fn eq(&self, other: &Error) -> bool {
                match (self, other) {
                    (Error::SqliteFailure(e1, s1), Error::SqliteFailure(e2, s2)) => e1 == e2 && s1 == s2,
                    (Error::SqliteSingleThreadedMode, Error::SqliteSingleThreadedMode) => true,
                    (Error::IntegralValueOutOfRange(i1, n1), Error::IntegralValueOutOfRange(i2, n2)) => {
                        i1 == i2 && n1 == n2
                    }
                    (Error::Utf8Error(e1), Error::Utf8Error(e2)) => e1 == e2,
                    (Error::NulError(e1), Error::NulError(e2)) => e1 == e2,
                    (Error::InvalidParameterName(n1), Error::InvalidParameterName(n2)) => n1 == n2,
                    (Error::InvalidPath(p1), Error::InvalidPath(p2)) => p1 == p2,
                    (Error::ExecuteReturnedResults, Error::ExecuteReturnedResults) => true,
                    (Error::QueryReturnedNoRows, Error::QueryReturnedNoRows) => true,
                    (Error::InvalidColumnIndex(i1), Error::InvalidColumnIndex(i2)) => i1 == i2,
                    (Error::InvalidColumnName(n1), Error::InvalidColumnName(n2)) => n1 == n2,
                    (Error::InvalidColumnType(i1, n1, t1), Error::InvalidColumnType(i2, n2, t2)) => {
                        i1 == i2 && t1 == t2 && n1 == n2
                    }
                    (Error::StatementChangedRows(n1), Error::StatementChangedRows(n2)) => n1 == n2,
                }
            }
        }
        
        impl From<str::Utf8Error> for Error {
            #[cold]
            fn from(err: str::Utf8Error) -> Error {
                Error::Utf8Error(err)
            }
        }
        
        impl From< ::ffi::NulError> for Error {
            #[cold]
            fn from(err: ::ffi::NulError) -> Error {
                Error::NulError(err)
            }
        }
        
        const UNKNOWN_COLUMN: usize = usize::MAX;
        
        /// The conversion isn't precise, but it's convenient to have it
        /// to allow use of `get_raw().as_()?` in callbacks that take `Error`.
        impl From<FromSqlError> for Error {
            #[cold]
            fn from(err: FromSqlError) -> Error {
                // The error type requires index and type fields, but they aren't known in this
                // context.
                match err {
                    FromSqlError::OutOfRange(val) => Error::IntegralValueOutOfRange(UNKNOWN_COLUMN, val),
                    FromSqlError::InvalidBlobSize { .. } => {
                        Error::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Blob, Box::new(err))
                    }
                    FromSqlError::Other(source) => {
                        Error::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Null, source)
                    }
                    _ => Error::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Null, Box::new(err)),
                }
            }
        }
        
        impl From<ffi::InitError> for Error {
            #[cold]
            fn from(err: ffi::InitError) -> Error {
                Error::InitError(err)
            }
        }
        
        impl fmt::Display for Error {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match *self {
                    Error::SqliteFailure(ref err, None) => err.fmt(f),
                    Error::SqliteFailure(_, Some(ref s)) => write!(f, "{s}"),
                    Error::SqliteSingleThreadedMode => write!(
                        f,
                        "SQLite was compiled or configured for single-threaded use only"
                    ),
                    Error::FromSqlConversionFailure(i, ref t, ref err) => {
                        if i != UNKNOWN_COLUMN {
                            write!(f, "Conversion error from type {t} at index: {i}, {err}")
                        } else {
                            err.fmt(f)
                        }
                    }
                    Error::IntegralValueOutOfRange(col, val) => {
                        if col != UNKNOWN_COLUMN {
                            write!(f, "Integer {val} out of range at index {col}")
                        } else {
                            write!(f, "Integer {val} out of range")
                        }
                    }
                    Error::Utf8Error(ref err) => err.fmt(f),
                    Error::NulError(ref err) => err.fmt(f),
                    Error::InvalidParameterName(ref name) => write!(f, "Invalid parameter name: {name}"),
                    Error::InvalidPath(ref p) => write!(f, "Invalid path: {}", p.to_string_lossy()),
                    Error::ExecuteReturnedResults => {
                        write!(f, "Execute returned results - did you mean to call query?")
                    }
                    Error::QueryReturnedNoRows => write!(f, "Query returned no rows"),
                    Error::InvalidColumnIndex(i) => write!(f, "Invalid column index: {i}"),
                    Error::InvalidColumnName(ref name) => write!(f, "Invalid column name: {name}"),
                    Error::InvalidColumnType(i, ref name, ref t) => {
                        write!(f, "Invalid column type {t} at index: {i}, name: {name}")
                    }
                    Error::InvalidParameterCount(i1, n1) => write!(
                        f,
                        "Wrong number of parameters passed to query. Got {i1}, needed {n1}"
                    ),
                    Error::StatementChangedRows(i) => write!(f, "Query changed {i} rows"),
                }
            }
        }
        
        impl error::Error for Error {
            fn source(&self) -> Option<&(dyn error::Error + 'static)> {
                match *self {
                    Error::SqliteFailure(ref err, _) => Some(err),
                    Error::Utf8Error(ref err) => Some(err),
                    Error::NulError(ref err) => Some(err),
        
                    Error::IntegralValueOutOfRange(..)
                    | Error::SqliteSingleThreadedMode
                    | Error::InvalidParameterName(_)
                    | Error::ExecuteReturnedResults
                    | Error::QueryReturnedNoRows
                    | Error::InvalidColumnIndex(_)
                    | Error::InvalidColumnName(_)
                    | Error::InvalidColumnType(..)
                    | Error::InvalidPath(_)
                    | Error::InvalidParameterCount(..)
                    | Error::StatementChangedRows(_)
                    | Error::InvalidQuery
                    | Error::MultipleStatement => None,
        
                    Error::FromSqlConversionFailure(_, _, ref err)
                    | Error::ToSqlConversionFailure(ref err) => Some(&**err),
        
                    Error::UnwindingPanic => None,
                }
            }
        }
        
        impl Error {
            /// Returns the underlying SQLite error if this is [`Error::SqliteFailure`].
            #[inline]
            #[must_use]
            pub fn sqlite_error(&self) -> Option<&ffi::Error> {
                match self {
                    Self::SqliteFailure(error, _) => Some(error),
                    _ => None,
                }
            }
        
            /// Returns the underlying SQLite error code if this is
            /// [`Error::SqliteFailure`].
            #[inline]
            #[must_use]
            pub fn sqlite_error_code(&self) -> Option<ffi::ErrorCode> {
                self.sqlite_error().map(|error| error.code)
            }
        }
        
        #[cold]
        pub fn error_from_sqlite_code(code: c_int, message: Option<String>) -> Error {
            Error::SqliteFailure(ffi::Error::new(code), message)
        }
        
        #[cold]
        pub unsafe fn error_from_handle(db: *mut ffi::sqlite3, code: c_int) -> Error {
            let message = if db.is_null() {
                None
            } else {
                Some(errmsg_to_string(ffi::sqlite3_errmsg(db)))
            };
            error_from_sqlite_code(code, message)
        }

        pub fn check(code: c_int) -> Result<()> {
            if code != crate::ffi::SQLITE_OK {
                Err(error_from_sqlite_code(code, None))
            } else {
                Ok(())
            }
        }
        
        /// Transform Rust error to SQLite error (message and code).
        pub unsafe fn to_sqlite_error(e: &Error, err_msg: *mut *mut ::os::raw::c_char) -> c_int {
            use crate::util::alloc;
            match e {
                Error::SqliteFailure(err, s) => {
                    if let Some(s) = s {
                        *err_msg = alloc(s);
                    }
                    err.extended_code
                }
                err => {
                    *err_msg = alloc(&err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }
    }
    /*
    #[cfg(not(feature = "loadable_extension"))]
    pub mod auto_extension;
    #[cfg(feature = "backup")]
    #[cfg_attr(docsrs, doc(cfg(feature = "backup")))]
    pub mod backup;
    #[cfg(feature = "blob")]
    #[cfg_attr(docsrs, doc(cfg(feature = "blob")))]
    pub mod blob;;
    #[cfg(feature = "collation")]
    #[cfg_attr(docsrs, doc(cfg(feature = "collation")))]
    mod collation;
    
    #[cfg(any(feature = "functions", feature = "vtab"))]
    mod context;
    #[cfg(feature = "functions")]
    #[cfg_attr(docsrs, doc(cfg(feature = "functions")))]
    pub mod functions;
    #[cfg(feature = "hooks")]
    #[cfg_attr(docsrs, doc(cfg(feature = "hooks")))]
    pub mod hooks;
    #[cfg(feature = "limits")]
    #[cfg_attr(docsrs, doc(cfg(feature = "limits")))]
    pub mod limits;
    #[cfg(feature = "load_extension")]
    mod load_extension_guard;
    #[cfg(feature = "serialize")]
    #[cfg_attr(docsrs, doc(cfg(feature = "serialize")))]
    pub mod serialize;
    #[cfg(feature = "session")]
    #[cfg_attr(docsrs, doc(cfg(feature = "session")))]
    pub mod session;
    #[cfg(feature = "trace")]
    #[cfg_attr(docsrs, doc(cfg(feature = "trace")))]
    pub mod trace;
    
    #[cfg(feature = "unlock_notify")]
    mod unlock_notify;
    
    #[cfg(feature = "vtab")]
    #[cfg_attr(docsrs, doc(cfg(feature = "vtab")))]
    pub mod vtab; */

    pub mod auto
    {
        //! Automatic extension loading
        use ::
        {
            *,
        };
        /*
        use super::ffi;
        use crate::error::{check, to_sqlite_error};
        use crate::{Connection, Error, Result};
        use ::os::raw::{c_char, c_int};
        use ::panic::catch_unwind;
        */
        /// Automatic extension initialization routine
        pub type AutoExtension = fn(Connection) -> Result<()>;
        
        /// Raw automatic extension initialization routine
        pub type RawAutoExtension = unsafe extern "C" fn(
            db: *mut ffi::sqlite3,
            pz_err_msg: *mut *mut c_char,
            _: *const ffi::sqlite3_api_routines,
        ) -> c_int;
        
        /// Bridge between `RawAutoExtension` and `AutoExtension`
        pub unsafe fn init_auto_extension(
            db: *mut ffi::sqlite3,
            pz_err_msg: *mut *mut c_char,
            ax: AutoExtension,
        ) -> c_int {
            let r = catch_unwind(|| {
                let c = Connection::from_handle(db);
                c.and_then(ax)
            })
            .unwrap_or_else(|_| Err(Error::UnwindingPanic));
            match r {
                Err(e) => to_sqlite_error(&e, pz_err_msg),
                _ => ffi::SQLITE_OK,
            }
        }
        
        /// Register au auto-extension
        pub unsafe fn register_auto_extension(ax: RawAutoExtension) -> Result<()> {
            check(ffi::sqlite3_auto_extension(Some(ax)))
        }
        
        /// Unregister the initialization routine
        pub fn cancel_auto_extension(ax: RawAutoExtension) -> bool {
            unsafe { ffi::sqlite3_cancel_auto_extension(Some(ax)) == 1 }
        }
        
        /// Disable all automatic extensions previously registered
        pub fn reset_auto_extension() {
            unsafe { ffi::sqlite3_reset_auto_extension() }
        }

    }
    
    pub mod busy
    {
        //! Busy handler (when the database is locked)
        use ::
        {
            *,
        };
        /*
        use ::mem;
        use ::os::raw::{c_int, c_void};
        use ::panic::catch_unwind;
        use ::ptr;
        use ::time::Duration;
        
        use crate::ffi;
        use crate::{Connection, InnerConnection, Result};
        */
        
        impl Connection {
            /// Set a busy handler that sleeps for a specified amount of time when a
            /// table is locked.
            pub fn busy_timeout(&self, timeout: Duration) -> Result<()> {
                let ms: i32 = timeout
                    .as_secs()
                    .checked_mul(1000)
                    .and_then(|t| t.checked_add(timeout.subsec_millis().into()))
                    .and_then(|t| t.try_into().ok())
                    .expect("too big");
                self.db.borrow_mut().busy_timeout(ms)
            }
        
            /// Register a callback to handle `SQLITE_BUSY` errors.
            pub fn busy_handler(&self, callback: Option<fn(i32) -> bool>) -> Result<()> {
                unsafe extern "C" fn busy_handler_callback(p_arg: *mut c_void, count: c_int) -> c_int {
                    let handler_fn: fn(i32) -> bool = mem::transmute(p_arg);
                    c_int::from(catch_unwind(|| handler_fn(count)).unwrap_or_default())
                }
                let c = self.db.borrow_mut();
                let r = match callback {
                    Some(f) => unsafe {
                        ffi::sqlite3_busy_handler(c.db(), Some(busy_handler_callback), f as *mut c_void)
                    },
                    None => unsafe { ffi::sqlite3_busy_handler(c.db(), None, ptr::null_mut()) },
                };
                c.decode_result(r)
            }
        }
        
        impl InnerConnection {
            #[inline] fn busy_timeout(&mut self, timeout: c_int) -> Result<()> {
                let r = unsafe { ffi::sqlite3_busy_timeout(self.db, timeout) };
                self.decode_result(r)
            }
        }
    }
    
    pub mod cache
    {
        //! Prepared statements cache for faster execution.
        use ::
        {
            *,
        };
        /*
        use crate::raw_statement::RawStatement;
        use crate::{Connection, PrepFlags, Result, Statement};
        use hashlink::LruCache;
        use ::cell::RefCell;
        use ::ops::{Deref, DerefMut};
        use ::sync::Arc;
        */
        impl Connection {
            /// Prepare a SQL statement for execution, returning a previously prepared
            /// (but not currently in-use) statement if one is available.
            #[inline] pub fn prepare_cached(&self, sql: &str) -> Result<CachedStatement<'_>> {
                self.cache.get(self, sql)
            }
        
            /// Set the maximum number of cached prepared statements this connection
            /// will hold.
            #[inline] pub fn set_prepared_statement_cache_capacity(&self, capacity: usize) {
                self.cache.set_capacity(capacity);
            }
        
            /// Remove/finalize all prepared statements currently in the cache.
            #[inline] pub fn flush_prepared_statement_cache(&self) {
                self.cache.flush();
            }
        }
        
        /// Prepared statements LRU cache.
        #[derive(Debug)]
        pub struct StatementCache(RefCell<LruCache<Arc<str>, RawStatement>>);
        
        #[allow(clippy::non_send_fields_in_send_ty)]
        unsafe impl Send for StatementCache {}
        
        /// Cacheable statement.
        pub struct CachedStatement<'conn> {
            stmt: Option<Statement<'conn>>,
            cache: &'conn StatementCache,
        }
        
        impl<'conn> Deref for CachedStatement<'conn> {
            type Target = Statement<'conn>;
        
            #[inline] fn deref(&self) -> &Statement<'conn> {
                self.stmt.as_ref().unwrap()
            }
        }
        
        impl<'conn> DerefMut for CachedStatement<'conn> {
            #[inline] fn deref_mut(&mut self) -> &mut Statement<'conn> {
                self.stmt.as_mut().unwrap()
            }
        }
        
        impl Drop for CachedStatement<'_> {
            #[allow(unused_must_use)]
            #[inline] fn drop(&mut self) {
                if let Some(stmt) = self.stmt.take() {
                    self.cache.cache_stmt(unsafe { stmt.into_raw() });
                }
            }
        }
        
        impl CachedStatement<'_> {
            #[inline] fn new<'conn>(stmt: Statement<'conn>, cache: &'conn StatementCache) -> CachedStatement<'conn> {
                CachedStatement {
                    stmt: Some(stmt),
                    cache,
                }
            }
        
            /// Discard the statement, preventing it from being returned to its
            /// [`Connection`]'s collection of cached statements.
            #[inline] pub fn discard(mut self) {
                self.stmt = None;
            }
        }
        
        impl StatementCache {
            /// Create a statement cache.
            #[inline] pub fn with_capacity(capacity: usize) -> StatementCache {
                StatementCache(RefCell::new(LruCache::new(capacity)))
            }
        
            #[inline] fn set_capacity(&self, capacity: usize) {
                self.0.borrow_mut().set_capacity(capacity);
            }
        
            // Search the cache for a prepared-statement object that implements `sql`.
            fn get<'conn>(
                &'conn self,
                conn: &'conn Connection,
                sql: &str,
            ) -> Result<CachedStatement<'conn>> {
                let trimmed = sql.trim();
                let mut cache = self.0.borrow_mut();
                let stmt = match cache.remove(trimmed) {
                    Some(raw_stmt) => Ok(Statement::new(conn, raw_stmt)),
                    None => conn.prepare_with_flags(trimmed, PrepFlags::SQLITE_PREPARE_PERSISTENT),
                };
                stmt.map(|mut stmt| {
                    stmt.stmt.set_statement_cache_key(trimmed);
                    CachedStatement::new(stmt, self)
                })
            }
        
            // Return a statement to the cache.
            fn cache_stmt(&self, mut stmt: RawStatement) {
                if stmt.is_null() {
                    return;
                }
                let mut cache = self.0.borrow_mut();
                stmt.clear_bindings();
                if let Some(sql) = stmt.statement_cache_key() {
                    cache.insert(sql, stmt);
                } else {
                    debug_assert!(
                        false,
                        "bug in statement cache code, statement returned to cache that without key"
                    );
                }
            }
        
            #[inline] fn flush(&self) {
                let mut cache = self.0.borrow_mut();
                cache.clear();
            }
        }
    }
    
    pub mod column
    {
        use ::
        {
            *,
        };
        /*
        use ::str;
        
        use crate::{Error, Result, Statement};
        */
        
        /// Information about a column of a SQLite query.
        #[derive(Debug)]
        pub struct Column<'stmt> {
            name: &'stmt str,
            decl_type: Option<&'stmt str>,
        }
        
        impl Column<'_> {
            /// Returns the name of the column.
            #[inline]
            #[must_use]
            pub fn name(&self) -> &str {
                self.name
            }
        
            /// Returns the type of the column (`None` for expression).
            #[inline]
            #[must_use]
            pub fn decl_type(&self) -> Option<&str> {
                self.decl_type
            }
        }
        
        impl Statement<'_> {
            /// Get all the column names in the result set of the prepared statement.
            ///
            /// If associated DB schema can be altered concurrently, you should make
            /// sure that current statement has already been stepped once before
            /// calling this method.
            pub fn column_names(&self) -> Vec<&str> {
                let n = self.column_count();
                let mut cols = Vec::with_capacity(n);
                for i in 0..n {
                    let s = self.column_name_unwrap(i);
                    cols.push(s);
                }
                cols
            }
        
            /// Return the number of columns in the result set returned by the prepared
            /// statement.
            #[inline] pub fn column_count(&self) -> usize {
                self.stmt.column_count()
            }
        
            /// Check that column name reference lifetime is limited.
            #[inline] pub fn column_name_unwrap(&self, col: usize) -> &str {
                // Just panic if the bounds are wrong for now, we never call this
                // without checking first.
                self.column_name(col).expect("Column out of bounds")
            }
        
            /// Returns the name assigned to a particular column in the result set
            /// returned by the prepared statement.
            #[inline] pub fn column_name(&self, col: usize) -> Result<&str> {
                self.stmt
                    .column_name(col)
                    // clippy::or_fun_call (nightly) vs clippy::unnecessary-lazy-evaluations (stable)
                    .ok_or(Error::InvalidColumnIndex(col))
                    .map(|slice| {
                        slice
                            .to_str()
                            .expect("Invalid UTF-8 sequence in column name")
                    })
            }
        
            /// Returns the column index in the result set for a given column name.
            #[inline] pub fn column_index(&self, name: &str) -> Result<usize> {
                let bytes = name.as_bytes();
                let n = self.column_count();
                for i in 0..n {
                    // Note: `column_name` is only fallible if `i` is out of bounds,
                    // which we've already checked.
                    if bytes.eq_ignore_ascii_case(self.stmt.column_name(i).unwrap().to_bytes()) {
                        return Ok(i);
                    }
                }
                Err(Error::InvalidColumnName(String::from(name)))
            }
        
            /// Returns a slice describing the columns of the result of the query.
            pub fn columns(&self) -> Vec<Column> {
                let n = self.column_count();
                let mut cols = Vec::with_capacity(n);
                for i in 0..n {
                    let name = self.column_name_unwrap(i);
                    let slice = self.stmt.column_decltype(i);
                    let decl_type = slice.map(|s| {
                        s.to_str()
                            .expect("Invalid UTF-8 sequence in column declaration")
                    });
                    cols.push(Column { name, decl_type });
                }
                cols
            }
        }
    }
    
    pub mod config
    {
        //! Configure database connections
        use ::
        {
            *,
        };
        /*
        use ::os::raw::c_int;
        
        use crate::error::check;
        use crate::ffi;
        use crate::{Connection, Result};
        */
        
        /// Database Connection Configuration Options
        #[repr(i32)]
        #[derive(Copy, Clone, Debug)]
        #[allow(non_snake_case, non_camel_case_types)]
        #[non_exhaustive]
        #[allow(clippy::upper_case_acronyms)]
        pub enum DbConfig {
            //SQLITE_DBCONFIG_MAINDBNAME = 1000, /* const char* */
            //SQLITE_DBCONFIG_LOOKASIDE = 1001,  /* void* int int */
            /// Enable or disable the enforcement of foreign key constraints.
            SQLITE_DBCONFIG_ENABLE_FKEY = ffi::SQLITE_DBCONFIG_ENABLE_FKEY,
            /// Enable or disable triggers.
            SQLITE_DBCONFIG_ENABLE_TRIGGER = ffi::SQLITE_DBCONFIG_ENABLE_TRIGGER,
            /// Enable or disable the fts3_tokenizer() function which is part of the
            /// FTS3 full-text search engine extension.
            SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = ffi::SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, // 3.12.0
            //SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005,
            /// In WAL mode, enable or disable the checkpoint operation before closing
            /// the connection.
            SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE = 1006, // 3.16.2
            /// Activates or deactivates the query planner stability guarantee (QPSG).
            SQLITE_DBCONFIG_ENABLE_QPSG = 1007, // 3.20.0
            /// Includes or excludes output for any operations performed by trigger
            /// programs from the output of EXPLAIN QUERY PLAN commands.
            SQLITE_DBCONFIG_TRIGGER_EQP = 1008, // 3.22.0
            /// Activates or deactivates the "reset" flag for a database connection.
            /// Run VACUUM with this flag set to reset the database.
            SQLITE_DBCONFIG_RESET_DATABASE = 1009, // 3.24.0
            /// Activates or deactivates the "defensive" flag for a database connection.
            SQLITE_DBCONFIG_DEFENSIVE = 1010, // 3.26.0
        }
        
        impl Connection {
            /// Returns the current value of a `config`.
            #[inline] pub fn db_config(&self, config: DbConfig) -> Result<bool> {
                let c = self.db.borrow();
                unsafe {
                    let mut val = 0;
                    check(ffi::sqlite3_db_config(
                        c.db(),
                        config as c_int,
                        -1,
                        &mut val,
                    ))?;
                    Ok(val != 0)
                }
            }
        
            /// Make configuration changes to a database connection
            #[inline] pub fn set_db_config(&self, config: DbConfig, new_val: bool) -> Result<bool> {
                let c = self.db.borrow_mut();
                unsafe {
                    let mut val = 0;
                    check(ffi::sqlite3_db_config(
                        c.db(),
                        config as c_int,
                        new_val as c_int,
                        &mut val,
                    ))?;
                    Ok(val != 0)
                }
            }
        }
    }
    
    pub mod inner_connection
    {
        use ::
        {
            *,
        };
        /*
        use ::ffi::CStr;
        use ::os::raw::{c_char, c_int};
        #[cfg(feature = "load_extension")]
        use ::path::Path;
        use ::ptr;
        use ::str;
        use ::sync::{Arc, Mutex};
        
        use super::ffi;
        use super::str_for_sqlite;
        use super::{Connection, InterruptHandle, OpenFlags, PrepFlags, Result};
        use crate::error::{error_from_handle, error_from_sqlite_code, error_with_offset, Error};
        use crate::raw_statement::RawStatement;
        use crate::statement::Statement;
        use crate::version_number;
        */
        
        pub struct InnerConnection {
            pub db: *mut ffi::sqlite3,
            interrupt_lock: Arc<Mutex<*mut ffi::sqlite3>>,
        }
        
        unsafe impl Send for InnerConnection {}
        
        impl InnerConnection
        {
            #[inline] pub unsafe fn new(db: *mut ffi::sqlite3, owned: bool) -> InnerConnection {
                InnerConnection {
                    db,
                    interrupt_lock: Arc::new(Mutex::new(db)),
                }
            }
        
            pub fn open_with_flags(
                c_path: &CStr,
                mut flags: OpenFlags,
                vfs: Option<&CStr>,
            ) -> Result<InnerConnection> {
                ensure_safe_sqlite_threading_mode()?;
        
                let z_vfs = match vfs {
                    Some(c_vfs) => c_vfs.as_ptr(),
                    None => ptr::null(),
                };
        
                // turn on extended results code before opening database to have a better diagnostic if a failure happens
                let exrescode = if version_number() >= 3_037_000 {
                    flags |= OpenFlags::SQLITE_OPEN_EXRESCODE;
                    true
                } else {
                    false // flag SQLITE_OPEN_EXRESCODE is ignored by SQLite version < 3.37.0
                };
        
                unsafe {
                    let mut db: *mut ffi::sqlite3 = ptr::null_mut();
                    let r = ffi::sqlite3_open_v2(c_path.as_ptr(), &mut db, flags.bits(), z_vfs);
                    if r != ffi::SQLITE_OK {
                        let e = if db.is_null() {
                            error_from_sqlite_code(r, Some(c_path.to_string_lossy().to_string()))
                        } else {
                            let mut e = error_from_handle(db, r);
                            if let Error::SqliteFailure(
                                ffi::Error {
                                    code: ffi::ErrorCode::CannotOpen,
                                    ..
                                },
                                Some(msg),
                            ) = e
                            {
                                e = Error::SqliteFailure(
                                    ffi::Error::new(r),
                                    Some(format!("{msg}: {}", c_path.to_string_lossy())),
                                );
                            }
                            ffi::sqlite3_close(db);
                            e
                        };
        
                        return Err(e);
                    }
        
                    // attempt to turn on extended results code; don't fail if we can't.
                    if !exrescode {
                        ffi::sqlite3_extended_result_codes(db, 1);
                    }
        
                    let r = ffi::sqlite3_busy_timeout(db, 5000);
                    if r != ffi::SQLITE_OK {
                        let e = error_from_handle(db, r);
                        ffi::sqlite3_close(db);
                        return Err(e);
                    }
        
                    Ok(InnerConnection::new(db, true))
                }
            }
        
            #[inline] pub fn db(&self) -> *mut ffi::sqlite3 {
                self.db
            }
        
            #[inline] pub fn decode_result(&self, code: c_int) -> Result<()> {
                unsafe { InnerConnection::decode_result_raw(self.db(), code) }
            }
        
            #[inline]
            unsafe fn decode_result_raw(db: *mut ffi::sqlite3, code: c_int) -> Result<()> {
                if code == ffi::SQLITE_OK {
                    Ok(())
                } else {
                    Err(error_from_handle(db, code))
                }
            }
            
            pub fn close(&mut self) -> Result<()> {
                if self.db.is_null() {
                    return Ok(());
                }
                self.remove_hooks();
                self.remove_preupdate_hook();
                let mut shared_handle = self.interrupt_lock.lock().unwrap();
                assert!(
                    !shared_handle.is_null(),
                    "Bug: Somehow interrupt_lock was cleared before the DB was closed"
                );
                if !self.owned {
                    self.db = ptr::null_mut();
                    return Ok(());
                }
                unsafe {
                    let r = ffi::sqlite3_close(self.db);
                    // Need to use _raw because _guard has a reference out, and
                    // decode_result takes &mut self.
                    let r = InnerConnection::decode_result_raw(self.db, r);
                    if r.is_ok() {
                        *shared_handle = ptr::null_mut();
                        self.db = ptr::null_mut();
                    }
                    r
                }
            }
        
            #[inline] pub fn get_interrupt_handle(&self) -> InterruptHandle {
                InterruptHandle {
                    db_lock: Arc::clone(&self.interrupt_lock),
                }
            }
        
            #[inline] pub fn last_insert_rowid(&self) -> i64 {
                unsafe { ffi::sqlite3_last_insert_rowid(self.db()) }
            }
        
            pub fn prepare<'a>(
                &mut self,
                conn: &'a Connection,
                sql: &str,
                flags: PrepFlags,
            ) -> Result<Statement<'a>> {
                let mut c_stmt: *mut ffi::sqlite3_stmt = ptr::null_mut();
                let (c_sql, len, _) = str_for_sqlite(sql.as_bytes())?;
                let mut c_tail: *const c_char = ptr::null();
                let r = unsafe { self.prepare_(c_sql, len, flags, &mut c_stmt, &mut c_tail) };

                // If there is an error, *ppStmt is set to NULL.
                if r != ffi::SQLITE_OK {
                    return Err(unsafe { error_with_offset(self.db, r, sql) });
                }
                // If the input text contains no SQL (if the input is an empty string or a
                // comment) then *ppStmt is set to NULL.
                let tail = if c_tail.is_null() {
                    0
                } else {
                    let n = (c_tail as isize) - (c_sql as isize);
                    if n <= 0 || n >= len as isize {
                        0
                    } else {
                        n as usize
                    }
                };
                Ok(Statement::new(conn, unsafe {
                    RawStatement::new(c_stmt, tail)
                }))
            }
                    
            #[inline] pub fn changes(&self) -> u64 {
                unsafe {
                    ffi::sqlite3_changes(self.db()) as u64
                }
            }
        
            #[inline] pub fn total_changes(&self) -> u64 {
                unsafe {
                    ffi::sqlite3_total_changes(self.db()) as u64
                }
            }
        
            #[inline] pub fn is_autocommit(&self) -> bool {
                unsafe { ffi::sqlite3_get_autocommit(self.db()) != 0 }
            }
        
            pub fn is_busy(&self) -> bool {
                let db = self.db();
                unsafe {
                    let mut stmt = ffi::sqlite3_next_stmt(db, ptr::null_mut());
                    while !stmt.is_null() {
                        if ffi::sqlite3_stmt_busy(stmt) != 0 {
                            return true;
                        }
                        stmt = ffi::sqlite3_next_stmt(db, stmt);
                    }
                }
                false
            }
        
            pub fn cache_flush(&mut self) -> Result<()> {
                crate::error::check(unsafe { ffi::sqlite3_db_cacheflush(self.db()) })
            }
                    
            pub fn db_readonly(&self, db_name: super::DatabaseName<'_>) -> Result<bool> {
                let name = db_name.as_cstring()?;
                let r = unsafe { ffi::sqlite3_db_readonly(self.db, name.as_ptr()) };
                match r {
                    0 => Ok(false),
                    1 => Ok(true),
                    -1 => Err(Error::SqliteFailure(
                        ffi::Error::new(ffi::SQLITE_MISUSE),
                        Some(format!("{db_name:?} is not the name of a database")),
                    )),
                    _ => Err(error_from_sqlite_code(
                        r,
                        Some("Unexpected result".to_owned()),
                    )),
                }
            }
        }
        
        impl Drop for InnerConnection {
            #[inline] fn drop(&mut self) {
                self.close();
            }
        }
    }
    
    pub mod params
    {
        use ::
        {
            *,
        };
        /*
        use crate::{Result, Statement, ToSql};
        */
        
        /// Trait used for [sets of parameter][params] passed into SQL
        /// statements/queries.
        pub trait Params: Sealed {
            #[doc(hidden)]
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()>;
        }
        
        impl Sealed for [&(dyn ToSql + Send + Sync); 0] {}
        impl Params for [&(dyn ToSql + Send + Sync); 0] {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.ensure_parameter_count(0)
            }
        }
        
        impl Sealed for &[&dyn ToSql] {}
        impl Params for &[&dyn ToSql] {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.bind_parameters(self)
            }
        }
        
        impl Sealed for &[(&str, &dyn ToSql)] {}
        impl Params for &[(&str, &dyn ToSql)] {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.bind_parameters_named(self)
            }
        }
        
        // Manual impls for the empty and singleton tuple, although the rest are covered
        // by macros.
        impl Sealed for () {}
        impl Params for () {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.ensure_parameter_count(0)
            }
        }
        
        // I'm pretty sure you could tweak the `single_tuple_impl` to accept this.
        impl<T: ToSql> Sealed for (T,) {}
        impl<T: ToSql> Params for (T,) {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.ensure_parameter_count(1)?;
                stmt.raw_bind_parameter(1, self.0)?;
                Ok(())
            }
        }
        
        macro_rules! single_tuple_impl 
        {
            ($count:literal : $(($field:tt $ftype:ident)),* $(,)?) =>
            {
                impl<$($ftype,)*> Sealed for ($($ftype,)*) where $($ftype: ToSql,)* {}
                impl<$($ftype,)*> Params for ($($ftype,)*) where $($ftype: ToSql,)* {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.ensure_parameter_count($count)?;
                        $({
                            debug_assert!($field < $count);
                            stmt.raw_bind_parameter($field + 1, self.$field)?;
                        })+
                        Ok(())
                    }
                }
            }
        }
        
        single_tuple_impl!(2: (0 A), (1 B));
        single_tuple_impl!(3: (0 A), (1 B), (2 C));
        single_tuple_impl!(4: (0 A), (1 B), (2 C), (3 D));
        single_tuple_impl!(5: (0 A), (1 B), (2 C), (3 D), (4 E));
        single_tuple_impl!(6: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F));
        single_tuple_impl!(7: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G));
        single_tuple_impl!(8: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H));
        single_tuple_impl!(9: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I));
        single_tuple_impl!(10: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J));
        single_tuple_impl!(11: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K));
        single_tuple_impl!(12: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L));
        single_tuple_impl!(13: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M));
        single_tuple_impl!(14: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N));
        single_tuple_impl!(15: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N), (14 O));
        single_tuple_impl!(16: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N), (14 O), (15 P));
        
        macro_rules! impl_for_array_ref
        {
            ($($N:literal)+) => {$(
                // These are already generic, and there's a shedload of them, so lets
                // avoid the compile time hit from making them all inline for now.
                impl<T: ToSql + ?Sized> Sealed for &[&T; $N] {}
                impl<T: ToSql + ?Sized> Params for &[&T; $N] {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters(self)
                    }
                }
                impl<T: ToSql + ?Sized> Sealed for &[(&str, &T); $N] {}
                impl<T: ToSql + ?Sized> Params for &[(&str, &T); $N] {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters_named(self)
                    }
                }
                impl<T: ToSql> Sealed for [T; $N] {}
                impl<T: ToSql> Params for [T; $N] {
                    #[inline]
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters(&self)
                    }
                }
            )+};
        }
        
        impl_for_array_ref!(
            1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
            18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
        );        
        /// Adapter type which allows any iterator over [`ToSql`] values to implement [`Params`].
        #[derive(Clone, Debug)]
        pub struct ParamsFromIter<I>(I);        
        /// Constructor function for a [`ParamsFromIter`].
        #[inline]
        pub fn params_from_iter<I>(iter: I) -> ParamsFromIter<I> where
            I: IntoIterator,
            I::Item: ToSql,
        {
            ParamsFromIter(iter)
        }
        
        impl<I> Sealed for ParamsFromIter<I> where
            I: IntoIterator,
            I::Item: ToSql,
        {
        }
        
        impl<I> Params for ParamsFromIter<I> where
            I: IntoIterator,
            I::Item: ToSql,
        {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                stmt.bind_parameters(self.0)
            }
        }
    }
    
    pub mod pragma
    {
        //! Pragma helpers
        use ::
        {
            *,
        };
        /*
        use ::ops::Deref;

        use crate::ffi;
        use crate::types::{ToSql, ToSqlOutput, ValueRef};
        use crate::{Connection, Result, Row};
        */
        pub struct Sql {
            buf: String,
        }

        impl Sql
        {
            pub fn new() -> Self {
                Self { buf: String::new() }
            }

            pub fn push_pragma(&mut self, schema_name: Option<&str>, pragma_name: &str) -> Result<()> {
                self.push_keyword("PRAGMA")?;
                self.push_space();
                if let Some(schema_name) = schema_name {
                    self.push_schema_name(schema_name);
                    self.push_dot();
                }
                self.push_keyword(pragma_name)
            }

            pub fn push_keyword(&mut self, keyword: &str) -> Result<()> {
                if !keyword.is_empty() && is_identifier(keyword) {
                    self.buf.push_str(keyword);
                    Ok(())
                } else {
                    Err(err!(ffi::SQLITE_MISUSE, "Invalid keyword \"{keyword}\""))
                }
            }

            pub fn push_schema_name(&mut self, schema_name: &str) {
                self.push_identifier(schema_name);
            }

            pub fn push_identifier(&mut self, s: &str) {
                if is_identifier(s) {
                    self.buf.push_str(s);
                } else {
                    self.wrap_and_escape(s, '"');
                }
            }

            pub fn push_value(&mut self, value: &dyn ToSql) -> Result<()> {
                let value = value.to_sql()?;
                let value = match value {
                    ToSqlOutput::Borrowed(v) => v,
                    ToSqlOutput::Owned(ref v) => ValueRef::from(v),
                };
                match value {
                    ValueRef::Integer(i) => {
                        self.push_int(i);
                    }
                    ValueRef::Real(r) => {
                        self.push_real(r);
                    }
                    ValueRef::Text(s) => {
                        let s = ::str::from_utf8(s)?;
                        self.push_string_literal(s);
                    }
                    _ => {
                        return Err(err!(ffi::SQLITE_MISUSE, "Unsupported value \"{value:?}\""));
                    }
                };
                Ok(())
            }

            pub fn push_string_literal(&mut self, s: &str) {
                self.wrap_and_escape(s, '\'');
            }

            pub fn push_int(&mut self, i: i64) {
                self.buf.push_str(&i.to_string());
            }

            pub fn push_real(&mut self, f: f64) {
                self.buf.push_str(&f.to_string());
            }

            pub fn push_space(&mut self) {
                self.buf.push(' ');
            }

            pub fn push_dot(&mut self) {
                self.buf.push('.');
            }

            pub fn push_equal_sign(&mut self) {
                self.buf.push('=');
            }

            pub fn open_brace(&mut self) {
                self.buf.push('(');
            }

            pub fn close_brace(&mut self) {
                self.buf.push(')');
            }

            pub fn as_str(&self) -> &str {
                &self.buf
            }

            fn wrap_and_escape(&mut self, s: &str, quote: char) {
                self.buf.push(quote);
                let chars = s.chars();
                for ch in chars {
                    // escape `quote` by doubling it
                    if ch == quote {
                        self.buf.push(ch);
                    }
                    self.buf.push(ch);
                }
                self.buf.push(quote);
            }
        }

        impl Deref for Sql {
            type Target = str;

            fn deref(&self) -> &str {
                self.as_str()
            }
        }

        impl Connection {
            /// Query the current value of `pragma_name`.
            pub fn pragma_query_value<T, F>(
                &self,
                schema_name: Option<&str>,
                pragma_name: &str,
                f: F,
            ) -> Result<T>
            where
                F: FnOnce(&Row<'_>) -> Result<T>,
            {
                let mut query = Sql::new();
                query.push_pragma(schema_name, pragma_name)?;
                self.query_row(&query, [], f)
            }

            /// Query the current rows/values of `pragma_name`.
            pub fn pragma_query<F>(
                &self,
                schema_name: Option<&str>,
                pragma_name: &str,
                mut f: F,
            ) -> Result<()>
            where
                F: FnMut(&Row<'_>) -> Result<()>,
            {
                let mut query = Sql::new();
                query.push_pragma(schema_name, pragma_name)?;
                let mut stmt = self.prepare(&query)?;
                let mut rows = stmt.query([])?;
                while let Some(result_row) = rows.next()? {
                    let row = result_row;
                    f(row)?;
                }
                Ok(())
            }

            /// Query the current value(s) of `pragma_name` associated to
            /// `pragma_value`.
            pub fn pragma<F, V>(
                &self,
                schema_name: Option<&str>,
                pragma_name: &str,
                pragma_value: V,
                mut f: F,
            ) -> Result<()>
            where
                F: FnMut(&Row<'_>) -> Result<()>,
                V: ToSql,
            {
                let mut sql = Sql::new();
                sql.push_pragma(schema_name, pragma_name)?;
                sql.open_brace();
                sql.push_value(&pragma_value)?;
                sql.close_brace();
                let mut stmt = self.prepare(&sql)?;
                let mut rows = stmt.query([])?;
                while let Some(result_row) = rows.next()? {
                    let row = result_row;
                    f(row)?;
                }
                Ok(())
            }

            /// Set a new value to `pragma_name`.
            pub fn pragma_update<V>(
                &self,
                schema_name: Option<&str>,
                pragma_name: &str,
                pragma_value: V,
            ) -> Result<()>
            where
                V: ToSql,
            {
                let mut sql = Sql::new();
                sql.push_pragma(schema_name, pragma_name)?;
                sql.push_equal_sign();
                sql.push_value(&pragma_value)?;
                self.execute_batch(&sql)
            }

            /// Set a new value to `pragma_name` and return the updated value.
            pub fn pragma_update_and_check<F, T, V>(
                &self,
                schema_name: Option<&str>,
                pragma_name: &str,
                pragma_value: V,
                f: F,
            ) -> Result<T>
            where
                F: FnOnce(&Row<'_>) -> Result<T>,
                V: ToSql,
            {
                let mut sql = Sql::new();
                sql.push_pragma(schema_name, pragma_name)?;
                sql.push_equal_sign();
                sql.push_value(&pragma_value)?;
                self.query_row(&sql, [], f)
            }
        }

        fn is_identifier(s: &str) -> bool {
            let chars = s.char_indices();
            for (i, ch) in chars {
                if i == 0 {
                    if !is_identifier_start(ch) {
                        return false;
                    }
                } else if !is_identifier_continue(ch) {
                    return false;
                }
            }
            true
        }

        fn is_identifier_start(c: char) -> bool {
            c.is_ascii_uppercase() || c == '_' || c.is_ascii_lowercase() || c > '\x7F'
        }

        fn is_identifier_continue(c: char) -> bool {
            c == '$'
                || c.is_ascii_digit()
                || c.is_ascii_uppercase()
                || c == '_'
                || c.is_ascii_lowercase()
                || c > '\x7F'
        }
    }
    
    pub mod raw_statement
    {
        use ::
        {
            *,
        };
        /*
        use super::ffi;
        use super::StatementStatus;
        use crate::util::ParamIndexCache;
        use crate::util::SqliteMallocString;
        use ::ffi::{c_int, CStr};
        use ::ptr;
        use ::sync::Arc;
        */
        #[derive(Debug)]
        pub struct RawStatement 
        {
            ptr: *mut ffi::sqlite3_stmt,
            /// Cached indices of named parameters, computed on the fly.
            cache: ParamIndexCache,
            /// Cached SQL (trimmed) that we use as the key when we're in the statement cache.
            statement_cache_key: Option<Arc<str>>,
        }

        impl RawStatement {
            #[inline]
            pub unsafe fn new(stmt: *mut ffi::sqlite3_stmt) -> Self {
                Self {
                    ptr: stmt,
                    cache: ParamIndexCache::default(),
                    statement_cache_key: None,
                }
            }

            #[inline] pub fn is_null(&self) -> bool {
                self.ptr.is_null()
            }

            #[inline] pub fn set_statement_cache_key(&mut self, p: impl Into<Arc<str>>) {
                self.statement_cache_key = Some(p.into());
            }

            #[inline] pub fn statement_cache_key(&self) -> Option<Arc<str>> {
                self.statement_cache_key.clone()
            }

            #[inline]
            pub unsafe fn ptr(&self) -> *mut ffi::sqlite3_stmt {
                self.ptr
            }

            #[inline] pub fn column_count(&self) -> usize {
                unsafe { ffi::sqlite3_column_count(self.ptr) as usize }
            }

            #[inline] pub fn column_type(&self, idx: usize) -> c_int {
                unsafe { ffi::sqlite3_column_type(self.ptr, idx as c_int) }
            }

            #[inline] pub fn column_name(&self, idx: usize) -> Option<&CStr> {
                let idx = idx as c_int;
                if idx < 0 || idx >= self.column_count() as c_int {
                    return None;
                }
                unsafe {
                    let ptr = ffi::sqlite3_column_name(self.ptr, idx);
                    assert!(
                        !ptr.is_null(),
                        "Null pointer from sqlite3_column_name: Out of memory?"
                    );
                    Some(CStr::from_ptr(ptr))
                }
            }

            #[inline] pub fn reset(&self) -> c_int {
                unsafe { ffi::sqlite3_reset(self.ptr) }
            }

            #[inline] pub fn bind_parameter_count(&self) -> usize {
                unsafe { ffi::sqlite3_bind_parameter_count(self.ptr) as usize }
            }

            #[inline] pub fn bind_parameter_index(&self, name: &str) -> Option<usize> {
                self.cache.get_or_insert_with(name, |param_cstr| {
                    let r = unsafe { ffi::sqlite3_bind_parameter_index(self.ptr, param_cstr.as_ptr()) };
                    match r {
                        0 => None,
                        i => Some(i as usize),
                    }
                })
            }

            #[inline] pub fn bind_parameter_name(&self, index: i32) -> Option<&CStr> {
                unsafe {
                    let name = ffi::sqlite3_bind_parameter_name(self.ptr, index);
                    if name.is_null() {
                        None
                    } else {
                        Some(CStr::from_ptr(name))
                    }
                }
            }

            #[inline] pub fn clear_bindings(&mut self) {
                unsafe {
                    ffi::sqlite3_clear_bindings(self.ptr);
                } // rc is always SQLITE_OK
            }

            #[inline] pub fn sql(&self) -> Option<&CStr> {
                if self.ptr.is_null() {
                    None
                } else {
                    Some(unsafe { CStr::from_ptr(ffi::sqlite3_sql(self.ptr)) })
                }
            }

            #[inline] pub fn finalize(mut self) -> c_int {
                self.finalize_()
            }

            #[inline] fn finalize_(&mut self) -> c_int {
                let r = unsafe { ffi::sqlite3_finalize(self.ptr) };
                self.ptr = ptr::null_mut();
                r
            }
            
            #[inline] pub fn readonly(&self) -> bool {
                unsafe { ffi::sqlite3_stmt_readonly(self.ptr) != 0 }
            }

            #[inline] pub fn expanded_sql(&self) -> Option<SqliteMallocString> {
                unsafe { expanded_sql(self.ptr) }
            }

            #[inline] pub fn get_status(&self, status: StatementStatus, reset: bool) -> i32 {
                unsafe { stmt_status(self.ptr, status, reset) }
            }
        }

        #[inline]
        pub unsafe fn expanded_sql(ptr: *mut ffi::sqlite3_stmt) -> Option<SqliteMallocString> {
            SqliteMallocString::from_raw(ffi::sqlite3_expanded_sql(ptr))
        }
        #[inline]
        pub unsafe fn stmt_status(
            ptr: *mut ffi::sqlite3_stmt,
            status: StatementStatus,
            reset: bool,
        ) -> i32 {
            assert!(!ptr.is_null());
            ffi::sqlite3_stmt_status(ptr, status as i32, reset as i32)
        }

        impl Drop for RawStatement {
            fn drop(&mut self) {
                self.finalize_();
            }
        }
    }
    
    pub mod row
    {
        use ::
        {
            *,
        };
        /*
        use fallible_iterator::FallibleIterator;
        use fallible_streaming_iterator::FallibleStreamingIterator;
        use ::convert;

        use super::{Error, Result, Statement};
        use crate::types::{FromSql, FromSqlError, ValueRef};
        */
        /// A handle (lazy fallible streaming iterator) for the resulting rows of a query.
        #[must_use = "Rows is lazy and will do nothing unless consumed"]
        pub struct Rows<'stmt> {
            pub stmt: Option<&'stmt Statement<'stmt>>,
            row: Option<Row<'stmt>>,
        }

        impl<'stmt> Rows<'stmt> {
            #[inline] fn reset(&mut self) -> Result<()> {
                if let Some(stmt) = self.stmt.take() {
                    stmt.reset()
                } else {
                    Ok(())
                }
            }

            /// Attempt to get the next row from the query.
            #[expect(clippy::should_implement_trait)]
            #[inline] pub fn next(&mut self) -> Result<Option<&Row<'stmt>>> {
                self.advance()?;
                Ok((*self).get())
            }

            /// Map over this `Rows`, converting it to a [`Map`], which
            /// implements `FallibleIterator`.
            #[inline] pub fn map<F, B>(self, f: F) -> Map<'stmt, F>
            where
                F: FnMut(&Row<'_>) -> Result<B>,
            {
                Map { rows: self, f }
            }

            /// Map over this `Rows`, converting it to a [`MappedRows`], which
            /// implements `Iterator`.
            #[inline] pub fn mapped<F, B>(self, f: F) -> MappedRows<'stmt, F>
            where
                F: FnMut(&Row<'_>) -> Result<B>,
            {
                MappedRows { rows: self, map: f }
            }

            /// Map over this `Rows` with a fallible function, converting it to a
            /// [`AndThenRows`], which implements `Iterator` (instead of
            /// `FallibleStreamingIterator`).
            #[inline] pub fn and_then<F, T, E>(self, f: F) -> AndThenRows<'stmt, F>
            where
                F: FnMut(&Row<'_>) -> Result<T, E>,
            {
                AndThenRows { rows: self, map: f }
            }

            /// Give access to the underlying statement
            #[must_use]
            pub fn as_ref(&self) -> Option<&Statement<'stmt>> {
                self.stmt
            }
        }

        impl<'stmt> Rows<'stmt> {
            #[inline] pub fn new(stmt: &'stmt Statement<'stmt>) -> Self {
                Rows {
                    stmt: Some(stmt),
                    row: None,
                }
            }

            #[inline] pub fn get_expected_row(&mut self) -> Result<&Row<'stmt>> {
                match self.next()? {
                    Some(row) => Ok(row),
                    None => Err(Error::QueryReturnedNoRows),
                }
            }
        }

        impl Drop for Rows<'_> {
            #[expect(unused_must_use)]
            #[inline] fn drop(&mut self) {
                self.reset();
            }
        }

        /// `F` is used to transform the _streaming_ iterator into a _fallible_
        /// iterator.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct Map<'stmt, F> {
            rows: Rows<'stmt>,
            f: F,
        }

        impl<F, B> FallibleIterator for Map<'_, F> where 
            F: FnMut(&Row<'_>) -> Result<B>,
        {
            type Error = Error;
            type Item = B;

            #[inline] fn next(&mut self) -> Result<Option<B>> {
                match self.rows.next()? {
                    Some(v) => Ok(Some((self.f)(v)?)),
                    None => Ok(None),
                }
            }
        }

        /// An iterator over the mapped resulting rows of a query.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct MappedRows<'stmt, F> {
            rows: Rows<'stmt>,
            map: F,
        }

        impl<T, F> Iterator for MappedRows<'_, F> where 
            F: FnMut(&Row<'_>) -> Result<T>,
        {
            type Item = Result<T>;

            #[inline] fn next(&mut self) -> Option<Result<T>> {
                let map = &mut self.map;
                self.rows
                    .next()
                    .transpose()
                    .map(|row_result| row_result.and_then(map))
            }
        }

        /// An iterator over the mapped resulting rows of a query, with an Error type
        /// unifying with Error.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct AndThenRows<'stmt, F> {
            rows: Rows<'stmt>,
            map: F,
        }

        impl<T, E, F> Iterator for AndThenRows<'_, F> where 
            E: From<Error>,
            F: FnMut(&Row<'_>) -> Result<T, E>,
        {
            type Item = Result<T, E>;

            #[inline] fn next(&mut self) -> Option<Self::Item> {
                let map = &mut self.map;
                self.rows
                    .next()
                    .transpose()
                    .map(|row_result| row_result.map_err(E::from).and_then(map))
            }
        }

        /// `FallibleStreamingIterator` differs from the standard library's `Iterator`
        /// in two ways:
        /// * each call to `next` (`sqlite3_step`) can fail.
        /// * returned `Row` is valid until `next` is called again or `Statement` is
        ///   reset or finalized.
        impl<'stmt> FallibleStreamingIterator for Rows<'stmt> {
            type Error = Error;
            type Item = Row<'stmt>;

            #[inline] fn advance(&mut self) -> Result<()> {
                if let Some(stmt) = self.stmt {
                    match stmt.step() {
                        Ok(true) => {
                            self.row = Some(Row { stmt });
                            Ok(())
                        }
                        Ok(false) => {
                            let r = self.reset();
                            self.row = None;
                            r
                        }
                        Err(e) => {
                            let _ = self.reset();
                            self.row = None;
                            Err(e)
                        }
                    }
                } else {
                    self.row = None;
                    Ok(())
                }
            }

            #[inline] fn get(&self) -> Option<&Row<'stmt>> {
                self.row.as_ref()
            }
        }

        /// A single result row of a query.
        pub struct Row<'stmt> {
            pub stmt: &'stmt Statement<'stmt>,
        }

        impl Row<'_> {
            /// Get the value of a particular column of the result row.
            #[track_caller]
            pub fn get_unwrap<I: RowIndex, T: FromSql>(&self, idx: I) -> T {
                self.get(idx).unwrap() }
              /// Get the value of a particular column of the result row.
            #[track_caller]
            pub fn get<I: RowIndex, T: FromSql>(&self, idx: I) -> Result<T> {
                let idx = idx.idx(self.stmt)?;
                let value = self.stmt.value_ref(idx);
                FromSql::column_result(value).map_err(|err| match err {
                    FromSqlError::InvalidType => Error::InvalidColumnType(
                        idx,
                        self.stmt.column_name_unwrap(idx).into(),
                        value.data_type(),
                    ),
                    FromSqlError::OutOfRange(i) => Error::IntegralValueOutOfRange(idx, i),
                    FromSqlError::Other(err) => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), err)
                    }
                    FromSqlError::InvalidBlobSize { .. } => {
                        Error::FromSqlConversionFailure(idx, value.data_type(), Box::new(err))
                    }
                })
            }

            /// Get the value of a particular column of the result row as a `ValueRef`,
            /// allowing data to be read out of a row without copying.
            pub fn get_ref<I: RowIndex>(&self, idx: I) -> Result<ValueRef<'_>> {
                let idx = idx.idx(self.stmt)?;
                let val_ref = self.stmt.value_ref(idx);
                Ok(val_ref)
            }

            /// Get the value of a particular column of the result row as a `ValueRef`,
            /// allowing data to be read out of a row without copying.
            #[track_caller]
            pub fn get_ref_unwrap<I: RowIndex>(&self, idx: I) -> ValueRef<'_> {
                self.get_ref(idx).unwrap()
            }
        }

        impl<'stmt> AsRef<Statement<'stmt>> for Row<'stmt> {
            fn as_ref(&self) -> &Statement<'stmt> {
                self.stmt
            }
        }

        /// Debug `Row` like an ordered `Map<Result<&str>, Result<(Type, ValueRef)>>`
        /// with column name as key except that for `Type::Blob` only its size is
        /// printed (not its content).
        impl ::fmt::Debug for Row<'_> {
            fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                let mut dm = f.debug_map();
                for c in 0..self.stmt.column_count() {
                    let name = self.stmt.column_name(c).expect("valid column index");
                    dm.key(&name);
                    let value = self.get_ref(c);
                    match value {
                        Ok(value) => {
                            let dt = value.data_type();
                            match value {
                                ValueRef::Null => {
                                    dm.value(&(dt, ()));
                                }
                                ValueRef::Integer(i) => {
                                    dm.value(&(dt, i));
                                }
                                ValueRef::Real(f) => {
                                    dm.value(&(dt, f));
                                }
                                ValueRef::Text(s) => {
                                    dm.value(&(dt, String::from_utf8_lossy(s)));
                                }
                                ValueRef::Blob(b) => {
                                    dm.value(&(dt, b.len()));
                                }
                            }
                        }
                        Err(ref _err) => {
                            dm.value(&value);
                        }
                    }
                }
                dm.finish()
            }
        } 

        /// A trait implemented by types that can index into columns of a row.
        pub trait RowIndex
        {
            /// Returns the index of the appropriate column, or `Error` if no such
            /// column exists.
            fn idx(&self, stmt: &Statement<'_>) -> Result<usize>;
        }

        impl RowIndex for usize {
            #[inline] fn idx(&self, stmt: &Statement<'_>) -> Result<usize> {
                if *self >= stmt.column_count() {
                    Err(Error::InvalidColumnIndex(*self))
                } else {
                    Ok(*self)
                }
            }
        }

        impl RowIndex for &'_ str {
            #[inline] fn idx(&self, stmt: &Statement<'_>) -> Result<usize> {
                stmt.column_index(self)
            }
        }

        macro_rules! tuple_try_from_row {
            ($($field:ident),*) => {
                impl<'a, $($field,)*> convert::TryFrom<&'a Row<'a>> for ($($field,)*) where $($field: FromSql,)* {
                    type Error = crate::Error;
                    
                    fn try_from(row: &'a Row<'a>) -> Result<Self> {
                        let mut index = 0;
                        $(
                            #[expect(non_snake_case)]
                            let $field = row.get::<_, $field>(index)?;
                            index += 1;
                        )*
                        Ok(($($field,)*))
                    }
                }
            }
        }

        macro_rules! tuples_try_from_row {
            () => {
                tuple_try_from_row!();
            };
            ($first:ident $(, $remaining:ident)*) => {
                tuple_try_from_row!($first $(, $remaining)*);
                tuples_try_from_row!($($remaining),*);
            };
        }

        tuples_try_from_row!(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P);
    }
    
    pub mod statement
    {
        use ::
        {
            *,
        };
        /*
        use ::ffi::{c_int, c_void};
        #[cfg(feature = "array")]
        use ::rc::Rc;
        use ::slice::from_raw_parts;
        use ::{fmt, mem, ptr, str};

        use super::ffi;
        use super::{len_as_c_int, str_for_sqlite};
        use super::{
            AndThenRows, Connection, Error, MappedRows, Params, RawStatement, Result, Row, Rows, ValueRef,
        };
        use crate::bind::BindIndex;
        use crate::types::{ToSql, ToSqlOutput};
        #[cfg(feature = "array")]
        use crate::vtab::array::{free_array, ARRAY_TYPE};
        */
        /// A prepared statement.
        pub struct Statement<'conn> {
            pub conn: &'conn Connection,
            pub stmt: RawStatement,
        }

        impl Statement<'_> {
            /// Execute the prepared statement.
            #[inline] pub fn execute<P: Params>(&mut self, params: P) -> Result<usize> {
                params.__bind_in(self)?;
                self.execute_with_bound_parameters() }
              /// Execute an INSERT and return the ROWID.
            #[inline] pub fn insert<P: Params>(&mut self, params: P) -> Result<i64> {
                let changes = self.execute(params)?;
                match changes {
                    1 => Ok(self.conn.last_insert_rowid()),
                    _ => Err(Error::StatementChangedRows(changes)),
                }
            }

            /// Execute the prepared statement, returning a handle to the resulting
            /// rows.
            #[inline] pub fn query<P: Params>(&mut self, params: P) -> Result<Rows<'_>> {
                params.__bind_in(self)?;
                Ok(Rows::new(self))
            }

            /// Executes the prepared statement and maps a function over the resulting
            /// rows, returning an iterator over the mapped function results.
            pub fn query_map<T, P, F>(&mut self, params: P, f: F) -> Result<MappedRows<'_, F>>
            where
                P: Params,
                F: FnMut(&Row<'_>) -> Result<T>,
            {
                self.query(params).map(|rows| rows.mapped(f))
            }

            /// Executes the prepared statement and maps a function over the resulting
            /// rows, where the function returns a `Result` with `Error` type
            /// implementing ` ::convert::From<Error>` (so errors can be unified).
            #[inline] pub fn query_and_then<T, E, P, F>(&mut self, params: P, f: F) -> Result<AndThenRows<'_, F>>
            where
                P: Params,
                E: From<Error>,
                F: FnMut(&Row<'_>) -> Result<T, E>,
            {
                self.query(params).map(|rows| rows.and_then(f))
            }

            /// Return `true` if a query in the SQL statement it executes returns one
            /// or more rows and `false` if the SQL returns an empty set.
            #[inline] pub fn exists<P: Params>(&mut self, params: P) -> Result<bool> {
                let mut rows = self.query(params)?;
                let exists = rows.next()?.is_some();
                Ok(exists)
            }

            /// Convenience method to execute a query that is expected to return a
            /// single row.
            pub fn query_row<T, P, F>(&mut self, params: P, f: F) -> Result<T>
            where
                P: Params,
                F: FnOnce(&Row<'_>) -> Result<T>,
            {
                let mut rows = self.query(params)?;

                rows.get_expected_row().and_then(f)
            }

            /// Convenience method to execute a query that is expected to return exactly
            /// one row.
            pub fn query_one<T, P, F>(&mut self, params: P, f: F) -> Result<T>
            where
                P: Params,
                F: FnOnce(&Row<'_>) -> Result<T>,
            {
                let mut rows = self.query(params)?;
                let row = rows.get_expected_row().and_then(f)?;
                if rows.next()?.is_some() {
                    return Err(Error::QueryReturnedMoreThanOneRow);
                }
                Ok(row)
            }

            /// Consumes the statement.
            #[inline] pub fn finalize(mut self) -> Result<()> {
                self.finalize_() }
              /// Return the (one-based) index of an SQL parameter given its name.
            #[inline] pub fn parameter_index(&self, name: &str) -> Result<Option<usize>> {
                Ok(self.stmt.bind_parameter_index(name))
            }

            /// Return the SQL parameter name given its (one-based) index (the inverse
            /// of [`Statement::parameter_index`]).
            #[inline] pub fn parameter_name(&self, index: usize) -> Option<&'_ str> {
                self.stmt.bind_parameter_name(index as i32).map(|name| {
                    name.to_str()
                        .expect("Invalid UTF-8 sequence in parameter name")
                })
            }

            #[inline] pub fn bind_parameters<P>(&mut self, params: P) -> Result<()>
            where
                P: IntoIterator,
                P::Item: ToSql,
            {
                let expected = self.stmt.bind_parameter_count();
                let mut index = 0;
                for p in params {
                    index += 1; // The leftmost SQL parameter has an index of 1.
                    if index > expected {
                        break;
                    }
                    self.bind_parameter(&p, index)?;
                }
                if index != expected {
                    Err(Error::InvalidParameterCount(index, expected))
                } else {
                    Ok(())
                }
            }

            #[inline] pub fn ensure_parameter_count(&self, n: usize) -> Result<()> {
                let count = self.parameter_count();
                if count != n {
                    Err(Error::InvalidParameterCount(n, count))
                } else {
                    Ok(())
                }
            }

            #[inline] pub fn bind_parameters_named<S: BindIndex, T: ToSql>(
                &mut self,
                params: &[(S, T)],
            ) -> Result<()> {
                for (name, value) in params {
                    let i = name.idx(self)?;
                    let ts: &dyn ToSql = &value;
                    self.bind_parameter(ts, i)?;
                }
                Ok(())
            }

            /// Return the number of parameters that can be bound to this statement.
            #[inline] pub fn parameter_count(&self) -> usize {
                self.stmt.bind_parameter_count() }
              /// Low level API to directly bind a parameter to a given index.
            #[inline] pub fn raw_bind_parameter<I: BindIndex, T: ToSql>(
                &mut self,
                one_based_index: I,
                param: T,
            ) -> Result<()> {
                self.bind_parameter(&param, one_based_index.idx(self)?)
            }

            /// Low level API to execute a statement given that all parameters were
            /// bound explicitly with the [`Statement::raw_bind_parameter`] API.
            #[inline] pub fn raw_execute(&mut self) -> Result<usize> {
                self.execute_with_bound_parameters() }
              /// Low level API to get `Rows` for this query given that all parameters
            /// were bound explicitly with the [`Statement::raw_bind_parameter`] API.
            #[inline] pub fn raw_query(&mut self) -> Rows<'_> {
                Rows::new(self)
            }
            
            fn bind_parameter<P: ?Sized + ToSql>(&self, param: &P, ndx: usize) -> Result<()> {
                let value = param.to_sql()?;

                let ptr = unsafe { self.stmt.ptr() };
                let value = match value {
                    ToSqlOutput::Borrowed(v) => v,
                    ToSqlOutput::Owned(ref v) => ValueRef::from(v),
                };
                self.conn.decode_result(match value {
                    ValueRef::Null => unsafe { ffi::sqlite3_bind_null(ptr, ndx as c_int) },
                    ValueRef::Integer(i) => unsafe { ffi::sqlite3_bind_int64(ptr, ndx as c_int, i) },
                    ValueRef::Real(r) => unsafe { ffi::sqlite3_bind_double(ptr, ndx as c_int, r) },
                    ValueRef::Text(s) => unsafe {
                        let (c_str, len, destructor) = str_for_sqlite(s)?;
                        ffi::sqlite3_bind_text(ptr, ndx as c_int, c_str, len, destructor)
                    },
                    ValueRef::Blob(b) => unsafe {
                        let length = len_as_c_int(b.len())?;
                        if length == 0 {
                            ffi::sqlite3_bind_zeroblob(ptr, ndx as c_int, 0)
                        } else {
                            // TODO sqlite3_bind_blob64 // 3.8.7
                            ffi::sqlite3_bind_blob(
                                ptr,
                                ndx as c_int,
                                b.as_ptr().cast::<c_void>(),
                                length,
                                ffi::SQLITE_TRANSIENT(),
                            )
                        }
                    },
                })
            }

            #[inline] fn execute_with_bound_parameters(&mut self) -> Result<usize> {
                self.check_update()?;
                let r = self.stmt.step();
                let rr = self.stmt.reset();
                match r {
                    ffi::SQLITE_DONE => match rr {
                        ffi::SQLITE_OK => Ok(self.conn.changes() as usize),
                        _ => Err(self.conn.decode_result(rr).unwrap_err()),
                    },
                    ffi::SQLITE_ROW => Err(Error::ExecuteReturnedResults),
                    _ => Err(self.conn.decode_result(r).unwrap_err()),
                }
            }

            #[inline] fn finalize_(&mut self) -> Result<()> {
                let mut stmt = unsafe { RawStatement::new(ptr::null_mut()) };
                mem::swap(&mut stmt, &mut self.stmt);
                self.conn.decode_result(stmt.finalize())
            }

            /// Returns a string containing the SQL text of prepared statement with
            /// bound parameters expanded.
            pub fn expanded_sql(&self) -> Option<String> {
                self.stmt
                    .expanded_sql()
                    .map(|s| s.to_string_lossy().to_string())
            }

            /// Get the value for one of the status counters for this statement.
            #[inline] pub fn get_status(&self, status: StatementStatus) -> i32 {
                self.stmt.get_status(status, false)
            }

            /// Reset the value of one of the status counters for this statement,
            #[inline]
            /// returning the value it had before resetting.
            pub fn reset_status(&self, status: StatementStatus) -> i32 {
                self.stmt.get_status(status, true)
            }
            /// Returns true if the statement is read only.
            #[inline] pub fn readonly(&self) -> bool {
                self.stmt.readonly()
            }
            
            #[inline]
            pub unsafe fn into_raw(mut self) -> RawStatement {
                let mut stmt = RawStatement::new(ptr::null_mut());
                mem::swap(&mut stmt, &mut self.stmt);
                stmt
            }

            /// Reset all bindings
            pub fn clear_bindings(&mut self) {
                self.stmt.clear_bindings();
            }

            pub unsafe fn ptr(&self) -> *mut ffi::sqlite3_stmt {
                self.stmt.ptr()
            }
        }

        impl fmt::Debug for Statement<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                let sql = if self.stmt.is_null() {
                    Ok("")
                } else {
                    self.stmt.sql().unwrap().to_str()
                };
                f.debug_struct("Statement")
                    .field("conn", self.conn)
                    .field("stmt", &self.stmt)
                    .field("sql", &sql)
                    .finish()
            }
        }

        impl Drop for Statement<'_> {
            #[expect(unused_must_use)]
            #[inline] fn drop(&mut self) {
                self.finalize_();
            }
        }

        impl Statement<'_> {
            #[inline] pub fn new(conn: &Connection, stmt: RawStatement) -> Statement<'_> {
                Statement { conn, stmt }
            }

            pub fn value_ref(&self, col: usize) -> ValueRef<'_> {
                let raw = unsafe { self.stmt.ptr() };

                match self.stmt.column_type(col) {
                    ffi::SQLITE_NULL => ValueRef::Null,
                    ffi::SQLITE_INTEGER => {
                        ValueRef::Integer(unsafe { ffi::sqlite3_column_int64(raw, col as c_int) })
                    }
                    ffi::SQLITE_FLOAT => {
                        ValueRef::Real(unsafe { ffi::sqlite3_column_double(raw, col as c_int) })
                    }
                    ffi::SQLITE_TEXT => {
                        let s = unsafe {
                            // Quoting from "Using SQLite" book:
                            // To avoid problems, an application should first extract the desired type using
                            // a sqlite3_column_xxx() function, and then call the
                            // appropriate sqlite3_column_bytes() function.
                            let text = ffi::sqlite3_column_text(raw, col as c_int);
                            let len = ffi::sqlite3_column_bytes(raw, col as c_int);
                            assert!(
                                !text.is_null(),
                                "unexpected SQLITE_TEXT column type with NULL data"
                            );
                            from_raw_parts(text.cast::<u8>(), len as usize)
                        };

                        ValueRef::Text(s)
                    }
                    ffi::SQLITE_BLOB => {
                        let (blob, len) = unsafe {
                            (
                                ffi::sqlite3_column_blob(raw, col as c_int),
                                ffi::sqlite3_column_bytes(raw, col as c_int),
                            )
                        };

                        assert!(
                            len >= 0,
                            "unexpected negative return from sqlite3_column_bytes"
                        );
                        if len > 0 {
                            assert!(
                                !blob.is_null(),
                                "unexpected SQLITE_BLOB column type with NULL data"
                            );
                            ValueRef::Blob(unsafe { from_raw_parts(blob.cast::<u8>(), len as usize) })
                        } else {
                            // The return value from sqlite3_column_blob() for a zero-length BLOB
                            // is a NULL pointer.
                            ValueRef::Blob(&[])
                        }
                    }
                    _ => unreachable!("sqlite3_column_type returned invalid value"),
                }
            }

            #[inline] pub fn step(&self) -> Result<bool> {
                match self.stmt.step() {
                    ffi::SQLITE_ROW => Ok(true),
                    ffi::SQLITE_DONE => Ok(false),
                    code => Err(self.conn.decode_result(code).unwrap_err()),
                }
            }

            #[inline] pub fn reset(&self) -> Result<()> {
                match self.stmt.reset() {
                    ffi::SQLITE_OK => Ok(()),
                    code => Err(self.conn.decode_result(code).unwrap_err()),
                }
            }
        }

        /// Prepared statement status counters.
        #[repr(i32)]
        #[derive(Clone, Copy, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum StatementStatus {
            /// Equivalent to `SQLITE_STMTSTATUS_FULLSCAN_STEP`
            FullscanStep = 1,
            /// Equivalent to `SQLITE_STMTSTATUS_SORT`
            Sort = 2,
            /// Equivalent to `SQLITE_STMTSTATUS_AUTOINDEX`
            AutoIndex = 3,
            /// Equivalent to `SQLITE_STMTSTATUS_VM_STEP`
            VmStep = 4,
            /// Equivalent to `SQLITE_STMTSTATUS_REPREPARE` (3.20.0)
            RePrepare = 5,
            /// Equivalent to `SQLITE_STMTSTATUS_RUN` (3.20.0)
            Run = 6,
            /// Equivalent to `SQLITE_STMTSTATUS_FILTER_MISS`
            FilterMiss = 7,
            /// Equivalent to `SQLITE_STMTSTATUS_FILTER_HIT`
            FilterHit = 8,
            /// Equivalent to `SQLITE_STMTSTATUS_MEMUSED` (3.20.0)
            MemUsed = 99,
        }
    }
    
    pub mod transaction
    {
        use ::
        {
            *,
        };
        /*
        use crate::{Connection, Result};
        use ::ops::Deref;
        */
        /// Options for transaction behavior.
        #[derive(Copy, Clone)]
        #[non_exhaustive]
        pub enum TransactionBehavior {
            /// DEFERRED means that the transaction does not actually start until the
            /// database is first accessed.
            Deferred,
            /// IMMEDIATE cause the database connection to start a new write
            /// immediately, without waiting for a writes statement.
            Immediate,
            /// EXCLUSIVE prevents other database connections from reading the database
            /// while the transaction is underway.
            Exclusive,
        }

        /// Options for how a Transaction or Savepoint should behave when it is dropped.
        #[derive(Copy, Clone, Debug, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum DropBehavior {
            /// Roll back the changes. This is the default.
            Rollback,

            /// Commit the changes.
            Commit,

            /// Do not commit or roll back changes - this will leave the transaction or
            /// savepoint open, so should be used with care.
            Ignore,

            /// Panic. Used to enforce intentional behavior during development.
            Panic,
        }

        /// Represents a transaction on a database connection.
        #[derive(Debug)]
        pub struct Transaction<'conn> {
            conn: &'conn Connection,
            drop_behavior: DropBehavior,
        }

        /// Represents a savepoint on a database connection.
        #[derive(Debug)]
        pub struct Savepoint<'conn> {
            conn: &'conn Connection,
            name: String,
            drop_behavior: DropBehavior,
            committed: bool,
        }

        impl Transaction<'_> {
            /// Begin a new transaction. Cannot be nested; see `savepoint` for nested
            /// transactions.
            #[inline] pub fn new(conn: &mut Connection, behavior: TransactionBehavior) -> Result<Transaction<'_>> {
                Self::new_unchecked(conn, behavior)
            }

            /// Begin a new transaction, failing if a transaction is open.
            #[inline] pub fn new_unchecked(
                conn: &Connection,
                behavior: TransactionBehavior,
            ) -> Result<Transaction<'_>> {
                let query = match behavior {
                    TransactionBehavior::Deferred => "BEGIN DEFERRED",
                    TransactionBehavior::Immediate => "BEGIN IMMEDIATE",
                    TransactionBehavior::Exclusive => "BEGIN EXCLUSIVE",
                };
                conn.execute_batch(query).map(move |()| Transaction {
                    conn,
                    drop_behavior: DropBehavior::Rollback,
                })
            }

            /// Starts a new [savepoint](http://www.sqlite.org/lang_savepoint.html), allowing nested
            /// transactions.
            #[inline] pub fn savepoint(&mut self) -> Result<Savepoint<'_>> {
                Savepoint::new_(self.conn)
            }

            /// Create a new savepoint with a custom savepoint name. See `savepoint()`.
            #[inline] pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(self.conn, name)
            }

            /// Get the current setting for what happens to the transaction when it is
            /// dropped.
            #[inline]
            #[must_use]
            pub fn drop_behavior(&self) -> DropBehavior {
                self.drop_behavior
            }

            /// Configure the transaction to perform the specified action when it is
            /// dropped.
            #[inline] pub fn set_drop_behavior(&mut self, drop_behavior: DropBehavior) {
                self.drop_behavior = drop_behavior;
            }

            /// A convenience method which consumes and commits a transaction.
            #[inline] pub fn commit(mut self) -> Result<()> {
                self.commit_()
            }

            #[inline] fn commit_(&mut self) -> Result<()> {
                self.conn.execute_batch("COMMIT")?;
                Ok(())
            }

            /// A convenience method which consumes and rolls back a transaction.
            #[inline] pub fn rollback(mut self) -> Result<()> {
                self.rollback_()
            }

            #[inline] fn rollback_(&mut self) -> Result<()> {
                self.conn.execute_batch("ROLLBACK")?;
                Ok(())
            }

            /// Consumes the transaction, committing or rolling back according to the
            /// current setting (see `drop_behavior`).
            #[inline] pub fn finish(mut self) -> Result<()> {
                self.finish_()
            }

            #[inline] fn finish_(&mut self) -> Result<()> {
                if self.conn.is_autocommit() {
                    return Ok(());
                }
                match self.drop_behavior() {
                    DropBehavior::Commit => self.commit_().or_else(|_| self.rollback_()),
                    DropBehavior::Rollback => self.rollback_(),
                    DropBehavior::Ignore => Ok(()),
                    DropBehavior::Panic => panic!("Transaction dropped unexpectedly."),
                }
            }
        }

        impl Deref for Transaction<'_> {
            type Target = Connection;

            #[inline] fn deref(&self) -> &Connection {
                self.conn
            }
        }

        #[expect(unused_must_use)]
        impl Drop for Transaction<'_> {
            #[inline] fn drop(&mut self) {
                self.finish_();
            }
        }

        impl Savepoint<'_> {
            #[inline] fn with_name_<T: Into<String>>(conn: &Connection, name: T) -> Result<Savepoint<'_>> {
                let name = name.into();
                conn.execute_batch(&format!("SAVEPOINT {name}"))
                    .map(|()| Savepoint {
                        conn,
                        name,
                        drop_behavior: DropBehavior::Rollback,
                        committed: false,
                    })
            }

            #[inline] fn new_(conn: &Connection) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(conn, "_rusqlite_sp")
            }

            /// Begin a new savepoint. Can be nested.
            #[inline] pub fn new(conn: &mut Connection) -> Result<Savepoint<'_>> {
                Savepoint::new_(conn)
            }

            /// Begin a new savepoint with a user-provided savepoint name.
            #[inline] pub fn with_name<T: Into<String>>(conn: &mut Connection, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(conn, name)
            }

            /// Begin a nested savepoint.
            #[inline] pub fn savepoint(&mut self) -> Result<Savepoint<'_>> {
                Savepoint::new_(self.conn)
            }

            /// Begin a nested savepoint with a user-provided savepoint name.
            #[inline] pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name_(self.conn, name)
            }

            /// Get the current setting for what happens to the savepoint when it is
            /// dropped.
            #[inline]
            #[must_use]
            pub fn drop_behavior(&self) -> DropBehavior {
                self.drop_behavior
            }

            /// Configure the savepoint to perform the specified action when it is
            /// dropped.
            #[inline] pub fn set_drop_behavior(&mut self, drop_behavior: DropBehavior) {
                self.drop_behavior = drop_behavior;
            }

            /// A convenience method which consumes and commits a savepoint.
            #[inline] pub fn commit(mut self) -> Result<()> {
                self.commit_()
            }

            #[inline] fn commit_(&mut self) -> Result<()> {
                self.conn.execute_batch(&format!("RELEASE {}", self.name))?;
                self.committed = true;
                Ok(())
            }

            /// A convenience method which rolls back a savepoint.
            #[inline] pub fn rollback(&mut self) -> Result<()> {
                self.conn
                    .execute_batch(&format!("ROLLBACK TO {}", self.name))
            }

            /// Consumes the savepoint, committing or rolling back according to the
            /// current setting (see `drop_behavior`).
            #[inline] pub fn finish(mut self) -> Result<()> {
                self.finish_()
            }

            #[inline] fn finish_(&mut self) -> Result<()> {
                if self.committed {
                    return Ok(());
                }
                match self.drop_behavior() {
                    DropBehavior::Commit => self
                        .commit_()
                        .or_else(|_| self.rollback().and_then(|()| self.commit_())),
                    DropBehavior::Rollback => self.rollback().and_then(|()| self.commit_()),
                    DropBehavior::Ignore => Ok(()),
                    DropBehavior::Panic => panic!("Savepoint dropped unexpectedly."),
                }
            }
        }

        impl Deref for Savepoint<'_> {
            type Target = Connection;

            #[inline] fn deref(&self) -> &Connection {
                self.conn
            }
        }

        #[expect(unused_must_use)]
        impl Drop for Savepoint<'_> {
            #[inline] fn drop(&mut self) {
                self.finish_();
            }
        }

        /// Transaction state of a database
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum TransactionState {
            /// Equivalent to `SQLITE_TXN_NONE`
            None,
            /// Equivalent to `SQLITE_TXN_READ`
            Read,
            /// Equivalent to `SQLITE_TXN_WRITE`
            Write,
        }

        impl Connection {
            /// Begin a new transaction with the default behavior (DEFERRED).
            #[inline] pub fn transaction(&mut self) -> Result<Transaction<'_>> {
                Transaction::new(self, self.transaction_behavior)
            }

            /// Begin a new transaction with a specified behavior.
            #[inline] pub fn transaction_with_behavior(
                &mut self,
                behavior: TransactionBehavior,
            ) -> Result<Transaction<'_>> {
                Transaction::new(self, behavior)
            }

            /// Begin a new transaction with the default behavior (DEFERRED).
            pub fn unchecked_transaction(&self) -> Result<Transaction<'_>> {
                Transaction::new_unchecked(self, self.transaction_behavior)
            }

            /// Begin a new savepoint with the default behavior (DEFERRED).
            #[inline] pub fn savepoint(&mut self) -> Result<Savepoint<'_>> {
                Savepoint::new(self)
            }

            /// Begin a new savepoint with a specified name.
            #[inline] pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>> {
                Savepoint::with_name(self, name)
            }

            /// Determine the transaction state of a database
            pub fn transaction_state(
                &self,
                db_name: Option<crate::DatabaseName<'_>>,
            ) -> Result<TransactionState> {
                self.db.borrow().txn_state(db_name)
            }

            /// Set the default transaction behavior for the connection.
            pub fn set_transaction_behavior(&mut self, behavior: TransactionBehavior) {
                self.transaction_behavior = behavior;
            }
        }
    }
    
    pub mod types
    {
        //! Traits dealing with SQLite data types.
        use ::
        {
            *,
        };
        /*
        pub use self::from_sql::{FromSql, FromSqlError, FromSqlResult};
        pub use self::to_sql::{ToSql, ToSqlOutput};
        pub use self::value::Value;
        pub use self::value_ref::ValueRef;

        use ::fmt;
        */
        mod from_sql
        {
            use ::
            {
                *,
            };
            /*
            use super::{Value, ValueRef};
            use ::borrow::Cow;
            use ::error::Error;
            use ::fmt;
            */
            /// Enum listing possible errors from [`FromSql`] trait.
            #[derive(Debug)]
            #[non_exhaustive]
            pub enum FromSqlError 
            {
                /// Error when an SQLite value is requested, but the type of the result
                /// cannot be converted to the requested Rust type.
                InvalidType,

                /// Error when the i64 value returned by SQLite cannot be stored into the
                /// requested type.
                OutOfRange(i64),

                /// Error when the blob result returned by SQLite cannot be stored into the
                /// requested type due to a size mismatch.
                InvalidBlobSize {
                    /// The expected size of the blob.
                    expected_size: usize,
                    /// The actual size of the blob that was returned.
                    blob_size: usize,
                },

                /// An error case available for implementors of the [`FromSql`] trait.
                Other(Box<dyn Error + Send + Sync + 'static>),
            }

            impl PartialEq for FromSqlError {
                fn eq(&self, other: &Self) -> bool {
                    match (self, other) {
                        (Self::InvalidType, Self::InvalidType) => true,
                        (Self::OutOfRange(n1), Self::OutOfRange(n2)) => n1 == n2,
                        (
                            Self::InvalidBlobSize {
                                expected_size: es1,
                                blob_size: bs1,
                            },
                            Self::InvalidBlobSize {
                                expected_size: es2,
                                blob_size: bs2,
                            },
                        ) => es1 == es2 && bs1 == bs2,
                        (..) => false,
                    }
                }
            }

            impl fmt::Display for FromSqlError {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    match *self {
                        Self::InvalidType => write!(f, "Invalid type"),
                        Self::OutOfRange(i) => write!(f, "Value {i} out of range"),
                        Self::InvalidBlobSize {
                            expected_size,
                            blob_size,
                        } => {
                            write!(
                                f,
                                "Cannot read {expected_size} byte value out of {blob_size} byte blob"
                            )
                        }
                        Self::Other(ref err) => err.fmt(f),
                    }
                }
            }

            impl Error for FromSqlError {
                fn source(&self) -> Option<&(dyn Error + 'static)> {
                    if let Self::Other(ref err) = self {
                        Some(&**err)
                    } else {
                        None
                    }
                }
            }

            /// Result type for implementors of the [`FromSql`] trait.
            pub type FromSqlResult<T> = Result<T, FromSqlError>;

            /// A trait for types that can be created from a SQLite value.
            pub trait FromSql: Sized {
                /// Converts SQLite value into Rust value.
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self>;
            }

            macro_rules! from_sql_integral(
                ($t:ident) => (
                    impl FromSql for $t {
                        #[inline]
                        fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                            let i = i64::column_result(value)?;
                            i.try_into().map_err(|_| FromSqlError::OutOfRange(i))
                        }
                    }
                );
                (non_zero $nz:ty, $z:ty) => (
                    impl FromSql for $nz {
                        #[inline]
                        fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                            let i = <$z>::column_result(value)?;
                            <$nz>::new(i).ok_or(FromSqlError::OutOfRange(0))
                        }
                    }
                )
            );

            from_sql_integral!(i8);
            from_sql_integral!(i16);
            from_sql_integral!(i32);
            from_sql_integral!(isize);
            from_sql_integral!(u8);
            from_sql_integral!(u16);
            from_sql_integral!(u32);
            from_sql_integral!(u64);
            from_sql_integral!(usize);

            from_sql_integral!(non_zero ::num::NonZeroIsize, isize);
            from_sql_integral!(non_zero ::num::NonZeroI8, i8);
            from_sql_integral!(non_zero ::num::NonZeroI16, i16);
            from_sql_integral!(non_zero ::num::NonZeroI32, i32);
            from_sql_integral!(non_zero ::num::NonZeroI64, i64);

            from_sql_integral!(non_zero ::num::NonZeroUsize, usize);
            from_sql_integral!(non_zero ::num::NonZeroU8, u8);
            from_sql_integral!(non_zero ::num::NonZeroU16, u16);
            from_sql_integral!(non_zero ::num::NonZeroU32, u32);
            from_sql_integral!(non_zero ::num::NonZeroU64, u64);

            impl FromSql for i64 {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_i64()
                }
            }

            impl FromSql for f32 {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Integer(i) => Ok(i as Self),
                        ValueRef::Real(f) => Ok(f as Self),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }

            impl FromSql for f64 {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Integer(i) => Ok(i as Self),
                        ValueRef::Real(f) => Ok(f),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }

            impl FromSql for bool {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    i64::column_result(value).map(|i| i != 0)
                }
            }

            impl FromSql for String {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(ToString::to_string)
                }
            }

            impl FromSql for Box<str> {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(Into::into)
                }
            }

            impl FromSql for ::rc::Rc<str> {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(Into::into)
                }
            }

            impl FromSql for ::sync::Arc<str> {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_str().map(Into::into)
                }
            }

            impl FromSql for Vec<u8> {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_blob().map(<[u8]>::to_vec)
                }
            }

            impl FromSql for Box<[u8]> {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_blob().map(Box::<[u8]>::from)
                }
            }

            impl FromSql for ::rc::Rc<[u8]> {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_blob().map( ::rc::Rc::<[u8]>::from)
                }
            }

            impl FromSql for ::sync::Arc<[u8]> {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    value.as_blob().map( ::sync::Arc::<[u8]>::from)
                }
            }

            impl<const N: usize> FromSql for [u8; N] {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    let slice = value.as_blob()?;
                    slice.try_into().map_err(|_| FromSqlError::InvalidBlobSize {
                        expected_size: N,
                        blob_size: slice.len(),
                    })
                }
            }
            
            impl FromSql for uuid::Uuid {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    let bytes = <[u8; 16]>::column_result(value)?;
                    Ok(Self::from_u128(u128::from_be_bytes(bytes)))
                }
            }

            impl<T: FromSql> FromSql for Option<T> {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    match value {
                        ValueRef::Null => Ok(None),
                        _ => FromSql::column_result(value).map(Some),
                    }
                }
            }

            impl<T: ?Sized> FromSql for Cow<'_, T>
            where
                T: ToOwned,
                T::Owned: FromSql,
            {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    <T::Owned>::column_result(value).map(Cow::Owned)
                }
            }

            impl FromSql for Value {
                #[inline]
                fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
                    Ok(value.into())
                }
            }
        }
        
        mod to_sql
        {
            use ::
            {
                *,
            };
            /*
            use super::{Null, Value, ValueRef};
            #[cfg(feature = "array")]
            use crate::vtab::array::Array;
            use crate::{Error, Result};
            use ::borrow::Cow;
            */
            /// `ToSqlOutput` represents the possible output types for implementers of the
            /// [`ToSql`] trait.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ToSqlOutput<'a> {
                /// A borrowed SQLite-representable value.
                Borrowed(ValueRef<'a>),

                /// An owned SQLite-representable value.
                Owned(Value),
            }
            
            impl<'a, T: ?Sized> From<&'a T> for ToSqlOutput<'a>
            where
                &'a T: Into<ValueRef<'a>>,
            {
                #[inline]
                fn from(t: &'a T) -> Self {
                    ToSqlOutput::Borrowed(t.into())
                }
            }
            
            macro_rules! from_value(
                ($t:ty) => (
                    impl From<$t> for ToSqlOutput<'_> {
                        #[inline]
                        fn from(t: $t) -> Self { ToSqlOutput::Owned(t.into())}
                    }
                );
                (non_zero $t:ty) => (
                    impl From<$t> for ToSqlOutput<'_> {
                        #[inline]
                        fn from(t: $t) -> Self { ToSqlOutput::Owned(t.get().into())}
                    }
                )
            );
            from_value!(String);
            from_value!(Null);
            from_value!(bool);
            from_value!(i8);
            from_value!(i16);
            from_value!(i32);
            from_value!(i64);
            from_value!(isize);
            from_value!(u8);
            from_value!(u16);
            from_value!(u32);
            from_value!(f32);
            from_value!(f64);
            from_value!(Vec<u8>);

            from_value!(non_zero ::num::NonZeroI8);
            from_value!(non_zero ::num::NonZeroI16);
            from_value!(non_zero ::num::NonZeroI32);
            from_value!(non_zero ::num::NonZeroI64);
            from_value!(non_zero ::num::NonZeroIsize);
            from_value!(non_zero ::num::NonZeroU8);
            from_value!(non_zero ::num::NonZeroU16);
            from_value!(non_zero ::num::NonZeroU32);
            
            from_value!(uuid::Uuid);

            impl ToSql for ToSqlOutput<'_> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(match *self {
                        ToSqlOutput::Borrowed(v) => ToSqlOutput::Borrowed(v),
                        ToSqlOutput::Owned(ref v) => ToSqlOutput::Borrowed(ValueRef::from(v)),
                    })
                }
            }

            /// A trait for types that can be converted into SQLite values. Returns
            /// [`Error::ToSqlConversionFailure`] if the conversion fails.
            pub trait ToSql {
                /// Converts Rust value to SQLite value
                fn to_sql(&self) -> Result<ToSqlOutput<'_>>;
            }

            impl<T: ToSql + ToOwned + ?Sized> ToSql for Cow<'_, T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }

            impl<T: ToSql + ?Sized> ToSql for Box<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }

            impl<T: ToSql + ?Sized> ToSql for ::rc::Rc<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }

            impl<T: ToSql + ?Sized> ToSql for ::sync::Arc<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    self.as_ref().to_sql()
                }
            }
            
            macro_rules! to_sql_self(
                ($t:ty) => (
                    impl ToSql for $t {
                        #[inline]
                        fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                            Ok(ToSqlOutput::from(*self))
                        }
                    }
                )
            );

            to_sql_self!(Null);
            to_sql_self!(bool);
            to_sql_self!(i8);
            to_sql_self!(i16);
            to_sql_self!(i32);
            to_sql_self!(i64);
            to_sql_self!(isize);
            to_sql_self!(u8);
            to_sql_self!(u16);
            to_sql_self!(u32);
            to_sql_self!(f32);
            to_sql_self!(f64);

            to_sql_self!( ::num::NonZeroI8);
            to_sql_self!( ::num::NonZeroI16);
            to_sql_self!( ::num::NonZeroI32);
            to_sql_self!( ::num::NonZeroI64);
            to_sql_self!( ::num::NonZeroIsize);
            to_sql_self!( ::num::NonZeroU8);
            to_sql_self!( ::num::NonZeroU16);
            to_sql_self!( ::num::NonZeroU32);
            to_sql_self!(uuid::Uuid);

            macro_rules! to_sql_self_fallible(
                ($t:ty) => (
                    impl ToSql for $t {
                        #[inline]
                        fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                            Ok(ToSqlOutput::Owned(Value::Integer(
                                i64::try_from(*self).map_err(
                                    // TODO: Include the values in the error message.
                                    |err| Error::ToSqlConversionFailure(err.into())
                                )?
                            )))
                        }
                    }
                );
                (non_zero $t:ty) => (
                    impl ToSql for $t {
                        #[inline]
                        fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                            Ok(ToSqlOutput::Owned(Value::Integer(
                                i64::try_from(self.get()).map_err(
                                    // TODO: Include the values in the error message.
                                    |err| Error::ToSqlConversionFailure(err.into())
                                )?
                            )))
                        }
                    }
                )
            );
            
            to_sql_self_fallible!(u64);
            to_sql_self_fallible!(usize);
            to_sql_self_fallible!(non_zero ::num::NonZeroU64);
            to_sql_self_fallible!(non_zero ::num::NonZeroUsize);

            impl<T: ?Sized> ToSql for &'_ T
            where
                T: ToSql,
            {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    (*self).to_sql()
                }
            }

            impl ToSql for String {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self.as_str()))
                }
            }

            impl ToSql for str {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self))
                }
            }

            impl ToSql for Vec<u8> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self.as_slice()))
                }
            }

            impl<const N: usize> ToSql for [u8; N] {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(&self[..]))
                }
            }

            impl ToSql for [u8] {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self))
                }
            }

            impl ToSql for Value {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    Ok(ToSqlOutput::from(self))
                }
            }

            impl<T: ToSql> ToSql for Option<T> {
                #[inline]
                fn to_sql(&self) -> Result<ToSqlOutput<'_>> {
                    match *self {
                        None => Ok(ToSqlOutput::from(Null)),
                        Some(ref t) => t.to_sql(),
                    }
                }
            }
        }
        
        mod value
        {
            use ::
            {
                *,
            };
            /*
            use super::{Null, Type};
            */
            /// Owning [dynamic type value](http://sqlite.org/datatype3.html).
            #[derive(Clone, Debug, PartialEq)]
            pub enum Value {
                /// The value is a `NULL` value.
                Null,
                /// The value is a signed integer.
                Integer(i64),
                /// The value is a floating point number.
                Real(f64),
                /// The value is a text string.
                Text(String),
                /// The value is a blob of data
                Blob(Vec<u8>),
            }

            impl From<Null> for Value {
                #[inline]
                fn from(_: Null) -> Self {
                    Self::Null
                }
            }

            impl From<bool> for Value {
                #[inline]
                fn from(i: bool) -> Self {
                    Self::Integer(i as i64)
                }
            }

            impl From<isize> for Value {
                #[inline]
                fn from(i: isize) -> Self {
                    Self::Integer(i as i64)
                }
            }
            
            impl From<uuid::Uuid> for Value {
                #[inline]
                fn from(id: uuid::Uuid) -> Self {
                    Self::Blob(id.as_bytes().to_vec())
                }
            }

            macro_rules! from_i64(
                ($t:ty) => (
                    impl From<$t> for Value {
                        #[inline]
                        fn from(i: $t) -> Value {
                            Value::Integer(i64::from(i))
                        }
                    }
                )
            );

            from_i64!(i8);
            from_i64!(i16);
            from_i64!(i32);
            from_i64!(u8);
            from_i64!(u16);
            from_i64!(u32);

            impl From<i64> for Value {
                #[inline]
                fn from(i: i64) -> Self {
                    Self::Integer(i)
                }
            }

            impl From<f32> for Value {
                #[inline]
                fn from(f: f32) -> Self {
                    Self::Real(f.into())
                }
            }

            impl From<f64> for Value {
                #[inline]
                fn from(f: f64) -> Self {
                    Self::Real(f)
                }
            }

            impl From<String> for Value {
                #[inline]
                fn from(s: String) -> Self {
                    Self::Text(s)
                }
            }

            impl From<Vec<u8>> for Value {
                #[inline]
                fn from(v: Vec<u8>) -> Self {
                    Self::Blob(v)
                }
            }

            impl<T> From<Option<T>> for Value
            where
                T: Into<Self>,
            {
                #[inline]
                fn from(v: Option<T>) -> Self {
                    match v {
                        Some(x) => x.into(),
                        None => Self::Null,
                    }
                }
            }

            impl Value {
                /// Returns SQLite fundamental datatype.
                #[inline]
                #[must_use]
                pub fn data_type(&self) -> Type {
                    match *self {
                        Self::Null => Type::Null,
                        Self::Integer(_) => Type::Integer,
                        Self::Real(_) => Type::Real,
                        Self::Text(_) => Type::Text,
                        Self::Blob(_) => Type::Blob,
                    }
                }
            }
        }
        
        mod value_ref
        {
            use ::
            {
                *,
            };
            /*
            use super::{Type, Value};
            use crate::types::{FromSqlError, FromSqlResult};
            */
            /// A non-owning [dynamic type value](http://sqlite.org/datatype3.html).
            #[derive(Copy, Clone, Debug, PartialEq)]
            pub enum ValueRef<'a> {
                /// The value is a `NULL` value.
                Null,
                /// The value is a signed integer.
                Integer(i64),
                /// The value is a floating point number.
                Real(f64),
                /// The value is a text string.
                Text(&'a [u8]),
                /// The value is a blob of data
                Blob(&'a [u8]),
            }

            impl ValueRef<'_> {
                /// Returns SQLite fundamental datatype.
                #[inline]
                #[must_use]
                pub fn data_type(&self) -> Type {
                    match *self {
                        ValueRef::Null => Type::Null,
                        ValueRef::Integer(_) => Type::Integer,
                        ValueRef::Real(_) => Type::Real,
                        ValueRef::Text(_) => Type::Text,
                        ValueRef::Blob(_) => Type::Blob,
                    }
                }
            }

            impl<'a> ValueRef<'a> {
                /// If `self` is case `Integer`, returns the integral value. Otherwise,
                /// returns [`Err(FromSqlError::InvalidType)`](crate::types::from_sql::FromSqlError::InvalidType).
                #[inline]
                pub fn as_i64(&self) -> FromSqlResult<i64> {
                    match *self {
                        ValueRef::Integer(i) => Ok(i),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }

                /// If `self` is case `Null` returns None.
                /// If `self` is case `Integer`, returns the integral value.
                /// Otherwise, returns [`Err(FromSqlError::InvalidType)`](crate::types::from_sql::FromSqlError::InvalidType).
                #[inline]
                pub fn as_i64_or_null(&self) -> FromSqlResult<Option<i64>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Integer(i) => Ok(Some(i)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }

                /// If `self` is case `Real`, returns the floating point value. Otherwise,
                /// returns [`Err(FromSqlError::InvalidType)`](crate::types::from_sql::FromSqlError::InvalidType).
                #[inline]
                pub fn as_f64(&self) -> FromSqlResult<f64> {
                    match *self {
                        ValueRef::Real(f) => Ok(f),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }

                /// If `self` is case `Null` returns None.
                /// If `self` is case `Real`, returns the floating point value.
                /// Otherwise, returns [`Err(FromSqlError::InvalidType)`](crate::types::from_sql::FromSqlError::InvalidType).
                #[inline]
                pub fn as_f64_or_null(&self) -> FromSqlResult<Option<f64>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Real(f) => Ok(Some(f)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }

                /// If `self` is case `Text`, returns the string value. Otherwise, returns
                /// [`Err(FromSqlError::InvalidType)`](crate::types::from_sql::FromSqlError::InvalidType).
                #[inline]
                pub fn as_str(&self) -> FromSqlResult<&'a str> {
                    match *self {
                        ValueRef::Text(t) => {
                            ::str::from_utf8(t).map_err(|e| FromSqlError::Other(Box::new(e)))
                        }
                        _ => Err(FromSqlError::InvalidType),
                    }
                }

                /// If `self` is case `Null` returns None.
                /// If `self` is case `Text`, returns the string value.
                /// Otherwise, returns [`Err(FromSqlError::InvalidType)`](crate::types::from_sql::FromSqlError::InvalidType).
                #[inline]
                pub fn as_str_or_null(&self) -> FromSqlResult<Option<&'a str>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Text(t) => ::str::from_utf8(t)
                            .map_err(|e| FromSqlError::Other(Box::new(e)))
                            .map(Some),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }

                /// If `self` is case `Blob`, returns the byte slice. Otherwise, returns
                /// [`Err(FromSqlError::InvalidType)`](crate::types::from_sql::FromSqlError::InvalidType).
                #[inline]
                pub fn as_blob(&self) -> FromSqlResult<&'a [u8]> {
                    match *self {
                        ValueRef::Blob(b) => Ok(b),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }

                /// If `self` is case `Null` returns None.
                /// If `self` is case `Blob`, returns the byte slice.
                /// Otherwise, returns [`Err(FromSqlError::InvalidType)`](crate::types::from_sql::FromSqlError::InvalidType).
                #[inline]
                pub fn as_blob_or_null(&self) -> FromSqlResult<Option<&'a [u8]>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Blob(b) => Ok(Some(b)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }

                /// Returns the byte slice that makes up this `ValueRef` if it's either
                /// [`ValueRef::Blob`] or [`ValueRef::Text`].
                #[inline]
                pub fn as_bytes(&self) -> FromSqlResult<&'a [u8]> {
                    match self {
                        ValueRef::Text(s) | ValueRef::Blob(s) => Ok(s),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }

                /// If `self` is case `Null` returns None.
                /// If `self` is [`ValueRef::Blob`] or [`ValueRef::Text`] returns the byte
                /// slice that makes up this value
                #[inline]
                pub fn as_bytes_or_null(&self) -> FromSqlResult<Option<&'a [u8]>> {
                    match *self {
                        ValueRef::Null => Ok(None),
                        ValueRef::Text(s) | ValueRef::Blob(s) => Ok(Some(s)),
                        _ => Err(FromSqlError::InvalidType),
                    }
                }
            }

            impl From<ValueRef<'_>> for Value {
                #[inline]
                #[track_caller]
                fn from(borrowed: ValueRef<'_>) -> Self {
                    match borrowed {
                        ValueRef::Null => Self::Null,
                        ValueRef::Integer(i) => Self::Integer(i),
                        ValueRef::Real(r) => Self::Real(r),
                        ValueRef::Text(s) => {
                            let s = ::str::from_utf8(s).expect("invalid UTF-8");
                            Self::Text(s.to_string())
                        }
                        ValueRef::Blob(b) => Self::Blob(b.to_vec()),
                    }
                }
            }

            impl<'a> From<&'a str> for ValueRef<'a> {
                #[inline]
                fn from(s: &str) -> ValueRef<'_> {
                    ValueRef::Text(s.as_bytes())
                }
            }

            impl<'a> From<&'a [u8]> for ValueRef<'a> {
                #[inline]
                fn from(s: &[u8]) -> ValueRef<'_> {
                    ValueRef::Blob(s)
                }
            }

            impl<'a> From<&'a Value> for ValueRef<'a> {
                #[inline]
                fn from(value: &'a Value) -> Self {
                    match *value {
                        Value::Null => ValueRef::Null,
                        Value::Integer(i) => ValueRef::Integer(i),
                        Value::Real(r) => ValueRef::Real(r),
                        Value::Text(ref s) => ValueRef::Text(s.as_bytes()),
                        Value::Blob(ref b) => ValueRef::Blob(b),
                    }
                }
            }

            impl<T> From<Option<T>> for ValueRef<'_>
            where
                T: Into<Self>,
            {
                #[inline]
                fn from(s: Option<T>) -> Self {
                    match s {
                        Some(x) => x.into(),
                        None => ValueRef::Null,
                    }
                }
            }
        }
        
        /// Empty struct that can be used to fill in a query parameter as `NULL`.
        #[derive(Copy, Clone)]
        pub struct Null;

        /// SQLite data types.
        #[derive(Copy, Clone, Debug, PartialEq, Eq)]
        pub enum Type {
            /// NULL
            Null,
            /// 64-bit signed integer
            Integer,
            /// 64-bit IEEE floating point number
            Real,
            /// String
            Text,
            /// BLOB
            Blob,
        }

        impl fmt::Display for Type {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match *self {
                    Self::Null => f.pad("Null"),
                    Self::Integer => f.pad("Integer"),
                    Self::Real => f.pad("Real"),
                    Self::Text => f.pad("Text"),
                    Self::Blob => f.pad("Blob"),
                }
            }
        }

    }
    
    pub mod version
    {
        use ::
        {
            *,
        };
        /*
        */
    }
    
    pub mod util
    {
        use ::
        {
            *,
        };
        /*
        */
    } pub use util::SmallCString;
    
    /// Number of cached prepared statements we'll hold on to.
    const STATEMENT_CACHE_DEFAULT_CAPACITY: usize = 16;
    
    /// A macro making it more convenient to longer lists of
    /// parameters as a `&[&dyn ToSql]`.
    #[macro_export] macro_rules! params {
        () => {
            &[] as &[&dyn $crate::ToSql]
        };
        ($($param:expr),+ $(,)?) => {
            &[$(&$param as &dyn $crate::ToSql),+] as &[&dyn $crate::ToSql]
        };
    }
    
    /// A macro making it more convenient to pass lists of named parameters
    /// as a `&[(&str, &dyn ToSql)]`.
    #[macro_export] macro_rules! named_params {
        () => {
            &[] as &[(&str, &dyn $crate::ToSql)]
        };
        ($($param_name:literal: $param_val:expr),+ $(,)?) => {
            &[$(($param_name, &$param_val as &dyn $crate::ToSql)),+] as &[(&str, &dyn $crate::ToSql)]
        };
    }
        
    /// A typedef of the result returned by many methods.
    pub type Result<T, E = Error> = result::Result<T, E>;
    
    /// See the [method documentation](#tymethod.optional).
    pub trait OptionalExtension<T> {
        fn optional(self) -> Result<Option<T>>;
    }
    
    impl<T> OptionalExtension<T> for Result<T> {
        fn optional(self) -> Result<Option<T>> {
            match self {
                Ok(value) => Ok(Some(value)),
                Err(Error::QueryReturnedNoRows) => Ok(None),
                Err(e) => Err(e),
            }
        }
    }
    
    unsafe fn errmsg_to_string(errmsg: *const c_char) -> String {
        CStr::from_ptr(errmsg).to_string_lossy().into_owned()
    }
    
    fn str_to_cstring(s: &str) -> Result<SmallCString> {
        Ok(SmallCString::new(s)?)
    }
    
    /// Returns `Ok((string ptr, len as c_int, SQLITE_STATIC | SQLITE_TRANSIENT))`
    /// normally.
    fn str_for_sqlite(s: &[u8]) -> Result<(*const c_char, c_int, ffi::sqlite3_destructor_type)> {
        let len = len_as_c_int(s.len())?;
        let (ptr, dtor_info) = if len != 0 {
            (s.as_ptr().cast::<c_char>(), ffi::SQLITE_TRANSIENT())
        } else {
            // Return a pointer guaranteed to live forever
            ("".as_ptr().cast::<c_char>(), ffi::SQLITE_STATIC())
        };
        Ok((ptr, len, dtor_info))
    }
    
    fn len_as_c_int(len: usize) -> Result<c_int> {
        if len >= (c_int::MAX as usize) {
            Err(Error::SqliteFailure(
                ffi::Error::new(ffi::SQLITE_TOOBIG),
                None,
            ))
        } else {
            Ok(len as c_int)
        }
    }
    
    #[cfg(unix)]
    fn path_to_cstring(p: &Path) -> Result<CString> {
        use ::os::unix::ffi::OsStrExt;
        Ok(CString::new(p.as_os_str().as_bytes())?)
    }
    
    #[cfg(not(unix))]
    fn path_to_cstring(p: &Path) -> Result<CString> {
        let s = p.to_str().ok_or_else(|| Error::InvalidPath(p.to_owned()))?;
        Ok(CString::new(s)?)
    }
    
    /// Name for a database within a SQLite connection.
    #[derive(Copy, Clone, Debug)]
    pub enum DatabaseName<'a> {
        /// The main database.
        Main,
    
        /// The temporary database (e.g., any "CREATE TEMPORARY TABLE" tables).
        Temp,
    
        /// A database that has been attached via "ATTACH DATABASE ...".
        Attached(&'a str),
    }
    
    /// Shorthand for [`DatabaseName::Main`].
    pub const MAIN_DB: DatabaseName<'static> = DatabaseName::Main;
    
    /// Shorthand for [`DatabaseName::Temp`].
    pub const TEMP_DB: DatabaseName<'static> = DatabaseName::Temp;
    
    impl DatabaseName<'_> {
        #[inline]
        fn as_cstring(&self) -> Result<SmallCString> {
            use self::DatabaseName::{Attached, Main, Temp};
            match *self {
                Main => str_to_cstring("main"), // TODO C-string literals
                Temp => str_to_cstring("temp"),
                Attached(s) => str_to_cstring(s),
            }
        }
    }
    
    /// A connection to a SQLite database.
    pub struct Connection {
        db: RefCell<InnerConnection>,
        cache: StatementCache,
        transaction_behavior: TransactionBehavior,
    }
    
    unsafe impl Send for Connection {}
    
    impl Drop for Connection {
        #[inline]
        fn drop(&mut self) {
            self.flush_prepared_statement_cache();
        }
    }
    
    impl Connection {
        /// Open a new connection to a SQLite database. If a database does not exist
        /// at the path, one is created.
        #[inline]
        pub fn open<P: AsRef<Path>>(path: P) -> Result<Connection> {
            let flags = OpenFlags::default();
            Connection::open_with_flags(path, flags)
        }
    
        /// Open a new connection to an in-memory SQLite database.
        #[inline]
        pub fn open_in_memory() -> Result<Connection> {
            let flags = OpenFlags::default();
            Connection::open_in_memory_with_flags(flags)
        }
    
        /// Open a new connection to a SQLite database.
        #[inline]
        pub fn open_with_flags<P: AsRef<Path>>(path: P, flags: OpenFlags) -> Result<Connection> {
            let c_path = path_to_cstring(path.as_ref())?;
            InnerConnection::open_with_flags(&c_path, flags, None).map(|db| Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
    
        /// Open a new connection to a SQLite database using the specific flags and
        /// vfs name.
        #[inline]
        pub fn open_with_flags_and_vfs<P: AsRef<Path>>(
            path: P,
            flags: OpenFlags,
            vfs: &str,
        ) -> Result<Connection> {
            let c_path = path_to_cstring(path.as_ref())?;
            let c_vfs = str_to_cstring(vfs)?;
            InnerConnection::open_with_flags(&c_path, flags, Some(&c_vfs)).map(|db| Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
    
        /// Open a new connection to an in-memory SQLite database.
        #[inline]
        pub fn open_in_memory_with_flags(flags: OpenFlags) -> Result<Connection> {
            Connection::open_with_flags(":memory:", flags)
        }
    
        /// Open a new connection to an in-memory SQLite database using the specific
        /// flags and vfs name.
        #[inline]
        pub fn open_in_memory_with_flags_and_vfs(flags: OpenFlags, vfs: &str) -> Result<Connection> {
            Connection::open_with_flags_and_vfs(":memory:", flags, vfs)
        }
    
        /// Convenience method to run multiple SQL statements (that cannot take any
        /// parameters).
        pub fn execute_batch(&self, sql: &str) -> Result<()> {
            let mut sql = sql;
            while !sql.is_empty() {
                let stmt = self.prepare(sql)?;
                if !stmt.stmt.is_null() && stmt.step()? && cfg!(feature = "extra_check") {
                    // Some PRAGMA may return rows
                    return Err(Error::ExecuteReturnedResults);
                }
                let tail = stmt.stmt.tail();
                if tail == 0 || tail >= sql.len() {
                    break;
                }
                sql = &sql[tail..];
            }
            Ok(())
        }
            
        /// Get access to the underlying SQLite database connection handle.
        #[inline]
        pub unsafe fn handle(&self) -> *mut ffi::sqlite3 {
            self.db.borrow().db()
        }
    
        /// Create a `Connection` from a raw handle.
        #[inline]
        pub unsafe fn from_handle(db: *mut ffi::sqlite3) -> Result<Connection> {
            let db = InnerConnection::new(db, false);
            Ok(Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
            
        /// Create a `Connection` from a raw owned handle.
        #[inline]
        pub unsafe fn from_handle_owned(db: *mut ffi::sqlite3) -> Result<Connection> {
            let db = InnerConnection::new(db, true);
            Ok(Connection {
                db: RefCell::new(db),
                cache: StatementCache::with_capacity(STATEMENT_CACHE_DEFAULT_CAPACITY),
                transaction_behavior: TransactionBehavior::Deferred,
            })
        }
    
        /// Get access to a handle that can be used to interrupt long-running
        /// queries from another thread.
        #[inline]
        pub fn get_interrupt_handle(&self) -> InterruptHandle {
            self.db.borrow().get_interrupt_handle()
        }
    
        #[inline]
        fn decode_result(&self, code: c_int) -> Result<()> {
            self.db.borrow().decode_result(code)
        }
    
        /// Return the number of rows modified, inserted or deleted by the most
        /// recently completed INSERT, UPDATE or DELETE statement on the database
        /// connection.
        #[inline]
        pub fn changes(&self) -> u64 {
            self.db.borrow().changes()
        }
    
        /// Return the total number of rows modified, inserted or deleted by all
        /// completed INSERT, UPDATE or DELETE statements since the database
        /// connection was opened, including those executed as part of trigger programs.
        #[inline]
        pub fn total_changes(&self) -> u64 {
            self.db.borrow().total_changes()
        }
    
        /// Test for auto-commit mode.
        /// Autocommit mode is on by default.
        #[inline]
        pub fn is_autocommit(&self) -> bool {
            self.db.borrow().is_autocommit()
        }
    
        /// Determine if all associated prepared statements have been reset.
        #[inline]
        pub fn is_busy(&self) -> bool {
            self.db.borrow().is_busy()
        }
    
        /// Flush caches to disk mid-transaction
        pub fn cache_flush(&self) -> Result<()> {
            self.db.borrow_mut().cache_flush()
        }
    
        /// Determine if a database is read-only
        pub fn is_readonly(&self, db_name: DatabaseName<'_>) -> Result<bool> {
            self.db.borrow().db_readonly(db_name)
        }
    }
    
    impl fmt::Debug for Connection {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Connection")
                .field("path", &self.path())
                .finish()
        }
    }
    
    /// Batch iterator
    #[derive(Debug)]
    pub struct Batch<'conn, 'sql> {
        conn: &'conn Connection,
        sql: &'sql str,
        tail: usize,
    }
    
    impl<'conn, 'sql> Batch<'conn, 'sql> {
        /// Constructor
        pub fn new(conn: &'conn Connection, sql: &'sql str) -> Batch<'conn, 'sql> {
            Batch { conn, sql, tail: 0 }
        }
    
        /// Iterates on each batch statements.
        ///
        /// Returns `Ok(None)` when batch is completed.
        #[allow(clippy::should_implement_trait)] // fallible iterator
        pub fn next(&mut self) -> Result<Option<Statement<'conn>>> {
            while self.tail < self.sql.len() {
                let sql = &self.sql[self.tail..];
                let next = self.conn.prepare(sql)?;
                let tail = next.stmt.tail();
                if tail == 0 {
                    self.tail = self.sql.len();
                } else {
                    self.tail += tail;
                }
                if next.stmt.is_null() {
                    continue;
                }
                return Ok(Some(next));
            }
            Ok(None)
        }
    }
    
    impl<'conn> Iterator for Batch<'conn, '_> {
        type Item = Result<Statement<'conn>>;
    
        fn next(&mut self) -> Option<Result<Statement<'conn>>> {
            self.next().transpose()
        }
    }
    
    bitflags::bitflags! {
        /// Flags for opening SQLite database connections.
        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
        #[repr(C)]
        pub struct OpenFlags: ::os::raw::c_int {
            /// The database is opened in read-only mode.
            /// If the database does not already exist, an error is returned.
            const SQLITE_OPEN_READ_ONLY = ffi::SQLITE_OPEN_READONLY;
            /// The database is opened for reading and writing if possible,
            /// or reading only if the file is write-protected by the operating system.
            const SQLITE_OPEN_READ_WRITE = ffi::SQLITE_OPEN_READWRITE;
            /// The database is created if it does not already exist
            const SQLITE_OPEN_CREATE = ffi::SQLITE_OPEN_CREATE;
            /// The filename can be interpreted as a URI if this flag is set.
            const SQLITE_OPEN_URI = ffi::SQLITE_OPEN_URI;
            /// The database will be opened as an in-memory database.
            const SQLITE_OPEN_MEMORY = ffi::SQLITE_OPEN_MEMORY;
            /// The new database connection will not use a per-connection mutex (the
            /// connection will use the "multi-thread" threading mode, in SQLite
            /// parlance).
            const SQLITE_OPEN_NO_MUTEX = ffi::SQLITE_OPEN_NOMUTEX;
            /// The new database connection will use a per-connection mutex -- the
            /// "serialized" threading mode, in SQLite parlance.
            const SQLITE_OPEN_FULL_MUTEX = ffi::SQLITE_OPEN_FULLMUTEX;
            /// The database is opened with shared cache enabled.
            const SQLITE_OPEN_SHARED_CACHE = 0x0002_0000;
            /// The database is opened shared cache disabled.
            const SQLITE_OPEN_PRIVATE_CACHE = 0x0004_0000;
            /// The database filename is not allowed to be a symbolic link. (3.31.0)
            const SQLITE_OPEN_NOFOLLOW = 0x0100_0000;
            /// Extended result codes. (3.37.0)
            const SQLITE_OPEN_EXRESCODE = 0x0200_0000;
        }
    }
    
    impl Default for OpenFlags {
        #[inline]
        fn default() -> OpenFlags {
            // Note: update the `Connection::open` and top-level `OpenFlags` docs if
            // you change these.
            OpenFlags::SQLITE_OPEN_READ_WRITE
                | OpenFlags::SQLITE_OPEN_CREATE
                | OpenFlags::SQLITE_OPEN_NO_MUTEX
                | OpenFlags::SQLITE_OPEN_URI
        }
    }
    
    bitflags::bitflags! {
        /// Prepare flags. See
        /// [sqlite3_prepare_v3](https://sqlite.org/c3ref/c_prepare_normalize.html) for details.
        #[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]
        #[repr(C)]
        pub struct PrepFlags: ::os::raw::c_uint {
            /// A hint to the query planner that the prepared statement will be retained for a long time and probably reused many times.
            const SQLITE_PREPARE_PERSISTENT = 0x01;
            /// Causes the SQL compiler to return an error (error code SQLITE_ERROR) if the statement uses any virtual tables.
            const SQLITE_PREPARE_NO_VTAB = 0x04;
        }
    }
    
    /// Allows interrupting a long-running computation.
    pub struct InterruptHandle {
        db_lock: Arc<Mutex<*mut ffi::sqlite3>>,
    }
    
    unsafe impl Send for InterruptHandle {}
    unsafe impl Sync for InterruptHandle {}
    
    impl InterruptHandle {
        /// Interrupt the query currently executing on another thread. This will
        /// cause that query to fail with a `SQLITE3_INTERRUPT` error.
        pub fn interrupt(&self) {
            let db_handle = self.db_lock.lock().unwrap();
            if !db_handle.is_null() {
                unsafe { ffi::sqlite3_interrupt(*db_handle) }
            }
        }
    }
}

pub mod structopt
{
    //! This crate defines the `StructOpt` trait and its custom derive.
    use ::
    {
        *,
    };
    /*
    pub use structopt_derive::*;
    
    use ::ffi::OsString;
    
    /// Re-export of clap
    pub use clap;
    */
    /*
    [dependencies]
    syn = { version = "1", features = ["full"] }
    quote = "1"
    proc-macro2 = "1"
    heck = "0.3.0"
    proc-macro-error = "0.2"
    */
    pub mod derive
    {
        //! This crate is custom derive for `StructOpt`.
        use ::
        {
            *,
        };
        /*
        extern crate proc_macro;
        use crate::{
            attrs::{sub_type, Attrs, CasingStyle, Kind, Parser, Ty},
            spanned::Sp,
        };
        
        use proc_macro2::{Span, TokenStream};
        use proc_macro_error::{call_site_error, filter_macro_errors, span_error};
        use quote::{quote, quote_spanned};
        use syn::{punctuated::Punctuated, spanned::Spanned, token::Comma, *};
        */
        pub mod attrs
        {
            use ::
            {
                *,
            };
            /*
            use crate::spanned::Sp;
            
            use ::env;
            
            use heck::{CamelCase, KebabCase, MixedCase, ShoutySnakeCase, SnakeCase};
            use proc_macro2::{Span, TokenStream};
            use proc_macro_error::{call_site_error, span_error};
            use quote::quote;
            use syn::{
                self, spanned::Spanned, AngleBracketedGenericArguments, Attribute, GenericArgument, Ident,
                LitStr, MetaNameValue, PathArguments, PathSegment, Type::Path, TypePath,
            };
            
            use crate::parse::*;
            */
            #[derive(Clone, Debug)]
            pub enum Kind {
                Arg(Sp<Ty>),
                Subcommand(Sp<Ty>),
                FlattenStruct,
                Skip,
            }
            
            #[derive(Copy, Clone, PartialEq, Debug)]
            pub enum Ty {
                Bool,
                Vec,
                Option,
                OptionOption,
                OptionVec,
                Other,
            }
            
            #[derive(Clone)]
            pub struct Method {
                name: Ident,
                args: TokenStream,
            }
            
            #[derive(Debug, PartialEq, Clone)]
            pub enum Parser {
                FromStr,
                TryFromStr,
                FromOsStr,
                TryFromOsStr,
                FromOccurrences,
            }
            
            /// Defines the casing for the attributes long representation.
            #[derive(Copy, Clone, Debug, PartialEq)]
            pub enum CasingStyle {
                /// Indicate word boundaries with uppercase letter, excluding the first word.
                Camel,
                /// Keep all letters lowercase and indicate word boundaries with hyphens.
                Kebab,
                /// Indicate word boundaries with uppercase letter, including the first word.
                Pascal,
                /// Keep all letters uppercase and indicate word boundaries with underscores.
                ScreamingSnake,
                /// Keep all letters lowercase and indicate word boundaries with underscores.
                Snake,
                /// Use the original attribute name defined in the code.
                Verbatim,
            }
            
            #[derive(Clone)]
            pub struct Attrs {
                name: Sp<String>,
                cased_name: String,
                casing: Sp<CasingStyle>,
                methods: Vec<Method>,
                parser: Sp<(Sp<Parser>, TokenStream)>,
                author: Option<(Ident, LitStr)>,
                about: Option<(Ident, LitStr)>,
                version: Option<(Ident, LitStr)>,
                no_version: Option<Ident>,
                has_custom_parser: bool,
                kind: Sp<Kind>,
            }
            
            impl Parser {
                fn from_ident(ident: Ident) -> Sp<Self> {
                    use Parser::*;
            
                    let p = |kind| Sp::new(kind, ident.span());
                    match &*ident.to_string() {
                        "from_str" => p(FromStr),
                        "try_from_str" => p(TryFromStr),
                        "from_os_str" => p(FromOsStr),
                        "try_from_os_str" => p(TryFromOsStr),
                        "from_occurrences" => p(FromOccurrences),
                        s => span_error!(ident.span(), "unsupported parser `{}`", s),
                    }
                }
            }
            
            impl CasingStyle {
                fn translate(&self, input: &str) -> String {
                    use CasingStyle::*;
            
                    match self {
                        Pascal => input.to_camel_case(),
                        Kebab => input.to_kebab_case(),
                        Camel => input.to_mixed_case(),
                        ScreamingSnake => input.to_shouty_snake_case(),
                        Snake => input.to_snake_case(),
                        Verbatim => String::from(input),
                    }
                }
            
                fn from_lit(name: LitStr) -> Sp<Self> {
                    use CasingStyle::*;
            
                    let normalized = name.value().to_camel_case().to_lowercase();
                    let cs = |kind| Sp::new(kind, name.span());
            
                    match normalized.as_ref() {
                        "camel" | "camelcase" => cs(Camel),
                        "kebab" | "kebabcase" => cs(Kebab),
                        "pascal" | "pascalcase" => cs(Pascal),
                        "screamingsnake" | "screamingsnakecase" => cs(ScreamingSnake),
                        "snake" | "snakecase" => cs(Snake),
                        "verbatim" | "verbatimcase" => cs(Verbatim),
                        s => span_error!(name.span(), "unsupported casing: `{}`", s),
                    }
                }
            }
            
            impl Attrs {
                fn new(name: Sp<String>, casing: Sp<CasingStyle>) -> Self {
                    let cased_name = casing.translate(&name);
            
                    Self {
                        name,
                        cased_name,
                        casing,
                        methods: vec![],
                        parser: Sp::call_site((
                            Sp::call_site(Parser::TryFromStr),
                            quote!(:: ::str::FromStr::from_str),
                        )),
                        about: None,
                        author: None,
                        version: None,
                        no_version: None,
            
                        has_custom_parser: false,
                        kind: Sp::call_site(Kind::Arg(Sp::call_site(Ty::Other))),
                    }
                }
            
                /// push `.method("str literal")`
                fn push_str_method(&mut self, name: Sp<String>, arg: Sp<String>) {
                    match (&**name, &**arg) {
                        ("name", _) => {
                            self.cased_name = self.casing.translate(&arg);
                            self.name = arg;
                        }
                        _ => self.methods.push(Method {
                            name: name.as_ident(),
                            args: quote!(#arg),
                        }),
                    }
                }
            
                fn push_attrs(&mut self, attrs: &[Attribute]) {
                    use crate::parse::StructOptAttr::*;
            
                    fn from_lit_or_env(
                        ident: Ident,
                        lit: Option<LitStr>,
                        env_var: &str,
                    ) -> Option<(Ident, LitStr)> {
                        let lit = lit.unwrap_or_else(|| {
                            let gen = env::var(env_var)
                                .unwrap_or_else(|_|
                                 span_error!(ident.span(), "`{}` environment variable is not defined, use `{} = \"{}\"` to set it manually", env_var, env_var, env_var));
                            LitStr::new(&gen, Span::call_site())
                        });
            
                        Some((ident, lit))
                    }
            
                    for attr in parse_structopt_attributes(attrs) {
                        match attr {
                            Short(ident) => {
                                let cased_name = Sp::call_site(self.cased_name.clone());
                                self.push_str_method(ident.into(), cased_name);
                            }
            
                            Long(ident) => {
                                let cased_name = Sp::call_site(self.cased_name.clone());
                                self.push_str_method(ident.into(), cased_name);
                            }
            
                            Subcommand(ident) => {
                                let ty = Sp::call_site(Ty::Other);
                                let kind = Sp::new(Kind::Subcommand(ty), ident.span());
                                self.set_kind(kind);
                            }
            
                            Flatten(ident) => {
                                let kind = Sp::new(Kind::FlattenStruct, ident.span());
                                self.set_kind(kind);
                            }
            
                            Skip(ident) => {
                                let kind = Sp::new(Kind::Skip, ident.span());
                                self.set_kind(kind);
                            }
            
                            NoVersion(ident) => self.no_version = Some(ident),
            
                            About(ident, about) => {
                                self.about = from_lit_or_env(ident, about, "CARGO_PKG_DESCRIPTION")
                            }
            
                            Author(ident, author) => {
                                self.author =
                                    from_lit_or_env(ident, author, "CARGO_PKG_AUTHORS").map(|(ident, lit)| {
                                        let value = lit.value().replace(":", ", ");
                                        (ident.clone(), LitStr::new(&value, ident.span()))
                                    })
                            }
            
                            Version(ident, version) => self.version = Some((ident, version)),
            
                            NameLitStr(name, lit) => {
                                self.push_str_method(name.into(), lit.into());
                            }
            
                            NameExpr(name, expr) => self.methods.push(Method {
                                name: name.into(),
                                args: quote!(#expr),
                            }),
            
                            MethodCall(name, args) => self.methods.push(Method {
                                name: name.into(),
                                args: quote!(#(#args),*),
                            }),
            
                            RenameAll(_, casing_lit) => {
                                self.casing = CasingStyle::from_lit(casing_lit);
                                self.cased_name = self.casing.translate(&self.name);
                            }
            
                            Parse(ident, spec) => {
                                self.has_custom_parser = true;
            
                                self.parser = match spec.parse_func {
                                    None => {
                                        use crate::attrs::Parser::*;
            
                                        let parser: Sp<_> = Parser::from_ident(spec.kind).into();
                                        let function = match *parser {
                                            FromStr | FromOsStr => quote!(:: ::convert::From::from),
                                            TryFromStr => quote!(:: ::str::FromStr::from_str),
                                            TryFromOsStr => span_error!(
                                                parser.span(),
                                                "cannot omit parser function name with `try_from_os_str`"
                                            ),
                                            FromOccurrences => quote!({ |v| v as _ }),
                                        };
                                        Sp::new((parser, function), ident.span())
                                    }
            
                                    Some(func) => {
                                        let parser: Sp<_> = Parser::from_ident(spec.kind).into();
                                        match func {
                                            syn::Expr::Path(_) => {
                                                Sp::new((parser, quote!(#func)), ident.span())
                                            }
                                            _ => span_error!(
                                                func.span(),
                                                "`parse` argument must be a function path"
                                            ),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            
                fn push_doc_comment(&mut self, attrs: &[Attribute], name: &str) {
                    let doc_comments = attrs
                        .iter()
                        .filter_map(|attr| {
                            if attr.path.is_ident("doc") {
                                attr.parse_meta().ok()
                            } else {
                                None
                            }
                        })
                        .filter_map(|attr| {
                            use crate::Lit::*;
                            use crate::Meta::*;
                            if let NameValue(MetaNameValue {
                                path, lit: Str(s), ..
                            }) = attr
                            {
                                if !path.is_ident("doc") {
                                    return None;
                                }
                                let value = s.value();
            
                                let text = value
                                    .trim_start_matches("//!")
                                    .trim_start_matches("///")
                                    .trim_start_matches("/*!")
                                    .trim_start_matches("/**")
                                    .trim_end_matches("*/")
                                    .trim();
                                if text.is_empty() {
                                    Some("\n\n".to_string())
                                } else {
                                    Some(text.to_string())
                                }
                            } else {
                                None
                            }
                        })
                        .collect::<Vec<_>>();
            
                    if doc_comments.is_empty() {
                        return;
                    }
            
                    let merged_lines = doc_comments
                        .join(" ")
                        .split('\n')
                        .map(str::trim)
                        .map(str::to_string)
                        .collect::<Vec<_>>()
                        .join("\n");
            
                    let expected_doc_comment_split = if let Some(content) = doc_comments.get(1) {
                        (doc_comments.len() > 2) && (content == "\n\n")
                    } else {
                        false
                    };
            
                    if expected_doc_comment_split {
                        let long_name = Sp::call_site(format!("long_{}", name));
            
                        self.methods.push(Method {
                            name: long_name.as_ident(),
                            args: quote!(#merged_lines),
                        });
                        
                        let short_arg = doc_comments
                            .first()
                            .map(|s| s.trim())
                            .map_or("", |s| s.trim_end_matches('.'));
            
                        self.methods.push(Method {
                            name: Ident::new(name, Span::call_site()),
                            args: quote!(#short_arg),
                        });
                    } else {
                        self.methods.push(Method {
                            name: Ident::new(name, Span::call_site()),
                            args: quote!(#merged_lines),
                        });
                    }
                }
            
                pub fn from_struct(
                    attrs: &[Attribute],
                    name: Sp<String>,
                    argument_casing: Sp<CasingStyle>,
                ) -> Self {
                    let mut res = Self::new(name, argument_casing);
                    res.push_attrs(attrs);
                    res.push_doc_comment(attrs, "about");
            
                    if res.has_custom_parser {
                        span_error!(
                            res.parser.span(),
                            "parse attribute is only allowed on fields"
                        );
                    }
                    match &*res.kind {
                        Kind::Subcommand(_) => {
                            span_error!(res.kind.span(), "subcommand is only allowed on fields")
                        }
                        Kind::FlattenStruct => {
                            span_error!(res.kind.span(), "flatten is only allowed on fields")
                        }
                        Kind::Skip => span_error!(res.kind.span(), "skip is only allowed on fields"),
                        Kind::Arg(_) => res,
                    }
                }
            
                fn ty_from_field(ty: &syn::Type) -> Sp<Ty> {
                    let t = |kind| Sp::new(kind, ty.span());
                    if let Path(TypePath {
                        path: syn::Path { ref segments, .. },
                        ..
                    }) = *ty
                    {
                        match segments.iter().last().unwrap().ident.to_string().as_str() {
                            "bool" => t(Ty::Bool),
                            "Option" => sub_type(ty)
                                .map(Attrs::ty_from_field)
                                .map(|ty| match *ty {
                                    Ty::Option => t(Ty::OptionOption),
                                    Ty::Vec => t(Ty::OptionVec),
                                    _ => t(Ty::Option),
                                })
                                .unwrap_or(t(Ty::Option)),
            
                            "Vec" => t(Ty::Vec),
                            _ => t(Ty::Other),
                        }
                    } else {
                        t(Ty::Other)
                    }
                }
            
                pub fn from_field(field: &syn::Field, struct_casing: Sp<CasingStyle>) -> Self {
                    let name = field.ident.clone().unwrap();
                    let mut res = Self::new(name.into(), struct_casing);
                    res.push_doc_comment(&field.attrs, "help");
                    res.push_attrs(&field.attrs);
            
                    match &*res.kind {
                        Kind::FlattenStruct => {
                            if res.has_custom_parser {
                                span_error!(
                                    res.parser.span(),
                                    "parse attribute is not allowed for flattened entry"
                                );
                            }
                            if !res.methods.is_empty() {
                                span_error!(
                                    res.kind.span(),
                                    "methods and doc comments are not allowed for flattened entry"
                                );
                            }
                        }
                        Kind::Subcommand(_) => {
                            if res.has_custom_parser {
                                span_error!(
                                    res.parser.span(),
                                    "parse attribute is not allowed for subcommand"
                                );
                            }
                            if let Some(m) = res.methods.iter().find(|m| m.name != "help") {
                                span_error!(
                                    m.name.span(),
                                    "methods in attributes are not allowed for subcommand"
                                );
                            }
            
                            let ty = Self::ty_from_field(&field.ty);
                            match *ty {
                                Ty::OptionOption => {
                                    span_error!(
                                        ty.span(),
                                        "Option<Option<T>> type is not allowed for subcommand"
                                    );
                                }
                                Ty::OptionVec => {
                                    span_error!(
                                        ty.span(),
                                        "Option<Vec<T>> type is not allowed for subcommand"
                                    );
                                }
                                _ => (),
                            }
            
                            res.kind = Sp::new(Kind::Subcommand(ty), res.kind.span());
                        }
                        Kind::Skip => {
                            if let Some(m) = res.methods.iter().find(|m| m.name != "help") {
                                span_error!(m.name.span(), "methods are not allowed for skipped fields");
                            }
                        }
                        Kind::Arg(orig_ty) => {
                            let mut ty = Self::ty_from_field(&field.ty);
                            if res.has_custom_parser {
                                match *ty {
                                    Ty::Option | Ty::Vec => (),
                                    _ => ty = Sp::new(Ty::Other, ty.span()),
                                }
                            }
            
                            match *ty {
                                Ty::Bool => {
                                    if let Some(m) = res.find_method("default_value") {
                                        span_error!(m.name.span(), "default_value is meaningless for bool")
                                    }
                                    if let Some(m) = res.find_method("required") {
                                        span_error!(m.name.span(), "required is meaningless for bool")
                                    }
                                }
                                Ty::Option => {
                                    if let Some(m) = res.find_method("default_value") {
                                        span_error!(m.name.span(), "default_value is meaningless for Option")
                                    }
                                    if let Some(m) = res.find_method("required") {
                                        span_error!(m.name.span(), "required is meaningless for Option")
                                    }
                                }
                                Ty::OptionOption => {
                                    // If it's a positional argument.
                                    if !(res.has_method("long") || res.has_method("short")) {
                                        span_error!(
                                            ty.span(),
                                            "Option<Option<T>> type is meaningless for positional argument"
                                        )
                                    }
                                }
                                Ty::OptionVec => {
                                    // If it's a positional argument.
                                    if !(res.has_method("long") || res.has_method("short")) {
                                        span_error!(
                                            ty.span(),
                                            "Option<Vec<T>> type is meaningless for positional argument"
                                        )
                                    }
                                }
            
                                _ => (),
                            }
                            res.kind = Sp::new(Kind::Arg(ty), orig_ty.span());
                        }
                    }
            
                    res
                }
            
                fn set_kind(&mut self, kind: Sp<Kind>) {
                    if let Kind::Arg(_) = *self.kind {
                        self.kind = kind;
                    } else {
                        span_error!(
                            kind.span(),
                            "subcommand, flatten and skip cannot be used together"
                        );
                    }
                }
            
                pub fn has_method(&self, name: &str) -> bool {
                    self.find_method(name).is_some()
                }
            
                pub fn find_method(&self, name: &str) -> Option<&Method> {
                    self.methods.iter().find(|m| m.name == name)
                }
            
                /// generate methods from attributes on top of struct or enum
                pub fn top_level_methods(&self) -> TokenStream {
                    let version = match (&self.no_version, &self.version) {
                        (Some(no_version), Some(_)) => span_error!(
                            no_version.span(),
                            "`no_version` and `version = \"version\"` can't be used together"
                        ),
            
                        (None, Some((_, version))) => quote!(.version(#version)),
            
                        (None, None) => {
                            let version = env::var("CARGO_PKG_VERSION").unwrap_or_else(|_|{
                                call_site_error!("`CARGO_PKG_VERSION` environment variable is not defined, use `version = \"version\" to set it manually or `no_version` to not set it at all")
                            });
                            quote!(.version(#version))
                        }
            
                        (Some(_), None) => TokenStream::new(),
                    };
            
                    let version = Some(version);
                    let author = self
                        .author
                        .as_ref()
                        .map(|(_, version)| quote!(.author(#version)));
                    let about = self
                        .about
                        .as_ref()
                        .map(|(_, version)| quote!(.about(#version)));
            
                    let methods = self
                        .methods
                        .iter()
                        .map(|&Method { ref name, ref args }| quote!( .#name(#args) ))
                        .chain(version)
                        .chain(author)
                        .chain(about);
            
                    quote!( #(#methods)* )
                }
            
                /// generate methods on top of a field
                pub fn field_methods(&self) -> TokenStream {
                    let methods = self
                        .methods
                        .iter()
                        .map(|&Method { ref name, ref args }| quote!( .#name(#args) ));
            
                    quote!( #(#methods)* )
                }
            
                pub fn cased_name(&self) -> String {
                    self.cased_name.to_string()
                }
            
                pub fn parser(&self) -> &(Sp<Parser>, TokenStream) {
                    &self.parser
                }
            
                pub fn kind(&self) -> Sp<Kind> {
                    self.kind.clone()
                }
            
                pub fn casing(&self) -> Sp<CasingStyle> {
                    self.casing.clone()
                }
            }
            
            pub fn sub_type(t: &syn::Type) -> Option<&syn::Type> {
                let segs = match *t {
                    Path(TypePath {
                        path: syn::Path { ref segments, .. },
                        ..
                    }) => segments,
                    _ => return None,
                };
                match *segs.iter().last().unwrap() {
                    PathSegment {
                        arguments:
                            PathArguments::AngleBracketed(AngleBracketedGenericArguments { ref args, .. }),
                        ..
                    } if args.len() == 1 => {
                        if let GenericArgument::Type(ref ty) = args[0] {
                            Some(ty)
                        } else {
                            None
                        }
                    }
                    _ => None,
                }
            }
        }
        
        pub mod parse
        {
            use ::
            {
                *,
            };
            /*
            use ::iter::FromIterator;
            
            use proc_macro_error::{span_error, ResultExt};
            use syn::{
                self, parenthesized,
                parse::{Parse, ParseStream},
                parse2,
                punctuated::Punctuated,
                spanned::Spanned,
                Attribute, Expr, ExprLit, Ident, Lit, LitBool, LitStr, Token,
            };
            */
            pub struct StructOptAttributes {
                pub paren_token: syn::token::Paren,
                pub attrs: Punctuated<StructOptAttr, Token![,]>,
            }
            
            impl Parse for StructOptAttributes {
                fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
                    let content;
            
                    Ok(StructOptAttributes {
                        paren_token: parenthesized!(content in input),
                        attrs: content.parse_terminated(StructOptAttr::parse)?,
                    })
                }
            }
            
            pub enum StructOptAttr {
                // single-identifier attributes
                Short(Ident),
                Long(Ident),
                Flatten(Ident),
                Subcommand(Ident),
                Skip(Ident),
                NoVersion(Ident),
            
                // ident [= "string literal"]
                About(Ident, Option<LitStr>),
                Author(Ident, Option<LitStr>),
            
                // ident = "string literal"
                Version(Ident, LitStr),
                RenameAll(Ident, LitStr),
                NameLitStr(Ident, LitStr),
            
                // parse(parser_kind [= parser_func])
                Parse(Ident, ParserSpec),
            
                // ident = arbitrary_expr
                NameExpr(Ident, Expr),
            
                // ident(arbitrary_expr,*)
                MethodCall(Ident, Vec<Expr>),
            }
            
            impl Parse for StructOptAttr {
                fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
                    use self::StructOptAttr::*;
            
                    let name: Ident = input.parse()?;
                    let name_str = name.to_string();
            
                    if input.peek(Token![=]) {
                        let assign_token = input.parse::<Token![=]>()?; // skip '='
            
                        if input.peek(LitStr) {
                            let lit: LitStr = input.parse()?;
                            let lit_str = lit.value();
            
                            let check_empty_lit = |s| {
                                if lit_str.is_empty() {
                                    span_error!(lit.span(), "`#[structopt({} = \"\") is deprecated in structopt 3.0, now it's default behavior", s);
                                }
                            };
            
                            match &*name_str.to_string() {
                                "rename_all" => Ok(RenameAll(name, lit)),
            
                                "version" => {
                                    check_empty_lit("version");
                                    Ok(Version(name, lit))
                                }
            
                                "author" => {
                                    check_empty_lit("author");
                                    Ok(Author(name, Some(lit)))
                                }
            
                                "about" => {
                                    check_empty_lit("about");
                                    Ok(About(name, Some(lit)))
                                }
            
                                _ => Ok(NameLitStr(name, lit)),
                            }
                        } else {
                            match input.parse::<Expr>() {
                                Ok(expr) => Ok(NameExpr(name, expr)),
                                Err(_) => span_error! {
                                    assign_token.span(),
                                    "expected `string literal` or `expression` after `=`"
                                },
                            }
                        }
                    } else if input.peek(syn::token::Paren) {
                        let nested;
                        parenthesized!(nested in input);
            
                        match name_str.as_ref() {
                            "parse" => {
                                let parser_specs: Punctuated<ParserSpec, Token![,]> =
                                    nested.parse_terminated(ParserSpec::parse)?;
            
                                if parser_specs.len() == 1 {
                                    Ok(Parse(name, parser_specs[0].clone()))
                                } else {
                                    span_error!(name.span(), "parse must have exactly one argument")
                                }
                            }
            
                            "raw" => {
                                match nested.parse::<LitBool>() {
                                    Ok(bool_token) => {
                                        let expr = ExprLit { attrs: vec![], lit: Lit::Bool(bool_token) };
                                        let expr = Expr::Lit(expr);
                                        Ok(MethodCall(name, vec![expr]))
                                    }
            
                                    Err(_) => span_error!(name.span(),
                                        "`#[structopt(raw(...))` attributes are deprecated in structopt 3.0, only `raw(true)` and `raw(false)` are allowed")
                                }
                            }
            
                            _ => {
                                let method_args: Punctuated<_, Token![,]> = nested.parse_terminated(Expr::parse)?;
                                Ok(MethodCall(name, Vec::from_iter(method_args)))
                            }
                        }
                    } else {
                        match name_str.as_ref() {
                            "long" => Ok(Long(name)),
                            "short" => Ok(Short(name)),
                            "flatten" => Ok(Flatten(name)),
                            "subcommand" => Ok(Subcommand(name)),
                            "skip" => Ok(Skip(name)),
                            "no_version" => Ok(NoVersion(name)),
            
                            "about" => (Ok(About(name, None))),
                            "author" => (Ok(Author(name, None))),
            
                            "version" => {
                                span_error!(name.span(),
                                "#[structopt(version)] is invalid attribute, structopt 3.0 inherits version from Cargo.toml by default, no attribute needed")
                            },
            
                            _ => span_error!(name.span(), "unexpected attribute: {}", name_str),
                        }
                    }
                }
            }
            
            #[derive(Clone)]
            pub struct ParserSpec {
                pub kind: Ident,
                pub eq_token: Option<Token![=]>,
                pub parse_func: Option<Expr>,
            }
            
            impl Parse for ParserSpec {
                fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
                    let kind = input
                        .parse()
                        .map_err(|_| input.error("parser specification must start with identifier"))?;
                    let eq_token = input.parse()?;
                    let parse_func = match eq_token {
                        None => None,
                        Some(_) => Some(input.parse()?),
                    };
                    Ok(ParserSpec {
                        kind,
                        eq_token,
                        parse_func,
                    })
                }
            }
            
            pub fn parse_structopt_attributes(all_attrs: &[Attribute]) -> Vec<StructOptAttr> {
                all_attrs
                    .iter()
                    .filter(|attr| attr.path.is_ident("structopt"))
                    .flat_map(|attr| {
                        let attrs: StructOptAttributes = parse2(attr.tokens.clone())
                            .map_err(|e| match &*e.to_string() {
                                "unexpected end of input, expected parentheses" => {
                                    let span = attr.path.span();
                                    let patch_msg = "expected parentheses after `structopt`";
                                    syn::Error::new(span, patch_msg)
                                }
                                _ => e,
                            })
                            .unwrap_or_exit();
                        attrs.attrs
                    })
                    .collect()
            }
        }
        
        pub mod spanned
        {
            use ::
            {
                *,
            };
            /*
            use proc_macro2::{Ident, Span, TokenStream};
            use quote::{quote_spanned, ToTokens};
            use ::ops::{Deref, DerefMut};
            use syn::LitStr;
            */
            /// An entity with a span attached.
            #[derive(Debug, Clone)]
            pub struct Sp<T> {
                span: Span,
                val: T,
            }
            
            impl<T> Sp<T> {
                pub fn new(val: T, span: Span) -> Self {
                    Sp { val, span }
                }
            
                pub fn call_site(val: T) -> Self {
                    Sp {
                        val,
                        span: Span::call_site(),
                    }
                }
            
                pub fn span(&self) -> Span {
                    self.span.clone()
                }
            }
            
            impl<T: ToString> Sp<T> {
                pub fn as_ident(&self) -> Ident {
                    Ident::new(&self.to_string(), self.span.clone())
                }
            }
            
            impl<T> Deref for Sp<T> {
                type Target = T;
            
                fn deref(&self) -> &T {
                    &self.val
                }
            }
            
            impl<T> DerefMut for Sp<T> {
                fn deref_mut(&mut self) -> &mut T {
                    &mut self.val
                }
            }
            
            impl From<Ident> for Sp<String> {
                fn from(ident: Ident) -> Self {
                    Sp {
                        val: ident.to_string(),
                        span: ident.span(),
                    }
                }
            }
            
            impl From<LitStr> for Sp<String> {
                fn from(lit: LitStr) -> Self {
                    Sp {
                        val: lit.value(),
                        span: lit.span(),
                    }
                }
            }
            
            impl<'a> From<Sp<&'a str>> for Sp<String> {
                fn from(sp: Sp<&'a str>) -> Self {
                    Sp::new(sp.val.into(), sp.span)
                }
            }
            
            impl<T: PartialEq> PartialEq for Sp<T> {
                fn eq(&self, other: &Sp<T>) -> bool {
                    self.val == other.val
                }
            }
            
            impl<T: AsRef<str>> AsRef<str> for Sp<T> {
                fn as_ref(&self) -> &str {
                    self.val.as_ref()
                }
            }
            
            impl<T: ToTokens> ToTokens for Sp<T> {
                fn to_tokens(&self, stream: &mut TokenStream) {
                    let val = &self.val;
                    let quoted = quote_spanned!(self.span=> #val);
                    stream.extend(quoted);
                }
            }
        }
        
        /// Default casing style for generated arguments.
        const DEFAULT_CASING: CasingStyle = CasingStyle::Kebab;
        
        /// Output for the `gen_xxx()` methods were we need more than a simple stream of tokens.
        struct GenOutput {
            tokens: TokenStream,
            attrs: Attrs,
        }
        
        /// Generates the `StructOpt` impl.
        #[proc_macro_derive(StructOpt, attributes(structopt))]
        pub fn structopt(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
            filter_macro_errors! {
                let input: DeriveInput = syn::parse(input).unwrap();
                let gen = impl_structopt(&input);
                gen.into()
            }
        }
        
        /// Generate a block of code to add arguments/subcommands corresponding to
        /// the `fields` to an app.
        fn gen_augmentation(
            fields: &Punctuated<Field, Comma>,
            app_var: &Ident,
            parent_attribute: &Attrs,
        ) -> TokenStream {
            let mut subcmds = fields.iter().filter_map(|field| {
                let attrs = Attrs::from_field(field, parent_attribute.casing());
                if let Kind::Subcommand(ty) = &*attrs.kind() {
                    let subcmd_type = match (**ty, sub_type(&field.ty)) {
                        (Ty::Option, Some(sub_type)) => sub_type,
                        _ => &field.ty,
                    };
                    let required = if **ty == Ty::Option {
                        quote!()
                    } else {
                        quote! {
                            let #app_var = #app_var.setting(
                                ::structopt::clap::AppSettings::SubcommandRequiredElseHelp
                            );
                        }
                    };
        
                    let span = field.span();
                    let ts = quote! {
                        let #app_var = <#subcmd_type>::augment_clap( #app_var );
                        #required
                    };
                    Some((span, ts))
                } else {
                    None
                }
            });
        
            let subcmd = subcmds.next().map(|(_, ts)| ts);
            if let Some((span, _)) = subcmds.next() {
                span_error!(
                    span,
                    "nested subcommands are not allowed, that's the second"
                );
            }
        
            let args = fields.iter().filter_map(|field| {
                let attrs = Attrs::from_field(field, parent_attribute.casing());
                match &*attrs.kind() {
                    Kind::Subcommand(_) | Kind::Skip => None,
                    Kind::FlattenStruct => {
                        let ty = &field.ty;
                        Some(quote! {
                            let #app_var = <#ty>::augment_clap(#app_var);
                            let #app_var = if <#ty>::is_subcommand() {
                                #app_var.setting(::structopt::clap::AppSettings::SubcommandRequiredElseHelp)
                            } else {
                                #app_var
                            };
                        })
                    }
                    Kind::Arg(ty) => {
                        let convert_type = match **ty {
                            Ty::Vec | Ty::Option => sub_type(&field.ty).unwrap_or(&field.ty),
                            Ty::OptionOption | Ty::OptionVec => sub_type(&field.ty).and_then(sub_type).unwrap_or(&field.ty),
                            _ => &field.ty,
                        };
        
                        let occurrences = *attrs.parser().0 == Parser::FromOccurrences;
        
                        let (parser, f) = attrs.parser();
                        let validator = match **parser {
                            Parser::TryFromStr => quote! {
                                .validator(|s| {
                                    #f(&s)
                                    .map(|_: #convert_type| ())
                                    .map_err(|e| e.to_string())
                                })
                            },
                            Parser::TryFromOsStr => quote! {
                                .validator_os(|s| #f(&s).map(|_: #convert_type| ()))
                            },
                            _ => quote!(),
                        };
        
                        let modifier = match **ty {
                            Ty::Bool => quote!( .takes_value(false).multiple(false) ),
                            Ty::Option => quote!( .takes_value(true).multiple(false) #validator ),
                            Ty::OptionOption => {
                                quote! ( .takes_value(true).multiple(false).min_values(0).max_values(1) #validator )
                            }
                            Ty::OptionVec => {
                                quote! ( .takes_value(true).multiple(true).min_values(0) #validator )
                            }
                            Ty::Vec => quote!( .takes_value(true).multiple(true) #validator ),
                            Ty::Other if occurrences => quote!( .takes_value(false).multiple(true) ),
                            Ty::Other => {
                                let required = !attrs.has_method("default_value");
                                quote!( .takes_value(true).multiple(false).required(#required) #validator )
                            }
                        };
        
                        let name = attrs.cased_name();
                        let methods = attrs.field_methods();
        
                        Some(quote! {
                            let #app_var = #app_var.arg(
                                ::structopt::clap::Arg::with_name(#name)
                                    #modifier
                                    #methods
                            );
                        })
                    }
                }
            });
        
            quote! {{
                #( #args )*
                #subcmd
                #app_var
            }}
        }
        
        fn gen_constructor(fields: &Punctuated<Field, Comma>, parent_attribute: &Attrs) -> TokenStream {
            let fields = fields.iter().map(|field| {
                let attrs = Attrs::from_field(field, parent_attribute.casing());
                let field_name = field.ident.as_ref().unwrap();
                let kind = attrs.kind();
                match &*kind {
                    Kind::Subcommand(ty) => {
                        let subcmd_type = match (**ty, sub_type(&field.ty)) {
                            (Ty::Option, Some(sub_type)) => sub_type,
                            _ => &field.ty,
                        };
                        let unwrapper = match **ty {
                            Ty::Option => quote!(),
                            _ => quote!( .unwrap() ),
                        };
                        quote!(#field_name: <#subcmd_type>::from_subcommand(matches.subcommand())#unwrapper)
                    }
                    Kind::FlattenStruct => quote!(#field_name: ::structopt::StructOpt::from_clap(matches)),
                    Kind::Skip => quote_spanned!(kind.span()=> #field_name: Default::default()),
                    Kind::Arg(ty) => {
                        use crate::attrs::Parser::*;
                        let (parser, f) = attrs.parser();
                        let (value_of, values_of, parse) = match **parser {
                            FromStr => (quote!(value_of), quote!(values_of), f.clone()),
                            TryFromStr => (
                                quote!(value_of),
                                quote!(values_of),
                                quote!(|s| #f(s).unwrap()),
                            ),
                            FromOsStr => (quote!(value_of_os), quote!(values_of_os), f.clone()),
                            TryFromOsStr => (
                                quote!(value_of_os),
                                quote!(values_of_os),
                                quote!(|s| #f(s).unwrap()),
                            ),
                            FromOccurrences => (quote!(occurrences_of), quote!(), f.clone()),
                        };
        
                        let occurrences = *attrs.parser().0 == Parser::FromOccurrences;
                        let name = attrs.cased_name();
                        let field_value = match **ty {
                            Ty::Bool => quote!(matches.is_present(#name)),
                            Ty::Option => quote! {
                                matches.#value_of(#name)
                                    .map(#parse)
                            },
                            Ty::OptionOption => quote! {
                                if matches.is_present(#name) {
                                    Some(matches.#value_of(#name).map(#parse))
                                } else {
                                    None
                                }
                            },
                            Ty::OptionVec => quote! {
                                if matches.is_present(#name) {
                                    Some(matches.#values_of(#name)
                                         .map(|v| v.map(#parse).collect())
                                         .unwrap_or_else(Vec::new))
                                } else {
                                    None
                                }
                            },
                            Ty::Vec => quote! {
                                matches.#values_of(#name)
                                    .map(|v| v.map(#parse).collect())
                                    .unwrap_or_else(Vec::new)
                            },
                            Ty::Other if occurrences => quote! {
                                #parse(matches.#value_of(#name))
                            },
                            Ty::Other => quote! {
                                matches.#value_of(#name)
                                    .map(#parse)
                                    .unwrap()
                            },
                        };
        
                        quote!( #field_name: #field_value )
                    }
                }
            });
        
            quote! {{
                #( #fields ),*
            }}
        }
        
        fn gen_from_clap(
            struct_name: &Ident,
            fields: &Punctuated<Field, Comma>,
            parent_attribute: &Attrs,
        ) -> TokenStream {
            let field_block = gen_constructor(fields, parent_attribute);
        
            quote! {
                fn from_clap(matches: &::structopt::clap::ArgMatches) -> Self {
                    #struct_name #field_block
                }
            }
        }
        
        fn gen_clap(attrs: &[Attribute]) -> GenOutput {
            let name = ::env::var("CARGO_PKG_NAME").ok().unwrap_or_default();
        
            let attrs = Attrs::from_struct(attrs, Sp::call_site(name), Sp::call_site(DEFAULT_CASING));
            let tokens = {
                let name = attrs.cased_name();
                let methods = attrs.top_level_methods();
        
                quote!(::structopt::clap::App::new(#name)#methods)
            };
        
            GenOutput { tokens, attrs }
        }
        
        fn gen_clap_struct(struct_attrs: &[Attribute]) -> GenOutput {
            let initial_clap_app_gen = gen_clap(struct_attrs);
            let clap_tokens = initial_clap_app_gen.tokens;
        
            let augmented_tokens = quote! {
                fn clap<'a, 'b>() -> ::structopt::clap::App<'a, 'b> {
                    let app = #clap_tokens;
                    Self::augment_clap(app)
                }
            };
        
            GenOutput {
                tokens: augmented_tokens,
                attrs: initial_clap_app_gen.attrs,
            }
        }
        
        fn gen_augment_clap(fields: &Punctuated<Field, Comma>, parent_attribute: &Attrs) -> TokenStream {
            let app_var = Ident::new("app", Span::call_site());
            let augmentation = gen_augmentation(fields, &app_var, parent_attribute);
            quote! {
                pub fn augment_clap<'a, 'b>(
                    #app_var: ::structopt::clap::App<'a, 'b>
                ) -> ::structopt::clap::App<'a, 'b> {
                    #augmentation
                }
            }
        }
        
        fn gen_clap_enum(enum_attrs: &[Attribute]) -> GenOutput {
            let initial_clap_app_gen = gen_clap(enum_attrs);
            let clap_tokens = initial_clap_app_gen.tokens;
        
            let tokens = quote! {
                fn clap<'a, 'b>() -> ::structopt::clap::App<'a, 'b> {
                    let app = #clap_tokens
                        .setting(::structopt::clap::AppSettings::SubcommandRequiredElseHelp);
                    Self::augment_clap(app)
                }
            };
        
            GenOutput {
                tokens,
                attrs: initial_clap_app_gen.attrs,
            }
        }
        
        fn gen_augment_clap_enum(
            variants: &Punctuated<Variant, Comma>,
            parent_attribute: &Attrs,
        ) -> TokenStream {
            use syn::Fields::*;
        
            let subcommands = variants.iter().map(|variant| {
                let attrs = Attrs::from_struct(
                    &variant.attrs,
                    variant.ident.clone().into(),
                    parent_attribute.casing(),
                );
                let app_var = Ident::new("subcommand", Span::call_site());
                let arg_block = match variant.fields {
                    Named(ref fields) => gen_augmentation(&fields.named, &app_var, &attrs),
                    Unit => quote!( #app_var ),
                    Unnamed(FieldsUnnamed { ref unnamed, .. }) if unnamed.len() == 1 => {
                        let ty = &unnamed[0];
                        quote! {
                            {
                                let #app_var = <#ty>::augment_clap(#app_var);
                                if <#ty>::is_subcommand() {
                                    #app_var.setting(
                                        ::structopt::clap::AppSettings::SubcommandRequiredElseHelp
                                    )
                                } else {
                                    #app_var
                                }
                            }
                        }
                    }
                    Unnamed(..) => call_site_error!("{}: tuple enums are not supported", variant.ident),
                };
        
                let name = attrs.cased_name();
                let from_attrs = attrs.top_level_methods();
        
                quote! {
                    .subcommand({
                        let #app_var = ::structopt::clap::SubCommand::with_name(#name);
                        let #app_var = #arg_block;
                        #app_var#from_attrs
                    })
                }
            });
        
            quote! {
                pub fn augment_clap<'a, 'b>(
                    app: ::structopt::clap::App<'a, 'b>
                ) -> ::structopt::clap::App<'a, 'b> {
                    app #( #subcommands )*
                }
            }
        }
        
        fn gen_from_clap_enum(name: &Ident) -> TokenStream {
            quote! {
                fn from_clap(matches: &::structopt::clap::ArgMatches) -> Self {
                    <#name>::from_subcommand(matches.subcommand())
                        .unwrap()
                }
            }
        }
        
        fn gen_from_subcommand(
            name: &Ident,
            variants: &Punctuated<Variant, Comma>,
            parent_attribute: &Attrs,
        ) -> TokenStream {
            use syn::Fields::*;
        
            let match_arms = variants.iter().map(|variant| {
                let attrs = Attrs::from_struct(
                    &variant.attrs,
                    variant.ident.clone().into(),
                    parent_attribute.casing(),
                );
                let sub_name = attrs.cased_name();
                let variant_name = &variant.ident;
                let constructor_block = match variant.fields {
                    Named(ref fields) => gen_constructor(&fields.named, &attrs),
                    Unit => quote!(),
                    Unnamed(ref fields) if fields.unnamed.len() == 1 => {
                        let ty = &fields.unnamed[0];
                        quote!( ( <#ty as ::structopt::StructOpt>::from_clap(matches) ) )
                    }
                    Unnamed(..) => call_site_error!("{}: tuple enums are not supported", variant.ident),
                };
        
                quote! {
                    (#sub_name, Some(matches)) =>
                        Some(#name :: #variant_name #constructor_block)
                }
            });
        
            quote! {
                pub fn from_subcommand<'a, 'b>(
                    sub: (&'b str, Option<&'b ::structopt::clap::ArgMatches<'a>>)
                ) -> Option<Self> {
                    match sub {
                        #( #match_arms ),*,
                        _ => None
                    }
                }
            }
        }
        
        fn impl_structopt_for_struct(
            name: &Ident,
            fields: &Punctuated<Field, Comma>,
            attrs: &[Attribute],
        ) -> TokenStream {
            let basic_clap_app_gen = gen_clap_struct(attrs);
            let augment_clap = gen_augment_clap(fields, &basic_clap_app_gen.attrs);
            let from_clap = gen_from_clap(name, fields, &basic_clap_app_gen.attrs);
            let paw_impl = gen_paw_impl(name);
        
            let clap_tokens = basic_clap_app_gen.tokens;
            quote! {
                #[allow(unused_variables)]
                impl ::structopt::StructOpt for #name {
                    #clap_tokens
                    #from_clap
                }
        
                #[allow(dead_code, unreachable_code)]
                #[doc(hidden)]
                impl #name {
                    #augment_clap
                    pub fn is_subcommand() -> bool { false }
                }
        
                #paw_impl
            }
        }
        
        fn impl_structopt_for_enum(
            name: &Ident,
            variants: &Punctuated<Variant, Comma>,
            attrs: &[Attribute],
        ) -> TokenStream {
            let basic_clap_app_gen = gen_clap_enum(attrs);
        
            let augment_clap = gen_augment_clap_enum(variants, &basic_clap_app_gen.attrs);
            let from_clap = gen_from_clap_enum(name);
            let from_subcommand = gen_from_subcommand(name, variants, &basic_clap_app_gen.attrs);
            let paw_impl = gen_paw_impl(name);
        
            let clap_tokens = basic_clap_app_gen.tokens;
            quote! {
                impl ::structopt::StructOpt for #name {
                    #clap_tokens
                    #from_clap
                }
        
                #[allow(unused_variables, dead_code, unreachable_code)]
                #[doc(hidden)]
                impl #name {
                    #augment_clap
                    #from_subcommand
                    pub fn is_subcommand() -> bool { true }
                }
        
                #paw_impl
            }
        }
        
        fn impl_structopt(input: &DeriveInput) -> TokenStream {
            use syn::Data::*;
        
            let struct_name = &input.ident;
            match input.data {
                Struct(DataStruct {
                    fields: syn::Fields::Named(ref fields),
                    ..
                }) => impl_structopt_for_struct(struct_name, &fields.named, &input.attrs),
                Enum(ref e) => impl_structopt_for_enum(struct_name, &e.variants, &input.attrs),
                _ => call_site_error!("structopt only supports non-tuple structs and enums"),
            }
        }
    }
    /// A struct that is converted from command line arguments.
    pub trait StructOpt {
        /// Returns the corresponding `clap::App`.
        fn clap<'a, 'b>() -> clap::App<'a, 'b>;
    
        /// Creates the struct from `clap::ArgMatches`.
        fn from_clap(matches: &clap::ArgMatches<'_>) -> Self;
    
        /// Gets the struct from the command line arguments.
        fn from_args() -> Self where 
            Self: Sized,
        {
            Self::from_clap(&Self::clap().get_matches())
        }
    
        /// Gets the struct from any iterator such as a `Vec` of your making.
        fn from_iter<I>(iter: I) -> Self where 
            Self: Sized,
            I: IntoIterator,
            I::Item: Into<OsString> + Clone,
        {
            Self::from_clap(&Self::clap().get_matches_from(iter))
        }
    
        /// Gets the struct from any iterator such as a `Vec` of your making.
        fn from_iter_safe<I>(iter: I) -> Result<Self, clap::Error> where 
            Self: Sized,
            I: IntoIterator,
            I::Item: Into<OsString> + Clone,
        {
            Ok(Self::from_clap(&Self::clap().get_matches_from_safe(iter)?))
        }
    }
}

pub mod uuid
{
    //! Generate and parse universally unique identifiers (UUIDs).
    use ::
    {
        *,
    };
    /*
    */
    pub mod builder
    {
        //! A Builder type for [`Uuid`]s.
        use ::
        {
            *,
        };
        /*
        use crate::{error::*, timestamp, Bytes, Uuid, Variant, Version};
        */
        /// A builder for creating a UUID.
        #[allow(missing_copy_implementations)]
        #[derive(Debug)]
        pub struct Builder(Uuid);
        
        impl Uuid {
            /// The 'nil UUID' (all zeros).
            pub const fn nil() -> Self {
                Uuid::from_bytes([0; 16])
            }
        
            /// The 'max UUID' (all ones).
            #[cfg(uuid_unstable)]
            pub const fn max() -> Self {
                Uuid::from_bytes([0xFF; 16])
            }
        
            /// Creates a UUID from four field values.
            pub const fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Uuid {
                Uuid::from_bytes([
                    (d1 >> 24) as u8,
                    (d1 >> 16) as u8,
                    (d1 >> 8) as u8,
                    d1 as u8,
                    (d2 >> 8) as u8,
                    d2 as u8,
                    (d3 >> 8) as u8,
                    d3 as u8,
                    d4[0],
                    d4[1],
                    d4[2],
                    d4[3],
                    d4[4],
                    d4[5],
                    d4[6],
                    d4[7],
                ])
            }
        
            /// Creates a UUID from four field values in little-endian order.
            pub const fn from_fields_le(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Uuid {
                Uuid::from_bytes([
                    d1 as u8,
                    (d1 >> 8) as u8,
                    (d1 >> 16) as u8,
                    (d1 >> 24) as u8,
                    (d2) as u8,
                    (d2 >> 8) as u8,
                    d3 as u8,
                    (d3 >> 8) as u8,
                    d4[0],
                    d4[1],
                    d4[2],
                    d4[3],
                    d4[4],
                    d4[5],
                    d4[6],
                    d4[7],
                ])
            }
        
            /// Creates a UUID from a 128bit value.
            pub const fn from_u128(v: u128) -> Self {
                Uuid::from_bytes([
                    (v >> 120) as u8,
                    (v >> 112) as u8,
                    (v >> 104) as u8,
                    (v >> 96) as u8,
                    (v >> 88) as u8,
                    (v >> 80) as u8,
                    (v >> 72) as u8,
                    (v >> 64) as u8,
                    (v >> 56) as u8,
                    (v >> 48) as u8,
                    (v >> 40) as u8,
                    (v >> 32) as u8,
                    (v >> 24) as u8,
                    (v >> 16) as u8,
                    (v >> 8) as u8,
                    v as u8,
                ])
            }
        
            /// Creates a UUID from a 128bit value in little-endian order.
            pub const fn from_u128_le(v: u128) -> Self {
                Uuid::from_bytes([
                    v as u8,
                    (v >> 8) as u8,
                    (v >> 16) as u8,
                    (v >> 24) as u8,
                    (v >> 32) as u8,
                    (v >> 40) as u8,
                    (v >> 48) as u8,
                    (v >> 56) as u8,
                    (v >> 64) as u8,
                    (v >> 72) as u8,
                    (v >> 80) as u8,
                    (v >> 88) as u8,
                    (v >> 96) as u8,
                    (v >> 104) as u8,
                    (v >> 112) as u8,
                    (v >> 120) as u8,
                ])
            }
        
            /// Creates a UUID from two 64bit values.
            pub const fn from_u64_pair(high_bits: u64, low_bits: u64) -> Self {
                Uuid::from_bytes([
                    (high_bits >> 56) as u8,
                    (high_bits >> 48) as u8,
                    (high_bits >> 40) as u8,
                    (high_bits >> 32) as u8,
                    (high_bits >> 24) as u8,
                    (high_bits >> 16) as u8,
                    (high_bits >> 8) as u8,
                    high_bits as u8,
                    (low_bits >> 56) as u8,
                    (low_bits >> 48) as u8,
                    (low_bits >> 40) as u8,
                    (low_bits >> 32) as u8,
                    (low_bits >> 24) as u8,
                    (low_bits >> 16) as u8,
                    (low_bits >> 8) as u8,
                    low_bits as u8,
                ])
            }
        
            /// Creates a UUID using the supplied bytes.
            pub fn from_slice(b: &[u8]) -> Result<Uuid, Error> {
                if b.len() != 16 {
                    return Err(Error(ErrorKind::ByteLength { len: b.len() }));
                }
        
                let mut bytes: Bytes = [0; 16];
                bytes.copy_from_slice(b);
                Ok(Uuid::from_bytes(bytes))
            }
        
            /// Creates a UUID using the supplied bytes in little endian order.
            pub fn from_slice_le(b: &[u8]) -> Result<Uuid, Error> {
                if b.len() != 16 {
                    return Err(Error(ErrorKind::ByteLength { len: b.len() }));
                }
        
                let mut bytes: Bytes = [0; 16];
                bytes.copy_from_slice(b);
                Ok(Uuid::from_bytes_le(bytes))
            }
        
            /// Creates a UUID using the supplied bytes.
            pub const fn from_bytes(bytes: Bytes) -> Uuid {
                Uuid(bytes)
            }
        
            /// Creates a UUID using the supplied bytes in little endian order.
            pub const fn from_bytes_le(b: Bytes) -> Uuid {
                Uuid([
                    b[3], b[2], b[1], b[0], b[5], b[4], b[7], b[6], b[8], b[9], b[10], b[11], b[12], b[13],
                    b[14], b[15],
                ])
            }
        
            /// Creates a reference to a UUID from a reference to the supplied bytes.
            pub fn from_bytes_ref(bytes: &Bytes) -> &Uuid {
                // SAFETY: `Bytes` and `Uuid` have the same ABI
                unsafe { &*(bytes as *const Bytes as *const Uuid) }
            }
        }
        
        impl Builder {
            /// Creates a `Builder` using the supplied bytes.
            pub const fn from_bytes(b: Bytes) -> Self {
                Builder(Uuid::from_bytes(b))
            }
        
            /// Creates a `Builder` using the supplied bytes in little endian order.
            pub const fn from_bytes_le(b: Bytes) -> Self {
                Builder(Uuid::from_bytes_le(b))
            }
        
            /// Creates a `Builder` for a version 1 UUID using the supplied timestamp and node ID.
            pub const fn from_rfc4122_timestamp(ticks: u64, counter: u16, node_id: &[u8; 6]) -> Self {
                Builder(timestamp::encode_rfc4122_timestamp(ticks, counter, node_id))
            }
        
            /// Creates a `Builder` for a version 3 UUID using the supplied MD5 hashed bytes.
            pub const fn from_md5_bytes(md5_bytes: Bytes) -> Self {
                Builder(Uuid::from_bytes(md5_bytes))
                    .with_variant(Variant::RFC4122)
                    .with_version(Version::Md5)
            }
        
            /// Creates a `Builder` for a version 4 UUID using the supplied random bytes.
            pub const fn from_random_bytes(random_bytes: Bytes) -> Self {
                Builder(Uuid::from_bytes(random_bytes))
                    .with_variant(Variant::RFC4122)
                    .with_version(Version::Random)
            }
        
            /// Creates a `Builder` for a version 5 UUID using the supplied SHA-1 hashed bytes.
            pub const fn from_sha1_bytes(sha1_bytes: Bytes) -> Self {
                Builder(Uuid::from_bytes(sha1_bytes))
                    .with_variant(Variant::RFC4122)
                    .with_version(Version::Sha1)
            }
        
            /// Creates a `Builder` for a version 6 UUID using the supplied timestamp and node ID.
            #[cfg(uuid_unstable)]
            pub const fn from_sorted_rfc4122_timestamp(
                ticks: u64,
                counter: u16,
                node_id: &[u8; 6],
            ) -> Self {
                Builder(timestamp::encode_sorted_rfc4122_timestamp(
                    ticks, counter, node_id,
                ))
            }
        
            /// Creates a `Builder` for a version 7 UUID using the supplied Unix timestamp and random bytes.
            #[cfg(uuid_unstable)]
            pub const fn from_unix_timestamp_millis(millis: u64, random_bytes: &[u8; 10]) -> Self {
                Builder(timestamp::encode_unix_timestamp_millis(
                    millis,
                    random_bytes,
                ))
            }
        
            /// Creates a `Builder` for a version 8 UUID using the supplied user-defined bytes.
            #[cfg(uuid_unstable)]
            pub const fn from_custom_bytes(custom_bytes: Bytes) -> Self {
                Builder::from_bytes(custom_bytes)
                    .with_variant(Variant::RFC4122)
                    .with_version(Version::Custom)
            }
        
            /// Creates a `Builder` using the supplied bytes.
            pub fn from_slice(b: &[u8]) -> Result<Self, Error> {
                Ok(Builder(Uuid::from_slice(b)?))
            }
        
            /// Creates a `Builder` using the supplied bytes in little endian order.
            pub fn from_slice_le(b: &[u8]) -> Result<Self, Error> {
                Ok(Builder(Uuid::from_slice_le(b)?))
            }
        
            /// Creates a `Builder` from four field values.
            pub const fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Self {
                Builder(Uuid::from_fields(d1, d2, d3, d4))
            }
        
            /// Creates a `Builder` from four field values.
            pub const fn from_fields_le(d1: u32, d2: u16, d3: u16, d4: &[u8; 8]) -> Self {
                Builder(Uuid::from_fields_le(d1, d2, d3, d4))
            }
        
            /// Creates a `Builder` from a 128bit value.
            pub const fn from_u128(v: u128) -> Self {
                Builder(Uuid::from_u128(v))
            }
        
            /// Creates a UUID from a 128bit value in little-endian order.
            pub const fn from_u128_le(v: u128) -> Self {
                Builder(Uuid::from_u128_le(v))
            }
        
            /// Creates a `Builder` with an initial [`Uuid::nil`].
            pub const fn nil() -> Self {
                Builder(Uuid::nil())
            }
        
            /// Specifies the variant of the UUID.
            pub fn set_variant(&mut self, v: Variant) -> &mut Self {
                *self = Builder(self.0).with_variant(v);
                self
            }
        
            /// Specifies the variant of the UUID.
            pub const fn with_variant(mut self, v: Variant) -> Self {
                let byte = (self.0).0[8];
        
                (self.0).0[8] = match v {
                    Variant::NCS => byte & 0x7f,
                    Variant::RFC4122 => (byte & 0x3f) | 0x80,
                    Variant::Microsoft => (byte & 0x1f) | 0xc0,
                    Variant::Future => byte | 0xe0,
                };
        
                self
            }
        
            /// Specifies the version number of the UUID.
            pub fn set_version(&mut self, v: Version) -> &mut Self {
                *self = Builder(self.0).with_version(v);
                self
            }
        
            /// Specifies the version number of the UUID.
            pub const fn with_version(mut self, v: Version) -> Self {
                (self.0).0[6] = ((self.0).0[6] & 0x0f) | ((v as u8) << 4);
        
                self
            }
        
            /// Get a reference to the underlying [`Uuid`].
            pub const fn as_uuid(&self) -> &Uuid {
                &self.0
            }
        
            /// Convert the builder into a [`Uuid`].
            pub const fn into_uuid(self) -> Uuid {
                self.0
            }
        }
    }
    
    pub mod error
    {
        use ::
        {
            *,
        };
        /*
        */
        /// A general error that can occur when working with UUIDs.
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub struct Error(pub ErrorKind);
        
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub enum ErrorKind {
            /// Invalid character in the [`Uuid`] string.
            Char { character: char, index: usize },
            /// A simple [`Uuid`] didn't contain 32 characters.
            SimpleLength { len: usize },
            /// A byte array didn't contain 16 bytes
            ByteLength { len: usize },
            /// A hyphenated [`Uuid`] didn't contain 5 groups
            GroupCount { count: usize },
            /// A hyphenated [`Uuid`] had a group that wasn't the right length
            GroupLength {
                group: usize,
                len: usize,
                index: usize,
            },
            /// The input was not a valid UTF8 string
            InvalidUTF8,
            /// Some other error occurred.
            Other,
        }
        
        /// A string that is guaranteed to fail to parse to a [`Uuid`].
        #[derive(Clone, Debug, Eq, Hash, PartialEq)]
        pub struct InvalidUuid<'a>(pub &'a [u8]);
        
        impl<'a> InvalidUuid<'a> {
            /// Converts the lightweight error type into detailed diagnostics.
            pub fn into_err(self) -> Error {
                let input_str = match ::str::from_utf8(self.0) {
                    Ok(s) => s,
                    Err(_) => return Error(ErrorKind::InvalidUTF8),
                };
        
                let (uuid_str, offset, simple) = match input_str.as_bytes() {
                    [b'{', s @ .., b'}'] => (s, 1, false),
                    [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..] => {
                        (s, "urn:uuid:".len(), false)
                    }
                    s => (s, 0, true),
                };
        
                let mut hyphen_count = 0;
                let mut group_bounds = [0; 4];
                
                let uuid_str = unsafe { ::str::from_utf8_unchecked(uuid_str) };
        
                for (index, character) in uuid_str.char_indices() {
                    let byte = character as u8;
                    if character as u32 - byte as u32 > 0 {
                        // Multibyte char
                        return Error(ErrorKind::Char {
                            character,
                            index: index + offset + 1,
                        });
                    } else if byte == b'-' {
                        // While we search, also count group breaks
                        if hyphen_count < 4 {
                            group_bounds[hyphen_count] = index;
                        }
                        hyphen_count += 1;
                    } else if !matches!(byte, b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F') {
                        // Non-hex char
                        return Error(ErrorKind::Char {
                            character: byte as char,
                            index: index + offset + 1,
                        });
                    }
                }
        
                if hyphen_count == 0 && simple {
                    Error(ErrorKind::SimpleLength {
                        len: input_str.len(),
                    })
                } else if hyphen_count != 4 {
                    Error(ErrorKind::GroupCount {
                        count: hyphen_count + 1,
                    })
                } else {
                    const BLOCK_STARTS: [usize; 5] = [0, 9, 14, 19, 24];
                    for i in 0..4 {
                        if group_bounds[i] != BLOCK_STARTS[i + 1] - 1 {
                            return Error(ErrorKind::GroupLength {
                                group: i,
                                len: group_bounds[i] - BLOCK_STARTS[i],
                                index: offset + BLOCK_STARTS[i] + 1,
                            });
                        }
                    }
                    
                    Error(ErrorKind::GroupLength {
                        group: 4,
                        len: input_str.len() - BLOCK_STARTS[4],
                        index: offset + BLOCK_STARTS[4] + 1,
                    })
                }
            }
        }
        
        // NOTE: This impl is part of the public API. Breaking changes to it should be carefully considered
        impl fmt::Display for Error {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match self.0 {
                    ErrorKind::Char {
                        character, index, ..
                    } => {
                        write!(f, "invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `{}` at {}", character, index)
                    }
                    ErrorKind::SimpleLength { len } => {
                        write!(
                            f,
                            "invalid length: expected length 32 for simple format, found {}",
                            len
                        )
                    }
                    ErrorKind::ByteLength { len } => {
                        write!(f, "invalid length: expected 16 bytes, found {}", len)
                    }
                    ErrorKind::GroupCount { count } => {
                        write!(f, "invalid group count: expected 5, found {}", count)
                    }
                    ErrorKind::GroupLength { group, len, .. } => {
                        let expected = [8, 4, 4, 4, 12][group];
                        write!(
                            f,
                            "invalid group length in group {}: expected {}, found {}",
                            group, expected, len
                        )
                    }
                    ErrorKind::InvalidUTF8 => write!(f, "non-UTF8 input"),
                    ErrorKind::Other => write!(f, "failed to parse a UUID"),
                }
            }
        }
        
        impl ::error::Error for Error {}
    }
    
    pub mod parser
    {
        //! [`Uuid`] parsing constructs and utilities.
        use ::
        {
            *,
        };
        /*
        use crate::{
            error::*,
            ::{convert::TryFrom, str},
            Uuid,
        };
        */
        impl str::FromStr for Uuid {
            type Err = Error;
        
            fn from_str(uuid_str: &str) -> Result<Self, Self::Err> {
                Uuid::parse_str(uuid_str)
            }
        }
        
        impl TryFrom<&'_ str> for Uuid {
            type Error = Error;
        
            fn try_from(uuid_str: &'_ str) -> Result<Self, Self::Error> {
                Uuid::parse_str(uuid_str)
            }
        }
        
        impl Uuid {
            /// Parses a `Uuid` from a string of hexadecimal digits with optional
            /// hyphens.
            pub fn parse_str(input: &str) -> Result<Uuid, Error> {
                try_parse(input.as_bytes())
                    .map(Uuid::from_bytes)
                    .map_err(InvalidUuid::into_err)
            }
        
            /// Parses a `Uuid` from a string of hexadecimal digits with optional
            /// hyphens.
            pub const fn try_parse(input: &str) -> Result<Uuid, Error> {
                Self::try_parse_ascii(input.as_bytes())
            }
        
            /// Parses a `Uuid` from a string of hexadecimal digits with optional
            /// hyphens.
            pub const fn try_parse_ascii(input: &[u8]) -> Result<Uuid, Error> {
                match try_parse(input) {
                    Ok(bytes) => Ok(Uuid::from_bytes(bytes)),
                    Err(_) => Err(Error(ErrorKind::Other)),
                }
            }
        }
        
        const fn try_parse(input: &[u8]) -> Result<[u8; 16], InvalidUuid> {
            let result = match (input.len(), input) {
                (32, s) => parse_simple(s),
                (36, s)
                | (38, [b'{', s @ .., b'}'])
                | (45, [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..]) => {
                    parse_hyphenated(s)
                }
                _ => Err(()),
            };
        
            match result {
                Ok(b) => Ok(b),
                Err(()) => Err(InvalidUuid(input)),
            }
        }
        
        #[inline]
        const fn parse_simple(s: &[u8]) -> Result<[u8; 16], ()> {
            if s.len() != 32 {
                return Err(());
            }
        
            let mut buf: [u8; 16] = [0; 16];
            let mut i = 0;
        
            while i < 16 {
                let h1 = HEX_TABLE[s[i * 2] as usize];
                let h2 = HEX_TABLE[s[i * 2 + 1] as usize];
                
                if h1 | h2 == 0xff {
                    return Err(());
                }
                
                buf[i] = SHL4_TABLE[h1 as usize] | h2;
                i += 1;
            }
        
            Ok(buf)
        }
        
        #[inline]
        const fn parse_hyphenated(s: &[u8]) -> Result<[u8; 16], ()> {
            // This length check here removes all other bounds
            // checks in this function
            if s.len() != 36 {
                return Err(());
            }
        
            // We look at two hex-encoded values (4 chars) at a time because
            // that's the size of the smallest group in a hyphenated UUID.
            // The indexes we're interested in are:
            //
            // uuid     : 936da01f-9abd-4d9d-80c7-02af85c822a8
            //            |   |   ||   ||   ||   ||   |   |
            // hyphens  : |   |   8|  13|  18|  23|   |   |
            // positions: 0   4    9   14   19   24  28  32
        
            // First, ensure the hyphens appear in the right places
            match [s[8], s[13], s[18], s[23]] {
                [b'-', b'-', b'-', b'-'] => {}
                _ => return Err(()),
            }
        
            let positions: [u8; 8] = [0, 4, 9, 14, 19, 24, 28, 32];
            let mut buf: [u8; 16] = [0; 16];
            let mut j = 0;
        
            while j < 8 {
                let i = positions[j];
        
                // The decoding here is the same as the simple case
                // We're just dealing with two values instead of one
                let h1 = HEX_TABLE[s[i as usize] as usize];
                let h2 = HEX_TABLE[s[(i + 1) as usize] as usize];
                let h3 = HEX_TABLE[s[(i + 2) as usize] as usize];
                let h4 = HEX_TABLE[s[(i + 3) as usize] as usize];
        
                if h1 | h2 | h3 | h4 == 0xff {
                    return Err(());
                }
        
                buf[j * 2] = SHL4_TABLE[h1 as usize] | h2;
                buf[j * 2 + 1] = SHL4_TABLE[h3 as usize] | h4;
                j += 1;
            }
        
            Ok(buf)
        }
        
        const HEX_TABLE: &[u8; 256] = &{
            let mut buf = [0; 256];
            let mut i: u8 = 0;
        
            loop {
                buf[i as usize] = match i {
                    b'0'..=b'9' => i - b'0',
                    b'a'..=b'f' => i - b'a' + 10,
                    b'A'..=b'F' => i - b'A' + 10,
                    _ => 0xff,
                };
        
                if i == 255 {
                    break buf;
                }
        
                i += 1
            }
        };
        
        const SHL4_TABLE: &[u8; 256] = &{
            let mut buf = [0; 256];
            let mut i: u8 = 0;
        
            loop {
                buf[i as usize] = i.wrapping_shl(4);
        
                if i == 255 {
                    break buf;
                }
        
                i += 1;
            }
        };
    }
    
    pub mod fmt
    {
        //! Adapters for alternative string formats.
        use ::
        {
            *,
        };
        /*
        use crate::{
            ::{borrow::Borrow, fmt, ptr, str},
            Uuid, Variant,
        };
        */
        impl ::fmt::Debug for Uuid {
            #[inline] fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                fmt::LowerHex::fmt(self, f)
            }
        }
        
        impl fmt::Display for Uuid {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                fmt::LowerHex::fmt(self, f)
            }
        }
        
        impl fmt::Display for Variant {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match *self {
                    Variant::NCS => write!(f, "NCS"),
                    Variant::RFC4122 => write!(f, "RFC4122"),
                    Variant::Microsoft => write!(f, "Microsoft"),
                    Variant::Future => write!(f, "Future"),
                }
            }
        }
        
        impl fmt::LowerHex for Uuid {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                fmt::LowerHex::fmt(self.as_hyphenated(), f)
            }
        }
        
        impl fmt::UpperHex for Uuid {
            #[inline] fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                fmt::UpperHex::fmt(self.as_hyphenated(), f)
            }
        }
        
        /// Format a [`Uuid`] as a hyphenated string, like
        /// `67e55044-10b1-426f-9247-bb680e5fe0c8`.
        #[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
        #[repr(transparent)]
        pub struct Hyphenated(Uuid);
        
        /// Format a [`Uuid`] as a simple string, like
        /// `67e5504410b1426f9247bb680e5fe0c8`.
        #[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
        #[repr(transparent)]
        pub struct Simple(Uuid);
        
        /// Format a [`Uuid`] as a URN string, like
        /// `urn:uuid:67e55044-10b1-426f-9247-bb680e5fe0c8`.
        #[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
        #[repr(transparent)]
        pub struct Urn(Uuid);
        
        /// Format a [`Uuid`] as a braced hyphenated string, like
        /// `{67e55044-10b1-426f-9247-bb680e5fe0c8}`.
        #[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
        #[repr(transparent)]
        pub struct Braced(Uuid);
        
        impl Uuid {
            /// Get a [`Hyphenated`] formatter.
            #[inline]
            pub const fn hyphenated(self) -> Hyphenated {
                Hyphenated(self)
            }
        
            /// Get a borrowed [`Hyphenated`] formatter.
            #[inline] pub fn as_hyphenated(&self) -> &Hyphenated {
                // SAFETY: `Uuid` and `Hyphenated` have the same ABI
                unsafe { &*(self as *const Uuid as *const Hyphenated) }
            }
        
            /// Get a [`Simple`] formatter.
            #[inline]
            pub const fn simple(self) -> Simple {
                Simple(self)
            }
        
            /// Get a borrowed [`Simple`] formatter.
            #[inline] pub fn as_simple(&self) -> &Simple {
                // SAFETY: `Uuid` and `Simple` have the same ABI
                unsafe { &*(self as *const Uuid as *const Simple) }
            }
        
            /// Get a [`Urn`] formatter.
            #[inline]
            pub const fn urn(self) -> Urn {
                Urn(self)
            }
        
            /// Get a borrowed [`Urn`] formatter.
            #[inline] pub fn as_urn(&self) -> &Urn {
                // SAFETY: `Uuid` and `Urn` have the same ABI
                unsafe { &*(self as *const Uuid as *const Urn) }
            }
        
            /// Get a [`Braced`] formatter.
            #[inline]
            pub const fn braced(self) -> Braced {
                Braced(self)
            }
        
            /// Get a borrowed [`Braced`] formatter.
            #[inline] pub fn as_braced(&self) -> &Braced {
                // SAFETY: `Uuid` and `Braced` have the same ABI
                unsafe { &*(self as *const Uuid as *const Braced) }
            }
        }
        
        const UPPER: [u8; 16] = [
            b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9', b'A', b'B', b'C', b'D', b'E', b'F',
        ];
        const LOWER: [u8; 16] = [
            b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9', b'a', b'b', b'c', b'd', b'e', b'f',
        ];
        
        #[inline]
        const fn format_simple(src: &[u8; 16], upper: bool) -> [u8; 32] {
            let lut = if upper { &UPPER } else { &LOWER };
            let mut dst = [0; 32];
            let mut i = 0;
            while i < 16 {
                let x = src[i];
                dst[i * 2] = lut[(x >> 4) as usize];
                dst[i * 2 + 1] = lut[(x & 0x0f) as usize];
                i += 1;
            }
            dst
        }
        
        #[inline]
        const fn format_hyphenated(src: &[u8; 16], upper: bool) -> [u8; 36] {
            let lut = if upper { &UPPER } else { &LOWER };
            let groups = [(0, 8), (9, 13), (14, 18), (19, 23), (24, 36)];
            let mut dst = [0; 36];
        
            let mut group_idx = 0;
            let mut i = 0;
            while group_idx < 5 {
                let (start, end) = groups[group_idx];
                let mut j = start;
                while j < end {
                    let x = src[i];
                    i += 1;
        
                    dst[j] = lut[(x >> 4) as usize];
                    dst[j + 1] = lut[(x & 0x0f) as usize];
                    j += 2;
                }
                if group_idx < 4 {
                    dst[end] = b'-';
                }
                group_idx += 1;
            }
            dst
        }
        
        #[inline]
        fn encode_simple<'b>(src: &[u8; 16], buffer: &'b mut [u8], upper: bool) -> &'b mut str {
            let buf = &mut buffer[..Simple::LENGTH];
            let dst = buf.as_mut_ptr();
            
            unsafe {
                ptr::write(dst.cast(), format_simple(src, upper));
                str::from_utf8_unchecked_mut(buf)
            }
        }
        
        #[inline]
        fn encode_hyphenated<'b>(src: &[u8; 16], buffer: &'b mut [u8], upper: bool) -> &'b mut str {
            let buf = &mut buffer[..Hyphenated::LENGTH];
            let dst = buf.as_mut_ptr();
            
            unsafe {
                ptr::write(dst.cast(), format_hyphenated(src, upper));
                str::from_utf8_unchecked_mut(buf)
            }
        }
        
        #[inline]
        fn encode_braced<'b>(src: &[u8; 16], buffer: &'b mut [u8], upper: bool) -> &'b mut str {
            let buf = &mut buffer[..Braced::LENGTH];
            buf[0] = b'{';
            buf[Braced::LENGTH - 1] = b'}';
            
            unsafe {
                let dst = buf.as_mut_ptr().add(1);
        
                ptr::write(dst.cast(), format_hyphenated(src, upper));
                str::from_utf8_unchecked_mut(buf)
            }
        }
        
        #[inline]
        fn encode_urn<'b>(src: &[u8; 16], buffer: &'b mut [u8], upper: bool) -> &'b mut str {
            let buf = &mut buffer[..Urn::LENGTH];
            buf[..9].copy_from_slice(b"urn:uuid:");
            
            unsafe {
                let dst = buf.as_mut_ptr().add(9);
        
                ptr::write(dst.cast(), format_hyphenated(src, upper));
                str::from_utf8_unchecked_mut(buf)
            }
        }
        
        impl Hyphenated {
            /// The length of a hyphenated [`Uuid`] string.
            pub const LENGTH: usize = 36;
        
            /// Creates a [`Hyphenated`] from a [`Uuid`].
            pub const fn from_uuid(uuid: Uuid) -> Self {
                Hyphenated(uuid)
            }
        
            /// Writes the [`Uuid`] as a lower-case hyphenated string to
            /// `buffer`, and returns the subslice of the buffer that contains the
            /// encoded UUID.
            #[inline] pub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {
                encode_hyphenated(self.0.as_bytes(), buffer, false)
            }
        
            /// Writes the [`Uuid`] as an upper-case hyphenated string to
            /// `buffer`, and returns the subslice of the buffer that contains the
            /// encoded UUID.
            #[inline] pub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {
                encode_hyphenated(self.0.as_bytes(), buffer, true)
            }
        
            /// Get a reference to the underlying [`Uuid`].
            pub const fn as_uuid(&self) -> &Uuid {
                &self.0
            }
        
            /// Consumes the [`Hyphenated`], returning the underlying [`Uuid`].
            pub const fn into_uuid(self) -> Uuid {
                self.0
            }
        }
        
        impl Braced {
            /// The length of a braced [`Uuid`] string.
            pub const LENGTH: usize = 38;
        
            /// Creates a [`Braced`] from a [`Uuid`].
            pub const fn from_uuid(uuid: Uuid) -> Self {
                Braced(uuid)
            }
        
            /// Writes the [`Uuid`] as a lower-case hyphenated string surrounded by
            /// braces to `buffer`, and returns the subslice of the buffer that contains
            /// the encoded UUID.
            #[inline] pub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {
                encode_braced(self.0.as_bytes(), buffer, false)
            }
        
            /// Writes the [`Uuid`] as an upper-case hyphenated string surrounded by
            /// braces to `buffer`, and returns the subslice of the buffer that contains
            /// the encoded UUID.
            #[inline] pub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {
                encode_braced(self.0.as_bytes(), buffer, true)
            }
        
            /// Get a reference to the underlying [`Uuid`].
            pub const fn as_uuid(&self) -> &Uuid {
                &self.0
            }
        
            /// Consumes the [`Braced`], returning the underlying [`Uuid`].
            pub const fn into_uuid(self) -> Uuid {
                self.0
            }
        }
        
        impl Simple {
            /// The length of a simple [`Uuid`] string.
            pub const LENGTH: usize = 32;
        
            /// Creates a [`Simple`] from a [`Uuid`].
            pub const fn from_uuid(uuid: Uuid) -> Self {
                Simple(uuid)
            }
        
            /// Writes the [`Uuid`] as a lower-case simple string to `buffer`,
            /// and returns the subslice of the buffer that contains the encoded UUID.
            #[inline] pub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {
                encode_simple(self.0.as_bytes(), buffer, false)
            }
        
            /// Writes the [`Uuid`] as an upper-case simple string to `buffer`,
            /// and returns the subslice of the buffer that contains the encoded UUID.
            #[inline] pub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {
                encode_simple(self.0.as_bytes(), buffer, true)
            }
        
            /// Get a reference to the underlying [`Uuid`].
            pub const fn as_uuid(&self) -> &Uuid {
                &self.0
            }
        
            /// Consumes the [`Simple`], returning the underlying [`Uuid`].
            pub const fn into_uuid(self) -> Uuid {
                self.0
            }
        }
        
        impl Urn {
            /// The length of a URN [`Uuid`] string.
            pub const LENGTH: usize = 45;
        
            /// Creates a [`Urn`] from a [`Uuid`].
            pub const fn from_uuid(uuid: Uuid) -> Self {
                Urn(uuid)
            }
        
            /// Writes the [`Uuid`] as a lower-case URN string to
            /// `buffer`, and returns the subslice of the buffer that contains the
            /// encoded UUID.
            #[inline] pub fn encode_lower<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {
                encode_urn(self.0.as_bytes(), buffer, false)
            }
        
            /// Writes the [`Uuid`] as an upper-case URN string to
            /// `buffer`, and returns the subslice of the buffer that contains the
            /// encoded UUID.
            #[inline] pub fn encode_upper<'buf>(&self, buffer: &'buf mut [u8]) -> &'buf mut str {
                encode_urn(self.0.as_bytes(), buffer, true)
            }
        
            /// Get a reference to the underlying [`Uuid`].
            pub const fn as_uuid(&self) -> &Uuid {
                &self.0
            }
        
            /// Consumes the [`Urn`], returning the underlying [`Uuid`].
            pub const fn into_uuid(self) -> Uuid {
                self.0
            }
        }
        
        macro_rules! impl_fmt_traits {
            ($($T:ident<$($a:lifetime),*>),+) => {$(
                impl<$($a),*> fmt::Display for $T<$($a),*> {
                    #[inline]
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        fmt::LowerHex::fmt(self, f)
                    }
                }
        
                impl<$($a),*> fmt::LowerHex for $T<$($a),*> {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        f.write_str(self.encode_lower(&mut [0; Self::LENGTH]))
                    }
                }
        
                impl<$($a),*> fmt::UpperHex for $T<$($a),*> {
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        f.write_str(self.encode_upper(&mut [0; Self::LENGTH]))
                    }
                }
        
                impl_fmt_from!($T<$($a),*>);
            )+}
        }
        
        macro_rules! impl_fmt_from {
            ($T:ident<>) => {
                impl From<Uuid> for $T {
                    #[inline]
                    fn from(f: Uuid) -> Self {
                        $T(f)
                    }
                }
        
                impl From<$T> for Uuid {
                    #[inline]
                    fn from(f: $T) -> Self {
                        f.into_uuid()
                    }
                }
        
                impl AsRef<Uuid> for $T {
                    #[inline]
                    fn as_ref(&self) -> &Uuid {
                        &self.0
                    }
                }
        
                impl Borrow<Uuid> for $T {
                    #[inline]
                    fn borrow(&self) -> &Uuid {
                        &self.0
                    }
                }
            };
            ($T:ident<$a:lifetime>) => {
                impl<$a> From<&$a Uuid> for $T<$a> {
                    #[inline]
                    fn from(f: &$a Uuid) -> Self {
                        $T::from_uuid_ref(f)
                    }
                }
        
                impl<$a> From<$T<$a>> for &$a Uuid {
                    #[inline]
                    fn from(f: $T<$a>) -> &$a Uuid {
                        f.0
                    }
                }
        
                impl<$a> AsRef<Uuid> for $T<$a> {
                    #[inline]
                    fn as_ref(&self) -> &Uuid {
                        self.0
                    }
                }
        
                impl<$a> Borrow<Uuid> for $T<$a> {
                    #[inline]
                    fn borrow(&self) -> &Uuid {
                        self.0
                    }
                }
            };
        }
        
        impl_fmt_traits! {
            Hyphenated<>,
            Simple<>,
            Urn<>,
            Braced<>
        }
    }
    
    pub mod rng
    {
        use ::
        {
            *,
        };
        /*
        */
        pub fn bytes() -> [u8; 16] {
            rand::random()
        }
    }
    
    pub mod timestamp
    {
        //! Generating UUIDs from timestamps.
        use ::
        {
            *,
        };
        /*
        use crate::Uuid;
        */
        /// The number of 100 nanosecond ticks between the RFC4122 epoch
        pub const UUID_TICKS_BETWEEN_EPOCHS: u64 = 0x01B2_1DD2_1381_4000;
        
        /// A timestamp that can be encoded into a UUID.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        pub struct Timestamp {
            pub seconds: u64,
            pub nanos: u32,
        }
        
        impl Timestamp {
            /// Get a timestamp representing the current system time.
            pub fn now(context: impl ClockSequence<Output = u16>) -> Self {
                
                    let _ = context;
        
                let (seconds, nanos) = now();
        
                Timestamp {
                    seconds,
                    nanos,
                }
            }
        
            /// Construct a `Timestamp` from an RFC4122 timestamp and counter, as used
            /// in versions 1 and 6 UUIDs.
            pub const fn from_rfc4122(ticks: u64, counter: u16) -> Self {
                let _ = counter;
                let (seconds, nanos) = Self::rfc4122_to_unix(ticks);
        
                Timestamp {
                    seconds,
                    nanos,
                }
            }
        
            /// Construct a `Timestamp` from a Unix timestamp, as used in version 7 UUIDs..
            pub fn from_unix(context: impl ClockSequence<Output = u16>, seconds: u64, nanos: u32) -> Self 
            {
                let _ = context;
    
                Timestamp { seconds, nanos }
            }
                    
            /// Get the value of the timestamp as a Unix timestamp, as used in version 7 UUIDs.
            pub const fn to_unix(&self) -> (u64, u32) {
                (self.seconds, self.nanos)
            }
        
            const fn rfc4122_to_unix(ticks: u64) -> (u64, u32) {
                (
                    ticks.wrapping_sub(UUID_TICKS_BETWEEN_EPOCHS) / 10_000_000,
                    (ticks.wrapping_sub(UUID_TICKS_BETWEEN_EPOCHS) % 10_000_000) as u32 * 100,
                )
            }
        
            #[deprecated(note = "use `to_unix` instead; this method will be removed in a future release")]
            /// Get the number of fractional nanoseconds in the Unix timestamp.
            pub const fn to_unix_nanos(&self) -> u32 {
                panic!("`Timestamp::to_unix_nanos` is deprecated and will be removed: use `Timestamp::to_unix` instead")
            }
        }
        
        pub const fn encode_rfc4122_timestamp(ticks: u64, counter: u16, node_id: &[u8; 6]) -> Uuid {
            let time_low = (ticks & 0xFFFF_FFFF) as u32;
            let time_mid = ((ticks >> 32) & 0xFFFF) as u16;
            let time_high_and_version = (((ticks >> 48) & 0x0FFF) as u16) | (1 << 12);
        
            let mut d4 = [0; 8];
        
            d4[0] = (((counter & 0x3F00) >> 8) as u8) | 0x80;
            d4[1] = (counter & 0xFF) as u8;
            d4[2] = node_id[0];
            d4[3] = node_id[1];
            d4[4] = node_id[2];
            d4[5] = node_id[3];
            d4[6] = node_id[4];
            d4[7] = node_id[5];
        
            Uuid::from_fields(time_low, time_mid, time_high_and_version, &d4)
        }
        
        pub const fn decode_rfc4122_timestamp(uuid: &Uuid) -> (u64, u16) {
            let bytes = uuid.as_bytes();
        
            let ticks: u64 = ((bytes[6] & 0x0F) as u64) << 56
                | (bytes[7] as u64) << 48
                | (bytes[4] as u64) << 40
                | (bytes[5] as u64) << 32
                | (bytes[0] as u64) << 24
                | (bytes[1] as u64) << 16
                | (bytes[2] as u64) << 8
                | (bytes[3] as u64);
        
            let counter: u16 = ((bytes[8] & 0x3F) as u16) << 8 | (bytes[9] as u16);
        
            (ticks, counter)
        }
                
        fn now() -> (u64, u32) {
            let dur = ::time::SystemTime::UNIX_EPOCH.elapsed().expect(
                "Getting elapsed time since UNIX_EPOCH. If this fails, we've somehow violated causality",
            );
        
            (dur.as_secs(), dur.subsec_nanos())
        }
        
        /// A counter that can be used by version 1 and version 6 UUIDs to support
        /// the uniqueness of timestamps.
        pub trait ClockSequence {
            /// The type of sequence returned by this counter.
            type Output;
        
            /// Get the next value in the sequence to feed into a timestamp.
            fn generate_sequence(&self, seconds: u64, subsec_nanos: u32) -> Self::Output;
        }
        
        impl<'a, T: ClockSequence + ?Sized> ClockSequence for &'a T {
            type Output = T::Output;
            fn generate_sequence(&self, seconds: u64, subsec_nanos: u32) -> Self::Output {
                (**self).generate_sequence(seconds, subsec_nanos)
            }
        }
        
        /// Default implementations for the [`ClockSequence`] trait.
        pub mod context {
            use super::ClockSequence;
        
            /// An empty counter that will always return the value `0`.
            #[derive(Debug, Clone, Copy, Default)]
            pub struct NoContext;
        
            impl ClockSequence for NoContext {
                type Output = u16;
        
                fn generate_sequence(&self, _seconds: u64, _nanos: u32) -> Self::Output {
                    0
                }
            }
        }
    } pub use self::timestamp::{context::NoContext, ClockSequence, Timestamp};

    /// A 128-bit (16 byte) buffer containing the UUID.
    pub type Bytes = [u8; 16];
    
    /// The version of the UUID, denoting the generating algorithm.
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[non_exhaustive]
    #[repr(u8)]
    pub enum Version {
        /// The "nil" (all zeros) UUID.
        Nil = 0u8,
        /// Version 1: Timestamp and node ID.
        Mac = 1,
        /// Version 2: DCE Security.
        Dce = 2,
        /// Version 3: MD5 hash.
        Md5 = 3,
        /// Version 4: Random.
        Random = 4,
        /// Version 5: SHA-1 hash.
        Sha1 = 5,
        /// Version 6: Sortable Timestamp and node ID.
        #[cfg(uuid_unstable)]
        SortMac = 6,
        /// Version 7: Timestamp and random.
        #[cfg(uuid_unstable)]
        SortRand = 7,
        /// Version 8: Custom.
        #[cfg(uuid_unstable)]
        Custom = 8,
        /// The "max" (all ones) UUID.
        #[cfg(uuid_unstable)]
        Max = 0xff,
    }
    
    /// The reserved variants of UUIDs.
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[non_exhaustive]
    #[repr(u8)]
    pub enum Variant {
        /// Reserved by the NCS for backward compatibility.
        NCS = 0u8,
        /// As described in the RFC4122 Specification (default).
        RFC4122,
        /// Reserved by Microsoft for backward compatibility.
        Microsoft,
        /// Reserved for future expansion.
        Future,
    }
    
    /// A Universally Unique Identifier (UUID).
    #[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[repr(transparent)]
    pub struct Uuid(Bytes);
    
    impl Uuid {
        /// UUID namespace for Domain Name System (DNS).
        pub const NAMESPACE_DNS: Self = Uuid([
            0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,
            0xc8,
        ]);
    
        /// UUID namespace for ISO Object Identifiers (OIDs).
        pub const NAMESPACE_OID: Self = Uuid([
            0x6b, 0xa7, 0xb8, 0x12, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,
            0xc8,
        ]);
    
        /// UUID namespace for Uniform Resource Locators (URLs).
        pub const NAMESPACE_URL: Self = Uuid([
            0x6b, 0xa7, 0xb8, 0x11, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,
            0xc8,
        ]);
    
        /// UUID namespace for X.500 Distinguished Names (DNs).
        pub const NAMESPACE_X500: Self = Uuid([
            0x6b, 0xa7, 0xb8, 0x14, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30,
            0xc8,
        ]);
    
        /// Returns the variant of the UUID structure.
        pub const fn get_variant(&self) -> Variant {
            match self.as_bytes()[8] {
                x if x & 0x80 == 0x00 => Variant::NCS,
                x if x & 0xc0 == 0x80 => Variant::RFC4122,
                x if x & 0xe0 == 0xc0 => Variant::Microsoft,
                x if x & 0xe0 == 0xe0 => Variant::Future,
                _ => Variant::Future,
            }
        }
    
        /// Returns the version number of the UUID.
        pub const fn get_version_num(&self) -> usize {
            (self.as_bytes()[6] >> 4) as usize
        }
    
        /// Returns the version of the UUID.
        pub const fn get_version(&self) -> Option<Version> {
            match self.get_version_num() {
                0 if self.is_nil() => Some(Version::Nil),
                1 => Some(Version::Mac),
                2 => Some(Version::Dce),
                3 => Some(Version::Md5),
                4 => Some(Version::Random),
                5 => Some(Version::Sha1),
                #[cfg(uuid_unstable)]
                6 => Some(Version::SortMac),
                #[cfg(uuid_unstable)]
                7 => Some(Version::SortRand),
                #[cfg(uuid_unstable)]
                8 => Some(Version::Custom),
                #[cfg(uuid_unstable)]
                0xf => Some(Version::Max),
                _ => None,
            }
        }

        pub fn new_v4() -> Uuid {
            Builder::from_random_bytes(::rng::bytes()).into_uuid()
        }
    
        /// Returns the four field values of the UUID.
        pub fn as_fields(&self) -> (u32, u16, u16, &[u8; 8]) {
            let bytes = self.as_bytes();
    
            let d1 = (bytes[0] as u32) << 24
                | (bytes[1] as u32) << 16
                | (bytes[2] as u32) << 8
                | (bytes[3] as u32);
    
            let d2 = (bytes[4] as u16) << 8 | (bytes[5] as u16);
    
            let d3 = (bytes[6] as u16) << 8 | (bytes[7] as u16);
    
            let d4: &[u8; 8] = convert::TryInto::try_into(&bytes[8..16]).unwrap();
            (d1, d2, d3, d4)
        }
    
        /// Returns the four field values of the UUID in little-endian order.
        pub fn to_fields_le(&self) -> (u32, u16, u16, &[u8; 8]) {
            let d1 = (self.as_bytes()[0] as u32)
                | (self.as_bytes()[1] as u32) << 8
                | (self.as_bytes()[2] as u32) << 16
                | (self.as_bytes()[3] as u32) << 24;
    
            let d2 = (self.as_bytes()[4] as u16) | (self.as_bytes()[5] as u16) << 8;
    
            let d3 = (self.as_bytes()[6] as u16) | (self.as_bytes()[7] as u16) << 8;
    
            let d4: &[u8; 8] = convert::TryInto::try_into(&self.as_bytes()[8..16]).unwrap();
            (d1, d2, d3, d4)
        }
    
        /// Returns a 128bit value containing the value.
        pub const fn as_u128(&self) -> u128 {
            u128::from_be_bytes(*self.as_bytes())
        }
    
        /// Returns a 128bit little-endian value containing the value.
        pub const fn to_u128_le(&self) -> u128 {
            u128::from_le_bytes(*self.as_bytes())
        }
    
        /// Returns two 64bit values containing the value.
        pub const fn as_u64_pair(&self) -> (u64, u64) {
            let value = self.as_u128();
            ((value >> 64) as u64, value as u64)
        }
    
        /// Returns a slice of 16 octets containing the value.
        pub const fn as_bytes(&self) -> &Bytes {
            &self.0
        }
    
        /// Consumes self and returns the underlying byte value of the UUID.
        pub const fn into_bytes(self) -> Bytes {
            self.0
        }
    
        /// Returns the bytes of the UUID in little-endian order.
        pub const fn to_bytes_le(&self) -> Bytes {
            [
                self.0[3], self.0[2], self.0[1], self.0[0], self.0[5], self.0[4], self.0[7], self.0[6],
                self.0[8], self.0[9], self.0[10], self.0[11], self.0[12], self.0[13], self.0[14],
                self.0[15],
            ]
        }
    
        /// Tests if the UUID is nil (all zeros).
        pub const fn is_nil(&self) -> bool {
            self.as_u128() == u128::MIN
        }
    
        /// Tests if the UUID is max (all ones).
        #[cfg(uuid_unstable)]
        pub const fn is_max(&self) -> bool {
            self.as_u128() == u128::MAX
        }
    
        /// A buffer that can be used for `encode_...` calls, that is
        /// guaranteed to be long enough for any of the format adapters.
        pub const fn encode_buffer() -> [u8; fmt::Urn::LENGTH] {
            [0; fmt::Urn::LENGTH]
        }
    
        /// If the UUID is the correct version (v1, v6, or v7) this will return
        /// the timestamp and counter portion parsed from a V1 UUID.
        pub const fn get_timestamp(&self) -> Option<Timestamp> {
            match self.get_version() {
                Some(Version::Mac) => {
                    let (ticks, counter) = timestamp::decode_rfc4122_timestamp(self);
    
                    Some(Timestamp::from_rfc4122(ticks, counter))
                }
                #[cfg(uuid_unstable)]
                Some(Version::SortMac) => {
                    let (ticks, counter) = timestamp::decode_sorted_rfc4122_timestamp(self);
    
                    Some(Timestamp::from_rfc4122(ticks, counter))
                }
                #[cfg(uuid_unstable)]
                Some(Version::SortRand) => {
                    let millis = timestamp::decode_unix_timestamp_millis(self);
    
                    let seconds = millis / 1000;
                    let nanos = ((millis % 1000) * 1_000_000) as u32;
    
                    Some(Timestamp {
                        seconds,
                        nanos,
                    })
                }
                _ => None,
            }
        }
    }
    
    impl Default for Uuid {
        #[inline]
        fn default() -> Self {
            Uuid::nil()
        }
    }
    
    impl AsRef<[u8]> for Uuid {
        #[inline]
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    }
}
/*
yaml-rust = "0.4.0"
*/
pub mod yaml_rust
{
    //! YAML 1.2 implementation in pure Rust.
    use ::
    {
        *,
    };
    /*
    extern crate linked_hash_map;
    */
    pub mod yaml
    {
        use ::
        {
            *,
        };
        /*
        use ::collections::BTreeMap;
        use ::ops::Index;
        use ::string;
        use ::i64;
        use ::f64;
        use ::mem;
        use ::vec;
        use parser::*;
        use scanner::{TScalarStyle, ScanError, TokenType, Marker};
        use linked_hash_map::LinkedHashMap;
        */
        /// A YAML node is stored as this `Yaml` enumeration, which provides an easy way to access your YAML document.
        #[derive(Clone, PartialEq, PartialOrd, Debug, Eq, Ord, Hash)]
        pub enum Yaml {
            /// Float types are stored as String and parsed on demand.
            /// Note that f64 does NOT implement Eq trait and can NOT be stored in BTreeMap.
            Real(string::String),
            /// YAML int is stored as i64.
            Integer(i64),
            /// YAML scalar.
            String(string::String),
            /// YAML bool, e.g. `true` or `false`.
            Boolean(bool),
            /// YAML array, can be accessed as a `Vec`.
            Array(self::Array),
            /// YAML hash, can be accessed as a `LinkedHashMap`.
            ///
            /// Itertion order will match the order of insertion into the map.
            Hash(self::Hash),
            /// Alias, not fully supported yet.
            Alias(usize),
            /// YAML null, e.g. `null` or `~`.
            Null,
            /// Accessing a nonexistent node via the Index trait returns `BadValue`. This
            /// simplifies error handling in the calling code. Invalid type conversion also
            /// returns `BadValue`.
            BadValue,
        }
        
        pub type Array = Vec<Yaml>;
        pub type Hash = LinkedHashMap<Yaml, Yaml>;
        
        // parse f64 as Core schema
        // See: https://github.com/chyh1990/yaml-rust/issues/51
        fn parse_f64(v: &str) -> Option<f64> {
            match v {
                ".inf" | ".Inf" | ".INF" | "+.inf" | "+.Inf" | "+.INF" => Some(f64::INFINITY),
                "-.inf" | "-.Inf" | "-.INF" => Some(f64::NEG_INFINITY),
                ".nan" | "NaN" | ".NAN" => Some(f64::NAN),
                _ => v.parse::<f64>().ok()
            }
        }
        
        pub struct YamlLoader {
            docs: Vec<Yaml>,
            // states
            // (current node, anchor_id) tuple
            doc_stack: Vec<(Yaml, usize)>,
            key_stack: Vec<Yaml>,
            anchor_map: BTreeMap<usize, Yaml>,
        }
        
        impl MarkedEventReceiver for YamlLoader {
            fn on_event(&mut self, ev: Event, _: Marker) {
                // println!("EV {:?}", ev);
                match ev {
                    Event::DocumentStart => {
                        // do nothing
                    },
                    Event::DocumentEnd => {
                        match self.doc_stack.len() {
                            // empty document
                            0 => self.docs.push(Yaml::BadValue),
                            1 => self.docs.push(self.doc_stack.pop().unwrap().0),
                            _ => unreachable!()
                        }
                    },
                    Event::SequenceStart(aid) => {
                        self.doc_stack.push((Yaml::Array(Vec::new()), aid));
                    },
                    Event::SequenceEnd => {
                        let node = self.doc_stack.pop().unwrap();
                        self.insert_new_node(node);
                    },
                    Event::MappingStart(aid) => {
                        self.doc_stack.push((Yaml::Hash(Hash::new()), aid));
                        self.key_stack.push(Yaml::BadValue);
                    },
                    Event::MappingEnd => {
                        self.key_stack.pop().unwrap();
                        let node = self.doc_stack.pop().unwrap();
                        self.insert_new_node(node);
                    },
                    Event::Scalar(v, style, aid, tag) => {
                        let node = if style != TScalarStyle::Plain {
                            Yaml::String(v)
                        } else if let Some(TokenType::Tag(ref handle, ref suffix)) = tag {
                            // XXX tag:yaml.org,2002:
                            if handle == "!!" {
                                match suffix.as_ref() {
                                    "bool" => {
                                        // "true" or "false"
                                        match v.parse::<bool>() {
                                            Err(_) => Yaml::BadValue,
                                            Ok(v) => Yaml::Boolean(v)
                                        }
                                    },
                                    "int" => {
                                        match v.parse::<i64>() {
                                            Err(_) => Yaml::BadValue,
                                            Ok(v) => Yaml::Integer(v)
                                        }
                                    },
                                    "float" => {
                                        match parse_f64(&v) {
                                            Some(_) => Yaml::Real(v),
                                            None => Yaml::BadValue,
                                        }
                                    },
                                    "null" => {
                                        match v.as_ref() {
                                            "~" | "null" => Yaml::Null,
                                            _ => Yaml::BadValue,
                                        }
                                    }
                                    _  => Yaml::String(v),
                                }
                            } else {
                                Yaml::String(v)
                            }
                        } else {
                            // Datatype is not specified, or unrecognized
                            Yaml::from_str(&v)
                        };
        
                        self.insert_new_node((node, aid));
                    },
                    Event::Alias(id) => {
                        let n = match self.anchor_map.get(&id) {
                            Some(v) => v.clone(),
                            None => Yaml::BadValue,
                        };
                        self.insert_new_node((n, 0));
                    }
                    _ => { /* ignore */ }
                }
                // println!("DOC {:?}", self.doc_stack);
            }
        }
        
        impl YamlLoader {
            fn insert_new_node(&mut self, node: (Yaml, usize)) {
                // valid anchor id starts from 1
                if node.1 > 0 {
                    self.anchor_map.insert(node.1, node.0.clone());
                }
                if self.doc_stack.is_empty() {
                    self.doc_stack.push(node);
                } else {
                    let parent = self.doc_stack.last_mut().unwrap();
                    match *parent {
                        (Yaml::Array(ref mut v), _) => v.push(node.0),
                        (Yaml::Hash(ref mut h), _) => {
                            let mut cur_key = self.key_stack.last_mut().unwrap();
                            // current node is a key
                            if cur_key.is_badvalue() {
                                *cur_key = node.0;
                            // current node is a value
                            } else {
                                let mut newkey = Yaml::BadValue;
                                mem::swap(&mut newkey, cur_key);
                                h.insert(newkey, node.0);
                            }
                        },
                        _ => unreachable!(),
                    }
                }
            }
        
            pub fn load_from_str(source: &str) -> Result<Vec<Yaml>, ScanError>{
                let mut loader = YamlLoader {
                    docs: Vec::new(),
                    doc_stack: Vec::new(),
                    key_stack: Vec::new(),
                    anchor_map: BTreeMap::new(),
                };
                let mut parser = Parser::new(source.chars());
                try!(parser.load(&mut loader, true));
                Ok(loader.docs)
            }
        }
        
        macro_rules! define_as (
            ($name:ident, $t:ident, $yt:ident) => (
        pub fn $name(&self) -> Option<$t> {
            match *self {
                Yaml::$yt(v) => Some(v),
                _ => None
            }
        }
            );
        );
        
        macro_rules! define_as_ref (
            ($name:ident, $t:ty, $yt:ident) => (
        pub fn $name(&self) -> Option<$t> {
            match *self {
                Yaml::$yt(ref v) => Some(v),
                _ => None
            }
        }
            );
        );
        
        macro_rules! define_into (
            ($name:ident, $t:ty, $yt:ident) => (
        pub fn $name(self) -> Option<$t> {
            match self {
                Yaml::$yt(v) => Some(v),
                _ => None
            }
        }
            );
        );
        
        impl Yaml {
            define_as!(as_bool, bool, Boolean);
            define_as!(as_i64, i64, Integer);
        
            define_as_ref!(as_str, &str, String);
            define_as_ref!(as_hash, &Hash, Hash);
            define_as_ref!(as_vec, &Array, Array);
        
            define_into!(into_bool, bool, Boolean);
            define_into!(into_i64, i64, Integer);
            define_into!(into_string, String, String);
            define_into!(into_hash, Hash, Hash);
            define_into!(into_vec, Array, Array);
        
            pub fn is_null(&self) -> bool {
                match *self {
                    Yaml::Null => true,
                    _ => false
                }
            }
        
            pub fn is_badvalue(&self) -> bool {
                match *self {
                    Yaml::BadValue => true,
                    _ => false
                }
            }
        
            pub fn is_array(&self) -> bool {
                match *self {
                    Yaml::Array(_) => true,
                    _ => false
                }
            }
        
            pub fn as_f64(&self) -> Option<f64> {
                match *self {
                    Yaml::Real(ref v) => parse_f64(v),
                    _ => None
                }
            }
        
            pub fn into_f64(self) -> Option<f64> {
                match self {
                    Yaml::Real(ref v) => parse_f64(v),
                    _ => None
                }
            }
        }
                
        static BAD_VALUE: Yaml = Yaml::BadValue;
        impl<'a> Index<&'a str> for Yaml {
            type Output = Yaml;
        
            fn index(&self, idx: &'a str) -> &Yaml {
                let key = Yaml::String(idx.to_owned());
                match self.as_hash() {
                    Some(h) => h.get(&key).unwrap_or(&BAD_VALUE),
                    None => &BAD_VALUE
                }
            }
        }
        
        impl Index<usize> for Yaml {
            type Output = Yaml;
        
            fn index(&self, idx: usize) -> &Yaml {
                if let Some(v) = self.as_vec() {
                    v.get(idx).unwrap_or(&BAD_VALUE)
                } else if let Some(v) = self.as_hash() {
                    let key = Yaml::Integer(idx as i64);
                    v.get(&key).unwrap_or(&BAD_VALUE)
                } else {
                    &BAD_VALUE
                }
            }
        }
        
        impl IntoIterator for Yaml {
            type Item = Yaml;
            type IntoIter = YamlIter;
        
            fn into_iter(self) -> Self::IntoIter {
                YamlIter {
                    yaml: self.into_vec()
                        .unwrap_or_else(Vec::new).into_iter()
                }
            }
        }
        
        pub struct YamlIter {
            yaml: vec::IntoIter<Yaml>,
        }
        
        impl Iterator for YamlIter {
            type Item = Yaml;
        
            fn next(&mut self) -> Option<Yaml> {
                self.yaml.next()
            }
        }
    }
    
    pub mod scanner
    {
        use ::
        {
            *,
        };
        /*
        */
        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        pub enum TEncoding {
            Utf8
        }
        
        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        pub enum TScalarStyle {
            Any,
            Plain,
            SingleQuoted,
            DoubleQuoted,
        
            Literal,
            Foled
        }
        
        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        pub struct Marker {
            index: usize,
            line: usize,
            col: usize,
        }
        
        impl Marker {
            fn new(index: usize, line: usize, col: usize) -> Marker {
                Marker {
                    index: index,
                    line: line,
                    col: col
                }
            }
        
            pub fn index(&self) -> usize {
                self.index
            }
        
            pub fn line(&self) -> usize {
                self.line
            }
        
            pub fn col(&self) -> usize {
                self.col
            }
        }
        
        #[derive(Clone, PartialEq, Debug, Eq)]
        pub struct ScanError {
            mark: Marker,
            info: String,
        }
        
        impl ScanError {
            pub fn new(loc: Marker, info: &str) -> ScanError {
                ScanError {
                    mark: loc,
                    info: info.to_owned()
                }
            }
        
            pub fn marker(&self) -> &Marker {
                &self.mark
            }
        }
        
        impl Error for ScanError {
            fn description(&self) -> &str {
                self.info.as_ref()
            }
        
            fn cause(&self) -> Option<&Error> {
                None
            }
        }
        
        impl fmt::Display for ScanError {
            // col starts from 0
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                write!(formatter, "{} at line {} column {}", self.info,
                       self.mark.line, self.mark.col + 1)
            }
        }
        
        #[derive(Clone, PartialEq, Debug, Eq)]
        pub enum TokenType {
            NoToken,
            StreamStart(TEncoding),
            StreamEnd,
            /// major, minor
            VersionDirective(u32, u32),
            /// handle, prefix
            TagDirective(String, String),
            DocumentStart,
            DocumentEnd,
            BlockSequenceStart,
            BlockMappingStart,
            BlockEnd,
            FlowSequenceStart,
            FlowSequenceEnd,
            FlowMappingStart,
            FlowMappingEnd,
            BlockEntry,
            FlowEntry,
            Key,
            Value,
            Alias(String),
            Anchor(String),
            /// handle, suffix
            Tag(String, String),
            Scalar(TScalarStyle, String)
        }
        
        #[derive(Clone, PartialEq, Debug, Eq)]
        pub struct Token(pub Marker, pub TokenType);
        
        #[derive(Clone, PartialEq, Debug, Eq)]
        struct SimpleKey {
            possible: bool,
            required: bool,
            token_number: usize,
            mark: Marker,
        }
        
        impl SimpleKey {
            fn new(mark: Marker) -> SimpleKey {
                SimpleKey {
                    possible: false,
                    required: false,
                    token_number: 0,
                    mark: mark,
                }
            }
        }
        
        #[derive(Debug)]
        pub struct Scanner<T> {
            rdr: T,
            mark: Marker,
            tokens: VecDeque<Token>,
            buffer: VecDeque<char>,
            error: Option<ScanError>,
        
            stream_start_produced: bool,
            stream_end_produced: bool,
            simple_key_allowed: bool,
            simple_keys: Vec<SimpleKey>,
            indent: isize,
            indents: Vec<isize>,
            flow_level: usize,
            tokens_parsed: usize,
            token_available: bool,
        }
        
        impl<T: Iterator<Item=char>> Iterator for Scanner<T> {
            type Item = Token;
            fn next(&mut self) -> Option<Token> {
                if self.error.is_some() {
                    return None;
                }
                match self.next_token() {
                    Ok(tok) => tok,
                    Err(e) => {
                        self.error = Some(e);
                        None
                    }
                }
            }
        }
        
        #[inline]
        fn is_z(c: char) -> bool {
            c == '\0'
        }
        #[inline]
        fn is_break(c: char) -> bool {
            c == '\n' || c == '\r'
        }
        #[inline]
        fn is_breakz(c: char) -> bool {
            is_break(c) || is_z(c)
        }
        #[inline]
        fn is_blank(c: char) -> bool {
            c == ' ' || c == '\t'
        }
        #[inline]
        fn is_blankz(c: char) -> bool {
            is_blank(c) || is_breakz(c)
        }
        #[inline]
        fn is_digit(c: char) -> bool {
            c >= '0' && c <= '9'
        }
        #[inline]
        fn is_alpha(c: char) -> bool {
            match c {
                '0'...'9' | 'a'...'z' | 'A'...'Z' => true,
                '_' | '-' => true,
                _ => false
            }
        }
        #[inline]
        fn is_hex(c: char) -> bool {
            (c >= '0' && c <= '9')
                || (c >= 'a' && c <= 'f')
                || (c >= 'A' && c <= 'F')
        }
        #[inline]
        fn as_hex(c: char) -> u32 {
            match c {
                '0'...'9' => (c as u32) - ('0' as u32),
                'a'...'f' => (c as u32) - ('a' as u32) + 10,
                'A'...'F' => (c as u32) - ('A' as u32) + 10,
                _ => unreachable!()
            }
        }
        
        pub type ScanResult = Result<(), ScanError>;
        
        impl<T: Iterator<Item=char>> Scanner<T> {
            /// Creates the YAML tokenizer.
            pub fn new(rdr: T) -> Scanner<T> {
                Scanner {
                    rdr: rdr,
                    buffer: VecDeque::new(),
                    mark: Marker::new(0, 1, 0),
                    tokens: VecDeque::new(),
                    error: None,
        
                    stream_start_produced: false,
                    stream_end_produced: false,
                    simple_key_allowed: true,
                    simple_keys: Vec::new(),
                    indent: -1,
                    indents: Vec::new(),
                    flow_level: 0,
                    tokens_parsed: 0,
                    token_available: false,
                }
            }
            #[inline] pub fn get_error(&self) -> Option<ScanError> {
                match self.error {
                    None => None,
                    Some(ref e) => Some(e.clone()),
                }
            }
        
            #[inline] fn lookahead(&mut self, count: usize) {
                if self.buffer.len() >= count {
                    return;
                }
                for _ in 0..(count - self.buffer.len()) {
                    self.buffer.push_back(self.rdr.next().unwrap_or('\0'));
                }
            }
            #[inline] fn skip(&mut self) {
                let c = self.buffer.pop_front().unwrap();
        
                self.mark.index += 1;
                if c == '\n' {
                    self.mark.line += 1;
                    self.mark.col = 0;
                } else {
                    self.mark.col += 1;
                }
            }
            #[inline] fn skip_line(&mut self) {
                if self.buffer[0] == '\r' && self.buffer[1] == '\n' {
                    self.skip();
                    self.skip();
                } else if is_break(self.buffer[0]) {
                    self.skip();
                }
            }
            #[inline] fn ch(&self) -> char {
                self.buffer[0]
            }
            #[inline] fn ch_is(&self, c: char) -> bool {
                self.buffer[0] == c
            }
            #[allow(dead_code)]
            #[inline] fn eof(&self) -> bool {
                self.ch_is('\0')
            }
            #[inline] pub fn stream_started(&self) -> bool {
                self.stream_start_produced
            }
            #[inline] pub fn stream_ended(&self) -> bool {
                self.stream_end_produced
            }
            #[inline] pub fn mark(&self) -> Marker {
                self.mark
            }
            #[inline] fn read_break(&mut self, s: &mut String) {
                if self.buffer[0] == '\r' && self.buffer[1] == '\n' {
                    s.push('\n');
                    self.skip();
                    self.skip();
                } else if self.buffer[0] == '\r' || self.buffer[0] == '\n' {
                    s.push('\n');
                    self.skip();
                } else {
                    unreachable!();
                }
            }
            fn insert_token(&mut self, pos: usize, tok: Token) {
                let old_len = self.tokens.len();
                assert!(pos <= old_len);
                self.tokens.push_back(tok);
                for i in 0..old_len - pos {
                    self.tokens.swap(old_len - i, old_len - i - 1);
                }
            }
            fn allow_simple_key(&mut self) {
                    self.simple_key_allowed = true;
            }
            fn disallow_simple_key(&mut self) {
                    self.simple_key_allowed = false;
            }
        
            pub fn fetch_next_token(&mut self) -> ScanResult {
                self.lookahead(1);
                // println!("--> fetch_next_token Cur {:?} {:?}", self.mark, self.ch());
        
                if !self.stream_start_produced {
                    self.fetch_stream_start();
                    return Ok(());
                }
                self.skip_to_next_token();
        
                try!(self.stale_simple_keys());
        
                let mark = self.mark;
                self.unroll_indent(mark.col as isize);
        
                self.lookahead(4);
        
                if is_z(self.ch()) {
                    try!(self.fetch_stream_end());
                    return Ok(());
                }
        
                // Is it a directive?
                if self.mark.col == 0 && self.ch_is('%') {
                    return self.fetch_directive();
                }
        
                if self.mark.col == 0
                    && self.buffer[0] == '-'
                    && self.buffer[1] == '-'
                    && self.buffer[2] == '-'
                    && is_blankz(self.buffer[3]) {
                    try!(self.fetch_document_indicator(TokenType::DocumentStart));
                    return Ok(());
                }
        
                if self.mark.col == 0
                    && self.buffer[0] == '.'
                    && self.buffer[1] == '.'
                    && self.buffer[2] == '.'
                    && is_blankz(self.buffer[3]) {
                    try!(self.fetch_document_indicator(TokenType::DocumentEnd));
                    return Ok(());
                }
        
                let c = self.buffer[0];
                let nc = self.buffer[1];
                match c {
                    '[' => self.fetch_flow_collection_start(TokenType::FlowSequenceStart),
                    '{' => self.fetch_flow_collection_start(TokenType::FlowMappingStart),
                    ']' => self.fetch_flow_collection_end(TokenType::FlowSequenceEnd),
                    '}' => self.fetch_flow_collection_end(TokenType::FlowMappingEnd),
                    ',' => self.fetch_flow_entry(),
                    '-' if is_blankz(nc) => self.fetch_block_entry(),
                    '?' if self.flow_level > 0 || is_blankz(nc) => self.fetch_key(),
                    ':' if self.flow_level > 0 || is_blankz(nc) => self.fetch_value(),
                    // Is it an alias?
                    '*' => self.fetch_anchor(true),
                    // Is it an anchor?
                    '&' => self.fetch_anchor(false),
                    '!' => self.fetch_tag(),
                    // Is it a literal scalar?
                    '|' if self.flow_level == 0 => self.fetch_block_scalar(true),
                    // Is it a folded scalar?
                    '>' if self.flow_level == 0 => self.fetch_block_scalar(false),
                    '\'' => self.fetch_flow_scalar(true),
                    '"' => self.fetch_flow_scalar(false),
                    // plain scalar
                    '-' if !is_blankz(nc) => self.fetch_plain_scalar(),
                    ':' | '?' if !is_blankz(nc) && self.flow_level == 0 => self.fetch_plain_scalar(),
                    '%' | '@' | '`' => Err(ScanError::new(self.mark,
                            &format!("unexpected character: `{}'", c))),
                    _ => self.fetch_plain_scalar(),
                }
            }
        
            pub fn next_token(&mut self) -> Result<Option<Token>, ScanError> {
                if self.stream_end_produced {
                    return Ok(None);
                }
        
                if !self.token_available {
                    try!(self.fetch_more_tokens());
                }
                let t = self.tokens.pop_front().unwrap();
                self.token_available = false;
                self.tokens_parsed += 1;
        
                if let TokenType::StreamEnd = t.1 {
                    self.stream_end_produced = true;
                }
                Ok(Some(t))
            }
        
            pub fn fetch_more_tokens(&mut self) -> ScanResult {
                let mut need_more;
                loop {
                    need_more = false;
                    if self.tokens.is_empty() {
                        need_more = true;
                    } else {
                        try!(self.stale_simple_keys());
                        for sk in &self.simple_keys {
                            if sk.possible && sk.token_number == self.tokens_parsed {
                                need_more = true;
                                break;
                            }
                        }
                    }
        
                    if !need_more { break; }
                    try!(self.fetch_next_token());
                }
                self.token_available = true;
        
                Ok(())
            }
        
            fn stale_simple_keys(&mut self) -> ScanResult {
                for sk in &mut self.simple_keys {
                    if sk.possible && (sk.mark.line < self.mark.line
                        || sk.mark.index + 1024 < self.mark.index) {
                            if sk.required {
                                return Err(ScanError::new(self.mark, "simple key expect ':'"));
                            }
                            sk.possible = false;
                        }
                }
                Ok(())
            }
        
            fn skip_to_next_token(&mut self) {
                loop {
                    self.lookahead(1);
                    // TODO(chenyh) BOM
                    match self.ch() {
                        ' ' => self.skip(),
                        '\t' if self.flow_level > 0 || !self.simple_key_allowed => self.skip(),
                        '\n' | '\r' => {
                            self.lookahead(2);
                            self.skip_line();
                            if self.flow_level == 0 {
                                self.allow_simple_key();
                            }
                        },
                        '#' => while !is_breakz(self.ch()) { self.skip(); self.lookahead(1); },
                        _ => break
                    }
                }
            }
        
            fn fetch_stream_start(&mut self) {
                let mark = self.mark;
                self.indent = -1;
                self.stream_start_produced = true;
                self.allow_simple_key();
                self.tokens.push_back(Token(mark, TokenType::StreamStart(TEncoding::Utf8)));
                self.simple_keys.push(SimpleKey::new(Marker::new(0,0,0)));
            }
        
            fn fetch_stream_end(&mut self) -> ScanResult {
                // force new line
                if self.mark.col != 0 {
                    self.mark.col = 0;
                    self.mark.line += 1;
                }
        
                self.unroll_indent(-1);
                try!(self.remove_simple_key());
                self.disallow_simple_key();
        
                self.tokens.push_back(Token(self.mark, TokenType::StreamEnd));
                Ok(())
            }
        
            fn fetch_directive(&mut self) -> ScanResult {
                self.unroll_indent(-1);
                try!(self.remove_simple_key());
        
                self.disallow_simple_key();
        
                let tok = try!(self.scan_directive());
        
                self.tokens.push_back(tok);
        
                Ok(())
            }
        
            fn scan_directive(&mut self) -> Result<Token, ScanError> {
                let start_mark = self.mark;
                self.skip();
        
                let name = try!(self.scan_directive_name());
                let tok = match name.as_ref() {
                    "YAML" => {
                        try!(self.scan_version_directive_value(&start_mark))
                    },
                    "TAG" => {
                        try!(self.scan_tag_directive_value(&start_mark))
                    },
                    // XXX This should be a warning instead of an error
                    _ => {
                        // skip current line
                        self.lookahead(1);
                        while !is_breakz(self.ch()) {
                            self.skip();
                            self.lookahead(1);
                        }
                        // XXX return an empty TagDirective token
                        Token(start_mark, TokenType::TagDirective(String::new(), String::new()))
                        // return Err(ScanError::new(start_mark,
                        //     "while scanning a directive, found unknown directive name"))
                    }
                };
                self.lookahead(1);
        
                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }
        
                if self.ch() == '#' {
                    while !is_breakz(self.ch()) {
                        self.skip();
                        self.lookahead(1);
                    }
                }
        
                if !is_breakz(self.ch()) {
                    return Err(ScanError::new(start_mark,
                        "while scanning a directive, did not find expected comment or line break"));
                }
        
                // Eat a line break
                if is_break(self.ch()) {
                    self.lookahead(2);
                    self.skip_line();
                }
        
                Ok(tok)
            }
        
            fn scan_version_directive_value(&mut self, mark: &Marker) -> Result<Token, ScanError> {
                self.lookahead(1);
        
                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }
        
                let major = try!(self.scan_version_directive_number(mark));
        
                if self.ch() != '.' {
                    return Err(ScanError::new(*mark,
                        "while scanning a YAML directive, did not find expected digit or '.' character"));
                }
        
                self.skip();
        
                let minor = try!(self.scan_version_directive_number(mark));
        
                Ok(Token(*mark, TokenType::VersionDirective(major, minor)))
            }
        
            fn scan_directive_name(&mut self) -> Result<String, ScanError> {
                let start_mark = self.mark;
                let mut string = String::new();
                self.lookahead(1);
                while is_alpha(self.ch()) {
                    string.push(self.ch());
                    self.skip();
                    self.lookahead(1);
                }
        
                if string.is_empty() {
                    return Err(ScanError::new(start_mark,
                            "while scanning a directive, could not find expected directive name"));
                }
        
                if !is_blankz(self.ch()) {
                    return Err(ScanError::new(start_mark,
                            "while scanning a directive, found unexpected non-alphabetical character"));
                }
        
                Ok(string)
            }
        
            fn scan_version_directive_number(&mut self, mark: &Marker) -> Result<u32, ScanError> {
                let mut val = 0u32;
                let mut length = 0usize;
                self.lookahead(1);
                while is_digit(self.ch()) {
                    if length + 1 > 9 {
                        return Err(ScanError::new(*mark,
                            "while scanning a YAML directive, found extremely long version number"));
                    }
                    length += 1;
                    val = val * 10 + ((self.ch() as u32) - ('0' as u32));
                    self.skip();
                    self.lookahead(1);
                }
        
                if length == 0 {
                        return Err(ScanError::new(*mark,
                            "while scanning a YAML directive, did not find expected version number"));
                }
        
                Ok(val)
            }
        
            fn scan_tag_directive_value(&mut self, mark: &Marker) -> Result<Token, ScanError> {
                self.lookahead(1);
                /* Eat whitespaces. */
                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }
                let handle = try!(self.scan_tag_handle(true, mark));
        
                self.lookahead(1);
                /* Eat whitespaces. */
                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }
        
                let is_secondary = handle == "!!";
                let prefix = try!(self.scan_tag_uri(true, is_secondary, &String::new(), mark));
        
                self.lookahead(1);
        
                if is_blankz(self.ch()) {
                    Ok(Token(*mark, TokenType::TagDirective(handle, prefix)))
                } else {
                    Err(ScanError::new(*mark,
                        "while scanning TAG, did not find expected whitespace or line break"))
                }
            }
        
            fn fetch_tag(&mut self) -> ScanResult {
                try!(self.save_simple_key());
                self.disallow_simple_key();
        
                let tok = try!(self.scan_tag());
                self.tokens.push_back(tok);
                Ok(())
            }
        
            fn scan_tag(&mut self) -> Result<Token, ScanError> {
                let start_mark = self.mark;
                let mut handle = String::new();
                let mut suffix;
                let mut secondary = false;
        
                // Check if the tag is in the canonical form (verbatim).
                self.lookahead(2);
        
                if self.buffer[1] == '<' {
                    // Eat '!<'
                    self.skip();
                    self.skip();
                    suffix = try!(self.scan_tag_uri(false, false, &String::new(), &start_mark));
        
                    if self.ch() != '>' {
                        return Err(ScanError::new(start_mark,
                            "while scanning a tag, did not find the expected '>'"));
                    }
        
                    self.skip();
                } else {
                    // The tag has either the '!suffix' or the '!handle!suffix'
                    handle = try!(self.scan_tag_handle(false, &start_mark));
                    // Check if it is, indeed, handle.
                    if handle.len() >= 2 && handle.starts_with('!') && handle.ends_with('!') {
                        if handle == "!!" {
                            secondary = true;
                        }
                        suffix = try!(self.scan_tag_uri(false, secondary, &String::new(), &start_mark));
                    } else {
                        suffix = try!(self.scan_tag_uri(false, false, &handle, &start_mark));
                        handle = "!".to_owned();
                        // A special case: the '!' tag.  Set the handle to '' and the
                        // suffix to '!'.
                        if suffix.is_empty() {
                            handle.clear();
                            suffix = "!".to_owned();
                        }
                    }
                }
        
                self.lookahead(1);
                if is_blankz(self.ch()) {
                    // XXX: ex 7.2, an empty scalar can follow a secondary tag
                    Ok(Token(start_mark, TokenType::Tag(handle, suffix)))
                } else {
                    Err(ScanError::new(start_mark,
                        "while scanning a tag, did not find expected whitespace or line break"))
                }
            }
        
            fn scan_tag_handle(&mut self, directive: bool, mark: &Marker) -> Result<String, ScanError> {
                let mut string = String::new();
                self.lookahead(1);
                if self.ch() != '!' {
                    return Err(ScanError::new(*mark,
                        "while scanning a tag, did not find expected '!'"));
                }
        
                string.push(self.ch());
                self.skip();
        
                self.lookahead(1);
                while is_alpha(self.ch()) {
                    string.push(self.ch());
                    self.skip();
                    self.lookahead(1);
                }
        
                // Check if the trailing character is '!' and copy it.
                if self.ch() == '!' {
                    string.push(self.ch());
                    self.skip();
                } else if directive && string != "!" {
                    // It's either the '!' tag or not really a tag handle.  If it's a %TAG
                    // directive, it's an error.  If it's a tag token, it must be a part of
                    // URI.
                    return Err(ScanError::new(*mark,
                        "while parsing a tag directive, did not find expected '!'"));
                }
                Ok(string)
            }
        
            fn scan_tag_uri(&mut self, directive: bool, _is_secondary: bool,
                        head: &str, mark: &Marker) -> Result<String, ScanError> {
                let mut length = head.len();
                let mut string = String::new();
        
                // Copy the head if needed.
                // Note that we don't copy the leading '!' character.
                if length > 1 {
                    string.extend(head.chars().skip(1));
                }
        
                self.lookahead(1);
                /*
                 * The set of characters that may appear in URI is as follows:
                 *
                 *      '0'-'9', 'A'-'Z', 'a'-'z', '_', '-', ';', '/', '?', ':', '@', '&',
                 *      '=', '+', '$', ',', '.', '!', '~', '*', '\'', '(', ')', '[', ']',
                 *      '%'.
                 */
                while match self.ch() {
                    ';' | '/' | '?' | ':' | '@' | '&' => true,
                    '=' | '+' | '$' | ',' | '.' | '!' | '~' | '*' | '\'' | '(' | ')' | '[' | ']' => true,
                    '%' => true,
                    c if is_alpha(c) => true,
                    _ => false
                } {
                    // Check if it is a URI-escape sequence.
                    if self.ch() == '%' {
                        string.push(try!(self.scan_uri_escapes(directive, mark)));
                    } else {
                        string.push(self.ch());
                        self.skip();
                    }
        
                    length += 1;
                    self.lookahead(1);
                }
        
                if length == 0 {
                    return Err(ScanError::new(*mark,
                        "while parsing a tag, did not find expected tag URI"));
                }
        
                Ok(string)
            }
        
            fn scan_uri_escapes(&mut self, _directive: bool, mark: &Marker)
                -> Result<char, ScanError> {
                let mut width = 0usize;
                let mut code = 0u32;
                loop {
                    self.lookahead(3);
        
                    if !(self.ch() == '%'
                         && is_hex(self.buffer[1])
                         && is_hex(self.buffer[2])) {
                        return Err(ScanError::new(*mark,
                            "while parsing a tag, did not find URI escaped octet"));
                    }
        
                    let octet = (as_hex(self.buffer[1]) << 4) + as_hex(self.buffer[2]);
                    if width == 0 {
                        width = match octet {
                            _ if octet & 0x80 == 0x00 => 1,
                            _ if octet & 0xE0 == 0xC0 => 2,
                            _ if octet & 0xF0 == 0xE0 => 3,
                            _ if octet & 0xF8 == 0xF0 => 4,
                            _ => {
                                return Err(ScanError::new(*mark,
                                    "while parsing a tag, found an incorrect leading UTF-8 octet"));
                            }
                        };
                        code = octet;
                    } else {
                        if octet & 0xc0 != 0x80 {
                                return Err(ScanError::new(*mark,
                                    "while parsing a tag, found an incorrect trailing UTF-8 octet"));
                        }
                        code = (code << 8) + octet;
                    }
        
                    self.skip();
                    self.skip();
                    self.skip();
        
                    width -= 1;
                    if width == 0 {
                        break;
                    }
                }
        
                match char::from_u32(code) {
                    Some(ch) => Ok(ch),
                    None => Err(ScanError::new(*mark,
                        "while parsing a tag, found an invalid UTF-8 codepoint"))
                }
            }
        
            fn fetch_anchor(&mut self, alias: bool) -> ScanResult {
                try!(self.save_simple_key());
                self.disallow_simple_key();
        
                let tok = try!(self.scan_anchor(alias));
        
                self.tokens.push_back(tok);
        
                Ok(())
            }
        
            fn scan_anchor(&mut self, alias: bool)
                -> Result<Token, ScanError> {
                let mut string = String::new();
                let start_mark = self.mark;
        
                self.skip();
                self.lookahead(1);
                while is_alpha(self.ch()) {
                    string.push(self.ch());
                    self.skip();
                    self.lookahead(1);
                }
        
                if string.is_empty()
                    || match self.ch() {
                        c if is_blankz(c) => false,
                        '?' | ':' | ',' | ']' | '}' | '%' | '@' | '`' => false,
                        _ => true
                    } {
                    return Err(ScanError::new(start_mark, "while scanning an anchor or alias, did not find expected alphabetic or numeric character"));
                }
        
                if alias {
                    Ok(Token(start_mark, TokenType::Alias(string)))
                } else {
                    Ok(Token(start_mark, TokenType::Anchor(string)))
                }
            }
        
            fn fetch_flow_collection_start(&mut self, tok :TokenType) -> ScanResult {
                // The indicators '[' and '{' may start a simple key.
                try!(self.save_simple_key());
        
                self.increase_flow_level();
        
                self.allow_simple_key();
        
                let start_mark = self.mark;
                self.skip();
        
                self.tokens.push_back(Token(start_mark, tok));
                Ok(())
            }
        
            fn fetch_flow_collection_end(&mut self, tok :TokenType) -> ScanResult {
                try!(self.remove_simple_key());
                self.decrease_flow_level();
        
                self.disallow_simple_key();
        
                let start_mark = self.mark;
                self.skip();
        
                self.tokens.push_back(Token(start_mark, tok));
                Ok(())
            }
        
            fn fetch_flow_entry(&mut self) -> ScanResult {
                try!(self.remove_simple_key());
                self.allow_simple_key();
        
                let start_mark = self.mark;
                self.skip();
        
                self.tokens.push_back(Token(start_mark, TokenType::FlowEntry));
                Ok(())
            }
        
            fn increase_flow_level(&mut self) {
                self.simple_keys.push(SimpleKey::new(Marker::new(0,0,0)));
                self.flow_level += 1;
            }
            fn decrease_flow_level(&mut self) {
                if self.flow_level > 0 {
                    self.flow_level -= 1;
                    self.simple_keys.pop().unwrap();
                }
            }
        
            fn fetch_block_entry(&mut self) -> ScanResult {
                if self.flow_level == 0 {
                    // Check if we are allowed to start a new entry.
                    if !self.simple_key_allowed {
                        return Err(ScanError::new(self.mark,
                                "block sequence entries are not allowed in this context"));
                    }
        
                    let mark = self.mark;
                    // generate BLOCK-SEQUENCE-START if indented
                    self.roll_indent(mark.col, None, TokenType::BlockSequenceStart, mark);
                } else {
                    // - * only allowed in block
                    return Err(ScanError::new(self.mark, r#""-" is only valid inside a block"#))
                }
                try!(self.remove_simple_key());
                self.allow_simple_key();
        
                let start_mark = self.mark;
                self.skip();
        
                self.tokens.push_back(Token(start_mark, TokenType::BlockEntry));
                Ok(())
            }
        
            fn fetch_document_indicator(&mut self, t: TokenType) -> ScanResult {
                self.unroll_indent(-1);
                try!(self.remove_simple_key());
                self.disallow_simple_key();
        
                let mark = self.mark;
        
                self.skip();
                self.skip();
                self.skip();
        
                self.tokens.push_back(Token(mark, t));
                Ok(())
            }
        
            fn fetch_block_scalar(&mut self, literal: bool) -> ScanResult {
                try!(self.save_simple_key());
                self.allow_simple_key();
                let tok = try!(self.scan_block_scalar(literal));
        
                self.tokens.push_back(tok);
                Ok(())
            }
        
            fn scan_block_scalar(&mut self, literal: bool) -> Result<Token, ScanError> {
                let start_mark = self.mark;
                let mut chomping: i32 = 0;
                let mut increment: usize = 0;
                let mut indent: usize = 0;
                let mut trailing_blank: bool;
                let mut leading_blank: bool = false;
        
                let mut string = String::new();
                let mut leading_break = String::new();
                let mut trailing_breaks = String::new();
        
                // skip '|' or '>'
                self.skip();
                self.lookahead(1);
        
                if self.ch() == '+' || self.ch() == '-' {
                    if self.ch() == '+' {
                        chomping = 1;
                    } else {
                        chomping = -1;
                    }
                    self.skip();
                    self.lookahead(1);
                    if is_digit(self.ch()) {
                        if self.ch() == '0' {
                            return Err(ScanError::new(start_mark,
                                    "while scanning a block scalar, found an intendation indicator equal to 0"));
                        }
                        increment = (self.ch() as usize) - ('0' as usize);
                        self.skip();
                    }
                } else if is_digit(self.ch()) {
                    if self.ch() == '0' {
                        return Err(ScanError::new(start_mark,
                                 "while scanning a block scalar, found an intendation indicator equal to 0"));
                    }
        
                    increment = (self.ch() as usize) - ('0' as usize);
                    self.skip();
                    self.lookahead(1);
                    if self.ch() == '+' || self.ch() == '-' {
                        if self.ch() == '+' {
                            chomping = 1;
                        } else {
                            chomping = -1;
                        }
                        self.skip();
                    }
                }
        
                // Eat whitespaces and comments to the end of the line.
                self.lookahead(1);
        
                while is_blank(self.ch()) {
                    self.skip();
                    self.lookahead(1);
                }
        
                if self.ch() == '#' {
                    while !is_breakz(self.ch()) {
                        self.skip();
                        self.lookahead(1);
                    }
                }
        
                // Check if we are at the end of the line.
                if !is_breakz(self.ch()) {
                    return Err(ScanError::new(start_mark,
                            "while scanning a block scalar, did not find expected comment or line break"));
                }
        
                if is_break(self.ch()) {
                    self.lookahead(2);
                    self.skip_line();
                }
        
                if increment > 0 {
                    indent = if self.indent >= 0 { (self.indent + increment as isize) as usize } else { increment }
                }
                // Scan the leading line breaks and determine the indentation level if needed.
                try!(self.block_scalar_breaks(&mut indent, &mut trailing_breaks));
        
                self.lookahead(1);
        
                let start_mark = self.mark;
        
                while self.mark.col == indent && !is_z(self.ch()) {
                    // We are at the beginning of a non-empty line.
                    trailing_blank = is_blank(self.ch());
                    if !literal && !leading_break.is_empty()
                        && !leading_blank && !trailing_blank {
                            if trailing_breaks.is_empty() {
                                string.push(' ');
                            }
                            leading_break.clear();
                    } else {
                        string.push_str(&leading_break);
                        leading_break.clear();
                    }
        
                    string.push_str(&trailing_breaks);
                    trailing_breaks.clear();
        
                    leading_blank = is_blank(self.ch());
        
                    while !is_breakz(self.ch()) {
                        string.push(self.ch());
                        self.skip();
                        self.lookahead(1);
                    }
                    // break on EOF
                    if is_z(self.ch()) { break; }
        
                    self.lookahead(2);
                    self.read_break(&mut leading_break);
        
                    // Eat the following intendation spaces and line breaks.
                    try!(self.block_scalar_breaks(&mut indent, &mut trailing_breaks));
                }
        
                // Chomp the tail.
                if chomping != -1 {
                    string.push_str(&leading_break);
                }
        
                if chomping == 1 {
                    string.push_str(&trailing_breaks);
                }
        
                if literal {
                    Ok(Token(start_mark, TokenType::Scalar(TScalarStyle::Literal, string)))
                } else {
                    Ok(Token(start_mark, TokenType::Scalar(TScalarStyle::Foled, string)))
                }
            }
        
            fn block_scalar_breaks(&mut self, indent: &mut usize, breaks: &mut String) -> ScanResult {
                let mut max_indent = 0;
                loop {
                    self.lookahead(1);
                    while (*indent == 0 || self.mark.col < *indent)
                        && self.buffer[0] == ' ' {
                            self.skip();
                            self.lookahead(1);
                    }
        
                    if self.mark.col > max_indent {
                        max_indent = self.mark.col;
                    }
        
                    // Check for a tab character messing the intendation.
                    if (*indent == 0 || self.mark.col < *indent)
                        && self.buffer[0] == '\t' {
                        return Err(ScanError::new(self.mark,
                                "while scanning a block scalar, found a tab character where an intendation space is expected"));
                    }
        
                    if !is_break(self.ch()) {
                        break;
                    }
        
                    self.lookahead(2);
                    // Consume the line break.
                    self.read_break(breaks);
                }
        
                if *indent == 0 {
                    *indent = max_indent;
                    if *indent < (self.indent + 1) as usize {
                        *indent = (self.indent + 1) as usize;
                    }
                    if *indent < 1 {
                        *indent = 1;
                    }
                }
                Ok(())
            }
        
            fn fetch_flow_scalar(&mut self, single: bool) -> ScanResult {
                try!(self.save_simple_key());
                self.disallow_simple_key();
        
                let tok = try!(self.scan_flow_scalar(single));
        
                self.tokens.push_back(tok);
                Ok(())
            }
        
            fn scan_flow_scalar(&mut self, single: bool) -> Result<Token, ScanError> {
                let start_mark = self.mark;
        
                let mut string = String::new();
                let mut leading_break = String::new();
                let mut trailing_breaks = String::new();
                let mut whitespaces = String::new();
                let mut leading_blanks;
        
                /* Eat the left quote. */
                self.skip();
        
                loop {
                    /* Check for a document indicator. */
                    self.lookahead(4);
        
                    if self.mark.col == 0 &&
                        (((self.buffer[0] == '-') &&
                        (self.buffer[1] == '-') &&
                        (self.buffer[2] == '-')) ||
                        ((self.buffer[0] == '.') &&
                        (self.buffer[1] == '.') &&
                        (self.buffer[2] == '.'))) &&
                        is_blankz(self.buffer[3]) {
                            return Err(ScanError::new(start_mark,
                                "while scanning a quoted scalar, found unexpected document indicator"));
                        }
        
                    if is_z(self.ch()) {
                            return Err(ScanError::new(start_mark,
                                "while scanning a quoted scalar, found unexpected end of stream"));
                    }
        
                    self.lookahead(2);
        
                    leading_blanks = false;
                    // Consume non-blank characters.
        
                    while !is_blankz(self.ch()) {
                        match self.ch() {
                            // Check for an escaped single quote.
                            '\'' if self.buffer[1] == '\'' && single => {
                                string.push('\'');
                                self.skip();
                                self.skip();
                            },
                            // Check for the right quote.
                            '\'' if single => { break; },
                            '"' if !single => { break; },
                            // Check for an escaped line break.
                            '\\' if !single && is_break(self.buffer[1]) => {
                                self.lookahead(3);
                                self.skip();
                                self.skip_line();
                                leading_blanks = true;
                                break;
                            }
                            // Check for an escape sequence.
                            '\\' if !single => {
                                let mut code_length = 0usize;
                                match self.buffer[1] {
                                    '0' => string.push('\0'),
                                    'a' => string.push('\x07'),
                                    'b' => string.push('\x08'),
                                    't' | '\t' => string.push('\t'),
                                    'n' => string.push('\n'),
                                    'v' => string.push('\x0b'),
                                    'f' => string.push('\x0c'),
                                    'r' => string.push('\x0d'),
                                    'e' => string.push('\x1b'),
                                    ' ' => string.push('\x20'),
                                    '"' => string.push('"'),
                                    '\'' => string.push('\''),
                                    '\\' => string.push('\\'),
                                    // NEL (#x85)
                                    'N' => string.push(char::from_u32(0x85).unwrap()),
                                    // #xA0
                                    '_' => string.push(char::from_u32(0xA0).unwrap()),
                                    // LS (#x2028)
                                    'L' => string.push(char::from_u32(0x2028).unwrap()),
                                    // PS (#x2029)
                                    'P' => string.push(char::from_u32(0x2029).unwrap()),
                                    'x' => code_length = 2,
                                    'u' => code_length = 4,
                                    'U' => code_length = 8,
                                    _ => return Err(ScanError::new(start_mark,
                                            "while parsing a quoted scalar, found unknown escape character"))
                                }
                                self.skip();
                                self.skip();
                                // Consume an arbitrary escape code.
                                if code_length > 0 {
                                    self.lookahead(code_length);
                                    let mut value = 0u32;
                                    for i in 0..code_length {
                                        if !is_hex(self.buffer[i]) {
                                            return Err(ScanError::new(start_mark,
                                                "while parsing a quoted scalar, did not find expected hexdecimal number"));
                                        }
                                        value = (value << 4) + as_hex(self.buffer[i]);
                                    }
        
                                    let ch = match char::from_u32(value) {
                                        Some(v) => v,
                                        None => {
                                            return Err(ScanError::new(start_mark,
                                                "while parsing a quoted scalar, found invalid Unicode character escape code"));
                                        }
                                    };
                                    string.push(ch);
        
                                    for _ in 0..code_length {
                                        self.skip();
                                    }
                                }
                            },
                            c => { string.push(c); self.skip(); }
                        }
                        self.lookahead(2);
                    }
                    self.lookahead(1);
                    match self.ch() {
                        '\'' if single => { break; },
                        '"' if !single => { break; },
                        _ => {}
                    }
        
                    // Consume blank characters.
                    while is_blank(self.ch()) || is_break(self.ch()) {
                        if is_blank(self.ch()) {
                            // Consume a space or a tab character.
                            if leading_blanks {
                                self.skip();
                            } else {
                                whitespaces.push(self.ch());
                                self.skip();
                            }
                        } else {
                            self.lookahead(2);
                            // Check if it is a first line break.
                            if leading_blanks {
                                self.read_break(&mut trailing_breaks);
                            } else {
                                whitespaces.clear();
                                self.read_break(&mut leading_break);
                                leading_blanks = true;
                            }
                        }
                        self.lookahead(1);
                    }
                    // Join the whitespaces or fold line breaks.
                    if leading_blanks {
                        if leading_break.is_empty() {
                            string.push_str(&leading_break);
                            string.push_str(&trailing_breaks);
                            trailing_breaks.clear();
                            leading_break.clear();
                        } else {
                            if trailing_breaks.is_empty() {
                                string.push(' ');
                            } else {
                                string.push_str(&trailing_breaks);
                                trailing_breaks.clear();
                            }
                            leading_break.clear();
                        }
                    } else {
                        string.push_str(&whitespaces);
                        whitespaces.clear();
                    }
                } // loop
        
                // Eat the right quote.
                self.skip();
        
                if single {
                    Ok(Token(start_mark, TokenType::Scalar(TScalarStyle::SingleQuoted, string)))
                } else {
                    Ok(Token(start_mark, TokenType::Scalar(TScalarStyle::DoubleQuoted, string)))
                }
            }
        
            fn fetch_plain_scalar(&mut self) -> ScanResult {
                try!(self.save_simple_key());
                self.disallow_simple_key();
        
                let tok = try!(self.scan_plain_scalar());
        
                self.tokens.push_back(tok);
                Ok(())
            }
        
            fn scan_plain_scalar(&mut self) -> Result<Token, ScanError> {
                let indent = self.indent + 1;
                let start_mark = self.mark;
        
                let mut string = String::new();
                let mut leading_break = String::new();
                let mut trailing_breaks = String::new();
                let mut whitespaces = String::new();
                let mut leading_blanks = false;
        
                loop {
                    /* Check for a document indicator. */
                    self.lookahead(4);
        
                    if self.mark.col == 0 &&
                        (((self.buffer[0] == '-') &&
                         (self.buffer[1] == '-') &&
                         (self.buffer[2] == '-')) ||
                            ((self.buffer[0] == '.') &&
                             (self.buffer[1] == '.') &&
                             (self.buffer[2] == '.'))) &&
                            is_blankz(self.buffer[3]) {
                                break;
                            }
        
                    if self.ch() == '#' { break; }
                    while !is_blankz(self.ch()) {
                        if self.flow_level > 0 && self.ch() == ':'
                            && is_blankz(self.ch()) {
                                return Err(ScanError::new(start_mark,
                                                          "while scanning a plain scalar, found unexpected ':'"));
                            }
                        // indicators ends a plain scalar
                        match self.ch() {
                            ':' if is_blankz(self.buffer[1]) => break,
                            ',' | ':' | '?' | '[' | ']' |'{' |'}' if self.flow_level > 0 => break,
                            _ => {}
                        }
        
                        if leading_blanks || !whitespaces.is_empty() {
                            if leading_blanks {
                                if leading_break.is_empty() {
                                    string.push_str(&leading_break);
                                    string.push_str(&trailing_breaks);
                                    trailing_breaks.clear();
                                    leading_break.clear();
                                } else {
                                    if trailing_breaks.is_empty() {
                                        string.push(' ');
                                    } else {
                                        string.push_str(&trailing_breaks);
                                        trailing_breaks.clear();
                                    }
                                    leading_break.clear();
        
                                }
                                leading_blanks = false;
                            } else {
                                string.push_str(&whitespaces);
                                whitespaces.clear();
                            }
                        }
        
                        string.push(self.ch());
                        self.skip();
                        self.lookahead(2);
                    }
                    // is the end?
                    if !(is_blank(self.ch()) || is_break(self.ch())) { break; }
                    self.lookahead(1);
        
                    while is_blank(self.ch()) || is_break(self.ch()) {
                        if is_blank(self.ch()) {
                            if leading_blanks && (self.mark.col as isize) < indent
                                && self.ch() == '\t' {
                                    return Err(ScanError::new(start_mark,
                                        "while scanning a plain scalar, found a tab"));
                            }
        
                            if leading_blanks {
                                self.skip();
                            } else {
                                whitespaces.push(self.ch());
                                self.skip();
                            }
                        } else {
                            self.lookahead(2);
                            // Check if it is a first line break
                            if leading_blanks {
                                self.read_break(&mut trailing_breaks);
                            } else {
                                whitespaces.clear();
                                self.read_break(&mut leading_break);
                                leading_blanks = true;
                            }
                        }
                        self.lookahead(1);
                    }
        
                    // check intendation level
                    if self.flow_level == 0 && (self.mark.col as isize) < indent {
                        break;
                    }
                }
        
                if leading_blanks {
                    self.allow_simple_key();
                }
        
                Ok(Token(start_mark, TokenType::Scalar(TScalarStyle::Plain, string)))
            }
        
            fn fetch_key(&mut self) -> ScanResult {
                let start_mark = self.mark;
                if self.flow_level == 0 {
                    // Check if we are allowed to start a new key (not nessesary simple).
                    if !self.simple_key_allowed {
                        return Err(ScanError::new(self.mark, "mapping keys are not allowed in this context"));
                    }
                    self.roll_indent(start_mark.col, None,
                        TokenType::BlockMappingStart, start_mark);
                }
        
                try!(self.remove_simple_key());
        
                if self.flow_level == 0 {
                    self.allow_simple_key();
                } else {
                    self.disallow_simple_key();
                }
        
                self.skip();
                self.tokens.push_back(Token(start_mark, TokenType::Key));
                Ok(())
            }
        
            fn fetch_value(&mut self) -> ScanResult {
                let sk = self.simple_keys.last().unwrap().clone();
                let start_mark = self.mark;
                if sk.possible {
                    // insert simple key
                    let tok = Token(sk.mark, TokenType::Key);
                    let tokens_parsed = self.tokens_parsed;
                    self.insert_token(sk.token_number - tokens_parsed, tok);
        
                    // Add the BLOCK-MAPPING-START token if needed.
                    self.roll_indent(sk.mark.col, Some(sk.token_number),
                        TokenType::BlockMappingStart, start_mark);
        
                    self.simple_keys.last_mut().unwrap().possible = false;
                    self.disallow_simple_key();
                } else {
                    // The ':' indicator follows a complex key.
                    if self.flow_level == 0 {
                        if !self.simple_key_allowed {
                            return Err(ScanError::new(start_mark,
                                "mapping values are not allowed in this context"));
                        }
        
                        self.roll_indent(start_mark.col, None,
                            TokenType::BlockMappingStart, start_mark);
                    }
        
                    if self.flow_level == 0 {
                        self.allow_simple_key();
                    } else {
                        self.disallow_simple_key();
                    }
                }
                self.skip();
                self.tokens.push_back(Token(start_mark, TokenType::Value));
        
                Ok(())
            }
        
            fn roll_indent(&mut self, col: usize, number: Option<usize>,
                           tok: TokenType, mark: Marker) {
                if self.flow_level > 0 {
                    return;
                }
        
                if self.indent < col as isize {
                    self.indents.push(self.indent);
                    self.indent = col as isize;
                    let tokens_parsed = self.tokens_parsed;
                    match number {
                        Some(n) => self.insert_token(n - tokens_parsed, Token(mark, tok)),
                        None => self.tokens.push_back(Token(mark, tok))
                    }
                }
            }
        
            fn unroll_indent(&mut self, col: isize) {
                if self.flow_level > 0 {
                    return;
                }
                while self.indent > col {
                    self.tokens.push_back(Token(self.mark, TokenType::BlockEnd));
                    self.indent = self.indents.pop().unwrap();
                }
            }
        
            fn save_simple_key(&mut self) -> Result<(), ScanError> {
                let required = self.flow_level > 0 && self.indent == (self.mark.col as isize);
                if self.simple_key_allowed {
                    let mut sk = SimpleKey::new(self.mark);
                    sk.possible = true;
                    sk.required = required;
                    sk.token_number = self.tokens_parsed + self.tokens.len();
        
                    try!(self.remove_simple_key());
        
                    self.simple_keys.pop();
                    self.simple_keys.push(sk);
                }
                Ok(())
            }
        
            fn remove_simple_key(&mut self) -> ScanResult {
                let last = self.simple_keys.last_mut().unwrap();
                if last.possible && last.required {
                    return Err(ScanError::new(self.mark, "simple key expected"));
                }
        
                last.possible = false;
                Ok(())
            }
        
        }
    }
    
    pub mod parser
    {
        use ::
        {
            *,
        };
        /*
        use scanner::*;
        use ::collections::HashMap;
        */
        #[derive(Clone, Copy, PartialEq, Debug, Eq)]
        enum State {
            StreamStart,
            ImplicitDocumentStart,
            DocumentStart,
            DocumentContent,
            DocumentEnd,
            BlockNode,
            // BlockNodeOrIndentlessSequence,
            // FlowNode,
            BlockSequenceFirstEntry,
            BlockSequenceEntry,
            IndentlessSequenceEntry,
            BlockMappingFirstKey,
            BlockMappingKey,
            BlockMappingValue,
            FlowSequenceFirstEntry,
            FlowSequenceEntry,
            FlowSequenceEntryMappingKey,
            FlowSequenceEntryMappingValue,
            FlowSequenceEntryMappingEnd,
            FlowMappingFirstKey,
            FlowMappingKey,
            FlowMappingValue,
            FlowMappingEmptyValue,
            End
        }
        
        /// `Event` is used with the low-level event base parsing API,
        /// see `EventReceiver` trait.
        #[derive(Clone, PartialEq, Debug, Eq)]
        pub enum Event {
            /// Reserved for internal use
            Nothing,
            StreamStart,
            StreamEnd,
            DocumentStart,
            DocumentEnd,
            /// Refer to an anchor ID
            Alias(usize),
            /// Value, style, anchor_id, tag
            Scalar(String, TScalarStyle, usize, Option<TokenType>),
            /// Anchor ID
            SequenceStart(usize),
            SequenceEnd,
            /// Anchor ID
            MappingStart(usize),
            MappingEnd
        }
        
        impl Event {
            fn empty_scalar() -> Event {
                // a null scalar
                Event::Scalar("~".to_owned(), TScalarStyle::Plain, 0, None)
            }
        
            fn empty_scalar_with_anchor(anchor: usize, tag: Option<TokenType>) -> Event {
                Event::Scalar("".to_owned(), TScalarStyle::Plain, anchor, tag)
            }
        }
        
        #[derive(Debug)]
        pub struct Parser<T> {
            scanner: Scanner<T>,
            states: Vec<State>,
            state: State,
            marks: Vec<Marker>,
            token: Option<Token>,
            current: Option<(Event, Marker)>,
            anchors: HashMap<String, usize>,
            anchor_id: usize,
        }
        
        
        pub trait EventReceiver {
            fn on_event(&mut self, ev: Event);
        }
        
        
        pub trait MarkedEventReceiver {
            fn on_event(&mut self, ev: Event, _mark: Marker);
        }
        
        impl<R: EventReceiver> MarkedEventReceiver for R {
            fn on_event(&mut self, ev: Event, _mark: Marker) {
                self.on_event(ev)
            }
        }
        
        pub type ParseResult = Result<(Event, Marker), ScanError>;
        
        impl<T: Iterator<Item=char>> Parser<T> {
            pub fn new(src: T) -> Parser<T> {
                Parser {
                    scanner: Scanner::new(src),
                    states: Vec::new(),
                    state: State::StreamStart,
                    marks: Vec::new(),
                    token: None,
                    current: None,
        
                    anchors: HashMap::new(),
                    // valid anchor_id starts from 1
                    anchor_id: 1,
                }
            }
        
            pub fn peek(&mut self) -> Result<&(Event, Marker), ScanError> {
                match self.current {
                    Some(ref x) => Ok(x),
                    None => {
                        self.current = Some(try!(self.next()));
                        self.peek()
                    }
                }
            }
        
            pub fn next(&mut self) -> ParseResult {
                match self.current {
                    None => self.parse(),
                    Some(_) => {
                        Ok(self.current.take().unwrap())
                    }
                }
            }
        
            fn peek_token(&mut self) -> Result<&Token, ScanError> {
                match self.token {
                    None =>  {
                        self.token = Some(try!(self.scan_next_token()));
                        Ok(self.token.as_ref().unwrap())
                    },
                    Some(ref tok) => Ok(tok)
                }
            }
        
            fn scan_next_token(&mut self) -> Result<Token, ScanError> {
                let token = self.scanner.next();
                match token {
                    None =>
                        match self.scanner.get_error() {
                            None => Err(ScanError::new(self.scanner.mark(), "unexpected eof")),
                            Some(e) => Err(e),
                        },
                    Some(tok) => Ok(tok)
                }
            }
        
            fn fetch_token(&mut self) -> Token {
                self.token.take().expect("fetch_token needs to be preceded by peek_token")
            }
        
        
            fn skip(&mut self) {
                self.token = None;
                //self.peek_token();
            }
            fn pop_state(&mut self) {
                self.state = self.states.pop().unwrap()
            }
            fn push_state(&mut self, state: State) {
                self.states.push(state);
            }
        
            fn parse(&mut self) -> ParseResult {
                if self.state == State::End {
                    return Ok((Event::StreamEnd, self.scanner.mark()));
                }
                let (ev, mark) = try!(self.state_machine());
                // println!("EV {:?}", ev);
                Ok((ev, mark))
            }
        
            pub fn load<R: MarkedEventReceiver>(&mut self, recv: &mut R, multi: bool)
                -> Result<(), ScanError> {
                if !self.scanner.stream_started() {
                    let (ev, mark) = try!(self.next());
                    assert_eq!(ev, Event::StreamStart);
                    recv.on_event(ev, mark);
                }
        
                if self.scanner.stream_ended() {
                    // XXX has parsed?
                    recv.on_event(Event::StreamEnd, self.scanner.mark());
                    return Ok(());
                }
                loop {
                    let (ev, mark) = try!(self.next());
                    if ev == Event::StreamEnd {
                        recv.on_event(ev, mark);
                        return Ok(());
                    }
                    // clear anchors before a new document
                    self.anchors.clear();
                    try!(self.load_document(ev, mark, recv));
                    if !multi {
                        break;
                    }
                }
                Ok(())
            }
        
            fn load_document<R: MarkedEventReceiver>(&mut self, first_ev: Event, mark: Marker, recv: &mut R)
                -> Result<(), ScanError> {
                assert_eq!(first_ev, Event::DocumentStart);
                recv.on_event(first_ev, mark);
        
                let (ev, mark) = try!(self.next());
                try!(self.load_node(ev, mark, recv));
        
                // DOCUMENT-END is expected.
                let (ev, mark) = try!(self.next());
                assert_eq!(ev, Event::DocumentEnd);
                recv.on_event(ev, mark);
        
                Ok(())
            }
        
            fn load_node<R: MarkedEventReceiver>(&mut self, first_ev: Event, mark: Marker, recv: &mut R)
                -> Result<(), ScanError> {
                match first_ev {
                    Event::Alias(..) | Event::Scalar(..) => {
                        recv.on_event(first_ev, mark);
                        Ok(())
                    },
                    Event::SequenceStart(_) => {
                        recv.on_event(first_ev, mark);
                        self.load_sequence(recv)
                    },
                    Event::MappingStart(_) => {
                        recv.on_event(first_ev, mark);
                        self.load_mapping(recv)
                    },
                    _ => { println!("UNREACHABLE EVENT: {:?}", first_ev);
                        unreachable!(); }
                }
            }
        
            fn load_mapping<R: MarkedEventReceiver>(&mut self, recv: &mut R)
                -> Result<(), ScanError> {
                let (mut key_ev, mut key_mark) = try!(self.next());
                while key_ev != Event::MappingEnd {
                    // key
                    try!(self.load_node(key_ev, key_mark, recv));
        
                    // value
                    let (ev, mark) = try!(self.next());
                    try!(self.load_node(ev, mark, recv));
        
                    // next event
                    let (ev, mark) = try!(self.next());
                    key_ev = ev;
                    key_mark = mark;
        
                }
                recv.on_event(key_ev, key_mark);
                Ok(())
            }
        
            fn load_sequence<R: MarkedEventReceiver>(&mut self, recv: &mut R)
                -> Result<(), ScanError> {
                let (mut ev, mut mark) = try!(self.next());
                while ev != Event::SequenceEnd {
                    try!(self.load_node(ev, mark, recv));
        
                    // next event
                    let (next_ev, next_mark) = try!(self.next());
                    ev = next_ev;
                    mark = next_mark;
                }
                recv.on_event(ev, mark);
                Ok(())
            }
        
            fn state_machine(&mut self) -> ParseResult {
                // let next_tok = try!(self.peek_token());
                // println!("cur_state {:?}, next tok: {:?}", self.state, next_tok);
                match self.state {
                    State::StreamStart => self.stream_start(),
        
                    State::ImplicitDocumentStart => self.document_start(true),
                    State::DocumentStart => self.document_start(false),
                    State::DocumentContent => self.document_content(),
                    State::DocumentEnd => self.document_end(),
        
                    State::BlockNode => self.parse_node(true, false),
                    // State::BlockNodeOrIndentlessSequence => self.parse_node(true, true),
                    // State::FlowNode => self.parse_node(false, false),
        
                    State::BlockMappingFirstKey => self.block_mapping_key(true),
                    State::BlockMappingKey => self.block_mapping_key(false),
                    State::BlockMappingValue => self.block_mapping_value(),
        
                    State::BlockSequenceFirstEntry => self.block_sequence_entry(true),
                    State::BlockSequenceEntry => self.block_sequence_entry(false),
        
                    State::FlowSequenceFirstEntry => self.flow_sequence_entry(true),
                    State::FlowSequenceEntry => self.flow_sequence_entry(false),
        
                    State::FlowMappingFirstKey => self.flow_mapping_key(true),
                    State::FlowMappingKey => self.flow_mapping_key(false),
                    State::FlowMappingValue => self.flow_mapping_value(false),
        
                    State::IndentlessSequenceEntry => self.indentless_sequence_entry(),
        
                    State::FlowSequenceEntryMappingKey => self.flow_sequence_entry_mapping_key(),
                    State::FlowSequenceEntryMappingValue => self.flow_sequence_entry_mapping_value(),
                    State::FlowSequenceEntryMappingEnd => self.flow_sequence_entry_mapping_end(),
                    State::FlowMappingEmptyValue => self.flow_mapping_value(true),
        
                    /* impossible */
                    State::End => unreachable!(),
                }
            }
        
            fn stream_start(&mut self) -> ParseResult {
                match *try!(self.peek_token()) {
                    Token(mark, TokenType::StreamStart(_)) => {
                        self.state = State::ImplicitDocumentStart;
                        self.skip();
                        Ok((Event::StreamStart, mark))
                    },
                    Token(mark, _) => Err(ScanError::new(mark,
                        "did not find expected <stream-start>")),
                }
            }
        
            fn document_start(&mut self, implicit: bool) -> ParseResult {
                if !implicit {
                    while let TokenType::DocumentEnd = try!(self.peek_token()).1 {
                        self.skip();
                    }
                }
        
                match *try!(self.peek_token()) {
                    Token(mark, TokenType::StreamEnd) => {
                        self.state = State::End;
                        self.skip();
                        Ok((Event::StreamEnd, mark))
                    },
                    Token(_, TokenType::VersionDirective(..))
                    | Token(_, TokenType::TagDirective(..))
                    | Token(_, TokenType::DocumentStart) => {
                        // explicit document
                        self._explict_document_start()
                    },
                    Token(mark, _) if implicit => {
                        try!(self.parser_process_directives());
                        self.push_state(State::DocumentEnd);
                        self.state = State::BlockNode;
                        Ok((Event::DocumentStart, mark))
                    },
                    _ => {
                        // explicit document
                        self._explict_document_start()
                    }
                }
            }
        
            fn parser_process_directives(&mut self) -> Result<(), ScanError> {
                loop {
                    match try!(self.peek_token()).1 {
                        TokenType::VersionDirective(_, _) => {
                            // XXX parsing with warning according to spec
                            //if major != 1 || minor > 2 {
                            //    return Err(ScanError::new(tok.0,
                            //        "found incompatible YAML document"));
                            //}
                        },
                        TokenType::TagDirective(..) => {
                            // TODO add tag directive
                        },
                        _ => break
                    }
                    self.skip();
                }
                // TODO tag directive
                Ok(())
            }
        
            fn _explict_document_start(&mut self) -> ParseResult {
                try!(self.parser_process_directives());
                match *try!(self.peek_token()) {
                    Token(mark, TokenType::DocumentStart) => {
                        self.push_state(State::DocumentEnd);
                        self.state = State::DocumentContent;
                        self.skip();
                        Ok((Event::DocumentStart, mark))
                    }    
                    Token(mark, _) => Err(ScanError::new(mark, "did not find expected <document start>"))
                }        
            }
        
            fn document_content(&mut self) -> ParseResult {
                match *try!(self.peek_token()) {
                    Token(mark, TokenType::VersionDirective(..))
                    | Token(mark, TokenType::TagDirective(..))
                    | Token(mark, TokenType::DocumentStart)
                    | Token(mark, TokenType::DocumentEnd)
                    | Token(mark, TokenType::StreamEnd) => {
                        self.pop_state();
                        // empty scalar
                        Ok((Event::empty_scalar(), mark))
                    },
                    _ => {
                        self.parse_node(true, false)
                    }
                }
            }
        
            fn document_end(&mut self) -> ParseResult {
                let mut _implicit = true;
                let marker: Marker = match *try!(self.peek_token()) {
                    Token(mark, TokenType::DocumentEnd) => {
                        self.skip();
                        _implicit = false;
                        mark
                    },
                    Token(mark, _) => mark
                };
                
                // TODO tag handling
                self.state = State::DocumentStart;
                Ok((Event::DocumentEnd, marker))
            }
        
            fn register_anchor(&mut self, name: String, _: &Marker) -> Result<usize, ScanError> {
                // anchors can be overrided/reused
                // if self.anchors.contains_key(name) {
                //     return Err(ScanError::new(*mark,
                //         "while parsing anchor, found duplicated anchor"));
                // }
                let new_id = self.anchor_id;
                self.anchor_id += 1;
                self.anchors.insert(name, new_id);
                Ok(new_id)
            }
        
            fn parse_node(&mut self, block: bool, indentless_sequence: bool) -> ParseResult {
                let mut anchor_id = 0;
                let mut tag = None;
                match *try!(self.peek_token()) {
                    Token(_, TokenType::Alias(_)) => {
                        self.pop_state();
                        if let Token(mark, TokenType::Alias(name)) = self.fetch_token() {
                            match self.anchors.get(&name) {
                                None => return Err(ScanError::new(mark, "while parsing node, found unknown anchor")),
                                Some(id) => return Ok((Event::Alias(*id), mark))
                            }
                        } else {
                            unreachable!()
                        }
                    },
                    Token(_, TokenType::Anchor(_)) => {
                        if let Token(mark, TokenType::Anchor(name)) = self.fetch_token() {
                            anchor_id = try!(self.register_anchor(name, &mark));
                            if let TokenType::Tag(..) = try!(self.peek_token()).1 {
                                if let tg @ TokenType::Tag(..) = self.fetch_token().1 {
                                    tag = Some(tg);
                                } else {
                                    unreachable!()
                                }
                            }
                        } else {
                            unreachable!()
                        }
                    },
                    Token(_, TokenType::Tag(..)) => {
                        if let tg @ TokenType::Tag(..) = self.fetch_token().1 {
                            tag = Some(tg);
                            if let TokenType::Anchor(_) = try!(self.peek_token()).1 {
                                if let Token(mark, TokenType::Anchor(name)) = self.fetch_token() {
                                    anchor_id = try!(self.register_anchor(name, &mark));
                                } else {
                                    unreachable!()
                                }
                            }
                        } else {
                            unreachable!()
                        }
                    },
                    _ => {}
                }
                match *try!(self.peek_token()) {
                    Token(mark, TokenType::BlockEntry) if indentless_sequence => {
                        self.state = State::IndentlessSequenceEntry;
                        Ok((Event::SequenceStart(anchor_id), mark))
                    },
                    Token(_, TokenType::Scalar(..)) => {
                        self.pop_state();
                        if let Token(mark, TokenType::Scalar(style, v)) = self.fetch_token() {
                            Ok((Event::Scalar(v, style, anchor_id, tag), mark))
                        } else {
                            unreachable!()
                        }
                    },
                    Token(mark, TokenType::FlowSequenceStart) => {
                        self.state = State::FlowSequenceFirstEntry;
                        Ok((Event::SequenceStart(anchor_id), mark))
                    },
                    Token(mark, TokenType::FlowMappingStart) => {
                        self.state = State::FlowMappingFirstKey;
                        Ok((Event::MappingStart(anchor_id), mark))
                    },
                    Token(mark, TokenType::BlockSequenceStart) if block => {
                        self.state = State::BlockSequenceFirstEntry;
                        Ok((Event::SequenceStart(anchor_id), mark))
                    },
                    Token(mark, TokenType::BlockMappingStart) if block => {
                        self.state = State::BlockMappingFirstKey;
                        Ok((Event::MappingStart(anchor_id), mark))
                    },
                    // ex 7.2, an empty scalar can follow a secondary tag
                    Token(mark, _) if tag.is_some() || anchor_id > 0 => {
                        self.pop_state();
                        Ok((Event::empty_scalar_with_anchor(anchor_id, tag), mark))
                    },
                    Token(mark, _) => { Err(ScanError::new(mark, "while parsing a node, did not find expected node content")) }
                }
            }
        
            fn block_mapping_key(&mut self, first: bool) -> ParseResult {
                // skip BlockMappingStart
                if first {
                    let _ = try!(self.peek_token());
                    //self.marks.push(tok.0);
                    self.skip();
                }
                match *try!(self.peek_token()) {
                    Token(_, TokenType::Key) => {
                        self.skip();
                        match *try!(self.peek_token()) {
                            Token(mark, TokenType::Key)
                            | Token(mark, TokenType::Value)
                            | Token(mark, TokenType::BlockEnd) => {
                                self.state = State::BlockMappingValue;
                                // empty scalar
                                Ok((Event::empty_scalar(), mark))
                            }
                            _ => {
                                self.push_state(State::BlockMappingValue);
                                self.parse_node(true, true)
                            }
                        }
                    },
                    // XXX(chenyh): libyaml failed to parse spec 1.2, ex8.18
                    Token(mark, TokenType::Value) => {
                        self.state = State::BlockMappingValue;
                        Ok((Event::empty_scalar(), mark))
                    },
                    Token(mark, TokenType::BlockEnd) => {
                        self.pop_state();
                        self.skip();
                        Ok((Event::MappingEnd, mark))
                    },
                    Token(mark, _) => {
                        Err(ScanError::new(mark, "while parsing a block mapping, did not find expected key"))
                    }
                }
            }
        
            fn block_mapping_value(&mut self) -> ParseResult {
                match *try!(self.peek_token()) {
                    Token(_, TokenType::Value) => {
                        self.skip();
                        match *try!(self.peek_token()) {
                            Token(mark, TokenType::Key)
                            | Token(mark, TokenType::Value)
                            | Token(mark, TokenType::BlockEnd) => {
                                self.state = State::BlockMappingKey;
                                // empty scalar
                                Ok((Event::empty_scalar(), mark))
                            },
                            _ => {
                                self.push_state(State::BlockMappingKey);
                                self.parse_node(true, true)
                            }
                        }
                    },
                    Token(mark, _) => {
                        self.state = State::BlockMappingKey;
                        // empty scalar
                        Ok((Event::empty_scalar(), mark))
                    }
                }
            }
        
            fn flow_mapping_key(&mut self, first: bool) -> ParseResult {
                if first {
                    let _ = try!(self.peek_token());
                    self.skip();
                }
                let marker: Marker = {
                    match *try!(self.peek_token()) {
                        Token(mark, TokenType::FlowMappingEnd) => mark,
                        Token(mark, _) => {
                            if !first {
                                match *try!(self.peek_token()) {
                                    Token(_, TokenType::FlowEntry) => self.skip(),
                                    Token(mark, _) => return Err(ScanError::new(mark,
                                        "while parsing a flow mapping, did not find expected ',' or '}'"))
                                }
                            }
        
                            match *try!(self.peek_token()) {
                                Token(_, TokenType::Key) => {
                                    self.skip();
                                    match *try!(self.peek_token()) {
                                        Token(mark, TokenType::Value)
                                        | Token(mark, TokenType::FlowEntry)
                                        | Token(mark, TokenType::FlowMappingEnd) => {
                                            self.state = State::FlowMappingValue;
                                            return Ok((Event::empty_scalar(), mark));
                                        },
                                        _ => {
                                            self.push_state(State::FlowMappingValue);
                                            return self.parse_node(false, false);
                                        }
                                    }
                                },
                                Token(marker, TokenType::Value) => {
                                    self.state = State::FlowMappingValue;
                                    return Ok((Event::empty_scalar(), marker));
                                },
                                Token(_, TokenType::FlowMappingEnd) => (),
                                _ => {
                                    self.push_state(State::FlowMappingEmptyValue);
                                    return self.parse_node(false, false);
                                }
                            }
        
                            mark
                        }
                    }
                };
        
                self.pop_state();
                self.skip();
                Ok((Event::MappingEnd, marker))
            }
        
            fn flow_mapping_value(&mut self, empty: bool) -> ParseResult {
                let mark: Marker = {
                    if empty {
                        let Token(mark, _) = *try!(self.peek_token());
                        self.state = State::FlowMappingKey;
                        return Ok((Event::empty_scalar(), mark));
                    } else {
                        match *try!(self.peek_token()) {
                            Token(marker, TokenType::Value) => {
                                self.skip();
                                match try!(self.peek_token()).1 {
                                    TokenType::FlowEntry
                                        | TokenType::FlowMappingEnd => { },
                                    _ => {
                                        self.push_state(State::FlowMappingKey);
                                        return self.parse_node(false, false);
                                    }
                                }
                                marker
                            },
                            Token(marker, _) => marker
                        }
                    }
                };
                
                self.state = State::FlowMappingKey;
                Ok((Event::empty_scalar(), mark))
            }
        
            fn flow_sequence_entry(&mut self, first: bool) -> ParseResult {
                // skip FlowMappingStart
                if first {
                    let _ = try!(self.peek_token());
                    //self.marks.push(tok.0);
                    self.skip();
                }
                match *try!(self.peek_token()) {
                    Token(mark, TokenType::FlowSequenceEnd) => {
                        self.pop_state();
                        self.skip();
                        return Ok((Event::SequenceEnd, mark));
                    },
                    Token(_, TokenType::FlowEntry) if !first => {
                        self.skip();
                    },
                    Token(mark, _) if !first => {
                        return Err(ScanError::new(mark,
                                "while parsing a flow sequence, expectd ',' or ']'"));
                    }
                    _ => { /* next */ }
                }
                match *try!(self.peek_token()) {
                    Token(mark, TokenType::FlowSequenceEnd) => {
                        self.pop_state();
                        self.skip();
                        Ok((Event::SequenceEnd, mark))
                    },
                    Token(mark, TokenType::Key) => {
                        self.state = State::FlowSequenceEntryMappingKey;
                        self.skip();
                        Ok((Event::MappingStart(0), mark))
                    }
                    _ => {
                        self.push_state(State::FlowSequenceEntry);
                        self.parse_node(false, false)
                    }
                }
            }
        
            fn indentless_sequence_entry(&mut self) -> ParseResult {
                match *try!(self.peek_token()) {
                    Token(_, TokenType::BlockEntry) => (),
                    Token(mark, _) => {
                        self.pop_state();
                        return Ok((Event::SequenceEnd, mark));
                    }
                }
                self.skip();
                match *try!(self.peek_token()) {
                    Token(mark, TokenType::BlockEntry)
                    | Token(mark, TokenType::Key)
                    | Token(mark, TokenType::Value)
                    | Token(mark, TokenType::BlockEnd) => {
                        self.state = State::IndentlessSequenceEntry;
                        Ok((Event::empty_scalar(), mark))
                    },
                    _ => {
                        self.push_state(State::IndentlessSequenceEntry);
                        self.parse_node(true, false)
                    }
                }
            }
        
            fn block_sequence_entry(&mut self, first: bool) -> ParseResult {
                // BLOCK-SEQUENCE-START
                if first {
                    let _ = try!(self.peek_token());
                    //self.marks.push(tok.0);
                    self.skip();
                }
                match *try!(self.peek_token()) {
                    Token(mark, TokenType::BlockEnd) => {
                        self.pop_state();
                        self.skip();
                        Ok((Event::SequenceEnd, mark))
                    },
                    Token(_, TokenType::BlockEntry) => {
                        self.skip();
                        match *try!(self.peek_token()) {
                            Token(mark, TokenType::BlockEntry)
                            | Token(mark, TokenType::BlockEnd) => {
                                self.state = State::BlockSequenceEntry;
                                Ok((Event::empty_scalar(), mark))
                            },
                            _ => {
                                self.push_state(State::BlockSequenceEntry);
                                self.parse_node(true, false)
                            }
                        }
                    },
                    Token(mark, _) => {
                        Err(ScanError::new(mark,
                                "while parsing a block collection, did not find expected '-' indicator"))
                    }
                }
            }
        
            fn flow_sequence_entry_mapping_key(&mut self) -> ParseResult {
                match *try!(self.peek_token()) {
                    Token(mark, TokenType::Value)
                    | Token(mark, TokenType::FlowEntry)
                    | Token(mark, TokenType::FlowSequenceEnd) => {
                        self.skip();
                        self.state = State::FlowSequenceEntryMappingValue;
                        Ok((Event::empty_scalar(), mark))
                    },
                    _ => {
                        self.push_state(State::FlowSequenceEntryMappingValue);
                        self.parse_node(false, false)
                    }
                }
            }
        
            fn flow_sequence_entry_mapping_value(&mut self) -> ParseResult {
                match *try!(self.peek_token()) {
                    Token(_, TokenType::Value) => {
                            self.skip();
                            self.state = State::FlowSequenceEntryMappingValue;
                            match *try!(self.peek_token()) {
                                Token(mark, TokenType::FlowEntry)
                                | Token(mark, TokenType::FlowSequenceEnd) => {
                                    self.state = State::FlowSequenceEntryMappingEnd;
                                    Ok((Event::empty_scalar(), mark))
                                },
                                _ => {
                                    self.push_state(State::FlowSequenceEntryMappingEnd);
                                    self.parse_node(false, false)
                                }
                            }
                    },
                    Token(mark, _) => {
                        self.state = State::FlowSequenceEntryMappingEnd;
                        Ok((Event::empty_scalar(), mark))
                    }
                }
            }
        
            fn flow_sequence_entry_mapping_end(&mut self) -> ParseResult {
                self.state = State::FlowSequenceEntry;
                Ok((Event::MappingEnd, self.scanner.mark()))
            }
        }
    }
    
    pub mod emitter
    {
        use ::
        {
            *,
        };
        /*
        use ::fmt::{self, Display};
        use ::convert::From;
        use ::error::Error;
        use yaml::{Hash, Yaml};
        */
        #[derive(Copy, Clone, Debug)]
        pub enum EmitError {
                FmtError(fmt::Error),
                BadHashmapKey,
        }
        
        impl Error for EmitError {
            fn description(&self) -> &str {
                match *self {
                    EmitError::FmtError(ref err) => err.description(),
                    EmitError::BadHashmapKey => "bad hashmap key",
                }
            }
        
            fn cause(&self) -> Option<&Error> {
                None
            }
        }
        
        impl Display for EmitError {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                match *self {
                    EmitError::FmtError(ref err) => Display::fmt(err, formatter),
                    EmitError::BadHashmapKey => formatter.write_str("bad hashmap key"),
                }
            }
        }
        
        impl From<fmt::Error> for EmitError {
            fn from(f: fmt::Error) -> Self {
                EmitError::FmtError(f)
            }
        }
        
        pub struct YamlEmitter<'a> {
            writer: &'a mut fmt::Write,
            best_indent: usize,
            compact: bool,
        
            level: isize,
        }
        
        pub type EmitResult = Result<(), EmitError>;
        
        // from serialize::json
        fn escape_str(wr: &mut fmt::Write, v: &str) -> Result<(), fmt::Error> {
            try!(wr.write_str("\""));
        
            let mut start = 0;
        
            for (i, byte) in v.bytes().enumerate() {
                let escaped = match byte {
                    b'"' => "\\\"",
                    b'\\' => "\\\\",
                    b'\x00' => "\\u0000",
                    b'\x01' => "\\u0001",
                    b'\x02' => "\\u0002",
                    b'\x03' => "\\u0003",
                    b'\x04' => "\\u0004",
                    b'\x05' => "\\u0005",
                    b'\x06' => "\\u0006",
                    b'\x07' => "\\u0007",
                    b'\x08' => "\\b",
                    b'\t' => "\\t",
                    b'\n' => "\\n",
                    b'\x0b' => "\\u000b",
                    b'\x0c' => "\\f",
                    b'\r' => "\\r",
                    b'\x0e' => "\\u000e",
                    b'\x0f' => "\\u000f",
                    b'\x10' => "\\u0010",
                    b'\x11' => "\\u0011",
                    b'\x12' => "\\u0012",
                    b'\x13' => "\\u0013",
                    b'\x14' => "\\u0014",
                    b'\x15' => "\\u0015",
                    b'\x16' => "\\u0016",
                    b'\x17' => "\\u0017",
                    b'\x18' => "\\u0018",
                    b'\x19' => "\\u0019",
                    b'\x1a' => "\\u001a",
                    b'\x1b' => "\\u001b",
                    b'\x1c' => "\\u001c",
                    b'\x1d' => "\\u001d",
                    b'\x1e' => "\\u001e",
                    b'\x1f' => "\\u001f",
                    b'\x7f' => "\\u007f",
                    _ => { continue; }
                };
        
                if start < i {
                    try!(wr.write_str(&v[start..i]));
                }
        
                try!(wr.write_str(escaped));
        
                start = i + 1;
            }
        
            if start != v.len() {
                try!(wr.write_str(&v[start..]));
            }
        
            try!(wr.write_str("\""));
            Ok(())
        }
        
        impl<'a> YamlEmitter<'a> {
            pub fn new(writer: &'a mut fmt::Write) -> YamlEmitter {
                YamlEmitter {
                    writer: writer,
                    best_indent: 2,
                    compact: true,
        
                    level: -1
                }
            }
        
            /// Set 'compact inline notation' on or off, as described for block
            /// [sequences](http://www.yaml.org/spec/1.2/spec.html#id2797382)
            /// and
            /// [mappings](http://www.yaml.org/spec/1.2/spec.html#id2798057).
            ///
            /// In this form, blocks cannot have any properties (such as anchors
            /// or tags), which should be OK, because this emitter doesn't
            /// (currently) emit those anyways.
            pub fn compact(&mut self, compact: bool) {
              self.compact = compact;
            }
        
            /// Determine if this emitter is using 'compact inline notation'.
            pub fn is_compact(&self) -> bool {
              self.compact
            }
        
            pub fn dump(&mut self, doc: &Yaml) -> EmitResult {
                // write DocumentStart
                try!(write!(self.writer, "---\n"));
                self.level = -1;
                self.emit_node(doc)
            }
        
            fn write_indent(&mut self) -> EmitResult {
                if self.level <= 0 { return Ok(()); }
                for _ in 0..self.level {
                    for _ in 0..self.best_indent {
                        try!(write!(self.writer, " "));
                    }
                }
                Ok(())
            }
        
            fn emit_node(&mut self, node: &Yaml) -> EmitResult {
                match *node {
                    Yaml::Array(ref v) => self.emit_array(v),
                    Yaml::Hash(ref h) => self.emit_hash(h),
                    Yaml::String(ref v) => {
                        if need_quotes(v) {
                            try!(escape_str(self.writer, v));
                        }
                        else {
                            try!(write!(self.writer, "{}", v));
                        }
                        Ok(())
                    },
                    Yaml::Boolean(v) => {
                        if v {
                            try!(self.writer.write_str("true"));
                        } else {
                            try!(self.writer.write_str("false"));
                        }
                        Ok(())
                    },
                    Yaml::Integer(v) => {
                        try!(write!(self.writer, "{}", v));
                        Ok(())
                    },
                    Yaml::Real(ref v) => {
                        try!(write!(self.writer, "{}", v));
                        Ok(())
                    },
                    Yaml::Null | Yaml::BadValue => {
                        try!(write!(self.writer, "~"));
                        Ok(())
                    },
                    // XXX(chenyh) Alias
                    _ => { Ok(()) }
                }
            }
        
            fn emit_array(&mut self, v: &[Yaml]) -> EmitResult {
                if v.is_empty() {
                    try!(write!(self.writer, "[]"));
                } else {
                    self.level += 1;
                    for (cnt, x) in v.iter().enumerate() {
                        if cnt > 0 {
                            try!(write!(self.writer, "\n"));
                            try!(self.write_indent());
                        }
                        try!(write!(self.writer, "-"));
                        try!(self.emit_val(true, x));
                    }
                    self.level -= 1;
                }
                Ok(())
            }
        
            fn emit_hash(&mut self, h: &Hash) -> EmitResult {
                if h.is_empty() {
                    try!(self.writer.write_str("{}"));
                } else {
                    self.level += 1;
                    for (cnt, (k, v)) in h.iter().enumerate() {
                        let complex_key = match *k {
                          Yaml::Hash(_) | Yaml::Array(_) => true,
                          _ => false,
                        };
                        if cnt > 0 {
                            try!(write!(self.writer, "\n"));
                            try!(self.write_indent());
                        }
                        if complex_key {
                          try!(write!(self.writer, "?"));
                          try!(self.emit_val(true, k));
                          try!(write!(self.writer, "\n"));
                          try!(self.write_indent());
                          try!(write!(self.writer, ":"));
                          try!(self.emit_val(true, v));
                        } else {
                          try!(self.emit_node(k));
                          try!(write!(self.writer, ":"));
                          try!(self.emit_val(false, v));
                        }
                    }
                    self.level -= 1;
                }
                Ok(())
            }
        
            /// Emit a yaml as a hash or array value: i.e., which should appear
            /// following a ":" or "-", either after a space, or on a new line.
            /// If `inline` is true, then the preceeding characters are distinct
            /// and short enough to respect the compact flag.
            fn emit_val(&mut self, inline: bool, val: &Yaml) -> EmitResult {
                match *val {
                    Yaml::Array(ref v) => {
                        if (inline && self.compact) || v.is_empty() {
                            try!(write!(self.writer, " "));
                        } else {
                            try!(write!(self.writer, "\n"));
                            self.level += 1;
                            try!(self.write_indent());
                            self.level -= 1;
                        }
                        self.emit_array(v)
                    },
                    Yaml::Hash(ref h) => {
                        if (inline && self.compact) || h.is_empty() {
                            try!(write!(self.writer, " "));
                        } else {
                            try!(write!(self.writer, "\n"));
                            self.level += 1;
                            try!(self.write_indent());
                            self.level -= 1;
                        }
                        self.emit_hash(h)
                    },
                    _ => {
                        try!(write!(self.writer, " "));
                        self.emit_node(val)
                    }
                }
            }
        }
        
        /// Check if the string requires quoting.
        fn need_quotes(string: &str) -> bool {
            fn need_quotes_spaces(string: &str) -> bool {
                string.starts_with(' ')
                    || string.ends_with(' ')
            }
        
            string == ""
            || need_quotes_spaces(string)
            || string.contains(|character: char| {
                match character {
                    ':' | '{' | '}' | '[' | ']' | ',' | '&' | '*' | '#' | '?' | '|' | '-' | '<' | '>' | '=' | '!' | '%' | '@' | '`' | '\"' | '\'' | '\\' | '\0' ... '\x06' | '\t' | '\n' | '\r' | '\x0e' ... '\x1a' | '\x1c' ... '\x1f' => true,
                    _ => false,
                }
            })
            || [// http://yaml.org/type/bool.html
                "y","Y","yes","Yes","YES","n","N","no","No","NO",
                "True", "TRUE", "true", "False", "FALSE", "false",
                "on","On","ON","off","Off","OFF",
                // http://yaml.org/type/null.html
                "null","Null","NULL", "~"
            ].contains(&string)
            || string.starts_with('.')
            || string.parse::<i64>().is_ok()
            || string.parse::<f64>().is_ok()
        }
    }
    
    pub use self::scanner::ScanError;
    pub use self::parser::Event;
    pub use self::yaml::{Yaml, YamlLoader};
    pub use self::emitter::{YamlEmitter, EmitError};
}
/*
*/
pub mod calculator
{
    use ::
    {
        *,
    };
    /*
    // via: https://github.com/pest-parser/book/blob/b6a42eb7/examples/calculator/src/main.rs
    use ::num::Wrapping as W;
    
    use pest::Parser;
    use pest::iterators::{Pair, Pairs};
    use pest::pratt_parser::{Assoc, Op, PrattParser};
    */
    #[derive(Parser)]
    #[grammar = "calculator/grammar.pest"]
    struct Calculator;
    
    lazy_static! {
        static ref PRATT_PARSER: PrattParser<Rule> = {
            use Rule::*;
            use Assoc::*;
    
            PrattParser::new()
                .op(Op::infix(add, Left) | Op::infix(subtract, Left))
                .op(Op::infix(multiply, Left) | Op::infix(divide, Left))
                .op(Op::infix(power, Right))
        };
    }
    
    pub fn eval_int(expression: Pairs<Rule>) -> i64 {
        PRATT_PARSER
            .map_primary(|primary| match primary.as_rule() {
                Rule::num => primary.as_str().parse::<i64>().unwrap(),
                Rule::expr => eval_int(primary.into_inner()),
                _ => unreachable!(),
            })
            .map_infix(|lhs: i64, op: Pair<Rule>, rhs: i64| match op.as_rule() {
                Rule::add => (W(lhs) + W(rhs)).0,
                Rule::subtract => (W(lhs) - W(rhs)).0,
                Rule::multiply => (W(lhs) * W(rhs)).0,
                Rule::divide => {
                    if rhs == 0 {
                        (lhs as f64 / 0.0) as i64
                    } else {
                        (W(lhs) / W(rhs)).0
                    }
                }
                Rule::power => lhs.pow(rhs as u32),
                _ => unreachable!(),
            })
            .parse(expression)
    }
    
    pub fn eval_float(expression: Pairs<Rule>) -> f64 {
        PRATT_PARSER
            .map_primary(|primary| match primary.as_rule() {
                Rule::num => primary.as_str().parse::<f64>().unwrap(),
                Rule::expr => eval_float(primary.into_inner()),
                _ => unreachable!(),
            })
            .map_infix(|lhs, op, rhs| match op.as_rule() {
                Rule::add => lhs + rhs,
                Rule::subtract => lhs - rhs,
                Rule::multiply => lhs * rhs,
                Rule::divide => lhs / rhs,
                Rule::power => lhs.powf(rhs),
                _ => unreachable!(),
            })
            .parse(expression)
    }
    
    pub fn calculate(line: &str) -> Result<pest::iterators::Pairs<'_, Rule>, pest::error::Error<Rule>> {
        Calculator::parse(Rule::calculation, line)
    }
}

pub mod completers
{
    use ::
    {
        *,
    };
    /*
    use ::path::Path;
    use ::sync::Arc;
    
    use lineread::complete::{Completer, Completion};
    use lineread::prompter::Prompter;
    use lineread::terminal::Terminal;
    
    pub mod dots;
    pub mod env;
    pub mod make;
    pub mod path;
    pub mod ssh;
    pub mod utils;
    
    use crate::libs;
    use crate::parsers;
    use crate::shell;
    use crate::tools;
    */
    pub mod dots
    {
        use ::
        {
            *
        };
        /*
        use ::borrow::Cow;
        use ::fs::File;
        use ::io::{Read, Write};
        use ::path::Path;
        
        use lineread::complete::escape;
        use lineread::complete::escaped_word_start;
        use lineread::complete::unescape;
        use lineread::complete::Suffix;
        use lineread::complete::{Completer, Completion};
        use lineread::prompter::Prompter;
        use lineread::terminal::Terminal;
        use yaml_rust::{Yaml, YamlLoader};
        use yaml_rust::yaml::Hash;
        
        use crate::execute;
        use crate::parsers;
        use crate::tools;
        */
        /// Performs completion by searching dotfiles
        pub struct DotsCompleter;
        
        impl<Term: Terminal> Completer<Term> for DotsCompleter {
            fn complete(
                &self,
                word: &str,
                reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                let line = reader.buffer();
                Some(complete_dots(line, word))
            }
        
            fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
                escaped_word_start(&line[..end])
            }
        
            fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                escape(word)
            }
        
            fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> {
                unescape(word)
            }
        }
        
        fn get_dot_file(line: &str) -> (String, String) {
            let args = parsers::parser_line::line_to_plain_tokens(line);
            let dir = tools::get_user_completer_dir();
            let dot_file = format!("{}/{}.yaml", dir, args[0]);
            if !Path::new(&dot_file).exists() {
                return (String::new(), String::new());
            }
            let sub_cmd = if (args.len() >= 3 && !args[1].starts_with('-'))
                || (args.len() >= 2 && !args[1].starts_with('-') && line.ends_with(' '))
            {
                args[1].as_str()
            } else {
                ""
            };
        
            (dot_file, sub_cmd.to_string())
        }
        
        fn handle_lv1_string(res: &mut Vec<Completion>,
                             value: &str, word: &str) {
            if !value.starts_with(word) && !value.starts_with('`') {
                return;
            }
        
            let linfo = parsers::parser_line::parse_line(value);
            let tokens = linfo.tokens;
            if tokens.len() == 1 && tokens[0].0 == "`" {
                log!("run subcmd: {:?}", &tokens[0].1);
                let cr = execute::run(&tokens[0].1);
                let v: Vec<&str> = cr.stdout.split(|c| c == '\n' || c == ' ').collect();
                for s in v {
                    if s.trim().is_empty() {
                        continue;
                    }
                    handle_lv1_string(res, s, word);
                }
                return;
            }
        
            let display = None;
            let suffix = Suffix::Default;
            res.push(Completion {
                completion: value.to_string(),
                display,
                suffix,
            });
        }
        
        fn handle_lv1_hash(res: &mut Vec<Completion>,
                           h: &Hash, word: &str) {
            for v in h.values() {
                if let Yaml::Array(ref arr) = v {
                    for s in arr {
                        if let Yaml::String(value) = s {
                            if !value.starts_with(word) && !value.starts_with('`') {
                                continue;
                            }
                            handle_lv1_string(res, value, word);
                        }
                    }
                }
            }
        }
        
        fn complete_dots(line: &str, word: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            if line.trim().is_empty() {
                return res;
            }
            let (dot_file, sub_cmd) = get_dot_file(line);
            if dot_file.is_empty() {
                return res;
            }
        
            let mut f;
            match File::open(&dot_file) {
                Ok(x) => f = x,
                Err(e) => {
                    println_stderr!("\ncicada: open dot_file error: {:?}", e);
                    return res;
                }
            }
        
            let mut s = String::new();
            match f.read_to_string(&mut s) {
                Ok(_) => {}
                Err(e) => {
                    println_stderr!("\ncicada: read_to_string error: {:?}", e);
                    return res;
                }
            }
        
            let docs = match YamlLoader::load_from_str(&s) {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("\ncicada: Bad Yaml file: {}: {:?}", dot_file, e);
                    return res;
                }
            };
        
            for doc in docs.iter() {
                match *doc {
                    Yaml::Array(ref v) => {
                        for x in v {
                            match *x {
                                Yaml::String(ref name) => {
                                    if !sub_cmd.is_empty() {
                                        continue;
                                    }
                                    handle_lv1_string(&mut res, name, word);
                                }
                                Yaml::Hash(ref h) => {
                                    if sub_cmd.is_empty() {
                                        for k in h.keys() {
                                            if let Yaml::String(value) = k {
                                                handle_lv1_string(&mut res, value, word);
                                            }
                                        }
                                    } else {
                                        let key = Yaml::from_str(&sub_cmd);
                                        if !h.contains_key(&key) {
                                            continue;
                                        }
                                        handle_lv1_hash(&mut res, h, word);
                                    }
                                }
                                _ => {
                                    println_stderr!("\nThis yaml file is in bad format: {}", dot_file);
                                }
                            }
                        }
                    }
                    _ => {
                        println_stderr!("\nThis yaml file is in bad format: {}", dot_file);
                    }
                }
            }
            res
        }

    }
    
    pub mod env
    {
        use ::
        {
            *
        };
        /*
        use ::env;
        use ::sync::Arc;
        
        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::prompter::Prompter;
        use lineread::terminal::Terminal;
        
        use crate::shell;
        */
        pub struct EnvCompleter {
            pub sh: Arc<shell::Shell>,
        }
        
        impl<Term: Terminal> Completer<Term> for EnvCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                let sh = Arc::try_unwrap(self.sh.clone());
                match sh {
                    Ok(x) => Some(complete_env(&x, word)),
                    Err(x) => Some(complete_env(&x, word)),
                }
            }
        }
        
        fn complete_env(sh: &shell::Shell, path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            if path.trim().is_empty() {
                return res;
            }
            let mut prefix = path.to_string();
            prefix.remove(0);
        
            for (key, _) in env::vars_os() {
                let env_name = key.to_string_lossy().to_string();
                if env_name.starts_with(&prefix) {
                    res.push(Completion {
                        completion: format!("${}", env_name),
                        display: None,
                        suffix: Suffix::Default,
                    });
                }
            }
        
            // sh.envs is a just clone here; see FIXME in main.rs
            for key in sh.envs.keys() {
                if key.starts_with(&prefix) {
                    res.push(Completion {
                        completion: format!("${}", key),
                        display: None,
                        suffix: Suffix::Default,
                    });
                }
            }
        
            res
        }
    }
    
    pub mod make
    {
        use ::
        {
            *
        };
        /*
        use ::env;
        use ::fs::File;
        use ::io::{BufRead, BufReader, Write};
        
        use regex::Regex;
        
        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::prompter::Prompter;
        use lineread::terminal::Terminal;
        */
        pub struct MakeCompleter;
        
        impl<Term: Terminal> Completer<Term> for MakeCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_make(word))
            }
        }
        
        fn handle_file(ci: &mut Vec<Completion>, path: &str, file_path: &str, current_dir: &str) {
            if let Ok(f) = File::open(file_path) {
                let file = BufReader::new(&f);
                let re_cmd = match Regex::new(r"^ *([^ ]+):") {
                    Ok(x) => x,
                    Err(e) => {
                        println_stderr!("cicada: regex build error: {:?}", e);
                        return;
                    }
                };
        
                let re_include = match Regex::new(r"^ *include  *([^ ]+) *$") {
                    Ok(x) => x,
                    Err(e) => {
                        println_stderr!("cicada: regex build error: {:?}", e);
                        return;
                    }
                };
        
                for line in file.lines().map_while(Result::ok) {
                    if re_cmd.is_match(&line) {
                        for cap in re_cmd.captures_iter(&line) {
                            if !cap[1].starts_with(path) {
                                continue;
                            }
                            ci.push(Completion {
                                completion: cap[1].to_string(),
                                display: None,
                                suffix: Suffix::Default,
                            });
                        }
                    }
                    if re_include.is_match(&line) {
                        for cap in re_include.captures_iter(&line) {
                            let _file = &cap[1];
                            if _file.contains('/') {
                                handle_file(ci, path, _file, current_dir);
                            } else {
                                let make_file = current_dir.to_owned() + "/" + _file;
                                handle_file(ci, path, &make_file, current_dir);
                            }
                        }
                    }
                }
            }
        }
        
        fn complete_make(path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            let current_dir = match env::current_dir() {
                Ok(dir) => match dir.to_str() {
                    Some(s) => s.to_string(),
                    None => {
                        println!("cicada: to_str error");
                        return res;
                    }
                },
                Err(e) => {
                    println!("cicada: get current_dir error: {:?}", e);
                    return res;
                }
            };
        
            let make_file = format!("{}/Makefile", current_dir);
            handle_file(&mut res, path, &make_file, &current_dir);
            res
        }
    }
    
    pub mod path
    {
        use ::
        {
            *
        };
        /*
        use ::collections::HashSet;
        use ::env;
        use ::fs::read_dir;
        use ::io::Write;
        use ::iter::FromIterator;
        use ::os::unix::fs::PermissionsExt;
        use ::path::MAIN_SEPARATOR;
        use ::sync::Arc;
        
        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::terminal::Terminal;
        use lineread::Prompter;
        
        use crate::completers::utils;
        use crate::libs;
        use crate::parsers;
        use crate::shell;
        use crate::tools;
        */
        pub struct BinCompleter {
            pub sh: Arc<shell::Shell>,
        }
        pub struct CdCompleter;
        pub struct PathCompleter;
        
        fn is_env_prefix(line: &str) -> bool {
            libs::re::re_contains(line, r" *\$[a-zA-Z_][A-Za-z0-9_]*")
        }
        
        fn is_pipelined(path: &str) -> bool {
            if !path.contains('|') {
                return false;
            }
            !path.starts_with('"') && !path.starts_with('\'')
        }
        
        impl<Term: Terminal> Completer<Term> for BinCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                let sh = Arc::try_unwrap(self.sh.clone());
                match sh {
                    Ok(x) => Some(complete_bin(&x, word)),
                    Err(x) => Some(complete_bin(&x, word)),
                }
            }
        }
        
        impl<Term: Terminal> Completer<Term> for PathCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_path(word, false))
            }
        }
        
        impl<Term: Terminal> Completer<Term> for CdCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_path(word, true))
            }
        }
        
        fn needs_expand_home(line: &str) -> bool {
            libs::re::re_contains(line, r"( +~ +)|( +~/)|(^ *~/)|( +~ *$)")
        }
        
        /// Returns a sorted list of paths whose prefix matches the given path.
        pub fn complete_path(word: &str, for_dir: bool) -> Vec<Completion> {
            let is_env = is_env_prefix(word);
            let mut res = Vec::new();
            let linfo = parsers::parser_line::parse_line(word);
            let tokens = linfo.tokens;
            let (path, path_sep) = if tokens.is_empty() {
                (String::new(), String::new())
            } else {
                let (ref _path_sep, ref _path) = tokens[tokens.len() - 1];
                (_path.clone(), _path_sep.clone())
            };
        
            let (_, _dir_orig, _f) = split_pathname(&path, "");
            let dir_orig = if _dir_orig.is_empty() {
                String::new()
            } else {
                _dir_orig.clone()
            };
            let mut path_extended = path.clone();
            if needs_expand_home(&path_extended) {
                utils::expand_home_string(&mut path_extended)
            }
            utils::expand_env_string(&mut path_extended);
        
            let (_, _dir_lookup, file_name) = split_pathname(&path_extended, "");
            let dir_lookup = if _dir_lookup.is_empty() {
                ".".to_string()
            } else {
                _dir_lookup.clone()
            };
            // let dir_lookup = _dir_lookup.unwrap_or(".");
            if let Ok(entries) = read_dir(dir_lookup) {
                for entry in entries.flatten() {
                    let pathbuf = entry.path();
                    let is_dir = pathbuf.is_dir();
                    if for_dir && !is_dir {
                        continue;
                    }
        
                    let entry_name = entry.file_name();
                    // TODO: Deal with non-UTF8 paths in some way
                    if let Ok(_path) = entry_name.into_string() {
                        if _path.starts_with(&file_name) {
                            let (name, display) = if !dir_orig.is_empty() {
                                (
                                    format!("{}{}{}", dir_orig, MAIN_SEPARATOR, _path),
                                    Some(_path),
                                )
                            } else {
                                (_path, None)
                            };
                            let mut name = str::replace(name.as_str(), "//", "/");
                            if path_sep.is_empty() && !is_env {
                                name = tools::escape_path(&name);
                            }
                            let mut quoted = false;
                            if !path_sep.is_empty() {
                                name = tools::wrap_sep_string(&path_sep, &name);
                                quoted = true;
                            }
                            let suffix = if is_dir {
                                if quoted {
                                    name.pop();
                                }
                                Suffix::Some(MAIN_SEPARATOR)
                            } else {
                                Suffix::Default
                            };
                            res.push(Completion {
                                completion: name,
                                display,
                                suffix,
                            });
                        }
                    }
                }
            }
            res.sort_by(|a, b| a.completion.cmp(&b.completion));
            res
        }
        
        // Split optional directory and prefix. (see its test cases for more details)
        fn split_pathname(path: &str, prefix: &str) -> (String, String, String) {
            if is_pipelined(path) {
                let tokens: Vec<&str> = path.rsplitn(2, '|').collect();
                let prefix = format!("{}|", tokens[1]);
                return split_pathname(tokens[0], &prefix);
            }
            match path.rfind('/') {
                Some(pos) => (
                    prefix.to_string(),
                    path[..=pos].to_string(),
                    path[pos + 1..].to_string(),
                ),
                None => (prefix.to_string(), String::new(), path.to_string()),
            }
        }
        
        /// Returns a sorted list of paths whose prefix matches the given path.
        fn complete_bin(sh: &shell::Shell, path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            let (prefix, _, fname) = split_pathname(path, "");
            let env_path = match env::var("PATH") {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: env error when complete_bin: {:?}", e);
                    return res;
                }
            };
        
            let mut checker: HashSet<String> = HashSet::new();
        
            // handle alias, builtins, and functions
            for func in sh.funcs.keys() {
                if !func.starts_with(&fname) {
                    continue;
                }
                if checker.contains(func) {
                    continue;
                }
                checker.insert(func.clone());
                res.push(Completion {
                    completion: func.to_owned(),
                    display: None,
                    suffix: Suffix::Default,
                });
            }
            for alias in sh.aliases.keys() {
                if !alias.starts_with(&fname) {
                    continue;
                }
                if checker.contains(alias) {
                    continue;
                }
                checker.insert(alias.clone());
                res.push(Completion {
                    completion: alias.to_owned(),
                    display: None,
                    suffix: Suffix::Default,
                });
            }
        
            let builtins = vec![
                "alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg",
                "history", "jobs", "read", "source", "ulimit", "unalias", "vox",
                "minfd", "set", "unset", "unpath",
            ];
            for item in &builtins {
                if !item.starts_with(&fname) {
                    continue;
                }
                if checker.contains(*item) {
                    continue;
                }
                checker.insert(item.to_string());
                res.push(Completion {
                    completion: item.to_string(),
                    display: None,
                    suffix: Suffix::Default,
                });
            }
        
            let vec_path: Vec<&str> = env_path.split(':').collect();
            let path_list: HashSet<&str> = HashSet::from_iter(vec_path.iter().cloned());
        
            for p in &path_list {
                if let Ok(list) = read_dir(p) {
                    for entry in list.flatten() {
                        if let Ok(name) = entry.file_name().into_string() {
                            if name.starts_with(&fname) {
                                let _mode = match entry.metadata() {
                                    Ok(x) => x,
                                    Err(e) => {
                                        println_stderr!("cicada: metadata error: {:?}", e);
                                        continue;
                                    }
                                };
                                let mode = _mode.permissions().mode();
                                if mode & 0o111 == 0 {
                                    // not binary
                                    continue;
                                }
                                if checker.contains(&name) {
                                    continue;
                                }
        
                                let display = None;
                                let suffix = Suffix::Default;
                                checker.insert(name.clone());
                                // TODO: need to handle quoted: `$ "foo#bar"`
                                let name_e = tools::escape_path(&name);
                                let name_e = format!("{}{}", prefix, name_e);
                                res.push(Completion {
                                    completion: name_e,
                                    display,
                                    suffix,
                                });
                            }
                        }
                    }
                }
            }
            res
        }
    }
    
    pub mod ssh
    {
        use ::
        {
            *
        };
        /*
        use ::fs::File;
        use ::io::{BufRead, BufReader};
        
        use regex::Regex;
        
        use lineread::complete::{Completer, Completion, Suffix};
        use lineread::terminal::Terminal;
        use lineread::Prompter;
        
        use crate::tools;
        */
        pub struct SshCompleter;
        
        impl<Term: Terminal> Completer<Term> for SshCompleter {
            fn complete(
                &self,
                word: &str,
                _reader: &Prompter<Term>,
                _start: usize,
                _end: usize,
            ) -> Option<Vec<Completion>> {
                Some(complete_ssh(word))
            }
        }
        
        fn complete_ssh(path: &str) -> Vec<Completion> {
            let mut res = Vec::new();
            let home = tools::get_user_home();
            let ssh_config = home + "/.ssh/config";
            if let Ok(f) = File::open(&ssh_config) {
                let file = BufReader::new(&f);
                let re = match Regex::new(r"^ *(?i)host +([^ ]+)") {
                    Ok(x) => x,
                    Err(e) => {
                        println!("Regex build error: {:?}", e);
                        return res;
                    }
                };
                for line in file.lines().map_while(Result::ok) {
                    if !re.is_match(&line) {
                        continue;
                    }
                    for cap in re.captures_iter(&line) {
                        if !cap[1].starts_with(path) {
                            continue;
                        }
                        res.push(Completion {
                            completion: cap[1].to_string(),
                            display: None,
                            suffix: Suffix::Default,
                        });
                    }
                }
            }
            res
        }
    }
    
    pub mod utils
    {
        use ::
        {
            *
        };
        /*
        use regex::Regex;
        use ::env;
        
        use crate::libs;
        use crate::tools;
        */
        pub fn expand_home_string(text: &mut String) {
            let v = vec![
                r"(?P<head> +)~(?P<tail> +)",
                r"(?P<head> +)~(?P<tail>/)",
                r"^(?P<head> *)~(?P<tail>/)",
                r"(?P<head> +)~(?P<tail> *$)",
            ];
            for item in &v {
                let re;
                if let Ok(x) = Regex::new(item) {
                    re = x;
                } else {
                    return;
                }
                let home = tools::get_user_home();
                let ss = text.clone();
                let to = format!("$head{}$tail", home);
                let result = re.replace_all(ss.as_str(), to.as_str());
                *text = result.to_string();
            }
        }
        
        pub fn expand_env_string(text: &mut String) {
            // expand "$HOME/.local/share" to "/home/tom/.local/share"
            if !text.starts_with('$') {
                return;
            }
            let ptn = r"^\$([A-Za-z_][A-Za-z0-9_]*)";
            let mut env_value = String::new();
            match libs::re::find_first_group(ptn, text) {
                Some(x) => {
                    if let Ok(val) = env::var(&x) {
                        env_value = val;
                    }
                }
                None => {
                    return;
                }
            }
        
            if env_value.is_empty() {
                return;
            }
            let t = text.clone();
            *text = libs::re::replace_all(&t, ptn, &env_value);
        }

    }
        
    pub struct CicadaCompleter {
        pub sh: Arc<shell::Shell>,
    }
    
    fn for_make(line: &str) -> bool {
        libs::re::re_contains(line, r"^ *make ")
    }
    
    fn for_env(line: &str) -> bool {
        libs::re::re_contains(line, r" *\$[_a-zA-Z0-9]*$")
    }
    
    fn for_ssh(line: &str) -> bool {
        libs::re::re_contains(line, r"^ *(ssh|scp).* +[^ \./]+ *$")
    }
    
    fn for_cd(line: &str) -> bool {
        libs::re::re_contains(line, r"^ *cd +")
    }
    
    fn for_bin(line: &str) -> bool {
        let ptn = r"(^ *(sudo|which|nohup)? *[a-zA-Z0-9_\.-]+$)|(^.+\| *(sudo|which|nohup)? *[a-zA-Z0-9_\.-]+$)";
        libs::re::re_contains(line, ptn)
    }
    
    fn for_dots(line: &str) -> bool {
        let args = parsers::parser_line::line_to_plain_tokens(line);
        let len = args.len();
        if len == 0 {
            return false;
        }
        let dir = tools::get_user_completer_dir();
        let dot_file = format!("{}/{}.yaml", dir, args[0]);
        Path::new(dot_file.as_str()).exists()
    }
    
    impl<Term: Terminal> Completer<Term> for CicadaCompleter {
        fn complete(
            &self,
            word: &str,
            reader: &Prompter<Term>,
            start: usize,
            _end: usize,
        ) -> Option<Vec<Completion>> {
            let line = reader.buffer();
    
            let completions: Option<Vec<Completion>>;
            if for_dots(line) {
                let cpl = Arc::new(dots::DotsCompleter);
                completions = cpl.complete(word, reader, start, _end);
            } else if for_ssh(line) {
                let cpl = Arc::new(ssh::SshCompleter);
                completions = cpl.complete(word, reader, start, _end);
            } else if for_make(line) {
                let cpl = Arc::new(make::MakeCompleter);
                completions = cpl.complete(word, reader, start, _end);
            } else if for_bin(line) {
                let cpl = Arc::new(path::BinCompleter {
                    sh: self.sh.clone(),
                });
                completions = cpl.complete(word, reader, start, _end);
            } else if for_env(line) {
                let cpl = Arc::new(env::EnvCompleter {
                    sh: self.sh.clone(),
                });
                completions = cpl.complete(word, reader, start, _end);
            } else if for_cd(line) {
                // `for_cd` should be put a bottom position, so that
                // `cd $SOME_ENV_<TAB>` works as expected.
                let cpl = Arc::new(path::CdCompleter);
                // completions for `cd` should not fail back to path-completion
                return cpl.complete(word, reader, start, _end);
            } else {
                completions = None;
            }
    
            if let Some(x) = completions {
                if !x.is_empty() {
                    return Some(x);
                }
            }
    
            // empty completions should fail back to path-completion,
            // so that `$ make generate /path/to/fi<Tab>` still works.
            let cpl = Arc::new(path::PathCompleter);
            cpl.complete(word, reader, start, _end)
        }
    
        fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize {
            escaped_word_start(&line[..end])
        }
    }
    
    pub fn escaped_word_start(line: &str) -> usize {
        let mut start_position: usize = 0;
        let mut found_bs = false;
        let mut found_space = false;
        let mut with_quote = false;
        let mut ch_quote = '\0';
        let mut extra_bytes = 0;
        for (i, c) in line.chars().enumerate() {
            if found_space {
                found_space = false;
                start_position = i + extra_bytes;
            }
    
            if c == '\\' {
                found_bs = true;
                continue;
            }
            if c == ' ' && !found_bs && !with_quote {
                found_space = true;
                continue;
            }
    
            if !with_quote && !found_bs && (c == '"' || c == '\'') {
                with_quote = true;
                ch_quote = c;
            } else if with_quote && !found_bs && ch_quote == c {
                with_quote = false;
            }
    
            let bytes_c = c.len_utf8();
            if bytes_c > 1 {
                extra_bytes += bytes_c - 1;
            }
            found_bs = false;
        }
        if found_space {
            start_position = line.len();
        }
        start_position
    }
}

pub mod core
{
    use ::
    {
        *,
    };
    /*
    use ::env;
    use ::ffi::{CStr, CString};
    use ::fs::File;
    use ::io::{Read, Write};
    use ::os::unix::io::FromRawFd;
    use ::os::fd::RawFd;
    use ::process;
    
    use nix::uni ::{execve, ForkResult};
    use libs::pipes::pipe;
    
    use crate::builtins;
    use crate::calculator;
    use crate::jobc;
    use crate::libs;
    use crate::parsers;
    use crate::scripting;
    use crate::shell::{self, Shell};
    use crate::tools;
    use crate::types::{CommandLine, CommandOptions, CommandResult};
    */
    fn try_run_builtin_in_subprocess(
        sh: &mut Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<i32> {
        if let Some(cr) = try_run_builtin(sh, cl, idx_cmd, capture) {
            return Some(cr.status);
        }
        None
    }
    
    fn try_run_builtin(
        sh: &mut Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<CommandResult> {
        // for builtin, only capture its outputs when it locates at the end
        let capture = capture && idx_cmd + 1 == cl.commands.len();
    
        if idx_cmd >= cl.commands.len() {
            println_stderr!("unexpected error in try_run_builtin");
            return None;
        }
    
        let cmd = &cl.commands[idx_cmd];
        let tokens = cmd.tokens.clone();
        let cname = tokens[0].1.clone();
        if cname == "alias" {
            let cr = builtins::alias::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "bg" {
            let cr = builtins::bg::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "cd" {
            let cr = builtins::cd::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "cinfo" {
            let cr = builtins::cinfo::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "exec" {
            let cr = builtins::exec::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "exit" {
            let cr = builtins::exit::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "export" {
            let cr = builtins::export::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "fg" {
            let cr = builtins::fg::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "history" {
            let cr = builtins::history::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "jobs" {
            let cr = builtins::jobs::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "minfd" {
            let cr = builtins::minfd::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "read" {
            let cr = builtins::read::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "set" {
            let cr = builtins::set::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "source" {
            let cr = builtins::source::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "ulimit" {
            let cr = builtins::ulimit::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "unalias" {
            let cr = builtins::unalias::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "unset" {
            let cr = builtins::unset::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "unpath" {
            let cr = builtins::unpath::run(sh, cl, cmd, capture);
            return Some(cr);
        } else if cname == "vox" {
            let cr = builtins::vox::run(sh, cl, cmd, capture);
            return Some(cr);
        }
        None
    }
    
    /// Run a pipeline (e.g. `echo hi | wc -l`)
    /// returns: (is-terminal-given, command-result)
    pub fn run_pipeline(
        sh: &mut shell::Shell,
        cl: &CommandLine,
        tty: bool,
        capture: bool,
        log_cmd: bool,
    ) -> (bool, CommandResult) {
        let mut term_given = false;
        if cl.background && capture {
            println_stderr!("cicada: cannot capture output of background cmd");
            return (term_given, CommandResult::error());
        }
    
        if let Some(cr) = try_run_calculator(&cl.line, capture) {
            return (term_given, cr);
        }
    
        // FIXME: move func-run into run single command
        if let Some(cr) = try_run_func(sh, cl, capture, log_cmd) {
            return (term_given, cr);
        }
    
        if log_cmd {
            log!("run: {}", cl.line);
        }
    
        let length = cl.commands.len();
        if length == 0 {
            println!("cicada: invalid command: cmds with empty length");
            return (false, CommandResult::error());
        }
    
        let mut pipes = Vec::new();
        let mut errored_pipes = false;
        for _ in 0..length - 1 {
            match pipe() {
                Ok(fds) => pipes.push(fds),
                Err(e) => {
                    errored_pipes = true;
                    println_stderr!("cicada: pipeline1: {}", e);
                    break;
                }
            }
        }
    
        if errored_pipes {
            // release fds that already created when errors occurred
            for fds in pipes {
                libs::close(fds.0);
                libs::close(fds.1);
            }
            return (false, CommandResult::error());
        }
    
        if pipes.len() + 1 != length {
            println!("cicada: invalid command: unmatched pipes count");
            return (false, CommandResult::error());
        }
    
        let mut pgid: i32 = 0;
        let mut fg_pids: Vec<i32> = Vec::new();
    
        let isatty = if tty {
            unsafe { libc::isatty(1) == 1 }
        } else {
            false
        };
        let options = CommandOptions {
            isatty,
            capture_output: capture,
            background: cl.background,
            envs: cl.envs.clone(),
        };
    
        let mut fds_capture_stdout = None;
        let mut fds_capture_stderr = None;
        if capture {
            match pipe() {
                Ok(fds) => fds_capture_stdout = Some(fds),
                Err(e) => {
                    println_stderr!("cicada: pipeline2: {}", e);
                    return (false, CommandResult::error());
                }
            }
            match pipe() {
                Ok(fds) => fds_capture_stderr = Some(fds),
                Err(e) => {
                    if let Some(fds) = fds_capture_stdout {
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                    println_stderr!("cicada: pipeline3: {}", e);
                    return (false, CommandResult::error());
                }
            }
        }
    
        let mut cmd_result = CommandResult::new();
        for i in 0..length {
            let child_id: i32 = run_single_program(
                sh,
                cl,
                i,
                &options,
                &mut pgid,
                &mut term_given,
                &mut cmd_result,
                &pipes,
                &fds_capture_stdout,
                &fds_capture_stderr,
            );
    
            if child_id > 0 && !cl.background {
                fg_pids.push(child_id);
            }
        }
    
        if cl.is_single_and_builtin() {
            return (false, cmd_result);
        }
    
        if cl.background {
            if let Some(job) = sh.get_job_by_gid(pgid) {
                println_stderr!("[{}] {}", job.id, job.gid);
            }
        }
    
        if !fg_pids.is_empty() {
            let _cr = jobc::wait_fg_job(sh, pgid, &fg_pids);
            // for capture commands, e.g. `echo foo` in `echo "hello $(echo foo)"
            // the cmd_result is already built in loop calling run_single_program()
            // above.
            if !capture {
                cmd_result = _cr;
            }
        }
        (term_given, cmd_result)
    }
    
    /// Run a single command.
    /// e.g. the `sort -k2` part of `ps ax | sort -k2 | head`
    fn run_single_program(
        sh: &mut shell::Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        options: &CommandOptions,
        pgid: &mut i32,
        term_given: &mut bool,
        cmd_result: &mut CommandResult,
        pipes: &[(RawFd, RawFd)],
        fds_capture_stdout: &Option<(RawFd, RawFd)>,
        fds_capture_stderr: &Option<(RawFd, RawFd)>,
    ) -> i32 {
        let capture = options.capture_output;
        if cl.is_single_and_builtin() {
            if let Some(cr) = try_run_builtin(sh, cl, idx_cmd, capture) {
                *cmd_result = cr;
                return unsafe { libc::getpid() };
            }
    
            println_stderr!("cicada: error when run singler builtin");
            log!("error when run singler builtin: {:?}", cl);
            return 1;
        }
    
        let pipes_count = pipes.len();
        let mut fds_stdin = None;
        let cmd = cl.commands.get(idx_cmd).unwrap();
    
        if cmd.has_here_string() {
            match pipe() {
                Ok(fds) => fds_stdin = Some(fds),
                Err(e) => {
                    println_stderr!("cicada: pipeline4: {}", e);
                    return 1;
                }
            }
        }
    
        match libs::fork::fork() {
            Ok(ForkResult::Child) => {
                unsafe {
                    // child processes need to handle ctrl-Z
                    libc::signal(libc::SIGTSTP, libc::SIG_DFL);
                    libc::signal(libc::SIGQUIT, libc::SIG_DFL);
                }
    
                // close pipes unrelated to current child (left side)
                if idx_cmd > 0 {
                    for i in 0..idx_cmd - 1 {
                        let fds = pipes[i];
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                }
                // close pipes unrelated to current child (right side)
                for i in idx_cmd + 1..pipes_count {
                    let fds = pipes[i];
                    libs::close(fds.0);
                    libs::close(fds.1);
                }
                // close pipe fds for capturing stdout/stderr
                // (they're only used in last child)
                if idx_cmd < pipes_count {
                    if let Some(fds) = fds_capture_stdout {
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                    if let Some(fds) = fds_capture_stderr {
                        libs::close(fds.0);
                        libs::close(fds.1);
                    }
                }
    
                if idx_cmd == 0 {
                    unsafe {
                        let pid = libc::getpid();
                        libc::setpgid(0, pid);
                    }
                } else {
                    unsafe {
                        libc::setpgid(0, *pgid);
                    }
                }
    
                // (in child) replace stdin/stdout with read/write ends of pipe
                if idx_cmd > 0 {
                    let fds_prev = pipes[idx_cmd - 1];
                    libs::dup2(fds_prev.0, 0);
                    libs::close(fds_prev.0);
                    libs::close(fds_prev.1);
                }
                if idx_cmd < pipes_count {
                    let fds = pipes[idx_cmd];
                    libs::dup2(fds.1, 1);
                    libs::close(fds.1);
                    libs::close(fds.0);
                }
    
                if cmd.has_redirect_from() {
                    if let Some(redirect_from) = &cmd.redirect_from {
                        let fd = tools::get_fd_from_file(&redirect_from.clone().1);
                        if fd == -1 {
                            process::exit(1);
                        }
    
                        libs::dup2(fd, 0);
                        libs::close(fd);
                    }
                }
    
                if cmd.has_here_string() {
                    if let Some(fds) = fds_stdin {
                        libs::close(fds.1);
                        libs::dup2(fds.0, 0);
                        libs::close(fds.0);
                    }
                }
    
                let mut stdout_redirected = false;
                let mut stderr_redirected = false;
                for item in &cmd.redirects_to {
                    let from_ = &item.0;
                    let op_ = &item.1;
                    let to_ = &item.2;
                    if to_ == "&1" && from_ == "2" {
                        if idx_cmd < pipes_count {
                            libs::dup2(1, 2);
                        } else if !options.capture_output {
                            let fd = libs::dup(1);
                            if fd == -1 {
                                println_stderr!("cicada: dup error");
                                process::exit(1);
                            }
                            libs::dup2(fd, 2);
                        } else {
                            // note: capture output with redirections does not
                            // make much sense
                        }
                    } else if to_ == "&2" && from_ == "1" {
                        if idx_cmd < pipes_count || !options.capture_output {
                            let fd = libs::dup(2);
                            if fd == -1 {
                                println_stderr!("cicada: dup error");
                                process::exit(1);
                            }
                            libs::dup2(fd, 1);
                        } else {
                            // note: capture output with redirections does not
                            // make much sense
                        }
                    } else {
                        let append = op_ == ">>";
                        match tools::create_raw_fd_from_file(to_, append) {
                            Ok(fd) => {
                                if fd == -1 {
                                    println_stderr!("cicada: fork: fd error");
                                    process::exit(1);
                                }
    
                                if from_ == "1" {
                                    libs::dup2(fd, 1);
                                    stdout_redirected = true;
                                } else {
                                    libs::dup2(fd, 2);
                                    stderr_redirected = true;
                                }
                            }
                            Err(e) => {
                                println_stderr!("cicada: fork: {}", e);
                                process::exit(1);
                            }
                        }
                    }
                }
    
                // capture output of last process if needed.
                if idx_cmd == pipes_count && options.capture_output {
                    if !stdout_redirected {
                        if let Some(fds) = fds_capture_stdout {
                            libs::close(fds.0);
                            libs::dup2(fds.1, 1);
                            libs::close(fds.1);
                        }
                    }
                    if !stderr_redirected {
                        if let Some(fds) = fds_capture_stderr {
                            libs::close(fds.0);
                            libs::dup2(fds.1, 2);
                            libs::close(fds.1);
                        }
                    }
                }
    
                if cmd.is_builtin() {
                    if let Some(status) = try_run_builtin_in_subprocess(sh, cl, idx_cmd, capture) {
                        process::exit(status);
                    }
                }
    
                // our strings do not have '\x00' bytes in them,
                // we can use CString::new().expect() safely.
                let mut c_envs: Vec<_> = env::vars()
                    .map(|(k, v)| {
                        CString::new(format!("{}={}", k, v).as_str()).expect("CString error")
                    })
                    .collect();
                for (key, value) in cl.envs.iter() {
                    c_envs.push(
                        CString::new(format!("{}={}", key, value).as_str()).expect("CString error"),
                    );
                }
    
                let program = &cmd.tokens[0].1;
                let path = if program.contains('/') {
                    program.clone()
                } else {
                    libs::path::find_file_in_path(program, true)
                };
                if path.is_empty() {
                    println_stderr!("cicada: {}: command not found", program);
                    process::exit(127);
                }
    
                let c_program = CString::new(path.as_str()).expect("CString::new failed");
                let c_args: Vec<_> = cmd
                    .tokens
                    .iter()
                    .map(|x| CString::new(x.1.as_str()).expect("CString error"))
                    .collect();
    
                let c_args: Vec<&CStr> = c_args.iter().map(|x| x.as_c_str()).collect();
                let c_envs: Vec<&CStr> = c_envs.iter().map(|x| x.as_c_str()).collect();
                match execve(&c_program, &c_args, &c_envs) {
                    Ok(_) => {}
                    Err(e) => match e {
                        nix::Error::ENOEXEC => {
                            println_stderr!("cicada: {}: exec format error (ENOEXEC)", program);
                        }
                        nix::Error::ENOENT => {
                            println_stderr!("cicada: {}: file does not exist", program);
                        }
                        nix::Error::EACCES => {
                            println_stderr!("cicada: {}: Permission denied", program);
                        }
                        _ => {
                            println_stderr!("cicada: {}: {:?}", program, e);
                        }
                    },
                }
    
                process::exit(1);
            }
            Ok(ForkResult::Parent { child, .. }) => {
                let pid: i32 = child.into();
                if idx_cmd == 0 {
                    *pgid = pid;
                    unsafe {
                        // we need to wait pgid of child set to itself,
                        // before give terminal to it (for macos).
                        // 1. this loop causes `bash`, `htop` etc to go `T` status
                        //    immediate after start on linux (ubuntu).
                        // 2. but on mac, we need this loop, otherwise commands
                        //    like `vim` will go to `T` status after start.
                        if cfg!(target_os = "macos") {
                            loop {
                                let _pgid = libc::getpgid(pid);
                                if _pgid == pid {
                                    break;
                                }
                            }
                        }
    
                        if sh.has_terminal
                            && options.isatty
                            && !cl.background
                        {
                            *term_given = shell::give_terminal_to(pid);
                        }
                    }
                }
    
                if options.isatty && !options.capture_output {
                    let _cmd = parsers::parser_line::tokens_to_line(&cmd.tokens);
                    sh.insert_job(*pgid, pid, &_cmd, "Running", cl.background);
                }
    
                if let Some(redirect_from) = &cmd.redirect_from {
                    if redirect_from.0 == "<<<" {
                        if let Some(fds) = fds_stdin {
                            unsafe {
                                libs::close(fds.0);
    
                                let mut f = File::from_raw_fd(fds.1);
                                match f.write_all(redirect_from.1.clone().as_bytes()) {
                                    Ok(_) => {}
                                    Err(e) => println_stderr!("cicada: write_all: {}", e),
                                }
                                match f.write_all(b"\n") {
                                    Ok(_) => {}
                                    Err(e) => println_stderr!("cicada: write_all: {}", e),
                                }
                            }
                        }
                    }
                }
    
                // (in parent) close unused pipe ends
                if idx_cmd < pipes_count {
                    let fds = pipes[idx_cmd];
                    libs::close(fds.1);
                }
                if idx_cmd > 0 {
                    // close pipe end only after dupped in the child
                    let fds = pipes[idx_cmd - 1];
                    libs::close(fds.0);
                }
    
                if idx_cmd == pipes_count && options.capture_output {
                    let mut s_out = String::new();
                    let mut s_err = String::new();
    
                    unsafe {
                        if let Some(fds) = fds_capture_stdout {
                            libs::close(fds.1);
    
                            let mut f = File::from_raw_fd(fds.0);
                            match f.read_to_string(&mut s_out) {
                                Ok(_) => {}
                                Err(e) => println_stderr!("cicada: readstr: {}", e),
                            }
                        }
                        if let Some(fds) = fds_capture_stderr {
                            libs::close(fds.1);
                            let mut f_err = File::from_raw_fd(fds.0);
                            match f_err.read_to_string(&mut s_err) {
                                Ok(_) => {}
                                Err(e) => println_stderr!("cicada: readstr: {}", e),
                            }
                        }
                    }
    
                    *cmd_result = CommandResult {
                        gid: *pgid,
                        status: 0,
                        stdout: s_out.clone(),
                        stderr: s_err.clone(),
                    };
                }
    
                pid
            }
    
            Err(_) => {
                println_stderr!("Fork failed");
                *cmd_result = CommandResult::error();
                0
            }
        }
    }
    
    fn try_run_func(
        sh: &mut Shell,
        cl: &CommandLine,
        capture: bool,
        log_cmd: bool,
    ) -> Option<CommandResult> {
        if cl.is_empty() {
            return None;
        }
    
        let command = &cl.commands[0];
        if let Some(func_body) = sh.get_func(&command.tokens[0].1) {
            let mut args = vec!["cicada".to_string()];
            for token in &command.tokens {
                args.push(token.1.to_string());
            }
            if log_cmd {
                log!("run func: {:?}", &args);
            }
            let cr_list = scripting::run_lines(sh, &func_body, &args, capture);
            let mut stdout = String::new();
            let mut stderr = String::new();
            for cr in cr_list {
                stdout.push_str(cr.stdout.trim());
                stdout.push(' ');
                stderr.push_str(cr.stderr.trim());
                stderr.push(' ');
            }
            let mut cr = CommandResult::new();
            cr.stdout = stdout;
            cr.stderr = stderr;
            return Some(cr);
        }
        None
    }
    
    fn try_run_calculator(line: &str, capture: bool) -> Option<CommandResult> {
        if tools::is_arithmetic(line) {
            match run_calculator(line) {
                Ok(result) => {
                    let mut cr = CommandResult::new();
                    if capture {
                        cr.stdout = result.clone();
                    } else {
                        println!("{}", result);
                    }
                    return Some(cr);
                }
                Err(e) => {
                    let mut cr = CommandResult::from_status(0, 1);
                    if capture {
                        cr.stderr = e.to_string();
                    } else {
                        println_stderr!("cicada: calculator: {}", e);
                    }
                    return Some(cr);
                }
            }
        }
        None
    }
    
    pub fn run_calculator(line: &str) -> Result<String, &str> {
        let parse_result = calculator::calculate(line);
        match parse_result {
            Ok(mut calc) => {
                let expr = calc.next().unwrap().into_inner();
    
                if line.contains('.') {
                    Ok(format!("{}", calculator::eval_float(expr)))
                } else {
                    Ok(format!("{}", calculator::eval_int(expr)))
                }
            }
            Err(_) => {
                Err("syntax error")
            }
        }
    }
}

pub mod execute
{
    use ::
    {
        *,
    };
    /*
    use ::collections::HashMap;
    use ::io::{self, Read, Write};
    
    use regex::Regex;
    
    use crate::core;
    use crate::libs;
    use crate::parsers;
    use crate::shell::{self, Shell};
    use crate::types::{CommandLine, CommandResult, Tokens};
    */
    /// Entry point for non-ttys (e.g. Cmd-N on MacVim)
    pub fn run_procs_for_non_tty(sh: &mut Shell) {
        let mut buffer = String::new();
        let stdin = io::stdin();
        let mut handle = stdin.lock();
        match handle.read_to_string(&mut buffer) {
            Ok(_) => {
                log!("run non tty command: {}", &buffer);
                run_command_line(sh, &buffer, false, false);
            }
            Err(e) => {
                println!("cicada: stdin.read_to_string() failed: {:?}", e);
            }
        }
    }
    
    pub fn run_command_line(sh: &mut Shell, line: &str, tty: bool,
                            capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();
        for token in parsers::parser_line::line_to_cmds(line) {
            if token == ";" || token == "&&" || token == "||" {
                sep = token.clone();
                continue;
            }
            if sep == "&&" && status != 0 {
                break;
            }
            if sep == "||" && status == 0 {
                break;
            }
            let cmd = token.clone();
            let cr = run_proc(sh, &cmd, tty, capture);
            status = cr.status;
            sh.previous_status = status;
            cr_list.push(cr);
        }
        cr_list
    }
    
    fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String> {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let ptn_env_exp = r"^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$";
        let re = Regex::new(ptn_env_exp).unwrap();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !libs::re::re_contains(text, ptn_env_exp) {
                break;
            }
    
            for cap in re.captures_iter(text) {
                let name = cap[1].to_string();
                let value = parsers::parser_line::unquote(&cap[2]);
                envs.insert(name, value);
            }
    
            n += 1;
        }
        if n > 0 {
            tokens.drain(0..n);
        }
        envs
    }
    
    fn line_to_tokens(sh: &mut Shell, line: &str) -> (Tokens, HashMap<String, String>) {
        let linfo = parsers::parser_line::parse_line(line);
        let mut tokens = linfo.tokens;
        shell::do_expansion(sh, &mut tokens);
        let envs = drain_env_tokens(&mut tokens);
        (tokens, envs)
    }
    
    fn set_shell_vars(sh: &mut Shell, envs: &HashMap<String, String>) {
        for (name, value) in envs.iter() {
            sh.set_env(name, value);
        }
    }
    
    /// Run simple command or pipeline without using `&&`, `||`, `;`.
    /// example 1: `ls`
    /// example 2: `ls | wc`
    fn run_proc(sh: &mut Shell, line: &str, tty: bool,
                capture: bool) -> CommandResult {
        let log_cmd = !sh.cmd.starts_with(' ');
        match CommandLine::from_line(line, sh) {
            Ok(cl) => {
                if cl.is_empty() {
                    if !cl.envs.is_empty() {
                        set_shell_vars(sh, &cl.envs);
                    }
                    return CommandResult::new();
                }
    
                let (term_given, cr) = ::run_pipeline(sh, &cl, tty, capture, log_cmd);
                if term_given {
                    unsafe {
                        let gid = libc::getpgid(0);
                        shell::give_terminal_to(gid);
                    }
                }
    
                cr
            }
            Err(e) => {
                println_stderr!("cicada: {}", e);
                CommandResult::from_status(0, 1)
            }
        }
    }
    
    fn run_with_shell(sh: &mut Shell, line: &str) -> CommandResult {
        let (tokens, envs) = line_to_tokens(sh, line);
        if tokens.is_empty() {
            set_shell_vars(sh, &envs);
            return CommandResult::new();
        }
    
        match CommandLine::from_line(line, sh) {
            Ok(c) => {
                let (term_given, cr) = ::run_pipeline(sh, &c, false, true, false);
                if term_given {
                    unsafe {
                        let gid = libc::getpgid(0);
                        shell::give_terminal_to(gid);
                    }
                }
    
                cr
            }
            Err(e) => {
                println_stderr!("cicada: {}", e);
                CommandResult::from_status(0, 1)
            }
        }
    }
    
    pub fn run(line: &str) -> CommandResult {
        let mut sh = Shell::new();
        run_with_shell(&mut sh, line)
    }
}

pub mod history
{
    use ::
    {
        *,
    };
    /*
    use ::collections::HashMap;
    use ::env;
    use ::fs;
    use ::io::Write;
    use ::path::Path;
    
    use lineread::terminal::DefaultTerminal;
    use lineread::Interface;
    use rusqlite::Connection as Conn;
    use rusqlite::Error::SqliteFailure;
    
    use crate::shell;
    use crate::tools;
    */
    fn init_db(hfile: &str, htable: &str) {
        let path = Path::new(hfile);
        if !path.exists() {
            let _parent = match path.parent() {
                Some(x) => x,
                None => {
                    println_stderr!("cicada: history init - no parent found");
                    return;
                }
            };
            let parent = match _parent.to_str() {
                Some(x) => x,
                None => {
                    println_stderr!("cicada: parent to_str is None");
                    return;
                }
            };
            match fs::create_dir_all(parent) {
                Ok(_) => {}
                Err(e) => {
                    println_stderr!("cicada: histdir create error: {}", e);
                    return;
                }
            }
            match fs::File::create(hfile) {
                Ok(_) => {
                    println!("cicada: created history file: {}", hfile);
                }
                Err(e) => {
                    println_stderr!("cicada: history: file create failed: {}", e);
                }
            }
        }
    
        let conn = match Conn::open(hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: history: open db error: {}", e);
                return;
            }
        };
        let sql = format!(
            "
            CREATE TABLE IF NOT EXISTS {}
                (inp TEXT,
                 rtn INTEGER,
                 tsb REAL,
                 tse REAL,
                 sessionid TEXT,
                 out TEXT,
                 info TEXT
                );
        ",
            htable
        );
        match conn.execute(&sql, []) {
            Ok(_) => {}
            Err(e) => println_stderr!("cicada: history: query error: {}", e),
        }
    }
    
    pub fn init(rl: &mut Interface<DefaultTerminal>) {
        let mut hist_size: usize = 99999;
        if let Ok(x) = env::var("HISTORY_SIZE") {
            if let Ok(y) = x.parse::<usize>() {
                hist_size = y;
            }
        }
        rl.set_history_size(hist_size);
    
        let history_table = get_history_table();
        let hfile = get_history_file();
    
        if !Path::new(&hfile).exists() {
            init_db(&hfile, &history_table);
        }
    
        let mut delete_dups = true;
        if let Ok(x) = env::var("HISTORY_DELETE_DUPS") {
            if x == "0" {
                delete_dups = false;
            }
        }
        if delete_dups {
            delete_duplicated_histories();
        }
    
        let conn = match Conn::open(&hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };
        let sql = format!("SELECT inp FROM {} ORDER BY tsb;", history_table);
        let mut stmt = match conn.prepare(&sql) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: prepare select error: {}", e);
                return;
            }
        };
    
        let rows = match stmt.query_map([], |row| row.get(0)) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: query select error: {}", e);
                return;
            }
        };
    
        let mut dict_helper: HashMap<String, bool> = HashMap::new();
        for x in rows.flatten() {
            let inp: String = x;
            if dict_helper.contains_key(&inp) {
                continue;
            }
            dict_helper.insert(inp.clone(), true);
            rl.add_history(inp.trim().to_string());
        }
    }
    
    pub fn get_history_file() -> String {
        if let Ok(hfile) = env::var("HISTORY_FILE") {
            hfile
        } else if let Ok(d) = env::var("XDG_DATA_HOME") {
            format!("{}/{}", d, "cicada/history.sqlite")
        } else {
            let home = tools::get_user_home();
            format!("{}/{}", home, ".local/share/cicada/history.sqlite")
        }
    }
    
    pub fn get_history_table() -> String {
        if let Ok(hfile) = env::var("HISTORY_TABLE") {
            hfile
        } else {
            String::from("cicada_history")
        }
    }
    
    fn delete_duplicated_histories() {
        let hfile = get_history_file();
        let history_table = get_history_table();
        let conn = match Conn::open(&hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };
        let sql = format!(
            "DELETE FROM {} WHERE rowid NOT IN (
            SELECT MAX(rowid) FROM {} GROUP BY inp)",
            history_table, history_table
        );
        match conn.execute(&sql, []) {
            Ok(_) => {}
            Err(e) => match e {
                SqliteFailure(ee, msg) => {
                    if ee.extended_code == 5 {
                        log!(
                            "failed to delete dup histories: {}",
                            msg.unwrap_or("db is locked?".to_owned()),
                        );
                        return;
                    }
                    println_stderr!(
                        "cicada: history: delete dups error: {}: {:?}",
                        &ee,
                        &msg
                    );
                }
                _ => {
                    println_stderr!("cicada: history: delete dup error: {}", e);
                }
            },
        }
    }
    
    pub fn add_raw(sh: &shell::Shell, line: &str, status: i32,
                   tsb: f64, tse: f64) {
        let hfile = get_history_file();
        let history_table = get_history_table();
        if !Path::new(&hfile).exists() {
            init_db(&hfile, &history_table);
        }
    
        let conn = match Conn::open(&hfile) {
            Ok(x) => x,
            Err(e) => {
                println_stderr!("cicada: history: conn error: {}", e);
                return;
            }
        };
        let sql = format!(
            "INSERT INTO \
             {} (inp, rtn, tsb, tse, sessionid, info) \
             VALUES('{}', {}, {}, {}, '{}', 'dir:{}|');",
            history_table,
            str::replace(line.trim(), "'", "''"),
            status,
            tsb,
            tse,
            sh.session_id,
            sh.current_dir,
        );
        match conn.execute(&sql, []) {
            Ok(_) => {}
            Err(e) => println_stderr!("cicada: history: save error: {}", e),
        }
    }
    
    pub fn add(sh: &shell::Shell, rl: &mut Interface<DefaultTerminal>, line: &str,
               status: i32, tsb: f64, tse: f64) {
        add_raw(sh, line, status, tsb, tse);
        rl.add_history(line.to_string());
    }
}

pub mod highlight
{
    use ::
    {
        *,
    };
    /*
    use ::ops::Range;
    use ::sync::Arc;
    use ::collections::HashSet;
    use ::path::Path;
    use ::env;
    use ::fs;
    use ::sync::Mutex;
    use ::os::unix::fs::PermissionsExt;
    
    use lineread::highlighting::{Highlighter, Style};
    
    use crate::tools;
    use crate::shell;
    use crate::parsers::parser_line;
    */
    pub struct CicadaHighlighter;
    
    /// ANSI color codes wrapped with \x01 and \x02 for lineread
    const GREEN: &str = "\x01\x1b[0;32m\x02";
    
    lazy_static! {
        static ref AVAILABLE_COMMANDS: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
        static ref ALIASES: Mutex<HashSet<String>> = Mutex::new(HashSet::new());
    }
    
    /// Initialize the available commands cache by scanning PATH directories
    pub fn init_command_cache() {
        let commands = scan_available_commands();
        if let Ok(mut cache) = AVAILABLE_COMMANDS.lock() {
            *cache = commands;
        }
    }
    
    /// Update aliases in the highlighter's cache
    pub fn update_aliases(sh: &shell::Shell) {
        if let Ok(mut aliases) = ALIASES.lock() {
            aliases.clear();
            for alias_name in sh.aliases.keys() {
                aliases.insert(alias_name.clone());
            }
        }
    }
    
    fn scan_available_commands() -> HashSet<String> {
        let mut commands = HashSet::new();
    
        if let Ok(path_var) = env::var("PATH") {
            for path in path_var.split(':') {
                if path.is_empty() {
                    continue;
                }
    
                let dir_path = Path::new(path);
                if !dir_path.is_dir() {
                    continue;
                }
    
                if let Ok(entries) = fs::read_dir(dir_path) {
                    for entry in entries.filter_map(Result::ok) {
                        if let Ok(file_type) = entry.file_type() {
                            if file_type.is_file() || file_type.is_symlink() {
                                if let Ok(metadata) = entry.metadata() {
                                    if metadata.permissions().mode() & 0o111 != 0 {
                                        if let Some(name) = entry.file_name().to_str() {
                                            commands.insert(name.to_string());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    
        commands
    }
    
    fn is_command(word: &str) -> bool {
        if tools::is_builtin(word) {
            return true;
        }
        if let Ok(aliases) = ALIASES.lock() {
            if aliases.contains(word) {
                return true;
            }
        }
        if let Ok(commands) = AVAILABLE_COMMANDS.lock() {
            if commands.contains(word) {
                return true;
            }
        }
        false
    }
    
    fn find_token_range_heuristic(line: &str, start_byte: usize, token: &(String, String)) -> Option<Range<usize>> {
        let (sep, word) = token;
        let mut search_area = &line[start_byte..];
        let token_start_byte = if let Some(non_ws_offset) = search_area.find(|c: char| !c.is_whitespace()) {
            // Calculate the actual byte index of the first non-whitespace character
            start_byte + search_area.char_indices().nth(non_ws_offset).map_or(0, |(idx, _)| idx)
        } else {
            return None; // Only whitespace left
        };
    
        search_area = &line[token_start_byte..];
        
        let mut estimated_len = 0;
        let mut current_search_offset = 0;
        
        if !sep.is_empty() && search_area.starts_with(sep) {
            estimated_len += sep.len();
            current_search_offset += sep.len();
        }
        
        if search_area[current_search_offset..].starts_with(word) {
             estimated_len += word.len();
             current_search_offset += word.len();
             
            if !sep.is_empty() && search_area[current_search_offset..].starts_with(sep) {
                estimated_len += sep.len();
            }
    
            Some(token_start_byte..(token_start_byte + estimated_len))
    
        } else if word.is_empty() && !sep.is_empty() && search_area.starts_with(sep) && search_area[sep.len()..].starts_with(sep) {
             estimated_len += sep.len() * 2;
             Some(token_start_byte..(token_start_byte + estimated_len))
        }
        else {
            if search_area.starts_with(word) {
                 Some(token_start_byte..(token_start_byte + word.len()))
            } else {
                 None
            }
        }
    }
    
    impl Highlighter for CicadaHighlighter {
        fn highlight(&self, line: &str) -> Vec<(Range<usize>, Style)> {
            let mut styles = Vec::new();
            if line.is_empty() {
                return styles;
            }
    
            let line_info = parser_line::parse_line(line);
            if line_info.tokens.is_empty() {
                styles.push((0..line.len(), Style::Default));
                return styles;
            }
    
            let mut current_byte_idx = 0;
            let mut is_start_of_segment = true;
    
            for token in &line_info.tokens {
                // Find the range in the original line for this token
                match find_token_range_heuristic(line, current_byte_idx, token) {
                    Some(token_range) => {
                        // Style potential whitespace before the token
                        if token_range.start > current_byte_idx {
                            styles.push((current_byte_idx..token_range.start, Style::Default));
                        }
    
                        let (_sep, word) = token;
                        let mut current_token_style = Style::Default;
    
                        if is_start_of_segment && !word.is_empty() {
                            if is_command(word) {
                                current_token_style = Style::AnsiColor(GREEN.to_string());
                            }
                            // Only the first non-empty token in a segment can be a command
                            is_start_of_segment = false;
                        }
    
                        styles.push((token_range.clone(), current_token_style));
    
                        // Check if this token marks the end of a command segment
                        if ["|", "&&", "||", ";"].contains(&word.as_str()) {
                            is_start_of_segment = true;
                        }
    
                        current_byte_idx = token_range.end;
                    }
                    None => {
                        // If we can't map a token, style the rest of the line as default and stop.
                        if current_byte_idx < line.len() {
                           styles.push((current_byte_idx..line.len(), Style::Default));
                        }
                        current_byte_idx = line.len(); // Mark as done
                        break; // Stop processing further tokens
                    }
                }
            }
            
            if current_byte_idx < line.len() {
                styles.push((current_byte_idx..line.len(), Style::Default));
            }
    
            styles
        }
    }
    
    pub fn create_highlighter() -> Arc<CicadaHighlighter> {
        Arc::new(CicadaHighlighter)
    }
}

pub mod libs
{
    use ::
    {
        *,
    };

    pub mod colored
    {
        use ::
        {
            *,
        };
        // cicada special
        pub const SEQ: &str = "\x01";
        pub const END_SEQ: &str = "\x02";
        pub const ESC: &str = "\x1B";
        
        // Set
        pub const BOLD: &str = "\x01\x1B[1m\x02";
        pub const DIM: &str = "\x01\x1B[2m\x02";
        pub const UNDERLINED: &str = "\x01\x1B[4m\x02";
        pub const BLINK: &str = "\x01\x1B[5m\x02";
        pub const REVERSE: &str = "\x01\x1B[7m\x02";
        pub const HIDDEN: &str = "\x01\x1B[8m\x02";
        
        // Reset
        pub const RESET: &str = "\x01\x1B[0m\x02";
        pub const RESET_BOLD: &str = "\x01\x1B[21m\x02";
        pub const RESET_DIM: &str = "\x01\x1B[22m\x02";
        pub const RESET_UNDERLINED: &str = "\x01\x1B[24m\x02";
        pub const RESET_BLINK: &str = "\x01\x1B[25m\x02";
        pub const RESET_REVERSE: &str = "\x01\x1B[27m\x02";
        pub const RESET_HIDDEN: &str = "\x01\x1B[28m\x02";
        
        // Foreground (text)
        pub const DEFAULT: &str = "\x01\x1B[39m\x02";
        pub const BLACK: &str = "\x01\x1B[30m\x02";
        pub const RED: &str = "\x01\x1B[31m\x02";
        pub const GREEN: &str = "\x01\x1B[32m\x02";
        pub const YELLOW: &str = "\x01\x1B[33m\x02";
        pub const BLUE: &str = "\x01\x1B[34m\x02";
        pub const MAGENTA: &str = "\x01\x1B[35m\x02";
        pub const CYAN: &str = "\x01\x1B[36m\x02";
        pub const GRAY_L: &str = "\x01\x1B[37m\x02";
        
        pub const GRAY_D: &str = "\x01\x1B[90m\x02";
        pub const RED_L: &str = "\x01\x1B[91m\x02";
        pub const GREEN_L: &str = "\x01\x1B[92m\x02";
        pub const YELLOW_L: &str = "\x01\x1B[93m\x02";
        pub const BLUE_L: &str = "\x01\x1B[94m\x02";
        pub const MAGENTA_L: &str = "\x01\x1B[95m\x02";
        pub const CYAN_L: &str = "\x01\x1B[96m\x02";
        pub const WHITE: &str = "\x01\x1B[97m\x02";
        
        pub const BLUE_B: &str = "\x01\x1B[34m\x1B[1m\x02";
        pub const BLACK_B: &str = "\x01\x1B[30m\x1B[1m\x02";
        pub const WHITE_B: &str = "\x01\x1B[97m\x1B[1m\x02";
        pub const RED_B: &str = "\x01\x1B[31m\x1B[1m\x02";
        pub const GREEN_B: &str = "\x01\x1B[32m\x1B[1m\x02";
        
        // Background
        pub const DEFAULT_BG: &str = "\x01\x1B[49m\x02";
        pub const BLACK_BG: &str   = "\x01\x1B[40m\x02";
        pub const RED_BG: &str     = "\x01\x1B[41m\x02";
        pub const GREEN_BG: &str   = "\x01\x1B[42m\x02";
        pub const YELLOW_BG: &str   = "\x01\x1B[43m\x02";
        pub const BLUE_BG: &str    = "\x01\x1B[44m\x02";
        pub const MAGENTA_BG: &str    = "\x01\x1B[45m\x02";
        pub const CYAN_BG: &str    = "\x01\x1B[46m\x02";
        pub const GRAY_L_BG: &str    = "\x01\x1B[47m\x02";
        
        pub const GRAY_D_BG: &str   = "\x01\x1B[100m\x02";
        pub const RED_L_BG: &str   = "\x01\x1B[101m\x02";
        pub const GREEN_L_BG: &str   = "\x01\x1B[102m\x02";
        pub const YELLOW_L_BG: &str   = "\x01\x1B[103m\x02";
        pub const BLUE_L_BG: &str   = "\x01\x1B[104m\x02";
        pub const MAGENTA_L_BG: &str   = "\x01\x1B[105m\x02";
        pub const CYAN_L_BG: &str   = "\x01\x1B[106m\x02";
        pub const WHITE_BG: &str   = "\x01\x1B[107m\x02";
    }
    
    pub mod fork
    {
        use ::
        {
            *,
        };
        /*
        use nix::Result;
        use nix::uni ::{fork as nix_fork, ForkResult};
        */
        // make fork "safe again", in order not to touch the code in core.rs,
        // see https://github.com/nix-rust/nix/issues/586
        // we can have refactorings any time needed.
        pub fn fork() -> Result<ForkResult> {
            unsafe{ nix_fork() }
        }
    }
    
    pub mod os_type
    {
        use ::
        {
            *,
        };
        /*
        use crate::execute;
        */
        pub fn get_os_name() -> String {
            let uname = get_uname();
            if uname.to_lowercase() == "darwin" {
                get_macos_name()
            } else {
                get_other_os_name()
            }
        }
        
        fn get_other_os_name() -> String {
            let mut name = get_release_value("PRETTY_NAME");
            if !name.is_empty() {
                return name;
            }
            name = get_release_value("DISTRIB_DESCRIPTION");
            if !name.is_empty() {
                return name;
            }
            name = get_release_value("IMAGE_DESCRIPTION");
            if !name.is_empty() {
                return name;
            }
            get_uname_mo()
        }
        
        fn get_release_value(ptn: &str) -> String {
            let line = format!(
                "grep -i '{}' /etc/*release* 2>&1 | grep -o '=.*' | tr '\"=' ' '",
                ptn
            );
            let cr = execute::run(&line);
            return cr.stdout.trim().to_string();
        }
        
        fn get_uname() -> String {
            let cr = execute::run("uname");
            return cr.stdout.trim().to_string();
        }
        
        fn get_uname_mo() -> String {
            let cr = execute::run("uname -m -o");
            return cr.stdout.trim().to_string();
        }
        
        fn get_macos_name() -> String {
            let mut os_name = get_osx_codename();
            let ver = get_osx_version();
            if !ver.is_empty() {
                os_name.push(' ');
                os_name.push_str(&ver);
            }
            os_name
        }
        
        fn get_osx_codename() -> String {
            let cr = execute::run("grep -o 'SOFTWARE LICENSE AGREEMENT FOR .*[a-zA-Z]' '/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf' | sed 's/SOFTWARE LICENSE AGREEMENT FOR *//'");
            return cr.stdout.trim().to_string();
        }
        
        fn get_osx_version() -> String {
            let cr = execute::run("sw_vers -productVersion");
            return cr.stdout.trim().to_string();
        }
    }
    
    pub mod path
    {
        use ::
        {
            *,
        };
        /*
        use ::borrow::Cow;
        use ::env;
        use ::fs::read_dir;
        use ::io::{ErrorKind, Write};
        use ::os::unix::fs::PermissionsExt;
        
        use regex::Regex;
        
        use crate::tools;
        */
        pub fn basename(path: &str) -> Cow<'_, str> {
            let mut pieces = path.rsplit('/');
            match pieces.next() {
                Some(p) => p.into(),
                None => path.into(),
            }
        }
        
        pub fn expand_home(text: &str) -> String {
            let mut s: String = text.to_string();
            let v = vec![
                r"(?P<head> +)~(?P<tail> +)",
                r"(?P<head> +)~(?P<tail>/)",
                r"^(?P<head> *)~(?P<tail>/)",
                r"(?P<head> +)~(?P<tail> *$)",
            ];
            for item in &v {
                let re;
                if let Ok(x) = Regex::new(item) {
                    re = x;
                } else {
                    return String::new();
                }
                let home = tools::get_user_home();
                let ss = s.clone();
                let to = format!("$head{}$tail", home);
                let result = re.replace_all(ss.as_str(), to.as_str());
                s = result.to_string();
            }
            s
        }
        
        pub fn find_file_in_path(filename: &str, exec: bool) -> String {
            let env_path = match env::var("PATH") {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: error with env PATH: {:?}", e);
                    return String::new();
                }
            };
            let vec_path: Vec<&str> = env_path.split(':').collect();
            for p in &vec_path {
                match read_dir(p) {
                    Ok(list) => {
                        for entry in list.flatten() {
                            if let Ok(name) = entry.file_name().into_string() {
                                if name != filename {
                                    continue;
                                }
        
                                if exec {
                                    let _mode = match entry.metadata() {
                                        Ok(x) => x,
                                        Err(e) => {
                                            println_stderr!("cicada: metadata error: {:?}", e);
                                            continue;
                                        }
                                    };
                                    let mode = _mode.permissions().mode();
                                    if mode & 0o111 == 0 {
                                        // not binary
                                        continue;
                                    }
                                }
        
                                return entry.path().to_string_lossy().to_string();
                            }
                        }
                    }
                    Err(e) => {
                        if e.kind() == ErrorKind::NotFound {
                            continue;
                        }
                        log!("cicada: fs read_dir error: {}: {}", p, e);
                    }
                }
            }
            String::new()
        }
        
        pub fn current_dir() -> String {
            let _current_dir = match env::current_dir() {
                Ok(x) => x,
                Err(e) => {
                    log!("cicada: PROMPT: env current_dir error: {}", e);
                    return String::new();
                }
            };
            let current_dir = match _current_dir.to_str() {
                Some(x) => x,
                None => {
                    log!("cicada: PROMPT: to_str error");
                    return String::new();
                }
            };
        
            current_dir.to_string()
        }
    }
    
    pub mod re
    {
        use ::
        {
            *,
        };
        pub fn find_first_group(ptn: &str, text: &str) -> Option<String> {
            let re = match regex::Regex::new(ptn) {
                Ok(x) => x,
                Err(_) => return None,
            };
            match re.captures(text) {
                Some(caps) => {
                    if let Some(x) = caps.get(1) {
                        return Some(x.as_str().to_owned());
                    }
                }
                None => {
                    return None;
                }
            }
            None
        }
        
        pub fn re_contains(text: &str, ptn: &str) -> bool {
            let re = match regex::Regex::new(ptn) {
                Ok(x) => x,
                Err(e) => {
                    println!("Regex new error: {:?}", e);
                    return false;
                }
            };
            re.is_match(text)
        }
        
        pub fn replace_all(text: &str, ptn: &str, ptn_to: &str) -> String {
            let re = regex::Regex::new(ptn).unwrap();
            let result = re.replace_all(text, ptn_to);
            result.to_string()
        }
    }
    
    pub mod term_size
    {
        use ::
        {
            *,
        };
        /*
        use libc::{c_int, c_ulong, winsize, STDERR_FILENO, STDIN_FILENO, STDOUT_FILENO};
        use ::mem::zeroed;
        */
        #[cfg(any(target_os = "linux", target_os = "android"))]
        static TIOCGWINSZ: c_ulong = 0x5413;
        
        #[cfg(any(
            target_os = "macos",
            target_os = "ios",
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "netbsd",
            target_os = "openbsd"
        ))]
        static TIOCGWINSZ: c_ulong = 0x40087468;
        
        #[cfg(target_os = "solaris")]
        static TIOCGWINSZ: c_ulong = 0x5468;
        
        extern "C" {
            fn ioctl(fd: c_int, request: c_ulong, ...) -> c_int;
        }
        
        /// Runs the ioctl command. Returns (0, 0) if all of the streams are not to a terminal, or
        /// there is an error. (0, 0) is an invalid size to have anyway, which is why
        /// it can be used as a nil value.
        unsafe fn get_dimensions_any() -> winsize {
            let mut window: winsize = zeroed();
            let mut result = ioctl(STDOUT_FILENO, TIOCGWINSZ, &mut window);
        
            if result == -1 {
                window = zeroed();
                result = ioctl(STDIN_FILENO, TIOCGWINSZ, &mut window);
                if result == -1 {
                    window = zeroed();
                    result = ioctl(STDERR_FILENO, TIOCGWINSZ, &mut window);
                    if result == -1 {
                        return zeroed();
                    }
                }
            }
            window
        }
        
        /// Query the current processes's output (`stdout`), input (`stdin`), and error (`stderr`) in
        /// that order, in the attempt to dtermine terminal width. If one of those streams is actually
        /// a tty, this function returns its width and height as a number of characters.
        ///
        /// # Errors
        ///
        /// If *all* of the streams are not ttys or return any errors this function will return `None`.
        ///
        /// # Example
        ///
        /// To get the dimensions of your terminal window, simply use the following:
        ///
        /// ```ignore
        /// if let Some((w, h)) = term_size::dimensions() {
        ///     println!("Width: {}\nHeight: {}", w, h);
        /// } else {
        ///     println!("Unable to get term size :(")
        /// }
        /// ```
        pub fn dimensions() -> Option<(usize, usize)> {
            let w = unsafe { get_dimensions_any() };
        
            if w.ws_col == 0 || w.ws_row == 0 {
                None
            } else {
                Some((w.ws_col as usize, w.ws_row as usize))
            }
        }
    }
    
    pub mod progopts
    {
        use ::
        {
            *,
        };
        
        pub fn is_login(args: &[String]) -> bool {
            if !args.is_empty() && args[0].starts_with("-") {
                return true;
            }
        
            if args.len() > 1 && (args[1] == "--login" || args[1] == "-l") {
                return true;
            }
        
            if let Ok(term_program) = ::env::var("TERM_PROGRAM") {
                if term_program == "vscode" {
                    return true;
                }
            }
        
            false
        }
        
        pub fn is_script(args: &[String]) -> bool {
            args.len() > 1 && !args[1].starts_with("-")
        }
        
        pub fn is_command_string(args: &[String]) -> bool {
            args.len() > 1 && args[1] == "-c"
        }
        
        pub fn is_non_tty() -> bool {
            unsafe { libc::isatty(0) == 0 }
        }
    }
    
    pub mod pipes
    {
        use ::
        {
            *,
        };
        /*
        use ::os::fd::RawFd;
        use nix::Error;
        use ::mem;
        use libc::c_int;
        */
        pub fn pipe() -> ::result::Result<(RawFd, RawFd), Error> {
            let mut fds = mem::MaybeUninit::<[c_int; 2]>::uninit();
            let res = unsafe { libc::pipe(fds.as_mut_ptr() as *mut c_int) };
            Error::result(res)?;
            unsafe { Ok((fds.assume_init()[0], fds.assume_init()[1])) }
        }
    }
        
    pub fn close(fd: i32) { unsafe { libc::close(fd); } }
    
    pub fn dup(fd: i32) -> i32 { unsafe { libc::dup(fd) } }
    
    pub fn dup2(src: i32, dst: i32) { unsafe { libc::dup2(src, dst); } }
}

pub mod parsers
{
    use ::
    {
        *,
    };
    
    pub mod parser_line
    {
        use ::
        {
            *,
        };
        /*
        use regex::Regex;
        
        use crate::libs;
        use crate::tools;
        use crate::types::{LineInfo, Redirection, Tokens};
        */
        pub fn line_to_plain_tokens(line: &str) -> Vec<String> {
            let mut result = Vec::new();
            let linfo = parse_line(line);
            for (_, r) in linfo.tokens {
                result.push(r.clone());
            }
            result
        }
        
        pub fn tokens_to_args(tokens: &Tokens) -> Vec<String> {
            let mut result = Vec::new();
            for s in tokens {
                result.push(s.1.clone());
            }
            result
        }
        
        pub fn tokens_to_line(tokens: &Tokens) -> String {
            let mut result = String::new();
            for t in tokens {
                if t.0.is_empty() {
                    result.push_str(&t.1);
                } else {
                    let s = tools::wrap_sep_string(&t.0, &t.1);
                    result.push_str(&s);
                }
                result.push(' ');
            }
            if result.ends_with(' ') {
                let len = result.len();
                result.truncate(len - 1);
            }
            result
        }
        
        /// Parse command line for multiple commands.
        pub fn line_to_cmds(line: &str) -> Vec<String> {
            let mut result = Vec::new();
            let mut sep = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let len = line.chars().count();
            for (i, c) in line.chars().enumerate() {
                if has_backslash {
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }
        
                if c == '\\' && sep != "'" {
                    has_backslash = true;
                    continue;
                }
        
                if c == '#' {
                    if sep.is_empty() {
                        break;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == '\'' || c == '"' || c == '`' {
                    if sep.is_empty() {
                        sep.push(c);
                        token.push(c);
                        continue;
                    } else if sep == c.to_string() {
                        token.push(c);
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == '&' || c == '|' {
                    // needs watch ahead here
                    if sep.is_empty() {
                        if i + 1 == len {
                            // for bg commands, e.g. `ls &`
                            token.push(c);
                            continue;
                        } else {
                            let c_next = match line.chars().nth(i + 1) {
                                Some(x) => x,
                                None => {
                                    println!("chars nth error - should never happen");
                                    continue;
                                }
                            };
        
                            if c_next != c {
                                token.push(c);
                                continue;
                            }
                        }
                    }
        
                    if sep.is_empty() {
                        sep.push(c);
                        continue;
                    } else if c.to_string() == sep {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        token = String::new();
                        result.push(format!("{}{}", sep, sep));
                        sep = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                if c == ';' {
                    if sep.is_empty() {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push(_token);
                        }
                        result.push(String::from(";"));
                        token = String::new();
                        continue;
                    } else {
                        token.push(c);
                        continue;
                    }
                }
                token.push(c);
            }
            if !token.is_empty() {
                result.push(token.trim().to_string());
            }
            result
        }
        
        /// parse command line to tokens
        /// >>> parse_line("echo 'hi yoo' | grep \"hi\"");
        /// LineInfo {
        ///    tokens: vec![
        ///        ("", "echo"),
        ///        ("'", "hi yoo"),
        ///        ("", "|"),
        ///        ("", "grep"),
        ///        ("\"", "hi"),
        ///    ],
        ///    is_complete: true
        /// }
        // #[allow(clippy::cyclomatic_complexity)]
        pub fn parse_line(line: &str) -> LineInfo {
            let mut result = Vec::new();
            if tools::is_arithmetic(line) {
                for x in line.split(' ') {
                    result.push((String::from(""), x.to_string()));
                }
                return LineInfo::new(result);
            }
        
            let mut sep = String::new();
            let mut sep_second = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let mut met_parenthesis = false;
            let mut new_round = true;
            let mut skip_next = false;
            let mut has_dollar = false;
            let mut parens_left_ignored = false;
            let mut sep_made = String::new();
            let mut semi_ok = false;
            let count_chars = line.chars().count();
            
            for (i, c) in line.chars().enumerate() {
                if skip_next {
                    skip_next = false;
                    continue;
                }
        
                if has_backslash && sep.is_empty() && (c == '>' || c == '<') {
                    sep_made = String::from("'");
                    token.push(c);
                    has_backslash = false;
                    continue;
                }
        
                if has_backslash && sep == "\"" && c != '\"' {
                    // constant with bash: "\"" --> "; "\a" --> \a
                    token.push('\\');
                    token.push(c);
                    has_backslash = false;
                    continue;
                }
        
                if has_backslash {
                    if new_round && sep.is_empty() && (c == '|' || c == '$') && token.is_empty() {
                        sep = String::from("\\");
                        token = format!("{}", c);
                    } else {
                        token.push(c);
                    }
                    new_round = false;
                    has_backslash = false;
                    continue;
                }
        
                if c == '$' {
                    has_dollar = true;
                }
        
                // for cases like: echo $(foo bar)
                if c == '(' && sep.is_empty() {
                    if !has_dollar && token.is_empty() {
                        // temp solution for cmd like `(ls)`, `(ls -lh)`
                        parens_left_ignored = true;
                        continue;
                    }
                    met_parenthesis = true;
                }
                if c == ')' {
                    if parens_left_ignored && !has_dollar {
                        // temp solution for cmd like `(ls)`, `(ls -lh)`
                        if i == count_chars - 1 ||
                                (i + 1 < count_chars &&
                                 line.chars().nth(i + 1).unwrap() == ' ') {
                            continue;
                        }
                    }
                    if sep.is_empty() {
                        met_parenthesis = false;
                    }
                }
        
                if c == '\\' {
                    if sep == "'" || !sep_second.is_empty() {
                        token.push(c)
                    } else {
                        has_backslash = true;
                    }
                    continue;
                }
        
                if new_round {
                    if c == ' ' {
                        continue;
                    } else if c == '"' || c == '\'' || c == '`' {
                        sep = c.to_string();
                        new_round = false;
                        continue;
                    }
        
                    sep = String::new();
        
                    if c == '#' {
                        // handle inline comments
                        break;
                    }
        
                    if c == '|' {
                        if i + 1 < count_chars && line.chars().nth(i + 1).unwrap() == '|' {
                            result.push((String::from(""), "||".to_string()));
                            skip_next = true;
                        } else {
                            result.push((String::from(""), "|".to_string()));
                        }
                        new_round = true;
                        continue;
                    }
        
                    token.push(c);
                    new_round = false;
                    continue;
                }
        
                if c == '|' && !has_backslash {
                    if semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((sep.to_string(), token));
                        }
                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    } else if !met_parenthesis && sep_second.is_empty() && sep.is_empty() {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((String::from(""), token));
                        }
                        result.push((String::from(""), "|".to_string()));
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        continue;
                    }
                }
        
                if c == ' ' {
                    if semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((sep.to_string(), token));
                        }
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }
        
                    if has_backslash {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }
        
                    if met_parenthesis {
                        token.push(c);
                        continue;
                    }
        
                    if sep == "\\" {
                        result.push((String::from("\\"), token));
                        token = String::new();
                        new_round = true;
                        continue;
                    }
        
                    if sep.is_empty() {
                        if sep_second.is_empty() {
                            if sep.is_empty() && !sep_made.is_empty() {
                                result.push((sep_made.clone(), token));
                                sep_made = String::new();
                            } else {
                                result.push((String::from(""), token));
                            }
                            token = String::new();
                            new_round = true;
                            continue;
                        } else {
                            token.push(c);
                            continue;
                        }
                    } else {
                        token.push(c);
                        continue;
                    }
                }
        
                if c == '\'' || c == '"' || c == '`' {
                    if has_backslash {
                        has_backslash = false;
                        token.push(c);
                        continue;
                    }
        
                    if sep != c.to_string() && semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push((sep_made.to_string(), token));
                            sep_made = String::new();
                        } else {
                            result.push((sep.to_string(), token));
                        }
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        // do not use continue here!
                    }
        
                    if sep != c.to_string() && met_parenthesis {
                        token.push(c);
                        continue;
                    }
                    if sep.is_empty() && !sep_second.is_empty() && sep_second != c.to_string() {
                        token.push(c);
                        continue;
                    }
        
                    if sep.is_empty() {
                        let is_an_env = libs::re::re_contains(&token, r"^[a-zA-Z0-9_]+=.*$");
                        if !is_an_env && (c == '\'' || c == '"') {
                            sep = c.to_string();
                            continue;
                        }
        
                        token.push(c);
                        if sep_second.is_empty() {
                            sep_second = c.to_string();
                        } else if sep_second == c.to_string() {
                            sep_second = String::new();
                        }
                        continue;
                    } else if sep == c.to_string() {
                        semi_ok = true;
                        continue;
                    } else {
                        token.push(c);
                    }
                } else {
                    if has_backslash {
                        has_backslash = false;
                        if sep == "\"" || sep == "'" {
                            token.push('\\');
                        }
                    }
                    token.push(c);
                }
            }
            if !token.is_empty() || semi_ok {
                if sep.is_empty() && !sep_made.is_empty() {
                    result.push((sep_made.clone(), token));
                } else {
                    result.push((sep.clone(), token));
                }
            }
        
            let mut is_line_complete = true;
            if !result.is_empty() {
                let token_last = result[result.len() - 1].clone();
                if token_last.0.is_empty() && token_last.1 == "|" {
                    is_line_complete = false;
                }
            }
        
            if !sep.is_empty() {
                is_line_complete = semi_ok;
            }
            if has_backslash {
                is_line_complete = false;
            }
        
            LineInfo { tokens: result, is_complete: is_line_complete }
        }
        
        pub fn tokens_to_redirections(tokens: &Tokens) -> Result<(Tokens, Vec<Redirection>), String> {
            let mut tokens_new = Vec::new();
            let mut redirects = Vec::new();
            let mut to_be_continued = false;
            let mut to_be_continued_s1 = String::new();
            let mut to_be_continued_s2 = String::new();
        
            for token in tokens {
                let sep = &token.0;
                if !sep.is_empty() && !to_be_continued {
                    tokens_new.push(token.clone());
                    continue;
                }
                let word = &token.1;
        
                if to_be_continued {
                    if sep.is_empty() && word.starts_with('&') {
                        return Err(String::from("bad redirection syntax near &"));
                    }
        
                    let s3 = word.to_string();
                    if libs::re::re_contains(&to_be_continued_s1, r"^\d+$") {
                        if to_be_continued_s1 != "1" && to_be_continued_s1 != "2" {
                            return Err(String::from("Bad file descriptor #3"));
                        }
                        let s1 = to_be_continued_s1.clone();
                        let s2 = to_be_continued_s2.clone();
                        redirects.push((s1, s2, s3));
                    } else {
                        if !to_be_continued_s1.is_empty() {
                            tokens_new.push((sep.clone(), to_be_continued_s1.to_string()));
                        }
                        redirects.push(("1".to_string(), to_be_continued_s2.clone(), s3));
                    }
        
                    to_be_continued = false;
                    continue;
                }
        
                let ptn1 = r"^([^>]*)(>>?)([^>]+)$";
                let ptn2 = r"^([^>]*)(>>?)$";
                if !libs::re::re_contains(word, r">") {
                    tokens_new.push(token.clone());
                } else if libs::re::re_contains(word, ptn1) {
                    let re;
                    if let Ok(x) = Regex::new(ptn1) {
                        re = x;
                    } else {
                        return Err(String::from("Failed to build Regex"));
                    }
        
                    if let Some(caps) = re.captures(word) {
                        let s1 = caps.get(1).unwrap().as_str();
                        let s2 = caps.get(2).unwrap().as_str();
                        let s3 = caps.get(3).unwrap().as_str();
                        if s3.starts_with('&') && s3 != "&1" && s3 != "&2" {
                            return Err(String::from("Bad file descriptor #1"));
                        }
        
                        if libs::re::re_contains(s1, r"^\d+$") {
                            if s1 != "1" && s1 != "2" {
                                return Err(String::from("Bad file descriptor #2"));
                            }
                            redirects.push((s1.to_string(), s2.to_string(), s3.to_string()));
                        } else {
                            if !s1.is_empty() {
                                tokens_new.push((sep.clone(), s1.to_string()));
                            }
                            redirects.push((String::from("1"), s2.to_string(), s3.to_string()));
                        }
                    }
                } else if libs::re::re_contains(word, ptn2) {
                    let re;
                    if let Ok(x) = Regex::new(ptn2) {
                        re = x;
                    } else {
                        return Err(String::from("Failed to build Regex"));
                    }
        
                    if let Some(caps) = re.captures(word) {
                        let s1 = caps.get(1).unwrap().as_str();
                        let s2 = caps.get(2).unwrap().as_str();
        
                        to_be_continued = true;
                        to_be_continued_s1 = s1.to_string();
                        to_be_continued_s2 = s2.to_string();
                    }
                }
            }
        
            if to_be_continued {
                return Err(String::from("redirection syntax error"));
            }
        
            Ok((tokens_new, redirects))
        }
        
        pub fn unquote(text: &str) -> String {
            let mut new_str = String::from(text);
            for &c in ['"', '\''].iter() {
                if text.starts_with(c) && text.ends_with(c) {
                    new_str.remove(0);
                    new_str.pop();
                    break;
                }
            }
            new_str
        }
    }
    
    pub mod locust
    {
        use ::
        {
            *,
        };
        /*
        use pest::Parser;
        use pest::iterators::Pairs;
        use pest::error::Error; */
        #[derive(Parser)]
        #[grammar = "parsers/grammar.pest"]
        struct Locust;
        
        pub fn parse_lines(lines: &str) -> Result<Pairs<crate::parsers::locust::Rule>, Error<crate::parsers::locust::Rule>> {
            Locust::parse(Rule::EXP, lines)
        }

    }
}

pub mod prompt
{
    use ::
    {
        *,
    };
    /*
    
    use crate::libs;
    use crate::shell;
    
    use self::main::get_prompt_string;
    use self::main::render_prompt;
    pub use self::multilines::EnterFunction;
    */
    mod main
    {
        use ::
        {
            *,
        };
        /*
        use ::env;
        
        use crate::execute;
        use crate::libs;
        use crate::shell;
        */
        const DEFAULT_PROMPT: &str = "${COLOR_STATUS}$USER${RESET}\
            @${COLOR_STATUS}$HOSTNAME${RESET}: \
            ${COLOR_STATUS}$CWD${RESET}$ ";
        use super::preset::apply_preset_item;
        use super::preset::apply_pyenv;
        
        fn is_prefix_char(c: char) -> bool {
            c == '[' || c == '{'
        }
        
        fn is_suffix_char(c: char) -> bool {
            c == ']' || c == '}'
        }
        
        fn is_prompt_item_char(c: char, token: &str) -> bool {
            let s = c.to_string();
            if token.is_empty() {
                libs::re::re_contains(&s, r#"^[a-zA-Z_]$"#)
            } else {
                libs::re::re_contains(&s, r#"^[a-zA-Z0-9_]$"#)
            }
        }
        
        pub fn get_prompt_string() -> String {
            if let Ok(x) = env::var("PROMPT") {
                return x;
            }
            DEFAULT_PROMPT.to_string()
        }
        
        fn apply_prompt_item(sh: &shell::Shell, result: &mut String, token: &str) {
            if let Some(x) = sh.get_env(token) {
                result.push_str(&x);
                return;
            }
            apply_preset_item(sh, result, token);
        }
        
        fn apply_command(result: &mut String, token: &str, prefix: &str, suffix: &str) {
            let cr = execute::run(token);
            let output = cr.stdout.trim();
            if !output.is_empty() {
                result.push_str(prefix);
                result.push_str(output);
                result.push_str(suffix);
            }
        }
        
        pub fn render_prompt(sh: &shell::Shell, ps: &str) -> String {
            let mut prompt = String::new();
            apply_pyenv(&mut prompt);
        
            let mut met_dollar = false;
            let mut met_brace = false;
            let mut met_paren = false;
            let mut token = String::new();
            let mut prefix = String::new();
            let mut suffix = String::new();
            for c in ps.chars() {
                if met_dollar {
                    if c == '(' && !met_brace && !met_paren {
                        met_paren = true;
                        continue;
                    }
                    if c == ')' && met_paren {
                        apply_command(&mut prompt, &token, &prefix, &suffix);
                        token.clear();
                        prefix.clear();
                        suffix.clear();
                        met_dollar = false;
                        met_paren = false;
                        continue;
                    }
                    if c == '{' && !met_brace && !met_paren {
                        met_brace = true;
                        continue;
                    } else if c == '}' && met_brace {
                        apply_prompt_item(sh, &mut prompt, &token);
                        token.clear();
                        met_dollar = false;
                        met_brace = false;
                        continue;
                    } else if c == '$' {
                        if token.is_empty() {
                            // to make single $ as a plain $
                            prompt.push('$');
                            met_dollar = true;
                            continue;
                        } else {
                            apply_prompt_item(sh, &mut prompt, &token);
                            token.clear();
                            // met_dollar is still true
                            continue;
                        }
                    } else if met_paren {
                        if is_prefix_char(c) {
                            prefix.push(c);
                        } else if is_suffix_char(c) {
                            suffix.push(c);
                        } else {
                            token.push(c);
                        }
                        continue;
                    } else if is_prompt_item_char(c, &token) {
                        token.push(c);
                        continue;
                    } else if token.is_empty() {
                        prompt.push('$');
                        prompt.push(c);
                        met_dollar = false;
                        continue;
                    }
                }
        
                if c == '$' {
                    met_dollar = true;
                    continue;
                }
        
                if !token.is_empty() {
                    apply_prompt_item(sh, &mut prompt, &token);
                    token.clear();
                }
                prompt.push(c);
                met_dollar = false;
            }
        
            if !token.is_empty() {
                apply_prompt_item(sh, &mut prompt, &token);
                met_dollar = false;
            }
        
            if met_dollar {
                // for cases like PROMPT='$$'
                prompt.push('$');
            }
        
            if prompt.trim().is_empty() {
                return format!("cicada-{} >> ", env!("CARGO_PKG_VERSION"));
            }
            prompt
        }
    }
    
    mod preset
    {
        use ::
        {
            *,
        };
        /*
        use ::env;
        use ::fs::File;
        use ::io::{Read, Write};
        use ::path::Path;
        
        use crate::libs;
        use crate::shell;
        use crate::tools;
        */
        fn apply_seq(prompt: &mut String) {
            prompt.push_str(libs::colored::SEQ);
        }
        
        fn apply_end_seq(prompt: &mut String) {
            prompt.push_str(libs::colored::END_SEQ);
        }
        
        fn apply_esc(prompt: &mut String) {
            prompt.push_str(libs::colored::ESC);
        }
        
        fn apply_underlined(prompt: &mut String) {
            prompt.push_str(libs::colored::UNDERLINED);
        }
        
        fn apply_user(prompt: &mut String) {
            let username = tools::get_user_name();
            prompt.push_str(&username);
        }
        
        fn apply_black(prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK);
        }
        
        fn apply_black_b(prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK_B);
        }
        
        fn apply_black_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK_BG);
        }
        
        fn apply_blue(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE);
        }
        
        fn apply_blue_b(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_B);
        }
        
        fn apply_blue_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_BG);
        }
        
        fn apply_bold(prompt: &mut String) {
            prompt.push_str(libs::colored::BOLD);
        }
        
        fn apply_green(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN);
        }
        
        fn apply_green_b(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_B);
        }
        
        fn apply_green_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_BG);
        }
        
        fn apply_red(prompt: &mut String) {
            prompt.push_str(libs::colored::RED);
        }
        
        fn apply_red_b(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_B);
        }
        
        fn apply_red_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_BG);
        }
        
        fn apply_white(prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE);
        }
        
        fn apply_white_b(prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE_B);
        }
        
        fn apply_white_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE_BG);
        }
        
        fn apply_hidden(prompt: &mut String) {
            prompt.push_str(libs::colored::HIDDEN);
        }
        
        fn apply_reset(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET);
        }
        
        fn apply_reverse(prompt: &mut String) {
            prompt.push_str(libs::colored::REVERSE);
        }
        
        fn apply_dim(prompt: &mut String) {
            prompt.push_str(libs::colored::DIM);
        }
        
        fn apply_blink(prompt: &mut String) {
            prompt.push_str(libs::colored::BLINK);
        }
        
        fn apply_reset_underlined(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_UNDERLINED);
        }
        
        fn apply_reset_dim(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_DIM);
        }
        
        fn apply_reset_reverse(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_REVERSE);
        }
        
        fn apply_reset_hidden(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_HIDDEN);
        }
        
        fn apply_reset_blink(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_BLINK);
        }
        
        fn apply_reset_bold(prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_BOLD);
        }
        
        fn apply_default(prompt: &mut String) {
            prompt.push_str(libs::colored::DEFAULT);
        }
        
        fn apply_default_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::DEFAULT_BG);
        }
        
        fn apply_cyan(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN);
        }
        
        fn apply_cyan_l(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_L);
        }
        
        fn apply_cyan_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_BG);
        }
        
        fn apply_cyan_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_L_BG);
        }
        
        fn apply_red_l(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_L);
        }
        
        fn apply_red_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::RED_L_BG);
        }
        
        fn apply_green_l(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_L);
        }
        
        fn apply_green_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_L_BG);
        }
        
        fn apply_gray_l(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_L);
        }
        
        fn apply_gray_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_L_BG);
        }
        
        fn apply_gray_d(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_D);
        }
        
        fn apply_gray_d_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_D_BG);
        }
        
        fn apply_magenta(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA);
        }
        
        fn apply_magenta_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_BG);
        }
        
        fn apply_magenta_l(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_L);
        }
        
        fn apply_magenta_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_L_BG);
        }
        
        fn apply_yellow(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW);
        }
        
        fn apply_yellow_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_BG);
        }
        
        fn apply_yellow_l(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_L);
        }
        
        fn apply_yellow_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_L_BG);
        }
        
        fn apply_blue_l(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_L);
        }
        
        fn apply_blue_l_bg(prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_L_BG);
        }
        
        fn apply_color_status(sh: &shell::Shell, prompt: &mut String) {
            if sh.previous_status == 0 {
                prompt.push_str(libs::colored::GREEN_B);
            } else {
                prompt.push_str(libs::colored::RED_B);
            }
        }
        
        fn _find_git_root() -> String {
            let current_dir = libs::path::current_dir();
            let dir_git = format!("{}/.git", current_dir);
            if Path::new(&dir_git).exists() {
                return current_dir;
            }
        
            let mut _dir = current_dir.clone();
            while Path::new(&_dir).parent().is_some() {
                match Path::new(&_dir).parent() {
                    Some(p) => {
                        _dir = p.to_string_lossy().to_string();
                        let dir_git = format!("{}/.git", _dir);
                        if Path::new(&dir_git).exists() {
                            return _dir;
                        }
                    }
                    None => {
                        break;
                    }
                }
            }
        
            String::new()
        }
        
        fn apply_gitbr(prompt: &mut String) {
            let git_root = _find_git_root();
            if git_root.is_empty() {
                return;
            }
        
            let file_head = format!("{}/.git/HEAD", git_root);
            if !Path::new(&file_head).exists() {
                return;
            }
        
            let mut file;
            match File::open(&file_head) {
                Ok(x) => file = x,
                Err(e) => {
                    println!("cicada: .git/HEAD err: {:?}", e);
                    return;
                }
            }
            let mut text = String::new();
            match file.read_to_string(&mut text) {
                Ok(_) => {}
                Err(e) => {
                    println!("cicada: read_to_string error: {:?}", e);
                    return;
                }
            }
        
            if let Some(branch) = libs::re::find_first_group(r"^[a-z]+: ?[a-z]+/[a-z]+/(.+)$", text.trim())
            {
                apply_blue_b(prompt);
                if let Ok(x) = env::var("CICADA_GITBR_PREFIX") {
                    prompt.push_str(&x);
                }
        
                let _len_default: i32 = 32;
                let mut len_max = if let Ok(x) = env::var("CICADA_GITBR_MAX_LEN") {
                    match x.parse::<i32>() {
                        Ok(n) => n,
                        Err(_) => _len_default,
                    }
                } else {
                    _len_default
                };
                if len_max <= 0 {
                    len_max = _len_default;
                }
        
                if branch.len() as i32 <= len_max {
                    prompt.push_str(&branch);
                } else {
                    let len = branch.len() as i32;
                    let offset = (len - len_max + 2) as usize;
                    let branch_short = format!("..{}", &branch[offset..]);
                    prompt.push_str(&branch_short);
                }
                if let Ok(x) = env::var("CICADA_GITBR_SUFFIX") {
                    prompt.push_str(&x);
                }
                apply_reset(prompt);
            }
        }
        
        fn apply_cwd(prompt: &mut String) {
            let _current_dir = match env::current_dir() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: PROMPT: env current_dir error: {}", e);
                    return;
                }
            };
            let current_dir = match _current_dir.to_str() {
                Some(x) => x,
                None => {
                    println_stderr!("cicada: PROMPT: to_str error");
                    return;
                }
            };
            let _tokens: Vec<&str> = current_dir.split('/').collect();
        
            let last = match _tokens.last() {
                Some(x) => x,
                None => {
                    log!("cicada: PROMPT: token last error");
                    return;
                }
            };
        
            let home = tools::get_user_home();
            let pwd = if last.is_empty() {
                "/"
            } else if current_dir == home {
                "~"
            } else {
                last
            };
            prompt.push_str(pwd);
        }
        
        fn apply_hostname(prompt: &mut String) {
            let hostname = tools::get_hostname();
            prompt.push_str(&hostname);
        }
        
        fn apply_newline(prompt: &mut String) {
            prompt.push('\n');
        }
        
        pub fn apply_pyenv(prompt: &mut String) {
            if let Ok(x) = env::var("VIRTUAL_ENV") {
                if !x.is_empty() {
                    let _tokens: Vec<&str> = x.split('/').collect();
                    let env_name = match _tokens.last() {
                        Some(x) => x,
                        None => {
                            log!("prompt token last error");
                            return;
                        }
                    };
        
                    apply_blue_b(prompt);
                    prompt.push('(');
                    prompt.push_str(env_name);
                    prompt.push(')');
                    apply_reset(prompt);
                }
            }
        }
        
        pub fn apply_preset_item(sh: &shell::Shell, prompt: &mut String, token: &str) {
            match token.to_ascii_lowercase().as_ref() {
                "black" => apply_black(prompt),
                "black_b" => apply_black_b(prompt),
                "black_bg" => apply_black_bg(prompt),
                "blink" => apply_blink(prompt),
                "blue" => apply_blue(prompt),
                "blue_b" => apply_blue_b(prompt),
                "blue_bg" => apply_blue_bg(prompt),
                "blue_l" => apply_blue_l(prompt),
                "blue_l_bg" => apply_blue_l_bg(prompt),
                "bold" => apply_bold(prompt),
                "color_status" => apply_color_status(sh, prompt),
                "cwd" => apply_cwd(prompt),
                "cyan" => apply_cyan(prompt),
                "cyan_bg" => apply_cyan_bg(prompt),
                "cyan_l" => apply_cyan_l(prompt),
                "cyan_l_bg" => apply_cyan_l_bg(prompt),
                "default" => apply_default(prompt),
                "default_bg" => apply_default_bg(prompt),
                "dim" => apply_dim(prompt),
                "end_seq" => apply_end_seq(prompt),
                "esc" => apply_esc(prompt),
                "gitbr" => apply_gitbr(prompt),
                "gray_d" => apply_gray_d(prompt),
                "gray_d_bg" => apply_gray_d_bg(prompt),
                "gray_l" => apply_gray_l(prompt),
                "gray_l_bg" => apply_gray_l_bg(prompt),
                "green" => apply_green(prompt),
                "green_b" => apply_green_b(prompt),
                "green_bg" => apply_green_bg(prompt),
                "green_l" => apply_green_l(prompt),
                "green_l_bg" => apply_green_l_bg(prompt),
                "hidden" => apply_hidden(prompt),
                "hostname" => apply_hostname(prompt),
                "magenta" => apply_magenta(prompt),
                "magenta_bg" => apply_magenta_bg(prompt),
                "magenta_l" => apply_magenta_l(prompt),
                "magenta_l_bg" => apply_magenta_l_bg(prompt),
                "newline" => apply_newline(prompt),
                "red" => apply_red(prompt),
                "red_b" => apply_red_b(prompt),
                "red_bg" => apply_red_bg(prompt),
                "red_l" => apply_red_l(prompt),
                "red_l_bg" => apply_red_l_bg(prompt),
                "reset" => apply_reset(prompt),
                "reset_blink" => apply_reset_blink(prompt),
                "reset_bold" => apply_reset_bold(prompt),
                "reset_dim" => apply_reset_dim(prompt),
                "reset_hidden" => apply_reset_hidden(prompt),
                "reset_reverse" => apply_reset_reverse(prompt),
                "reset_underlined" => apply_reset_underlined(prompt),
                "reverse" => apply_reverse(prompt),
                "seq" => apply_seq(prompt),
                "underlined" => apply_underlined(prompt),
                "user" => apply_user(prompt),
                "white" => apply_white(prompt),
                "white_b" => apply_white_b(prompt),
                "white_bg" => apply_white_bg(prompt),
                "yellow" => apply_yellow(prompt),
                "yellow_bg" => apply_yellow_bg(prompt),
                "yellow_l" => apply_yellow_l(prompt),
                "yellow_l_bg" => apply_yellow_l_bg(prompt),
                _ => (),
            }
        }
    }
    
    mod multilines
    {
        use ::
        {
            *,
        };
        /*
        use ::io;
        use lineread::{Function, Prompter, Terminal};
        
        use crate::parsers::parser_line;
        */
        pub struct EnterFunction;
        
        impl<T: Terminal> Function<T> for EnterFunction 
        {
            fn execute(&self, prompter: &mut Prompter<T>, count: i32, _ch: char) -> io::Result<()> {
                let buf = prompter.buffer();
                let linfo = parser_line::parse_line(buf);
                if linfo.is_complete {
                    prompter.accept_input()
                } else if count > 0 {
                    match prompter.insert(count as usize, '\n') {
                        Ok(_) => {},
                        Err(e) => {
                            println!("sub-prompt error: {}", e);
                        }
                    }
                    prompter.insert_str(">> ")
                } else {
                    Ok(())
                }
            }
        }
    }

    fn get_prompt_len(prompt: &str) -> i32 
    {
        let mut count = 0;
        let mut met_x01 = false;
        for c in prompt.chars() {
            if c == '\x01' {
                met_x01 = true;
                continue;
            } else if c == '\x02' {
                met_x01 = false;
                continue;
            }
            if !met_x01 {
                count += 1;
            }
        }
        count
    }
    
    pub fn get_prompt(sh: &shell::Shell) -> String {
        let ps = get_prompt_string();
        let mut prompt = render_prompt(sh, &ps);
        if let Some((w, _h)) = libs::term_size::dimensions() {
            if get_prompt_len(&prompt) > (w / 2) as i32
                && !libs::re::re_contains(&ps, r#"(?i)\$\{?newline.\}?"#)
            {
                prompt.push_str("\n$ ");
            }
        } else {
            log!("ERROR: Failed to get term size");
        }
        prompt
    }
}

pub mod rcfile
{
    use ::
    {
        *,
    };
    /*
    use ::path::Path;
    
    use crate::scripting;
    use crate::shell;
    use crate::tools;
    */
    pub fn get_rc_file() -> String {
        let dir_config = tools::get_config_dir();
        let rc_file = format!("{}/cicadarc", dir_config);
        if Path::new(&rc_file).exists() {
            return rc_file;
        }
    
        // fail back to $HOME/.cicadarc
        let home = tools::get_user_home();
        let rc_file_home = format!("{}/{}", home, ".cicadarc");
        if Path::new(&rc_file_home).exists() {
            return rc_file_home;
        }
    
        // use std path if both absent
        rc_file
    }
    
    pub fn load_rc_files(sh: &mut shell::Shell) {
        let rc_file = get_rc_file();
        if !Path::new(&rc_file).exists() {
            return;
        }
    
        let args = vec!["source".to_string(), rc_file];
        scripting::run_script(sh, &args);
    }
}

pub mod run
{
    use ::
    {
        *,
    };
    /*
    use regex::Regex;
    
    use crate::shell;
    use crate::tools;
    use crate::types::{Command, CommandLine, CommandResult};
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::builtins::utils::print_stdout_with_capture;

    use crate::builtins::utils::print_stderr_with_capture;
    use crate::jobc;
    use crate::libc;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use ::env;
    use ::path::Path;
    
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::parsers;
    use crate::shell;
    use crate::tools;
    use crate::types::{Command, CommandLine, CommandResult};

    use crate::builtins::utils::print_stdout_with_capture;
    use crate::history;
    use crate::libs;
    use crate::rcfile;
    use crate::shell::Shell;
    use crate::types::{Command, CommandLine, CommandResult};

    use exec;
    
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::parsers;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    #![allow(unreachable_code)]
    use ::process;
    
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use regex::Regex;
    use ::env;
    
    use crate::libs;
    use crate::parsers;
    use crate::tools;
    
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use libc;
    
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::jobc;
    use crate::shell::{self, Shell};
    use crate::types::{CommandResult, CommandLine, Command};

    use ::path::Path;
    
    use rusqlite::Connection as Conn;
    use structopt::StructOpt;
    
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::builtins::utils::print_stdout_with_capture;
    use crate::ctime;
    use crate::history;
    use crate::parsers;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use crate::builtins::utils::print_stdout_with_capture;
    use crate::jobc;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use ::io;
    
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::shell::Shell;
    use crate::libs::re::re_contains;
    use crate::types::{CommandResult, CommandLine, Command};
    use crate::tools;

    use structopt::StructOpt;
    
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::builtins::utils::print_stdout_with_capture;
    use crate::parsers;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use crate::builtins::utils::print_stderr_with_capture;
    use crate::parsers;
    use crate::scripting;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use clap::{Parser, CommandFactory};
    use ::io::Error;
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::builtins::utils::print_stdout_with_capture;
    use crate::parsers;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use crate::builtins::utils::print_stderr_with_capture;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use crate::builtins::utils::print_stderr_with_capture;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use crate::builtins::utils::print_stderr_with_capture;
    use crate::shell::Shell;
    use crate::types::{CommandResult, CommandLine, Command};

    use ::fs::File;
    use ::io::Write;
    use ::os::unix::io::{FromRawFd, RawFd};
    
    use errno::errno;
    
    use crate::tools;
    use crate::types::{Command, CommandLine, CommandResult, Redirection};

    use ::env;
    use ::fs;
    use ::path::Path;
    
    use crate::builtins::utils::print_stderr_with_capture;
    use crate::builtins::utils::print_stdout_with_capture;
    use crate::execute;
    use crate::parsers;
    use crate::shell::{self, Shell};
    use crate::types::{self, CommandResult, CommandLine, Command};
    */
    #[derive(Debug, StructOpt)]
    #[structopt(name = "history", about = "History in cicada shell")]
    struct OptMainHistory 
    {
        #[structopt(short, long, help = "For current session only")]
        session: bool,
    
        #[structopt(short, long, help = "Search old items first")]
        asc: bool,
    
        #[structopt(short, long, help = "For current directory only")]
        pwd: bool,
    
        #[structopt(short, long, help = "Only show ROWID")]
        only_id: bool,
    
        #[structopt(short, long, help = "Do not show ROWID")]
        no_id: bool,
    
        #[structopt(short="d", long, help = "Show date")]
        show_date: bool,
    
        #[structopt(short, long, default_value = "20")]
        limit: i32,
    
        #[structopt(name = "PATTERN", default_value = "", help = "You can use % to match anything")]
        pattern: String,
    
        #[structopt(subcommand)]
        cmd: Option<SubCommand>
    }

    #[derive(Debug, StructOpt)]
    #[structopt(name = "set", about = "Set shell options (BETA)")]
    struct OptMainSet 
    {
        #[structopt(short, help = "exit on error status")]
        exit_on_error: bool,
    }

    #[derive(Parser)]
    #[command(name = "ulimit", about = "show / modify shell resource limits")]
    #[allow(non_snake_case)]
    struct App 
    {
        #[arg(short, help = "All current limits are reported.")]
        a: bool,
        #[arg(short, value_name = "NEW VALUE", help = "The maximum number of open file descriptors.")]
        n: Option<Option<u64>>,
        #[arg(short, value_name = "NEW VALUE", help = "The maximum size of core files created.")]
        c: Option<Option<u64>>,
        #[arg(short = 'S', help = "Set a soft limit for the given resource. (default)")]
        S: bool,
        #[arg(short = 'H', help = "Set a hard limit for the given resource.")]
        H: bool,
    }
    
    #[derive(StructOpt, Debug)]
    enum SubCommand 
    {
        #[structopt(about="Add new item into history")]
        Add 
        {
            #[structopt(short="t", long, help = "Specify a timestamp for the new item")]
            timestamp: Option<f64>,
    
            #[structopt(name="INPUT", help = "input to be added into history")]
            input: String,
        },
        #[structopt(about="Delete item from history")]
        Delete 
        {
            #[structopt(name="ROWID", help = "Row IDs of item to delete")]
            rowid: Vec<usize>,
        }
    }
    
    pub fn alias(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();
    
        if tokens.len() == 1 {
            return show_alias_list(sh, cmd, cl, capture);
        }
    
        if tokens.len() > 2 {
            let info = "alias syntax error: usage: alias foo='echo foo'";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }
    
        let input = &tokens[1].1;
        let re_single_read = Regex::new(r"^[a-zA-Z0-9_\.-]+$").unwrap();
        if re_single_read.is_match(input) {
            return show_single_alias(sh, input, cmd, cl, capture);
        }
    
        let re_to_add = Regex::new(r"^([a-zA-Z0-9_\.-]+)=(.*)$").unwrap();
        for cap in re_to_add.captures_iter(input) {
            let name = tools::unquote(&cap[1]);
            // due to limitation of `parses::parser_line`,
            // `alias foo-bar='foo bar'` will become 'foo-bar=foo bar'
            // while `alias foo_bar='foo bar'` keeps foo_bar='foo bar'
            let value = if cap[2].starts_with('"') || cap[2].starts_with('\'') {
                tools::unquote(&cap[2])
            } else {
                cap[2].to_string()
            };
            sh.add_alias(name.as_str(), value.as_str());
        }
    
        CommandResult::new()
    }
    
    pub fn bg(sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();
    
        if sh.jobs.is_empty() {
            let info = "cicada: bg: no job found";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }
    
        let mut job_id = -1;
        if tokens.len() == 1 {
            if let Some((gid, _)) = sh.jobs.iter().next() {
                job_id = *gid;
            }
        }
    
        if tokens.len() >= 2 {
            let mut job_str = tokens[1].1.clone();
            if job_str.starts_with("%") {
                job_str = job_str.trim_start_matches('%').to_string();
            }
    
            match job_str.parse::<i32>() {
                Ok(n) => job_id = n,
                Err(_) => {
                    let info = "cicada: bg: invalid job id";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }
        }
        if job_id == -1 {
            let info = "cicada: bg: not such job";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }
    
        let gid: i32;
    
        {
            let mut result = sh.get_job_by_id(job_id);
            // fall back to find job by using prcess group id
            if result.is_none() {
                result = sh.get_job_by_gid(job_id);
            }
    
            match result {
                Some(job) => {
                    unsafe {
                        libc::killpg(job.gid, libc::SIGCONT);
                        gid = job.gid;
                        if job.status == "Running" {
                            let info = format!("cicada: bg: job {} already in background", job.id);
                            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                            return cr;
                        }
                    }
    
                    let info_cmd = format!("[{}]  {} &", job.id, job.cmd);
                    print_stderr_with_capture(&info_cmd, &mut cr, cl, cmd, capture);
                    cr.status = 0;
                }
                None => {
                    let info = "cicada: bg: not such job";
                    print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                    return cr;
                }
            }
        }
    
        jobc::mark_job_as_running(sh, gid, true);
        cr
    }
    
    pub fn cd(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();
        let args = parsers::parser_line::tokens_to_args(&tokens);
    
        if args.len() > 2 {
            let info = "cicada: cd: too many argument";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }
    
        let str_current_dir = tools::get_current_dir();
    
        let mut dir_to = if args.len() == 1 {
            let home = tools::get_user_home();
            home.to_string()
        } else {
            args[1..].join("")
        };
    
        if dir_to == "-" {
            if sh.previous_dir.is_empty() {
                let info = "no previous dir";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                return cr;
            }
            dir_to = sh.previous_dir.clone();
        } else if !dir_to.starts_with('/') {
            dir_to = format!("{}/{}", str_current_dir, dir_to);
        }
    
        if !Path::new(&dir_to).exists() {
            let info = format!("cicada: cd: {}: No such file or directory", &args[1]);
            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
            return cr;
        }
    
        match Path::new(&dir_to).canonicalize() {
            Ok(p) => {
                dir_to = p.as_path().to_string_lossy().to_string();
            }
            Err(e) => {
                let info = format!("cicada: cd: error: {}", e);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }
        }
    
        match env::set_current_dir(&dir_to) {
            Ok(_) => {
                sh.current_dir = dir_to.clone();
                if str_current_dir != dir_to {
                    sh.previous_dir = str_current_dir.clone();
                    env::set_var("PWD", &sh.current_dir);
                };
                cr.status = 0;
                cr
            }
            Err(e) => {
                let info = format!("cicada: cd: {}", e);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                cr
            }
        }
    }
    
    pub fn c(_sh: &mut Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult // cinfo
    {
        let mut info = vec![];
        const VERSION: &str = env!("CARGO_PKG_VERSION");
        info.push(("version", VERSION));
    
        let os_name = libs::os_type::get_os_name();
        info.push(("os-name", &os_name));
    
        let hfile = history::get_history_file();
        info.push(("history-file", &hfile));
    
        let rcf = rcfile::get_rc_file();
        info.push(("rc-file", &rcf));
    
        let git_hash = env!("GIT_HASH");
        if !git_hash.is_empty() {
            info.push(("git-commit", env!("GIT_HASH")));
        }
    
        let git_branch = env!("GIT_BRANCH");
        let mut branch = String::new();
        if !git_branch.is_empty() {
            branch.push_str(git_branch);
            let git_status = env!("GIT_STATUS");
            if git_status != "0" {
                branch.push_str(" (dirty)");
            }
            info.push(("git-branch", &branch));
        }
    
        info.push(("built-with", env!("BUILD_RUSTC_VERSION")));
        info.push(("built-at", env!("BUILD_DATE")));
    
        let mut lines = Vec::new();
        for (k, v) in &info {
            // longest key above is 12-char length
            lines.push(format!("{: >12}: {}", k, v));
        }
        let buffer = lines.join("\n");
        let mut cr = CommandResult::new();
        print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
        cr
    }

    pub fn exe(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult // exec
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();
        let args = parsers::parser_line::tokens_to_args(&tokens);
        let len = args.len();
        if len == 1 {
         print_stderr_with_capture("invalid usage", &mut cr, cl, cmd, capture);
         return cr;
        }

        let mut _cmd = exec::Command::new(&args[1]);
        let err = _cmd.args(&args[2..len]).exec();
        let info = format!("cicada: exe: {}", err);
        print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
        cr
    }

    pub fn exit(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();
        if tokens.len() > 2 {
         let info = "cicada: exit: too many arguments";
         print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
         return cr;
        }

        if tokens.len() == 2 {
         let _code = &tokens[1].1;
         match _code.parse::<i32>() {
             Ok(x) => {
                 process::exit(x);
             }
             Err(_) => {
                 let info = format!("cicada: exit: {}: numeric argument required", _code);
                 print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                 process::exit(255);
             }
         }
        }

        for (_i, job) in sh.jobs.iter() {
         if !job.cmd.starts_with("nohup ") {
             let mut info = String::new();
             info.push_str("There are background jobs.");
             info.push_str("Run `jobs` to see details; `exit 1` to force quit.");
             print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
             return cr;
         }
        }

        process::exit(0);
        cr
    }

    pub fn export(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();

        let re_name_ptn = Regex::new(r"^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$").unwrap();
        for (_, text) in tokens.iter() {
         if text == "export" {
             continue;
         }

         if !tools::is_env(text) {
             let mut info = String::new();
             info.push_str("export: invalid command\n");
             info.push_str("usage: export XXX=YYY");
             print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
             return cr;
         }

         if !re_name_ptn.is_match(text) {
             let mut info = String::new();
             info.push_str("export: invalid command\n");
             info.push_str("usage: export XXX=YYY ZZ=123");
             print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
             return cr;
         }

         for cap in re_name_ptn.captures_iter(text) {
             let name = cap[1].to_string();
             let token = parsers::parser_line::unquote(&cap[2]);
             let value = libs::path::expand_home(&token);
             env::set_var(name, &value);
         }
        }
        cr
    }

    pub fn fg(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();

        if sh.jobs.is_empty() {
         let info = "cicada: fg: no job found";
         print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
         return cr;
        }

        let mut job_id = -1;
        if tokens.len() == 1 {
         if let Some((gid, _)) = sh.jobs.iter().next() {
             job_id = *gid;
         }
        }

        if tokens.len() >= 2 {
         let mut job_str = tokens[1].1.clone();
         if job_str.starts_with("%") {
             job_str = job_str.trim_start_matches('%').to_string();
         }

         match job_str.parse::<i32>() {
             Ok(n) => job_id = n,
             Err(_) => {
                 let info = "cicada: fg: invalid job id";
                 print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                 return cr;
             }
         }
        }

        if job_id == -1 {
         let info = "cicada: not job id found";
         print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
         return cr;
        }

        let gid: i32;
        let pid_list: Vec<i32>;

        {
         let mut result = sh.get_job_by_id(job_id);
         // fall back to find job by using prcess group id
         if result.is_none() {
             result = sh.get_job_by_gid(job_id);
         }

         match result {
             Some(job) => {
                 print_stderr_with_capture(&job.cmd, &mut cr, cl, cmd, capture);
                 cr.status = 0;

                 unsafe {
                     if !shell::give_terminal_to(job.gid) {
                         return CommandResult::error();
                     }

                     libc::killpg(job.gid, libc::SIGCONT);
                     pid_list = job.pids.clone();
                     gid = job.gid;
                 }
             }
             None => {
                 let info = "cicada: fg: no such job";
                 print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                 return cr;
             }
         }
        }

        unsafe {
         jobc::mark_job_as_running(sh, gid, false);

         let cr = jobc::wait_fg_job(sh, gid, &pid_list);

         let gid_shell = libc::getpgid(0);
         if !shell::give_terminal_to(gid_shell) {
             log!("failed to give term to back to shell : {}", gid_shell);
         }

         cr
        }
    }

    pub fn history(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let hfile = history::get_history_file();
        let path = Path::new(hfile.as_str());
        if !path.exists() {
        let info = "no history file";
        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
        return cr;
        }
        let conn = match Conn::open(&hfile) {
        Ok(x) => x,
        Err(e) => {
            let info = format!("history: sqlite error: {:?}", e);
            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
            return cr;
        }
        };

        let tokens = cmd.tokens.clone();
        let args = parsers::parser_line::tokens_to_args(&tokens);

        let show_usage = args.len() > 1 && (args[1] == "-h" || args[1] == "--help");
        let opt = OptMain::from_iter_safe(args);
        match opt {
        Ok(opt) => {
            match opt.cmd {
                Some(SubCommand::Delete {rowid: rowids}) => {
                    let mut _count = 0;
                    for rowid in rowids {
                        let _deleted = delete_history_item(&conn, rowid);
                        if _deleted {
                            _count += 1;
                        }
                    }
                    if _count > 0 {
                        let info = format!("deleted {} items", _count);
                        print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                    }
                    cr
                }
                Some(SubCommand::Add {timestamp: ts, input}) => {
                    let ts = ts.unwrap_or(0 as f64);
                    add_history(sh, ts, &input);
                    cr
                }
                None => {
                    let (str_out, str_err) = list_current_history(sh, &conn, &opt);
                    if !str_out.is_empty() {
                        print_stdout_with_capture(&str_out, &mut cr, cl, cmd, capture);
                    }
                    if !str_err.is_empty() {
                        print_stderr_with_capture(&str_err, &mut cr, cl, cmd, capture);
                    }
                    cr
                }
            }
        }
        Err(e) => {
            let info = format!("{}", e);
            if show_usage {
                print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                cr.status = 0;
            } else {
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                cr.status = 1;
            }
            cr
        }
        }
    }

    pub fn jobs(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        if sh.jobs.is_empty() {
        return cr;
        }

        // update status of jobs if any
        jobc::try_wait_bg_jobs(sh, false, false);

        let mut lines = Vec::new();
        let jobs = sh.jobs.clone();
        let no_trim = cmd.tokens.len() >= 2 && cmd.tokens[1].1 == "-f";
        for (_i, job) in jobs.iter() {
        let line = jobc::get_job_line(job, !no_trim);
        lines.push(line);
        }
        let buffer = lines.join("\n");

        print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
        cr
    }

    pub fn minfd(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();

        let fd = nix::fcntl::open(
        "/dev/null",
        nix::fcntl::OFlag::empty(),
        nix::sys::stat::Mode::empty()
        );
        match fd {
        Ok(fd) => {
            let info = format!("{}", fd);
            print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
            unsafe { libc::close(fd); }
        }
        Err(e) => {
            println_stderr!("cicada: minfd: error: {}", e);
        }
        }

        cr
    }

    pub fn read(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();

        let name_list: Vec<String>;
        if tokens.len() <= 1 {
        name_list = vec!["REPLY".to_string()];
        } else {
        name_list = tokens[1..].iter().map(|x| x.1.clone()).collect();
        if let Some(id_) = _find_invalid_identifier(&name_list) {
            let info = format!("cicada: read: `{}': not a valid identifier", id_);
            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
            return cr;
        }
        }

        let mut buffer = String::new();

        if cmd.has_here_string() {
        if let Some(redirect_from) = &cmd.redirect_from {
            buffer.push_str(&redirect_from.1);
            buffer.push('\n');
        }
        } else {
        match io::stdin().read_line(&mut buffer) {
            Ok(_) => {}
            Err(e) => {
                let info = format!("cicada: read: error in reading stdin: {:?}", e);
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                return cr;
            }
        }
        }

        let envs = cl.envs.clone();
        let value_list = tools::split_into_fields(sh, buffer.trim(), &envs);

        let idx_2rd_last = name_list.len() - 1;
        for i in 0..idx_2rd_last {
        let name = name_list.get(i);
        if name.is_none() {
            let info = "cicada: read: name index error";
            print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
            return cr;
        }
        let name = name.unwrap();

        let value = value_list.get(i).unwrap_or(&String::new()).clone();
        sh.set_env(name, &value);
        }

        let name_last = &name_list[idx_2rd_last];
        let value_left: String = if value_list.len() > idx_2rd_last {
        value_list[idx_2rd_last..].join(" ")
        } else {
        String::new()
        };
        sh.set_env(name_last, &value_left);
        cr
    }

    pub fn set(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = &cmd.tokens;
        let args = parsers::parser_line::tokens_to_args(tokens);
        let show_usage = args.len() > 1 && (args[1] == "-h" || args[1] == "--help");

        let opt = OptMain::from_iter_safe(args);
        match opt {
        Ok(opt) => {
            if opt.exit_on_error {
                sh.exit_on_error = true;
                cr
            } else {
                let info = "cicada: set: option not implemented";
                print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
                cr
            }
        }
        Err(e) => {
            let info = format!("{}", e);
            if show_usage {
                print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                cr.status = 0;
            } else {
                print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
                cr.status = 1;
            }
            cr
        }
        }
    }

    pub fn source(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = &cmd.tokens;
        let args = parsers::parser_line::tokens_to_args(tokens);

        if args.len() < 2 {
        let info = "cicada: source: no file specified";
        print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
        return cr;
        }

        let status = scripting::run_script(sh, &args);
        cr.status = status;
        cr
    }

    pub fn ulimit(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = &cmd.tokens;
        let args = parsers::parser_line::tokens_to_args(tokens);
    
        if args.contains(&"--help".to_string()) || args.contains(&"-h".to_string()) {
            App::command().print_help().unwrap();
            println!();
            return cr;
        }
    
        let app = App::parse_from(args);
    
        if app.H && app.S {
            println!("cicada: ulimit: Cannot both hard and soft.");
            cr.status = 1;
            return cr;
        }
    
        let mut all_stdout = String::new();
        let mut all_stderr = String::new();
    
        if app.a {
            report_all(&app, &mut all_stdout, &mut all_stderr);
        } else if handle_limit(app.n, "open_files", app.H, &mut all_stdout, &mut all_stderr)
            || handle_limit(app.c, "core_file_size", app.H, &mut all_stdout, &mut all_stderr) {
        } else {
            report_all(&app, &mut all_stdout, &mut all_stderr);
        }
    
        if !all_stdout.is_empty() {
            print_stdout_with_capture(&all_stdout, &mut cr, cl, cmd, capture);
        }
        if !all_stderr.is_empty() {
            print_stderr_with_capture(&all_stderr, &mut cr, cl, cmd, capture);
        }
    
        cr
    }

    pub fn unalias(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();

        if tokens.len() != 2 {
         let info = "cicada: unalias: syntax error";
         print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
         return cr;
        }

        let input = &tokens[1].1;
        if !sh.remove_alias(input) {
         let info = format!("cicada: unalias: {}: not found", input);
         print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
         return cr;
        }
        cr
    }

    pub fn unpath(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();

        if tokens.len() != 2 {
         let info = "cicada: unpath: syntax error";
         print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
         return cr;
        }

        let input = &tokens[1].1;
        sh.remove_path(input);
        cr
    }

    pub fn unset(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let tokens = cmd.tokens.clone();
        let mut cr = CommandResult::new();

        if tokens.len() != 2 {
         let info = "cicada: unset: syntax error";
         print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
         return cr;
        }

        let input = &tokens[1].1;
        if !sh.remove_env(input) {
         let info = format!("cicada: unset: invalid varname: {:?}", input);
         print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
         return cr;
        }
        cr
    }

    pub fn vox(sh: &mut shell::Shell, cl: &CommandLine, cmd: &Command, capture: bool) -> CommandResult
    {
        let mut cr = CommandResult::new();
        let tokens = cmd.tokens.clone();
        let args = parsers::parser_line::tokens_to_args(&tokens);
        let len = args.len();
        let subcmd = if len > 1 { &args[1] } else { "" };

        if len == 1 || (len == 2 && subcmd == "ls") {
         match get_all_venvs() {
             Ok(venvs) => {
                 let info = venvs.join("\n");
                 print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
                 return cr;
             }
             Err(reason) => {
                 print_stderr_with_capture(&reason, &mut cr, cl, cmd, capture);
                 return cr;
             }
         }
        }

        if len == 3 && subcmd == "create" {
         let pybin = match env::var("VIRTUALENV_PYBIN") {
             Ok(x) => x,
             Err(_) => "python3".to_string(),
         };
         let dir_venv = get_envs_home();
         let venv_name = args[2].to_string();
         let line = format!("{} -m venv \"{}/{}\"", pybin, dir_venv, venv_name);
         print_stderr_with_capture(&line, &mut cr, cl, cmd, capture);
         let cr_list = execute::run_command_line(sh, &line, false, false);
         return cr_list[0].clone();
        }

        if len == 3 && subcmd == "enter" {
         let _err = enter_env(sh, args[2].as_str());
         if !_err.is_empty() {
             print_stderr_with_capture(&_err, &mut cr, cl, cmd, capture);
         }
         cr
        } else if len == 2 && subcmd == "exit" {
         let _err = exit_env(sh);
         if !_err.is_empty() {
             print_stderr_with_capture(&_err, &mut cr, cl, cmd, capture);
         }
         cr
        } else {
         let info = "cicada: vox: invalid option";
         print_stderr_with_capture(info, &mut cr, cl, cmd, capture);
         cr
        }
    }
    
    pub fn print_stdout(info: &str, cmd: &Command, cl: &CommandLine)
    {
        let fd = _get_dupped_stdout_fd(cmd, cl);
        if fd == -1 {
            return;
        }
    
        unsafe {
            let mut f = File::from_raw_fd(fd);
            let info = info.trim_end_matches('\n');
            match f.write_all(info.as_bytes()) {
                Ok(_) => {},
                Err(e) => {
                    println_stderr!("write_all: error: {}", e);
                }
            }
            if !info.is_empty() {
                match f.write_all(b"\n") {
                    Ok(_) => {},
                    Err(e) => {
                        println_stderr!("write_all: error: {}", e);
                    }
                }
            }
        }
    }
    
    pub fn print_stderr(info: &str, cmd: &Command, cl: &CommandLine) 
    {
        let fd = _get_dupped_stderr_fd(cmd, cl);
        if fd == -1 {
            return;
        }
    
        unsafe {
            let mut f = File::from_raw_fd(fd);
            let info = info.trim_end_matches('\n');
            match f.write_all(info.as_bytes()) {
                Ok(_) => (),
                Err(e) => {
                    println_stderr!("write_all: error: {}", e);
                }
            }
    
            if !info.is_empty() {
                match f.write_all(b"\n") {
                    Ok(_) => (),
                    Err(e) => {
                        println_stderr!("write_all: error: {}", e);
                    }
                }
            }
        }
    }
    
    pub fn print_stderr_with_capture( info: &str, cr: &mut CommandResult, cl: &CommandLine, cmd: &Command, capture: bool )
    {
        cr.status = 1;
        if capture {
            cr.stderr = info.to_string();
        } else {
            print_stderr(info, cmd, cl);
        }
    }
    
    pub fn print_stdout_with_capture(info: &str, cr: &mut CommandResult, cl: &CommandLine, cmd: &Command, capture: bool)
    {
        cr.status = 0;
        if capture {
            cr.stdout = info.to_string();
        } else {
            print_stdout(info, cmd, cl);
        }
    }
    
    fn add_history(sh: &Shell, ts: f64, input: &str) 
    {
        let (tsb, tse) = (ts, ts + 1.0);
        history::add_raw(sh, input, 0, tsb, tse);
    }

    fn list_current_history(sh: &Shell, conn: &Conn, opt: &OptMain) -> (String, String) 
    {
        let mut result_stderr = String::new();
        let result_stdout = String::new();

        let history_table = history::get_history_table();
        let mut sql = format!("SELECT ROWID, inp, tsb FROM {} WHERE ROWID > 0",
                          history_table);
        if !opt.pattern.is_empty() {
        sql = format!("{} AND inp LIKE '%{}%'", sql, opt.pattern)
        }
        if opt.session {
        sql = format!("{} AND sessionid = '{}'", sql, sh.session_id)
        }
        if opt.pwd {
        sql = format!("{} AND info like '%dir:{}|%'", sql, sh.current_dir)
        }

        if opt.asc {
        sql = format!("{} ORDER BY tsb", sql);
        } else {
        sql = format!("{} order by tsb desc", sql);
        };
        sql = format!("{} limit {} ", sql, opt.limit);

        let mut stmt = match conn.prepare(&sql) {
        Ok(x) => x,
        Err(e) => {
            let info = format!("history: prepare select error: {:?}", e);
            result_stderr.push_str(&info);
            return (result_stdout, result_stderr);
        }
        };

        let mut rows = match stmt.query([]) {
        Ok(x) => x,
        Err(e) => {
            let info = format!("history: query error: {:?}", e);
            result_stderr.push_str(&info);
            return (result_stdout, result_stderr);
        }
        };

        let mut lines = Vec::new();
        loop {
        match rows.next() {
            Ok(_rows) => {
                if let Some(row) = _rows {
                    let row_id: i32 = match row.get(0) {
                        Ok(x) => x,
                        Err(e) => {
                            let info = format!("history: error: {:?}", e);
                            result_stderr.push_str(&info);
                            return (result_stdout, result_stderr);
                        }
                    };
                    let inp: String = match row.get(1) {
                        Ok(x) => x,
                        Err(e) => {
                            let info = format!("history: error: {:?}", e);
                            result_stderr.push_str(&info);
                            return (result_stdout, result_stderr);
                        }
                    };

                    if opt.no_id {
                        lines.push(inp.to_string());
                    } else if opt.only_id {
                        lines.push(row_id.to_string());
                    } else if opt.show_date {
                        let tsb: f64 = match row.get(2) {
                            Ok(x) => x,
                            Err(e) => {
                                let info = format!("history: error: {:?}", e);
                                result_stderr.push_str(&info);
                                return (result_stdout, result_stderr);
                            }
                        };
                        let dt = ctime::DateTime::from_timestamp(tsb);
                        lines.push(format!("{}: {}: {}", row_id, dt, inp));
                    } else {
                        lines.push(format!("{}: {}", row_id, inp));
                    }
                } else {
                    break;
                }
            }
            Err(e) => {
                let info = format!("history: rows next error: {:?}", e);
                result_stderr.push_str(&info);
                return (result_stdout, result_stderr);
            }
        }
        }

        if !opt.asc {
        lines.reverse();
        }

        let buffer = lines.join("\n");

        (buffer, result_stderr)
    }

    fn delete_history_item(conn: &Conn, rowid: usize) -> bool 
    {
        let history_table = history::get_history_table();
        let sql = format!("DELETE from {} where rowid = {}", history_table, rowid);
        match conn.execute(&sql, []) {
        Ok(_) => true,
        Err(e) => {
            log!("history: error when delete: {:?}", e);
            false
        }
        }
    }
    
    fn show_alias_list(sh: &shell::Shell, cmd: &Command, cl: &CommandLine, capture: bool) -> CommandResult
    {
        let mut lines = Vec::new();
        for (name, value) in sh.get_alias_list() {
            let line = format!("alias {}='{}'", name, value);
            lines.push(line);
        }
        let buffer = lines.join("\n");
        let mut cr = CommandResult::new();
        print_stdout_with_capture(&buffer, &mut cr, cl, cmd, capture);
        cr
    }
    
    fn show_single_alias(sh: &shell::Shell, name_to_find: &str, cmd: &Command, cl: &CommandLine, capture: bool) -> CommandResult 
    {
        let mut cr = CommandResult::new();
        if let Some(content) = sh.get_alias_content(name_to_find) {
            let info = format!("alias {}='{}'", name_to_find, content);
            print_stdout_with_capture(&info, &mut cr, cl, cmd, capture);
        } else {
            let info = format!("cicada: alias: {}: not found", name_to_find);
            print_stderr_with_capture(&info, &mut cr, cl, cmd, capture);
        }
        cr
    }

    fn _find_invalid_identifier(name_list: &Vec<String>) -> Option<String> 
    {
        for id_ in name_list {
            if !re_contains(id_, r"^[a-zA-Z_][a-zA-Z0-9_]*$") {
                return Some(id_.to_string());
            }
        }
        None
    }

    fn set_limit(limit_name: &str, value: u64, for_hard: bool) -> String
    {
        let limit_id = match limit_name {
            "open_files" => libc::RLIMIT_NOFILE,
            "core_file_size" => libc::RLIMIT_CORE,
            _ => return String::from("invalid limit name"),
        };
    
        let mut rlp = libc::rlimit { rlim_cur: 0, rlim_max: 0 };
    
        unsafe {
            if libc::getrlimit(limit_id, &mut rlp) != 0 {
                return format!("cicada: ulimit: error getting limit: {}", Error::last_os_error());
            }
        }
    
        // to support armv7-linux-gnueabihf & 32-bit musl systems
        if for_hard {
            #[cfg(all(target_pointer_width = "32", target_env = "gnu"))]
            { rlp.rlim_max = value as u32; }
            #[cfg(not(all(target_pointer_width = "32", target_env = "gnu")))]
            { rlp.rlim_max = value; }
        } else {
            #[cfg(all(target_pointer_width = "32", target_env = "gnu"))]
            { rlp.rlim_cur = value as u32; }
            #[cfg(not(all(target_pointer_width = "32", target_env = "gnu")))]
            { rlp.rlim_cur = value; }
        }
    
        unsafe {
            if libc::setrlimit(limit_id, &rlp) != 0 {
                return format!("cicada: ulimit: error setting limit: {}", Error::last_os_error());
            }
        }
    
        String::new()
    }
    
    fn get_limit(limit_name: &str, single_print: bool, for_hard: bool) -> (String, String)
    {
        let (desc, limit_id) = match limit_name {
            "open_files" => ("open files", libc::RLIMIT_NOFILE),
            "core_file_size" => ("core file size", libc::RLIMIT_CORE),
            _ => return (String::new(), String::from("ulimit: error: invalid limit name")),
        };
    
        let mut rlp = libc::rlimit { rlim_cur: 0, rlim_max: 0 };
    
        let mut result_stdout = String::new();
        let mut result_stderr = String::new();
    
        unsafe {
            if libc::getrlimit(limit_id, &mut rlp) != 0 {
                result_stderr.push_str(&format!("error getting limit: {}", Error::last_os_error()));
                return (result_stdout, result_stderr);
            }
    
            let to_print = if for_hard { rlp.rlim_max } else { rlp.rlim_cur };
    
            let info = if to_print == libc::RLIM_INFINITY {
                if single_print { "unlimited\n".to_string() } else { format!("{}\t\tunlimited\n", desc) }
            } else if single_print {
                format!("{}\n", to_print)
            } else {
                format!("{}\t\t{}\n", desc, to_print)
            };
    
            result_stdout.push_str(&info);
        }
    
        (result_stdout, result_stderr)
    }
    
    fn report_all(app: &App, all_stdout: &mut String, all_stderr: &mut String)
    {
        for limit_name in &["open_files", "core_file_size"] {
            let (out, err) = get_limit(limit_name, false, app.H);
            all_stdout.push_str(&out);
            all_stderr.push_str(&err);
        }
    }
    
    fn handle_limit
    (
        limit_option: Option<Option<u64>>,
        limit_name: &str,
        for_hard: bool,
        all_stdout: &mut String,
        all_stderr: &mut String
    ) -> bool 
    {
        match limit_option {
            None => false,
            Some(None) => {
                let (out, err) = get_limit(limit_name, true, for_hard);
                all_stdout.push_str(&out);
                all_stderr.push_str(&err);
                true
            }
            Some(Some(value)) => {
                let err = set_limit(limit_name, value, for_hard);
                if !err.is_empty() {
                    all_stderr.push_str(&err);
                }
                true
            }
        }
    }
    /// Helper function to get (stdout, stderr) pairs for redirections
    fn _get_std_fds(redirects: &[Redirection]) -> (Option<RawFd>, Option<RawFd>) {
        if redirects.is_empty() {
            return (None, None);
        }
    
        let mut fd_out = None;
        let mut fd_err = None;
    
        for i in 0..redirects.len() {
            let item = &redirects[i];
            if item.0 == "1" {
                // 1>&2
                let mut _fd_candidate = None;
    
                if item.2 == "&2" {
                    let (_fd_out, _fd_err) = _get_std_fds(&redirects[i+1..]);
                    if let Some(fd) = _fd_err {
                        _fd_candidate = Some(fd);
                    } else {
                        _fd_candidate = unsafe { Some(libc::dup(2)) };
                    }
                } else {  // 1> foo.log
                    let append = item.1 == ">>";
                    if let Ok(fd) = tools::create_raw_fd_from_file(&item.2, append) {
                        _fd_candidate = Some(fd);
                    }
                }
    
                // for command like this: `alias > a.txt > b.txt > c.txt`,
                // we need to return the last one, but close the previous two.
                if let Some(fd) = fd_out {
                    unsafe { libc::close(fd); }
                }
    
                fd_out = _fd_candidate;
            }
    
            if item.0 == "2" {
                // 2>&1
                let mut _fd_candidate = None;
    
                if item.2 == "&1" {
                    if let Some(fd) = fd_out {
                        _fd_candidate = unsafe { Some(libc::dup(fd)) };
                    }
                } else {  // 2>foo.log
                    let append = item.1 == ">>";
                    if let Ok(fd) = tools::create_raw_fd_from_file(&item.2, append) {
                        _fd_candidate = Some(fd);
                    }
                }
    
                if let Some(fd) = fd_err {
                    unsafe { libc::close(fd); }
                }
    
                fd_err = _fd_candidate;
            }
        }
    
        (fd_out, fd_err)
    }
    
    fn _get_dupped_stdout_fd(cmd: &Command, cl: &CommandLine) -> RawFd {
        // if with pipeline, e.g. `history | grep foo`, then we don't need to
        // dup stdout since it is running in a sperated process, whose fd can
        // be dropped after use.
        if cl.with_pipeline() {
            return 1;
        }
    
        let (_fd_out, _fd_err) = _get_std_fds(&cmd.redirects_to);
        if let Some(fd) = _fd_err {
            unsafe { libc::close(fd); }
        }
        if let Some(fd) = _fd_out {
            fd
        } else {
            let fd = unsafe { libc::dup(1) };
            if fd == -1 {
                let eno = errno();
                println_stderr!("cicada: dup: {}", eno);
            }
            fd
        }
    }
    
    fn _get_dupped_stderr_fd(cmd: &Command, cl: &CommandLine) -> RawFd {
        if cl.with_pipeline() {
            return 2;
        }
    
        let (_fd_out, _fd_err) = _get_std_fds(&cmd.redirects_to);
        if let Some(fd) = _fd_out {
            unsafe { libc::close(fd); }
        }
    
        if let Some(fd) = _fd_err {
            fd
        } else {
            let fd = unsafe { libc::dup(2) };
            if fd == -1 {
                let eno = errno();
                println_stderr!("cicada: dup: {}", eno);
            }
            fd
        }
    }

    fn in_env() -> bool { env::var("VIRTUAL_ENV").map_or(false, |x| !x.is_empty()) }
    
    fn get_envs_home() -> String { env::var("VIRTUALENV_HOME").unwrap_or_default() }
    
    fn get_all_venvs() -> Result<Vec<String>, String>
    {
        let home_envs = get_envs_home();
        if home_envs.is_empty() {
            let info = String::from("you need to set VIRTUALENV_HOME to use vox");
            return Err(info);
        }
        if !Path::new(home_envs.as_str()).exists() {
            match fs::create_dir_all(home_envs.as_str()) {
                Ok(_) => {}
                Err(e) => {
                    let info = format!("fs create_dir_all failed: {:?}", e);
                    return Err(info);
                }
            }
        }
    
        let mut venvs = Vec::new();
        let pdir = home_envs.clone();
        if let Ok(list) = fs::read_dir(home_envs) {
            for ent in list.flatten() {
                let ent_name = ent.file_name();
                if let Ok(path) = ent_name.into_string() {
                    let full_path = format!("{}/{}/bin/activate", pdir, path);
                    if !Path::new(full_path.as_str()).exists() {
                        continue;
                    }
                    venvs.push(path);
                }
            }
        }
    
        Ok(venvs)
    }
    
    fn enter_env(sh: &Shell, path: &str) -> String
    {
        if in_env() {
            return "vox: already in env".to_string();
        }
    
        let home_envs = get_envs_home();
        let full_path = format!("{}/{}/bin/activate", home_envs, path);
        if !Path::new(full_path.as_str()).exists() {
            return format!("no such env: {}", full_path);
        }
    
        let path_env = format!("{}/{}", home_envs, path);
        env::set_var("VIRTUAL_ENV", &path_env);
        let path_new = String::from("${VIRTUAL_ENV}/bin:$PATH");
        let mut tokens: types::Tokens = Vec::new();
        tokens.push((String::new(), path_new));
        shell::expand_env(sh, &mut tokens);
        env::set_var("PATH", &tokens[0].1);
        String::new()
    }
    
    fn exit_env(sh: &Shell) -> String
    {
        if !in_env() {
            return String::from("vox: not in an env");
        }
    
        let env_path = match env::var("PATH") {
            Ok(x) => x,
            Err(_) => {
                return String::from("vox: cannot read PATH env");
            }
        };
    
        let mut _tokens: Vec<&str> = env_path.split(':').collect();
        let mut path_virtual_env = String::from("${VIRTUAL_ENV}/bin");
        // shell::extend_env(sh, &mut path_virtual_env);
        let mut tokens: types::Tokens = Vec::new();
        tokens.push((String::new(), path_virtual_env));
        shell::expand_env(sh, &mut tokens);
        path_virtual_env = tokens[0].1.clone();
        _tokens
            .iter()
            .position(|&n| n == path_virtual_env)
            .map(|e| _tokens.remove(e));
        let env_path_new = _tokens.join(":");
        env::set_var("PATH", &env_path_new);
        env::set_var("VIRTUAL_ENV", "");
    
        String::new()
    }
}

pub mod scripting
{
    use ::
    {
        *,
    };
    /*
    use ::fs::File;
    use ::io::{Read, Write, ErrorKind};
    use ::path::Path;
    
    use pest::iterators::Pair;
    use regex::{Regex, RegexBuilder};
    
    use crate::execute;
    use crate::libs;
    use crate::parsers;
    use crate::shell;
    use crate::types;
    use crate::types::CommandResult;
    */
    pub fn run_script(sh: &mut shell::Shell, args: &Vec<String>) -> i32 {
        let src_file = &args[1];
        let full_src_file: String;
        if src_file.contains('/') {
            full_src_file = src_file.clone();
        } else {
            let full_path = libs::path::find_file_in_path(src_file, false);
            if full_path.is_empty() {
                // not in PATH and not in current work directory
                if !Path::new(src_file).exists() {
                    println_stderr!("cicada: {}: no such file", src_file);
                    return 1;
                }
                full_src_file = format!("./{}", src_file);
            } else {
                full_src_file = full_path.clone();
            }
        }
    
        if !Path::new(&full_src_file).exists() {
            println_stderr!("cicada: {}: no such file", src_file);
            return 1;
        }
        if Path::new(&full_src_file).is_dir() {
            println_stderr!("cicada: {}: is a directory", src_file);
            return 1;
        }
    
        let mut file;
        match File::open(&full_src_file) {
            Ok(x) => file = x,
            Err(e) => {
                println_stderr!("cicada: {}: failed to open file - {:?}", &full_src_file, e.kind());
                return 1;
            }
        }
        let mut text = String::new();
        match file.read_to_string(&mut text) {
            Ok(_) => {}
            Err(e) => {
                match e.kind() {
                    ErrorKind::InvalidData => {
                        println_stderr!("cicada: {}: not a valid script file", &full_src_file);
                    }
                    _ => {
                        println_stderr!("cicada: {}: error: {:?}", &full_src_file, e);
                    }
                }
                return 1;
            }
        }
    
        if text.contains("\\\n") {
            let re = RegexBuilder::new(r#"([ \t]*\\\n[ \t]+)|([ \t]+\\\n[ \t]*)"#)
                .multi_line(true).build().unwrap();
            text = re.replace_all(&text, " ").to_string();
    
            let re = RegexBuilder::new(r#"\\\n"#).multi_line(true).build().unwrap();
            text = re.replace_all(&text, "").to_string();
        }
    
        let re_func_head = Regex::new(r"^function ([a-zA-Z_-][a-zA-Z0-9_-]*) *(?:\(\))? *\{$").unwrap();
        let re_func_tail = Regex::new(r"^\}$").unwrap();
        let mut text_new = String::new();
        let mut enter_func = false;
        let mut func_name = String::new();
        let mut func_body = String::new();
        for line in text.clone().lines() {
            if re_func_head.is_match(line.trim()) {
                enter_func = true;
                let cap = re_func_head.captures(line.trim()).unwrap();
                func_name = cap[1].to_string();
                func_body = String::new();
                continue;
            }
            if re_func_tail.is_match(line.trim()) {
                sh.set_func(&func_name, &func_body);
                enter_func = false;
                continue;
            }
            if enter_func {
                func_body.push_str(line);
                func_body.push('\n');
            } else {
                text_new.push_str(line);
                text_new.push('\n');
            }
        }
    
        let mut status = 0;
        let cr_list = run_lines(sh, &text_new, args, false);
        if let Some(last) = cr_list.last() {
            status = last.status;
        }
    
        // FIXME: We probably need to fix the issue in the `set` builtin,
        // which currently set `exit_on_error` at the shell session level,
        // we should instead set in a script-level.
        // Here is a work-around ugly fix.
        sh.exit_on_error = false;
    
        status
    }
    
    pub fn run_lines(sh: &mut shell::Shell,
                     lines: &str,
                     args: &Vec<String>,
                     capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        match parsers::locust::parse_lines(lines) {
            Ok(pairs_exp) => {
                for pair in pairs_exp {
                    let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, false, capture);
                    cr_list.append(&mut _cr_list);
                }
            }
            Err(e) => {
                println_stderr!("syntax error: {:?}", e);
                return cr_list;
            }
        }
        cr_list
    }
    
    fn expand_args(line: &str, args: &[String]) -> String {
        let linfo = parsers::parser_line::parse_line(line);
        let mut tokens = linfo.tokens;
        expand_args_in_tokens(&mut tokens, args);
        parsers::parser_line::tokens_to_line(&tokens)
    }
    
    fn expand_line_to_toknes(line: &str,
                             args: &[String],
                             sh: &mut shell::Shell) -> types::Tokens {
        let linfo = parsers::parser_line::parse_line(line);
        let mut tokens = linfo.tokens;
        expand_args_in_tokens(&mut tokens, args);
        shell::do_expansion(sh, &mut tokens);
        tokens
    }
    
    fn is_args_in_token(token: &str) -> bool {
        libs::re::re_contains(token, r"\$\{?[0-9@]+\}?")
    }
    
    fn expand_args_for_single_token(token: &str, args: &[String]) -> String {
        let re = Regex::new(r"^(.*?)\$\{?([0-9]+|@)\}?(.*)$").unwrap();
        if !re.is_match(token) {
            return token.to_string();
        }
    
        let mut result = String::new();
        let mut _token = token.to_string();
        let mut _head = String::new();
        let mut _output = String::new();
        let mut _tail = String::new();
        loop {
            if !re.is_match(&_token) {
                if !_token.is_empty() {
                    result.push_str(&_token);
                }
                break;
            }
            for cap in re.captures_iter(&_token) {
                _head = cap[1].to_string();
                _tail = cap[3].to_string();
                let _key = cap[2].to_string();
                if _key == "@" {
                    result.push_str(format!("{}{}", _head, args[1..].join(" ")).as_str());
                } else if let Ok(arg_idx) = _key.parse::<usize>() {
                    if arg_idx < args.len() {
                        result.push_str(format!("{}{}", _head, args[arg_idx]).as_str());
                    } else {
                        result.push_str(&_head);
                    }
                } else {
                    result.push_str(&_head);
                }
            }
    
            if _tail.is_empty() {
                break;
            }
            _token = _tail.clone();
        }
        result
    }
    
    fn expand_args_in_tokens(tokens: &mut types::Tokens, args: &[String]) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
    
        for (sep, token) in tokens.iter() {
            if sep == "`" || sep == "'" || !is_args_in_token(token) {
                idx += 1;
                continue;
            }
    
            let _token = expand_args_for_single_token(token, args);
            buff.push((idx, _token));
            idx += 1;
        }
    
        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }
    
    fn run_exp_test_br(sh: &mut shell::Shell,
                       pair_br: Pair<parsers::locust::Rule>,
                       args: &Vec<String>,
                       in_loop: bool,
                       capture: bool) -> (Vec<CommandResult>, bool, bool, bool) {
        let mut cr_list = Vec::new();
        let pairs = pair_br.into_inner();
        let mut test_pass = false;
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::IF_HEAD ||
                    rule == parsers::locust::Rule::IF_ELSEIF_HEAD ||
                    rule == parsers::locust::Rule::WHILE_HEAD {
                let pairs_test: Vec<Pair<parsers::locust::Rule>> =
                    pair.into_inner().collect();
                let pair_test = &pairs_test[0];
                let line = pair_test.as_str().trim();
                let line_new = expand_args(line, &args[1..]);
                let mut _cr_list = execute::run_command_line(sh, &line_new, true, capture);
                if let Some(last) = _cr_list.last() {
                    if last.status == 0 {
                        test_pass = true;
                    }
                }
                continue;
            }
    
            if rule == parsers::locust::Rule::KW_ELSE {
                test_pass = true;
                continue;
            }
    
            if rule == parsers::locust::Rule::EXP_BODY {
                if !test_pass {
                    return (cr_list, false, false, false);
                }
                let (mut _cr_list, _cont, _brk) = run_exp(sh, pair, args, in_loop, capture);
                cr_list.append(&mut _cr_list);
                // branch executed successfully
                return (cr_list, true, _cont, _brk);
            }
    
            unreachable!();
        }
        (cr_list, test_pass, false, false)
    }
    
    fn run_exp_if(sh: &mut shell::Shell,
                  pair_if: Pair<parsers::locust::Rule>,
                  args: &Vec<String>,
                  in_loop: bool,
                  capture: bool) -> (Vec<CommandResult>, bool, bool) {
        let mut cr_list = Vec::new();
        let pairs = pair_if.into_inner();
        let mut met_continue = false;
        let mut met_break = false;
        for pair in pairs {
            let (mut _cr_list, passed, _cont, _brk) = run_exp_test_br(sh, pair, args, in_loop, capture);
            met_continue = _cont;
            met_break = _brk;
            cr_list.append(&mut _cr_list);
            // break at first successful branch
            if passed {
                break;
            }
        }
        (cr_list, met_continue, met_break)
    }
    
    fn get_for_result_from_init(sh: &mut shell::Shell,
                                pair_init: Pair<parsers::locust::Rule>,
                                args: &[String]) -> Vec<String> {
        let mut result: Vec<String> = Vec::new();
        let pairs = pair_init.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::TEST {
                let line = pair.as_str().trim();
                let tokens = expand_line_to_toknes(line, &args[1..], sh);
                for (sep, token) in tokens {
                    if sep.is_empty() {
                        for x in token.split_whitespace() {
                            result.push(x.to_string());
                        }
                    } else {
                        result.push(token.clone());
                    }
                }
            }
        }
        result
    }
    
    fn get_for_result_list(sh: &mut shell::Shell,
                           pair_head: Pair<parsers::locust::Rule>,
                           args: &[String]) -> Vec<String> {
        let pairs = pair_head.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_INIT {
                return get_for_result_from_init(sh, pair, args);
            }
        }
        Vec::new()
    }
    
    fn get_for_var_name(pair_head: Pair<parsers::locust::Rule>) -> String {
        let pairs = pair_head.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_INIT {
                let pairs_init = pair.into_inner();
                for pair_init in pairs_init {
                    let rule_init = pair_init.as_rule();
                    if rule_init == parsers::locust::Rule::FOR_VAR {
                        let line = pair_init.as_str().trim();
                        return line.to_string();
                    }
                }
            }
        }
        String::new()
    }
    
    fn run_exp_for(sh: &mut shell::Shell,
                   pair_for: Pair<parsers::locust::Rule>,
                   args: &Vec<String>,
                   capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        let pairs = pair_for.into_inner();
        let mut result_list: Vec<String> = Vec::new();
        let mut var_name: String = String::new();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_HEAD {
                var_name = get_for_var_name(pair.clone());
                result_list = get_for_result_list(sh, pair.clone(), args);
                continue;
            }
            if rule == parsers::locust::Rule::EXP_BODY {
                for value in &result_list {
                    sh.set_env(&var_name, value);
                    let (mut _cr_list, _cont, _brk) = run_exp(
                        sh, pair.clone(), args, true, capture);
                    cr_list.append(&mut _cr_list);
                    if _brk {
                        break;
                    }
                }
            }
        }
        cr_list
    }
    
    fn run_exp_while(sh: &mut shell::Shell,
                     pair_while: Pair<parsers::locust::Rule>,
                     args: &Vec<String>,
                     capture: bool) -> Vec<CommandResult> {
        let mut cr_list = Vec::new();
        loop {
            let (mut _cr_list, passed, _cont, _brk) = run_exp_test_br(sh, pair_while.clone(), args, true, capture);
            cr_list.append(&mut _cr_list);
            if !passed || _brk {
                break;
            }
        }
        cr_list
    }
    
    fn run_exp(sh: &mut shell::Shell,
               pair_in: Pair<parsers::locust::Rule>,
               args: &Vec<String>,
               in_loop: bool,
               capture: bool) -> (Vec<CommandResult>, bool, bool) {
        let mut cr_list = Vec::new();
        let pairs = pair_in.into_inner();
        for pair in pairs {
            let line = pair.as_str().trim();
            if line.is_empty() {
                continue;
            }
    
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::CMD {
                if line == "continue" {
                    if in_loop {
                        return (cr_list, true, false);
                    } else {
                        println_stderr!("cicada: continue: only meaningful in loops");
                        continue;
                    }
                }
                if line == "break" {
                    if in_loop {
                        return (cr_list, false, true);
                    } else {
                        println_stderr!("cicada: break: only meaningful in loops");
                        continue;
                    }
                }
    
                let line_new = expand_args(line, &args[1..]);
                let mut _cr_list = execute::run_command_line(sh, &line_new, true, capture);
                cr_list.append(&mut _cr_list);
                if let Some(last) = cr_list.last() {
                    let status = last.status;
                    if status != 0 && sh.exit_on_error {
                        return (cr_list, false, false);
                    }
                }
            } else if rule == parsers::locust::Rule::EXP_IF {
                let (mut _cr_list, _cont, _brk) = run_exp_if(sh, pair, args, in_loop, capture);
                cr_list.append(&mut _cr_list);
                if _cont {
                    return (cr_list, true, false);
                }
                if _brk {
                    return (cr_list, false, true);
                }
            } else if rule == parsers::locust::Rule::EXP_FOR {
                let mut _cr_list = run_exp_for(sh, pair, args, capture);
                cr_list.append(&mut _cr_list);
            } else if rule == parsers::locust::Rule::EXP_WHILE {
                let mut _cr_list = run_exp_while(sh, pair, args, capture);
                cr_list.append(&mut _cr_list);
            }
        }
        (cr_list, false, false)
    }
}

pub mod shell
{
    use ::
    {
        *,
    };
    /*
    use errno::errno;
    use ::collections::{HashMap, HashSet};
    use ::env;
    use ::io::Write;
    use ::mem;
    
    use regex::Regex;
    use uuid::Uuid;
    
    use crate::core;
    use crate::libs;
    use crate::parsers;
    use crate::tools;
    use crate::types::{self, CommandLine};
    */
    #[derive(Debug, Clone)]
    pub struct Shell {
        pub jobs: HashMap<i32, types::Job>,
        pub aliases: HashMap<String, String>,
        pub envs: HashMap<String, String>,
        pub funcs: HashMap<String, String>,
        pub cmd: String,
        pub current_dir: String,
        pub previous_dir: String,
        pub previous_cmd: String,
        pub previous_status: i32,
        pub is_login: bool,
        pub exit_on_error: bool,
        pub has_terminal: bool,
        pub session_id: String,
    }
    
    impl Shell {
        pub fn new() -> Shell {
            let uuid = Uuid::new_v4().as_hyphenated().to_string();
            let current_dir = tools::get_current_dir();
            // TODO: the shell proc may have terminal later
            // e.g. $ cicada foo.sh &
            // then with a $ fg
            let has_terminal = proc_has_terminal();
            let (session_id, _) = uuid.split_at(13);
            Shell {
                jobs: HashMap::new(),
                aliases: HashMap::new(),
                envs: HashMap::new(),
                funcs: HashMap::new(),
                cmd: String::new(),
                current_dir: current_dir.clone(),
                previous_dir: String::new(),
                previous_cmd: String::new(),
                previous_status: 0,
                is_login: false,
                exit_on_error: false,
                has_terminal,
                session_id: session_id.to_string(),
            }
        }
    
        pub fn insert_job(&mut self, gid: i32, pid: i32, cmd: &str, status: &str, bg: bool) {
            let mut i = 1;
            loop {
                let mut indexed_job_missing = false;
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        x.pids.push(pid);
                        x.cmd = format!("{} | {}", x.cmd, cmd);
                        return;
                    }
                } else {
                    indexed_job_missing = true;
                }
    
                if indexed_job_missing {
                    self.jobs.insert(
                        i,
                        types::Job {
                            cmd: cmd.to_string(),
                            id: i,
                            gid,
                            pids: vec![pid],
                            pids_stopped: HashSet::new(),
                            status: status.to_string(),
                            is_bg: bg,
                        },
                    );
                    return;
                }
                i += 1;
            }
        }
    
        pub fn get_job_by_id(&self, job_id: i32) -> Option<&types::Job> {
            self.jobs.get(&job_id)
        }
    
        pub fn mark_job_member_continued(&mut self, pid: i32,
                                         gid: i32) -> Option<&types::Job> {
            if self.jobs.is_empty() {
                return None;
            }
            let mut i = 1;
            let mut idx_found = 0;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.pids_stopped.remove(&pid);
                        idx_found = i;
                        break;
                    }
                }
    
    
                i += 1;
                if i >= 65535 {
                    break;
                }
            }
    
            self.jobs.get(&idx_found)
        }
    
        pub fn mark_job_member_stopped(&mut self, pid: i32,
                                       gid: i32) -> Option<&types::Job> {
            if self.jobs.is_empty() {
                return None;
            }
            let mut i = 1;
            let mut idx_found = 0;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.pids_stopped.insert(pid);
                        idx_found = i;
                        break;
                    }
                }
    
    
                i += 1;
                if i >= 65535 {
                    break;
                }
            }
    
            self.jobs.get(&idx_found)
        }
    
        pub fn get_job_by_gid(&self, gid: i32) -> Option<&types::Job> {
            if self.jobs.is_empty() {
                return None;
            }
    
            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get(&i) {
                    if x.gid == gid {
                        return Some(x);
                    }
                }
    
                i += 1;
                if i >= 65535 {
                    break;
                }
            }
            None
        }
    
        pub fn mark_job_as_running(&mut self, gid: i32, bg: bool) {
            if self.jobs.is_empty() {
                return;
            }
    
            let mut i = 1;
            loop {
                if let Some(job) = self.jobs.get_mut(&i) {
                    if job.gid == gid {
                        job.status = "Running".to_string();
                        job.pids_stopped.clear();
                        job.is_bg = bg;
                        return;
                    }
                }
    
                i += 1;
                if i >= 65535 {
                    break;
                }
            }
        }
    
        pub fn mark_job_as_stopped(&mut self, gid: i32) {
            if self.jobs.is_empty() {
                return;
            }
    
            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        x.status = "Stopped".to_string();
                        x.is_bg = true;
                        return;
                    }
                }
    
                i += 1;
                if i >= 65535 {
                    break;
                }
            }
        }
    
        pub fn remove_pid_from_job(&mut self, gid: i32, pid: i32) -> Option<types::Job> {
            if self.jobs.is_empty() {
                return None;
            }
    
            let mut empty_pids = false;
            let mut i = 1;
            loop {
                if let Some(x) = self.jobs.get_mut(&i) {
                    if x.gid == gid {
                        if let Ok(i_pid) = x.pids.binary_search(&pid) {
                            x.pids.remove(i_pid);
                        }
                        empty_pids = x.pids.is_empty();
                        break;
                    }
                }
    
                i += 1;
                if i >= 65535 {
                    break;
                }
            }
    
            if empty_pids {
                return self.jobs.remove(&i);
            }
            None
        }
    
        /// Update existing *ENV Variable* if such name exists in ENVs,
        /// otherwise, we define a local *Shell Variable*, which would not
        /// be exported into child processes.
        pub fn set_env(&mut self, name: &str, value: &str) {
            if env::var(name).is_ok() {
                env::set_var(name, value);
            } else {
                self.envs.insert(name.to_string(), value.to_string());
            }
        }
    
        /// get *Shell Variable*, or *ENV Variable*.
        pub fn get_env(&self, name: &str) -> Option<String> {
            match self.envs.get(name) {
                Some(x) => Some(x.to_string()),
                None => {
                    match env::var(name) {
                        Ok(x) => Some(x),
                        Err(_) => None,
                    }
                }
            }
        }
    
        /// Remove environment variable, function from the environment of
        /// the currently running process
        pub fn remove_env(&mut self, name: &str) -> bool {
            // function names can contain the `-` char.
            let ptn_env = Regex::new(r"^[a-zA-Z_][a-zA-Z0-9_-]*$").unwrap();
            if !ptn_env.is_match(name) {
                return false;
            }
    
            env::remove_var(name);
            self.envs.remove(name);
            self.remove_func(name);
            true
        }
    
        pub fn remove_path(&mut self, path: &str) {
            if let Ok(paths) = env::var("PATH") {
                let mut paths_new: Vec<&str> = paths.split(":").collect();
                paths_new.retain(|&x| x != path);
                env::set_var("PATH", paths_new.join(":").as_str());
            }
        }
    
        fn remove_func(&mut self, name: &str) {
            self.funcs.remove(name);
        }
    
        pub fn set_func(&mut self, name: &str, value: &str) {
            self.funcs.insert(name.to_string(), value.to_string());
        }
    
        pub fn get_func(&self, name: &str) -> Option<String> {
            self.funcs.get(name).map(|x| x.to_string())
        }
    
        pub fn get_alias_list(&self) -> Vec<(String, String)> {
            let mut result = Vec::new();
            for (name, value) in &self.aliases {
                result.push((name.clone(), value.clone()));
            }
            result
        }
    
        pub fn add_alias(&mut self, name: &str, value: &str) {
            self.aliases.insert(name.to_string(), value.to_string());
        }
    
        pub fn is_alias(&self, name: &str) -> bool {
            self.aliases.contains_key(name)
        }
    
        pub fn remove_alias(&mut self, name: &str) -> bool {
            let opt = self.aliases.remove(name);
            opt.is_some()
        }
    
        pub fn get_alias_content(&self, name: &str) -> Option<String> {
            let result = match self.aliases.get(name) {
                Some(x) => x.to_string(),
                None => String::new(),
            };
            if result.is_empty() {
                None
            } else {
                Some(result)
            }
        }
    }
    
    pub unsafe fn give_terminal_to(gid: i32) -> bool {
        let mut mask: libc::sigset_t = mem::zeroed();
        let mut old_mask: libc::sigset_t = mem::zeroed();
    
        libc::sigemptyset(&mut mask);
        libc::sigaddset(&mut mask, libc::SIGTSTP);
        libc::sigaddset(&mut mask, libc::SIGTTIN);
        libc::sigaddset(&mut mask, libc::SIGTTOU);
        libc::sigaddset(&mut mask, libc::SIGCHLD);
    
        let rcode = libc::pthread_sigmask(libc::SIG_BLOCK, &mask, &mut old_mask);
        if rcode != 0 {
            log!("failed to call pthread_sigmask");
        }
        let rcode = libc::tcsetpgrp(1, gid);
        let given;
        if rcode == -1 {
            given = false;
            let e = errno();
            let code = e.0;
            log!("error in give_terminal_to() {}: {}", code, e);
        } else {
            given = true;
        }
        let rcode = libc::pthread_sigmask(libc::SIG_SETMASK, &old_mask, &mut mask);
        if rcode != 0 {
            log!("failed to call pthread_sigmask");
        }
        given
    }
    
    fn needs_globbing(line: &str) -> bool {
        let re = Regex::new(r"\*+").expect("Invalid regex ptn");
        re.is_match(line)
    }
    
    pub fn expand_glob(tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !needs_globbing(text) {
                idx += 1;
                continue;
            }
    
            let mut result: Vec<String> = Vec::new();
            let item = text.as_str();
    
            if !item.contains('*') || item.trim().starts_with('\'') || item.trim().starts_with('"') {
                result.push(item.to_string());
            } else {
                let _basename = libs::path::basename(item);
                let show_hidden = _basename.starts_with(".*");
    
                match glob::glob(item) {
                    Ok(paths) => {
                        let mut is_empty = true;
                        for entry in paths {
                            match entry {
                                Ok(path) => {
                                    let file_path = path.to_string_lossy();
                                    let _basename = libs::path::basename(&file_path);
                                    if _basename == ".." || _basename == "." {
                                        continue;
                                    }
                                    if _basename.starts_with('.') && !show_hidden {
                                        // skip hidden files, you may need to
                                        // type `ls .*rc` instead of `ls *rc`
                                        continue;
                                    }
                                    result.push(file_path.to_string());
                                    is_empty = false;
                                }
                                Err(e) => {
                                    log!("glob error: {:?}", e);
                                }
                            }
                        }
                        if is_empty {
                            result.push(item.to_string());
                        }
                    }
                    Err(e) => {
                        println!("glob error: {:?}", e);
                        result.push(item.to_string());
                        return;
                    }
                }
            }
    
            buff.push((idx, result));
            idx += 1;
        }
    
        for (i, result) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in result.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }
    
    fn expand_one_env(sh: &Shell, token: &str) -> String {
        // do not combine these two into one: `\{?..\}?`,
        // otherwize `}` in `{print $NF}` would gone.
        let re1 = Regex::new(r"^(.*?)\$([A-Za-z0-9_]+|\$|\?)(.*)$").unwrap();
        let re2 = Regex::new(r"(.*?)\$\{([A-Za-z0-9_]+|\$|\?)\}(.*)$").unwrap();
        if !re1.is_match(token) && !re2.is_match(token) {
            return token.to_string();
        }
    
        let mut result = String::new();
        let match_re1 = re1.is_match(token);
        let match_re2 = re2.is_match(token);
        if !match_re1 && !match_re2 {
            return token.to_string();
        }
    
        let cap_results = if match_re1 {
            re1.captures_iter(token)
        } else {
            re2.captures_iter(token)
        };
    
        for cap in cap_results {
            let head = cap[1].to_string();
            let tail = cap[3].to_string();
            let key = cap[2].to_string();
            if key == "?" {
                result.push_str(format!("{}{}", head, sh.previous_status).as_str());
            } else if key == "$" {
                unsafe {
                    let val = libc::getpid();
                    result.push_str(format!("{}{}", head, val).as_str());
                }
            } else if let Ok(val) = env::var(&key) {
                result.push_str(format!("{}{}", head, val).as_str());
            } else if let Some(val) = sh.get_env(&key) {
                result.push_str(format!("{}{}", head, val).as_str());
            } else {
                result.push_str(&head);
            }
            result.push_str(&tail);
        }
    
        result
    }
    
    fn need_expand_brace(line: &str) -> bool {
        libs::re::re_contains(line, r#"\{[^ "']*,[^ "']*,?[^ "']*\}"#)
    }
    
    fn brace_getitem(s: &str, depth: i32) -> (Vec<String>, String) {
        let mut out: Vec<String> = vec![String::new()];
        let mut ss = s.to_string();
        let mut tmp;
        while !ss.is_empty() {
            let c = match ss.chars().next() {
                Some(x) => x,
                None => {
                    return (out, ss);
                }
            };
            if depth > 0 && (c == ',' || c == '}') {
                return (out, ss);
            }
            if c == '{' {
                let mut sss = ss.clone();
                sss.remove(0);
                let result_groups = brace_getgroup(&sss, depth + 1);
                if let Some((out_group, s_group)) = result_groups {
                    let mut tmp_out = Vec::new();
                    for x in out.iter() {
                        for y in out_group.iter() {
                            let item = format!("{}{}", x, y);
                            tmp_out.push(item);
                        }
                    }
                    out = tmp_out;
                    ss = s_group.clone();
                    continue;
                }
            }
            // FIXME: here we mean more than one char.
            if c == '\\' && ss.len() > 1 {
                ss.remove(0);
                let c;
                match ss.chars().next() {
                    Some(x) => c = x,
                    None => {
                        return (out, ss)
                    }
                }
    
                tmp = format!("\\{}", c);
            } else {
                tmp = c.to_string();
            }
            let mut result = Vec::new();
            for x in out.iter() {
                let item = format!("{}{}", x, tmp);
                result.push(item);
            }
            out = result;
            ss.remove(0);
        }
        (out, ss)
    }
    
    fn brace_getgroup(s: &str, depth: i32) -> Option<(Vec<String>, String)> {
        let mut out: Vec<String> = Vec::new();
        let mut comma = false;
        let mut ss = s.to_string();
        while !ss.is_empty() {
            let (g, sss) = brace_getitem(ss.as_str(), depth);
            ss = sss.clone();
            if ss.is_empty() {
                break;
            }
            for x in g.iter() {
                out.push(x.clone());
            }
    
            let c = match ss.chars().next() {
                Some(x) => x,
                None => {
                    break;
                }
            };
            if c == '}' {
                let mut sss = ss.clone();
                sss.remove(0);
                if comma {
                    return Some((out, sss));
                }
                let mut result = Vec::new();
                for x in out.iter() {
                    let item = format!("{{{}}}", x);
                    result.push(item);
                }
                return Some((result, ss));
            }
            if c == ',' {
                comma = true;
                ss.remove(0);
            }
        }
    
        None
    }
    
    fn expand_brace(tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, token) in tokens.iter() {
            if !sep.is_empty() || !need_expand_brace(token) {
                idx += 1;
                continue;
            }
    
            let mut result: Vec<String> = Vec::new();
            let items = brace_getitem(token, 0);
            for x in items.0 {
                result.push(x.clone());
            }
            buff.push((idx, result));
            idx += 1;
        }
    
        for (i, items) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in items.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }
    
    fn expand_brace_range(tokens: &mut types::Tokens) {
        let re;
        if let Ok(x) = Regex::new(r#"\{(-?[0-9]+)\.\.(-?[0-9]+)(\.\.)?([0-9]+)?\}"#) {
            re = x;
        } else {
            println_stderr!("cicada: re new error");
            return;
        }
    
        let mut idx: usize = 0;
        let mut buff: Vec<(usize, Vec<String>)> = Vec::new();
        for (sep, token) in tokens.iter() {
            if !sep.is_empty() || !re.is_match(token) {
                idx += 1;
                continue;
            }
    
            // safe to unwrap here, since the `is_match` above already validated
            let caps = re.captures(token).unwrap();
    
            let start = match caps[1].to_string().parse::<i32>() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: {}", e);
                    return;
                }
            };
    
            let end = match caps[2].to_string().parse::<i32>() {
                Ok(x) => x,
                Err(e) => {
                    println_stderr!("cicada: {}", e);
                    return;
                }
            };
    
            // incr is always positive
            let mut incr = if caps.get(4).is_none() {
                1
            } else {
                match caps[4].to_string().parse::<i32>() {
                    Ok(x) => x,
                    Err(e) => {
                        println_stderr!("cicada: {}", e);
                        return;
                    }
                }
            };
            if incr <= 1 {
                incr = 1;
            }
    
            let mut result: Vec<String> = Vec::new();
            let mut n = start;
            if start > end {
                while n >= end {
                    result.push(format!("{}", n));
                    n -= incr;
                }
            } else {
                while n <= end {
                    result.push(format!("{}", n));
                    n += incr;
                }
            }
    
            buff.push((idx, result));
            idx += 1;
        }
    
        for (i, items) in buff.iter().rev() {
            tokens.remove(*i);
            for (j, token) in items.iter().enumerate() {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, (sep.to_string(), token.clone()));
            }
        }
    }
    
    fn expand_alias(sh: &Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        let mut is_head = true;
        for (sep, text) in tokens.iter() {
            if sep.is_empty() && text == "|" {
                is_head = true;
                idx += 1;
                continue;
            }
            if is_head && text == "xargs" {
                idx += 1;
                continue;
            }
    
            if !is_head || !sh.is_alias(text) {
                idx += 1;
                is_head = false;
                continue;
            }
    
            if let Some(value) = sh.get_alias_content(text) {
                buff.push((idx, value.clone()));
            }
    
            idx += 1;
            is_head = false;
        }
    
        for (i, text) in buff.iter().rev() {
            let linfo = parsers::parser_line::parse_line(text);
            let tokens_ = linfo.tokens;
            tokens.remove(*i);
            for item in tokens_.iter().rev() {
                tokens.insert(*i, item.clone());
            }
        }
    }
    
    fn expand_home(tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !text.starts_with("~") {
                idx += 1;
                continue;
            }
    
            let mut s: String = text.clone();
            let ptn = r"^~(?P<tail>.*)";
            let re = Regex::new(ptn).expect("invalid re ptn");
            let home = tools::get_user_home();
            let ss = s.clone();
            let to = format!("{}$tail", home);
            let result = re.replace_all(ss.as_str(), to.as_str());
            s = result.to_string();
    
            buff.push((idx, s.clone()));
            idx += 1;
        }
    
        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }
    
    fn env_in_token(token: &str) -> bool {
        if libs::re::re_contains(token, r"\$\{?[\$\?]\}?") {
            return true;
        }
    
        let ptn_env_name = r"[a-zA-Z_][a-zA-Z0-9_]*";
        let ptn_env = format!(r"\$\{{?{}\}}?", ptn_env_name);
        if !libs::re::re_contains(token, &ptn_env) {
            return false;
        }
    
        // do not expand env in a command substitution, e.g.:
        // - echo $(echo '$HOME')
        // - VERSION=$(foobar -h | grep 'version: v' | awk '{print $NF}')
        let ptn_cmd_sub1 = format!(r"^{}=`.*`$", ptn_env_name);
        let ptn_cmd_sub2 = format!(r"^{}=\$\(.*\)$", ptn_env_name);
        if libs::re::re_contains(token, &ptn_cmd_sub1)
            || libs::re::re_contains(token, &ptn_cmd_sub2)
            || libs::re::re_contains(token, r"^\$\(.+\)$")
        {
            return false;
        }
    
        // for cmd-line like `alias foo='echo $PWD'`
        let ptn_env = format!(r"='.*\$\{{?{}\}}?.*'$", ptn_env_name);
        !libs::re::re_contains(token, &ptn_env)
    }
    
    pub fn expand_env(sh: &Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff = Vec::new();
    
        for (sep, token) in tokens.iter() {
            if sep == "`" || sep == "'" {
                idx += 1;
                continue;
            }
    
            if !env_in_token(token) {
                idx += 1;
                continue;
            }
    
            let mut _token = token.clone();
            while env_in_token(&_token) {
                _token = expand_one_env(sh, &_token);
            }
            buff.push((idx, _token));
            idx += 1;
        }
    
        for (i, text) in buff.iter().rev() {
            tokens[*i].1 = text.to_string();
        }
    }
    
    fn should_do_dollar_command_extension(line: &str) -> bool {
        libs::re::re_contains(line, r"\$\([^\)]+\)") &&
        !libs::re::re_contains(line, r"='.*\$\([^\)]+\).*'$")
    }
    
    fn do_command_substitution_for_dollar(sh: &mut Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff: HashMap<usize, String> = HashMap::new();
    
        for (sep, token) in tokens.iter() {
            if sep == "'" || sep == "\\" || !should_do_dollar_command_extension(token) {
                idx += 1;
                continue;
            }
    
            let mut line = token.to_string();
            loop {
                if !should_do_dollar_command_extension(&line) {
                    break;
                }
    
                let ptn_cmd = r"\$\((.+)\)";
                let cmd = match libs::re::find_first_group(ptn_cmd, &line) {
                    Some(x) => x,
                    None => {
                        println_stderr!("cicada: calculator: no first group");
                        return;
                    }
                };
    
                let cmd_result = match CommandLine::from_line(&cmd, sh) {
                    Ok(c) => {
                        log!("run subcmd dollar: {:?}", &cmd);
                        let (term_given, cr) = ::run_pipeline(sh, &c, true, true, false);
                        if term_given {
                            unsafe {
                                let gid = libc::getpgid(0);
                                give_terminal_to(gid);
                            }
                        }
    
                        cr
                    }
                    Err(e) => {
                        println_stderr!("cicada: {}", e);
                        continue;
                    }
                };
    
                let output_txt = cmd_result.stdout.trim();
    
                let ptn = r"(?P<head>[^\$]*)\$\(.+\)(?P<tail>.*)";
                let re;
                if let Ok(x) = Regex::new(ptn) {
                    re = x;
                } else {
                    return;
                }
    
                let to = format!("${{head}}{}${{tail}}", output_txt);
                let line_ = line.clone();
                let result = re.replace(&line_, to.as_str());
                line = result.to_string();
            }
    
            buff.insert(idx, line.clone());
            idx += 1;
        }
    
        for (i, text) in buff.iter() {
            tokens[*i].1 = text.to_string();
        }
    }
    
    fn do_command_substitution_for_dot(sh: &mut Shell, tokens: &mut types::Tokens) {
        let mut idx: usize = 0;
        let mut buff: HashMap<usize, String> = HashMap::new();
        for (sep, token) in tokens.iter() {
            let new_token: String;
            if sep == "`" {
                log!("run subcmd dot1: {:?}", token);
                let cr = match CommandLine::from_line(token, sh) {
                    Ok(c) => {
                        let (term_given, _cr) = ::run_pipeline(sh, &c, true, true, false);
                        if term_given {
                            unsafe {
                                let gid = libc::getpgid(0);
                                give_terminal_to(gid);
                            }
                        }
    
                        _cr
                    }
                    Err(e) => {
                        println_stderr!("cicada: {}", e);
                        continue;
                    }
                };
    
                new_token = cr.stdout.trim().to_string();
            } else if sep == "\"" || sep.is_empty() {
                let re;
                if let Ok(x) = Regex::new(r"^([^`]*)`([^`]+)`(.*)$") {
                    re = x;
                } else {
                    println_stderr!("cicada: re new error");
                    return;
                }
                if !re.is_match(token) {
                    idx += 1;
                    continue;
                }
                let mut _token = token.clone();
                let mut _item = String::new();
                let mut _head = String::new();
                let mut _output = String::new();
                let mut _tail = String::new();
                loop {
                    if !re.is_match(&_token) {
                        if !_token.is_empty() {
                            _item = format!("{}{}", _item, _token);
                        }
                        break;
                    }
                    for cap in re.captures_iter(&_token) {
                        _head = cap[1].to_string();
                        _tail = cap[3].to_string();
                        log!("run subcmd dot2: {:?}", &cap[2]);
    
                        let cr = match CommandLine::from_line(&cap[2], sh) {
                            Ok(c) => {
                                let (term_given, _cr) = ::run_pipeline(sh, &c, true, true, false);
                                if term_given {
                                    unsafe {
                                        let gid = libc::getpgid(0);
                                        give_terminal_to(gid);
                                    }
                                }
    
                                _cr
                            }
                            Err(e) => {
                                println_stderr!("cicada: {}", e);
                                continue;
                            }
                        };
    
                        _output = cr.stdout.trim().to_string();
                    }
                    _item = format!("{}{}{}", _item, _head, _output);
                    if _tail.is_empty() {
                        break;
                    }
                    _token = _tail.clone();
                }
                new_token = _item;
            } else {
                idx += 1;
                continue;
            }
    
            buff.insert(idx, new_token.clone());
            idx += 1;
        }
    
        for (i, text) in buff.iter() {
            tokens[*i].1 = text.to_string();
        }
    }
    
    fn do_command_substitution(sh: &mut Shell, tokens: &mut types::Tokens) {
        do_command_substitution_for_dot(sh, tokens);
        do_command_substitution_for_dollar(sh, tokens);
    }
    
    pub fn do_expansion(sh: &mut Shell, tokens: &mut types::Tokens) {
        let line = parsers::parser_line::tokens_to_line(tokens);
        if tools::is_arithmetic(&line) {
            return;
        }
    
        if tokens.len() >= 2 && tokens[0].1 == "export" && tokens[1].1.starts_with("PROMPT=") {
            return;
        }
    
        expand_alias(sh, tokens);
        expand_home(tokens);
        expand_env(sh, tokens);
        expand_brace(tokens);
        expand_glob(tokens);
        do_command_substitution(sh, tokens);
        expand_brace_range(tokens);
    }
    
    pub fn trim_multiline_prompts(line: &str) -> String {
        let line_new = libs::re::replace_all(line, r"\\\n>> ", "");
        let line_new = libs::re::replace_all(&line_new, r"\| *\n>> ", "| ");
        libs::re::replace_all(&line_new, r"(?P<NEWLINE>\n)>> ", "$NEWLINE")
    }
    
    fn proc_has_terminal() -> bool {
        unsafe {
            let tgid = libc::tcgetpgrp(0);
            let pgid = libc::getpgid(0);
            tgid == pgid
        }
    }
}

pub mod signals
{
    use ::
    {
        *,
    };
    /*
    use errno::{errno, set_errno};
    use nix::sys::signal;
    use nix::sys::wait::{WaitPidFlag as WF, WaitStatus as WS, waitpid};
    use nix::uni ::Pid;
    use ::sync::Mutex;
    use ::collections::{HashMap, HashSet};
    */
    lazy_static! {
        static ref REAP_MAP: Mutex<HashMap<i32, i32>> = Mutex::new(HashMap::new());
        static ref STOP_MAP: Mutex<HashSet<i32>> = Mutex::new(HashSet::new());
        static ref CONT_MAP: Mutex<HashSet<i32>> = Mutex::new(HashSet::new());
        static ref KILL_MAP: Mutex<HashMap<i32, i32>> = Mutex::new(HashMap::new());
    }
    
    pub fn killed_map_insert(pid: i32, sig: i32) {
        if let Ok(mut m) = KILL_MAP.try_lock() {
            m.insert(pid, sig);
        }
    }
    
    pub fn killed_map_pop(pid: i32) -> Option<i32> {
        if let Ok(mut m) = KILL_MAP.try_lock() {
            m.remove(&pid)
        } else {
            None
        }
    }
    
    pub fn insert_cont_map(pid: i32) {
        if let Ok(mut m) = CONT_MAP.try_lock() {
            m.insert(pid);
        }
    }
    
    pub fn pop_cont_map(pid: i32) -> bool {
        match CONT_MAP.try_lock() {
            Ok(mut m) => m.remove(&pid),
            Err(_) => false,
        }
    }
    
    pub fn insert_stopped_map(pid: i32) {
        if let Ok(mut m) = STOP_MAP.try_lock() {
            m.insert(pid);
        }
    }
    
    pub fn pop_stopped_map(pid: i32) -> bool {
        match STOP_MAP.try_lock() {
            Ok(mut m) => m.remove(&pid),
            Err(_) => false,
        }
    }
    
    pub fn insert_reap_map(pid: i32, status: i32) {
        if let Ok(mut m) = REAP_MAP.try_lock() {
            m.insert(pid, status);
        }
    }
    
    pub fn pop_reap_map(pid: i32) -> Option<i32> {
        match REAP_MAP.try_lock() {
            Ok(mut m) => m.remove(&pid),
            Err(_) => None,
        }
    }
    
    pub fn block_signals() {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        match signal::sigprocmask(signal::SigmaskHow::SIG_BLOCK, Some(&sigset), None) {
            Ok(_) => {},
            Err(e) => {
                log!("sigprocmask block error: {:?}", e);
            }
        }
    }
    
    pub fn unblock_signals() {
        let mut sigset = signal::SigSet::empty();
        sigset.add(signal::SIGCHLD);
        match signal::sigprocmask(signal::SigmaskHow::SIG_UNBLOCK, Some(&sigset), None) {
            Ok(_) => {},
            Err(e) => {
                log!("sigprocmask unblock error: {:?}", e);
            }
        }
    }
    
    #[allow(unreachable_patterns)]
    pub extern "C" fn handle_sigchld(_sig: i32) {
        let saved_errno = errno();
        let options = Some(WF::WUNTRACED | WF::WNOHANG | WF::WCONTINUED);
        loop {
            match waitpid(Pid::from_raw(-1), options) {
                Ok(WS::Exited(pid, status)) => {
                    insert_reap_map(i32::from(pid), status);
                }
                Ok(WS::Stopped(pid, _sig)) => {
                    insert_stopped_map(i32::from(pid));
                }
                Ok(WS::Continued(pid)) => {
                    // NOTE: SIGCHLD generated by SIGCONT is not reliable
                    // on Mac (both for signal handler or sync waitpid).
                    insert_cont_map(i32::from(pid));
                }
                Ok(WS::Signaled(pid, sig, _core_dumped)) => {
                    killed_map_insert(i32::from(pid), sig as i32);
                }
                Ok(WS::StillAlive) => {
                    break;
                }
                Ok(_others) => {
                    // log!("sigchld others: {:?}", _others);
                }
                Err(e) => {
                    if e == nix::Error::ECHILD {
                        break;
                    }
    
                    log!("chld waitpid error: {:?}", e);
                    break;
                }
            }
        }
    
        set_errno(saved_errno);
    }
    
    pub fn setup_sigchld_handler() {
        let sigset = signal::SigSet::empty();
        let handler = signal::SigHandler::Handler(handle_sigchld);
        // automatically restart system calls interrupted by this signal handler
        let flags = signal::SaFlags::SA_RESTART;
        let sa = signal::SigAction::new(handler, flags, sigset);
        unsafe {
            match signal::sigaction(signal::SIGCHLD, &sa) {
                Ok(_) => {},
                Err(e) => {
                    log!("sigaction error: {:?}", e);
                }
            }
        }
    }
}

pub mod types
{
    use ::
    {
        *,
    };
    /*
    use regex::Regex;
    use ::collections::{HashMap, HashSet};
    use ::fmt;
    
    use crate::parsers;
    use crate::parsers::parser_line::tokens_to_redirections;
    use crate::shell;
    use crate::libs;
    use crate::tools;
    */
    
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct WaitStatus(i32, i32, i32);
    
    impl WaitStatus {
        pub fn from_exited(pid: i32, status: i32) -> Self {
            WaitStatus(pid, 0, status)
        }
    
        pub fn from_signaled(pid: i32, sig: i32) -> Self {
            WaitStatus(pid, 1, sig)
        }
    
        pub fn from_stopped(pid: i32, sig: i32) -> Self {
            WaitStatus(pid, 2, sig)
        }
    
        pub fn from_continuted(pid: i32) -> Self {
            WaitStatus(pid, 3, 0)
        }
    
        pub fn from_others() -> Self {
            WaitStatus(0, 9, 9)
        }
    
        pub fn from_error(errno: i32) -> Self {
            WaitStatus(0, 255, errno)
        }
    
        pub fn empty() -> Self {
            WaitStatus(0, 0, 0)
        }
    
        pub fn is_error(&self) -> bool {
            self.1 == 255
        }
    
        pub fn is_others(&self) -> bool {
            self.1 == 9
        }
    
        pub fn is_signaled(&self) -> bool {
            self.1 == 1
        }
    
        pub fn get_errno(&self) -> nix::Error {
            nix::Error::from_raw(self.2)
        }
    
        pub fn is_exited(&self) -> bool {
            self.0 != 0 && self.1 == 0
        }
    
        pub fn is_stopped(&self) -> bool {
            self.1 == 2
        }
    
        pub fn is_continued(&self) -> bool {
            self.1 == 3
        }
    
        pub fn get_pid(&self) -> i32 {
            self.0
        }
    
        fn _get_signaled_status(&self) -> i32 {
            self.2 + 128
        }
    
        pub fn get_signal(&self) -> i32 {
            self.2
        }
    
        pub fn get_name(&self) -> String {
            if self.is_exited() {
                "Exited".to_string()
            } else if self.is_stopped() {
                "Stopped".to_string()
            } else if self.is_continued() {
                "Continued".to_string()
            } else if self.is_signaled() {
                "Signaled".to_string()
            } else if self.is_others() {
                "Others".to_string()
            } else if self.is_error() {
                "Error".to_string()
            } else {
                format!("unknown: {}", self.2)
            }
        }
    
        pub fn get_status(&self) -> i32 {
            if self.is_exited() {
                self.2
            } else {
                self._get_signaled_status()
            }
        }
    }
    
    impl fmt::Debug for WaitStatus {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let mut formatter = f.debug_struct("WaitStatus");
            formatter.field("pid", &self.0);
            let name = self.get_name();
            formatter.field("name", &name);
            formatter.field("ext", &self.2);
            formatter.finish()
        }
    }
    
    pub type Token = (String, String);
    pub type Tokens = Vec<Token>;
    pub type Redirection = (String, String, String);
    
    #[derive(Debug)]
    pub struct LineInfo {
        // e.g. echo 'foo
        // is not a completed line, need to turn to multiple-line mode.
        pub tokens: Tokens,
        pub is_complete: bool,
    }
    
    impl LineInfo {
        pub fn new(tokens: Tokens) -> Self {
            LineInfo { tokens, is_complete: true }
        }
    }
    
    ///
    /// command line: `ls 'foo bar' 2>&1 > /dev/null < one-file` would be:
    /// Command {
    ///     tokens: [("", "ls"), ("", "-G"), ("\'", "foo bar")],
    ///     redirects_to: [
    ///         ("2", ">", "&1"),
    ///         ("1", ">", "/dev/null"),
    ///     ],
    ///     redirect_from: Some(("<", "one-file")),
    /// }
    ///
    #[derive(Debug)]
    pub struct Command {
        pub tokens: Tokens,
        pub redirects_to: Vec<Redirection>,
        pub redirect_from: Option<Token>,
    }
    
    #[derive(Debug)]
    pub struct CommandLine {
        pub line: String,
        pub commands: Vec<Command>,
        pub envs: HashMap<String, String>,
        pub background: bool,
    }
    
    impl Command {
        pub fn from_tokens(tokens: Tokens) -> Result<Command, String> {
            let mut tokens_new = tokens.clone();
            let mut redirects_from_type = String::new();
            let mut redirects_from_value = String::new();
            let mut has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");
    
            let mut len = tokens_new.len();
            while has_redirect_from {
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<") {
                    redirects_from_type = "<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<<<") {
                    redirects_from_type = "<<<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }
    
                has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<");
            }
    
            let tokens_final;
            let redirects_to;
            match tokens_to_redirections(&tokens_new) {
                Ok((_tokens, _redirects_to)) => {
                    tokens_final = _tokens;
                    redirects_to = _redirects_to;
                }
                Err(e) => {
                    return Err(e);
                }
            }
    
            let redirect_from = if redirects_from_type.is_empty() {
                None
            } else {
                Some((redirects_from_type, redirects_from_value))
            };
    
            Ok(Command{
                tokens: tokens_final,
                redirects_to,
                redirect_from,
            })
        }
    
        pub fn has_redirect_from(&self) -> bool {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<"
        }
    
        pub fn has_here_string(&self) -> bool {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<<<"
        }
    
        pub fn is_builtin(&self) -> bool {
            tools::is_builtin(&self.tokens[0].1)
        }
    }
    
    #[derive(Debug, Clone, Default)]
    pub struct Job {
        pub cmd: String,
        pub id: i32,
        pub gid: i32,
        pub pids: Vec<i32>,
        pub pids_stopped: HashSet<i32>,
        pub status: String,
        pub is_bg: bool,
    }
    
    impl Job {
        pub fn all_members_stopped(&self) -> bool {
            for pid in &self.pids {
                if !self.pids_stopped.contains(pid) {
                    return false;
                }
            }
            true
        }
    
        pub fn all_members_running(&self) -> bool {
            self.pids_stopped.is_empty()
        }
    }
    
    #[allow(dead_code)]
    #[derive(Clone, Debug, Default)]
    pub struct CommandResult {
        pub gid: i32,
        pub status: i32,
        pub stdout: String,
        pub stderr: String,
    }
    
    impl CommandResult {
        pub fn new() -> CommandResult {
            CommandResult {
                gid: 0,
                status: 0,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    
        pub fn from_status(gid: i32, status: i32) -> CommandResult {
            CommandResult {
                gid,
                status,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    
        pub fn error() -> CommandResult {
            CommandResult {
                gid: 0,
                status: 1,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    }
    
    #[allow(dead_code)]
    #[derive(Clone, Debug, Default)]
    pub struct CommandOptions {
        pub background: bool,
        pub isatty: bool,
        pub capture_output: bool,
        pub envs: HashMap<String, String>,
    }
    
    fn split_tokens_by_pipes(tokens: &[Token]) -> Vec<Tokens> {
        let mut cmd = Vec::new();
        let mut cmds = Vec::new();
        for token in tokens {
            let sep = &token.0;
            let value = &token.1;
            if sep.is_empty() && value == "|" {
                if cmd.is_empty() {
                    return Vec::new();
                }
                cmds.push(cmd.clone());
                cmd = Vec::new();
            } else {
                cmd.push(token.clone());
            }
        }
        if cmd.is_empty() {
            return Vec::new();
        }
        cmds.push(cmd.clone());
        cmds
    }
    
    fn drain_env_tokens(tokens: &mut Tokens) -> HashMap<String, String> {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let re = Regex::new(r"^([a-zA-Z0-9_]+)=(.*)$").unwrap();
        for (sep, text) in tokens.iter() {
            if !sep.is_empty() || !libs::re::re_contains(text, r"^([a-zA-Z0-9_]+)=(.*)$") {
                break;
            }
    
            for cap in re.captures_iter(text) {
                let name = cap[1].to_string();
                let value = parsers::parser_line::unquote(&cap[2]);
                envs.insert(name, value);
            }
    
            n += 1;
        }
        if n > 0 {
            tokens.drain(0..n);
        }
        envs
    }
    
    impl CommandLine {
        pub fn from_line(line: &str, sh: &mut shell::Shell) -> Result<CommandLine, String> {
            let linfo = parsers::parser_line::parse_line(line);
            let mut tokens = linfo.tokens;
            shell::do_expansion(sh, &mut tokens);
            let envs = drain_env_tokens(&mut tokens);
    
            let mut background = false;
            let len = tokens.len();
            if len > 1 && tokens[len - 1].1 == "&" {
                background = true;
                tokens.pop();
            }
    
            let mut commands = Vec::new();
            for sub_tokens in split_tokens_by_pipes(&tokens) {
                match Command::from_tokens(sub_tokens) {
                    Ok(c) => {
                        commands.push(c);
                    }
                    Err(e) => {
                        return Err(e);
                    }
                }
            }
    
            Ok(CommandLine{
                line: line.to_string(),
                commands,
                envs,
                background,
            })
        }
    
        pub fn is_empty(&self) -> bool {
            self.commands.is_empty()
        }
    
        pub fn with_pipeline(&self) -> bool {
            self.commands.len() > 1
        }
    
        pub fn is_single_and_builtin(&self) -> bool {
            self.commands.len() == 1 && self.commands[0].is_builtin()
        }
    }
}
// #[allow(clippy::cast_lossless)]
fn main() {
    unsafe {
        libc::signal(libc::SIGPIPE, libc::SIG_DFL);

        // ignore SIGTSTP (ctrl-Z) for the shell itself
        libc::signal(libc::SIGTSTP, libc::SIG_IGN);
        libc::signal(libc::SIGQUIT, libc::SIG_IGN);
    }

    tools::init_path_env();

    let mut sh = shell::Shell::new();
    let args: Vec<String> = env::args().collect();

    if libs::progopts::is_login(&args) {
        rcfile::load_rc_files(&mut sh);
        sh.is_login = true;
    }

    // Initialize command cache for highlighting
    highlight::init_command_cache();
    highlight::update_aliases(&sh);

    if libs::progopts::is_script(&args) {
        log!("run script: {:?} ", &args);
        let status = scripting::run_script(&mut sh, &args);
        ::process::exit(status);
    }

    if libs::progopts::is_command_string(&args) {
        // handles `cicada -c 'echo hi && echo yoo'`,
        // e.g. it could be triggered from Vim (`:!ls` etc).
        let line = tools::env_args_to_command_line();
        log!("run with -c args: {}", &line);
        execute::run_command_line(&mut sh, &line, false, false);
        ::process::exit(sh.previous_status);
    }

    if libs::progopts::is_non_tty() {
        // cases like open a new MacVim window,
        // (i.e. CMD+N) on an existing one
        execute::run_procs_for_non_tty(&mut sh);
        return;
    }

    let mut rl;
    match Interface::new("cicada") {
        Ok(x) => rl = x,
        Err(e) => {
            // non-tty will raise errors here
            println!("cicada: lineread error: {}", e);
            return;
        }
    }

    rl.define_function("enter-function", Arc::new(prompt::EnterFunction));
    rl.bind_sequence("\r", Command::from_str("enter-function"));

    let highlighter = highlight::create_highlighter();
    rl.set_highlighter(highlighter);

    history::init(&mut rl);
    rl.set_completer(Arc::new(completers::CicadaCompleter {
        sh: Arc::new(sh.clone()),
    }));

    let sig_handler_enabled = tools::is_signal_handler_enabled();
    if sig_handler_enabled {
        signals::setup_sigchld_handler();
        // block the signals at most of time, since Rust is not "async-signal-safe"
        // yet. see https://github.com/rust-lang/rfcs/issues/1368
        // we'll unblock them when necessary only.
        signals::block_signals();
    }

    loop {
        let prompt = prompt::get_prompt(&sh);
        match rl.set_prompt(&prompt) {
            Ok(_) => {}
            Err(e) => {
                println_stderr!("cicada: prompt error: {}", e);
            }
        }

        if sig_handler_enabled {
            // FIXME: in `rl.read_line()` below, there is lots of Rust code,
            // which may not be async-signal-safe. see follow links for details:
            // - https://ldpreload.com/blog/signalfd-is-useless
            // - https://man7.org/linux/man-pages/man7/signal-safety.7.html
            signals::unblock_signals();
        }
        match rl.read_line() {
            Ok(ReadResult::Input(line)) => {
                if sig_handler_enabled {
                    signals::block_signals();
                }

                let line = shell::trim_multiline_prompts(&line);
                if line.trim() == "" {
                    jobc::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                    continue;
                }
                sh.cmd = line.clone();

                let tsb = ctime::DateTime::now().unix_timestamp();
                let mut line = line.clone();

                // since `!!` expansion is only meaningful in an interactive
                // shell we extend it here, instead of in `run_command_line()`.
                tools::extend_bangbang(&sh, &mut line);

                let mut status = 0;
                let cr_list = execute::run_command_line(&mut sh, &line, true, false);
                if let Some(last) = cr_list.last() {
                    status = last.status;
                }
                let tse = ctime::DateTime::now().unix_timestamp();

                if !sh.cmd.starts_with(' ') && line != sh.previous_cmd {
                    history::add(&sh, &mut rl, &line, status, tsb, tse);
                    sh.previous_cmd = line.clone();
                }

                if tools::is_shell_altering_command(&line) {
                    // since our shell object need to be passed into
                    // `lineread::Completer` with an Arc.
                    // I currently do not know how to share the same sh
                    // instance at hand with it.

                    // update the Arc clone when alias/function/env changes
                    rl.set_completer(Arc::new(completers::CicadaCompleter {
                        sh: Arc::new(sh.clone()),
                    }));

                    // Update aliases in the highlighter when they might have changed
                    highlight::update_aliases(&sh);
                }

                jobc::try_wait_bg_jobs(&mut sh, true, sig_handler_enabled);
                continue;
            }
            Ok(ReadResult::Eof) => {
                if let Ok(x) = env::var("NO_EXIT_ON_CTRL_D") {
                    if x == "1" {
                        println!();
                    }
                } else {
                    println!("exit");
                    break;
                }
            }
            Ok(ReadResult::Signal(s)) => {
                println_stderr!("readline signal: {:?}", s);
            }
            Err(e) => {
                println_stderr!("readline error: {}", e);
                // There maybe other reason of this Err, but possibly it occurs
                // in cases we give term to a child, and it stops, and we
                // didn't have term back to shell in waitpid places. Here
                // it's a last resort.
                // FIXME: we only need this trick when job-control has issues
                unsafe {
                    let gid = libc::getpgid(0);
                    shell::give_terminal_to(gid);
                }
            }
        }
        if sig_handler_enabled {
            signals::block_signals();
        }
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
// 36770
