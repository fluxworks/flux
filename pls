/*!
    pls is a bash-like Unix shell written in Rust.

    If you would like to use pls as a regular shell,
    please see details in [its repository]( https://github.com/mitnk/pls )

    Here is how to use pls as a library:

    **Add pls into Cargo.toml**

    ```ignore
    [dependencies]
    pls = "1.0"
    ```

    **Use pls functions**

    ```no_run
    extern crate pls;

    fn main()
    {
        let info = pls::parse_line( "echo 'hi yoo' | `which wc`" );
        assert!( info.is_complete );

        let tokens = info.tokens;
        assert_eq!( tokens.len(), 4 );

        assert_eq!( tokens[0].0, "" );
        assert_eq!( tokens[0].1, "echo" );

        assert_eq!( tokens[1].0, "'" );
        assert_eq!( tokens[1].1, "hi yoo" );

        assert_eq!( tokens[2].0, "" );
        assert_eq!( tokens[2].1, "|" );

        assert_eq!( tokens[3].0, "`" );
        assert_eq!( tokens[3].1, "which wc" );

        let out1 = pls::run( "ls Cargo.toml foo" );
        assert_eq!( out1.status, 1 );
        assert_eq!( out1.stdout, "Cargo.toml\n" );
        assert_eq!( out1.stderr, "ls:foo:No such file or directory\n" );

        let out2 = pls::run( "ls | wc" );
        assert_eq!( out2.status, 0 );
        assert_eq!( out2.stdout, "       4       4      33\n" );
    }
    ```
*/
/*
Features */
#![feature
( 

 )]
/*
Allowances */
#![allow
( 
    dead_code,
    unknown_lints,
    unused_imports,
    unused_variables,
    unreachable_code,    
 )]
/*
External Macros */
#[macro_use] extern crate bitflags;
#[macro_use] extern crate lazy_static;
/*
External Crates */
extern crate clap;
extern crate fnv;
extern crate libc;
extern crate memchr;
extern crate nix;
extern crate regex as re;
extern crate smallvec;
extern crate time as timing;
extern crate unicode_normalization;
extern crate unicode_width;
/*
    #[macro_use] extern crate pest_derive;
    extern crate errno;
    extern crate exec;
    extern crate glob;
    extern crate linefeed;
    extern crate pest;
    extern crate rusqlite;
    extern crate yaml_rust;
    extern crate phf;
*/
use ::
{
    io::{ Write },
    prompt::lines::{ Command, Interface, ReadResult },
    sync::{ Arc },
};
/*
Macros */
#[macro_use] mod macros
{
    use ::
    {
        collections::{ HashMap },
        fs::{ OpenOptions },
        io::{ Write },
        os::unix::io::{ IntoRawFd },
        path::{ Path, PathBuf },
        *
    };

    pub use std::
    {
        assert_eq, assert_ne, debug_assert, debug_assert_eq, debug_assert_ne, unreachable, unimplemented, write, 
        writeln, todo,
    };

    #[macro_export] macro_rules! println_stderr
    {
        ( $fmt:expr ) =>
        ( 
            match writeln!( &mut ::io::stderr(), $fmt )
            {
                Ok( _ ) => {}
                Err( e ) => println!( "write to stderr failed:{:?}", e )
            }
 );

        ( $fmt:expr, $( $arg:tt )* ) =>
        ( 
            match writeln!( &mut ::io::stderr(), $fmt, $( $arg )* )
            {
                Ok( _ ) => {}
                Err( e ) => println!( "write to stderr failed:{:?}", e )
            }
 );
    }
}

pub mod alloc { pub use std::alloc::{ * }; }
pub mod any   { pub use std::arch::{ * }; }
pub mod arch  { pub use std::arch::{ * }; }
pub mod array { pub use std::array::{ * }; }
pub mod ascii
{
    pub use std::ascii::{ * };

    const NONE:u8 = 0b000000;
    const PRINT:u8 = 0b000001;
    const SPACE:u8 = 0b000010;
    const CONTROL:u8 = 0b000100;
    const PIPE:u8 = 0b001000;
    const COMMA:u8 = 0b010000;
    const EOL:u8 = 0b100000;
    
    static ASCII:[u8; 256] =
    [
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, SPACE, EOL, NONE, NONE, EOL, NONE, NONE, NONE, NONE, 
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, PRINT | SPACE, PRINT, PRINT,
        PRINT | CONTROL, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT | COMMA | CONTROL, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT | CONTROL,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
        PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT | PIPE,
        PRINT, PRINT, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, 
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, 
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
        NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
    ];

    #[inline( always )] pub fn is_ws( ch:u8 ) -> bool { unsafe { ASCII.get_unchecked( ch as usize ) & SPACE == SPACE } }

    #[inline( always )] pub fn is_eol( ch:u8 ) -> bool { unsafe { ASCII.get_unchecked( ch as usize ) & EOL == EOL } }

    #[inline( always )] pub fn is_printable_no_pipe( ch:u8 ) -> bool 
    { unsafe { ASCII.get_unchecked( ch as usize ) & ( PRINT | PIPE ) == PRINT } }

    #[inline( always )] pub fn is_printable_no_comma( ch:u8 ) -> bool 
    { unsafe { ASCII.get_unchecked( ch as usize ) & ( PRINT | COMMA ) == PRINT } }

    #[inline( always )] pub fn is_printable_no_control( ch:u8 ) -> bool
    {
        unsafe { ASCII.get_unchecked( ch as usize ) & ( PRINT | CONTROL ) == PRINT }
    }
}
pub mod borrow { pub use std::borrow::{ * }; }
pub mod boxed { pub use std::boxed::{ * }; }
pub mod builtins
{
    pub mod alias
    {
        use ::
        {
            regex::{ Regex },
            types::{ Command, CommandLine, CommandResult },
            print::{ print_stderr_with_capture, print_stdout_with_capture },
            *,
        };
        
        pub fn run( sh:&mut shell::Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();

            if tokens.len() == 1
            { return show_alias_list( sh, cmd, cl, capture ); }

            if tokens.len() > 2
            {
                let info = "alias syntax error:usage:alias foo='echo foo'";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            let input = &tokens[1].1;
            let re_single_read = Regex::new( r"^[a-zA-Z0-9_\.-]+$" ).unwrap();
            if re_single_read.is_match( input ) { return show_single_alias( sh, input, cmd, cl, capture ); }

            let re_to_add = Regex::new( r"^( [a-zA-Z0-9_\.-]+ )=( .* )$" ).unwrap();
            for cap in re_to_add.captures_iter( input )
            {
                let name = str::unquote( &cap[1] );
                let value = if cap[2].starts_with( '"' ) || cap[2].starts_with( '\'' )
                { str::unquote( &cap[2] ) }

                else
                { cap[2].to_string() };

                sh.add_alias( name.as_str(), value.as_str() );
            }

            CommandResult::new()
        }
        
        pub fn show_alias_list( sh:&shell::Shell, cmd:&Command, cl:&CommandLine, capture:bool ) -> CommandResult
        {
            let mut lines = Vec::new();
            for ( name, value ) in sh.get_alias_list()
            {
                let line = format!( "alias {}='{}'", name, value );
                lines.push( line );
            }

            let buffer = lines.join( "\n" );
            let mut cr = CommandResult::new();
            print_stdout_with_capture( &buffer, &mut cr, cl, cmd, capture );
            cr
        }
        
        pub fn show_single_alias( sh:&shell::Shell, named:&str, cmd:&Command, cl:&CommandLine, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            if let Some( content ) = sh.get_alias_content( named )
            {
                let info = format!( "alias {}='{}'", named, content );
                print_stdout_with_capture( &info, &mut cr, cl, cmd, capture );
            }
            else
            {
                let info = format!( "pls:alias:{}:not found", named );
                print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
            }
            cr
        }
    }
    
    pub mod bg
    {
        use ::
        {
            c::{ job },
            print::{ print_stderr_with_capture },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *
        };

        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if sh.jobs.is_empty()
            {
                let info = "pls:bg:no job found";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            let mut job_id = -1;
            if tokens.len() == 1
            {
                if let Some( ( gid, _ ) ) = sh.jobs.iter().next()
                { job_id = *gid; }
            }

            if tokens.len() >= 2
            {
                let mut job_str = tokens[1].1.clone();
                if job_str.starts_with( "%" )
                {
                    job_str = job_str.trim_start_matches( '%' ).to_string();
                }

                match job_str.parse::<i32>()
                {
                    Ok( n ) => job_id = n,
                    Err( _ ) =>
                    {
                        let info = "pls:bg:invalid job id";
                        print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                        return cr;
                    }
                }
            }
            
            if job_id == -1
            {
                let info = "pls:bg:not such job";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            let gid:i32;

            {
                let mut result = sh.get_job_by_id( job_id );
                if result.is_none() {
                    result = sh.get_job_by_gid( job_id );
                }

                match result
                {
                    Some( job ) =>
                    unsafe 
                    {
                        libc::killpg( job.gid, libc::SIGCONT );
                        gid = job.gid;
                        if job.status == "Running"
                        {
                            let info = format!( "pls:bg:job {} already in background", job.id );
                            print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                            return cr;
                        }

                        let info_cmd = format!( "[{}]  {} &", job.id, job.cmd );
                        print_stderr_with_capture( &info_cmd, &mut cr, cl, cmd, capture );
                        cr.status = 0;
                    }
                    
                    None =>
                    {
                        let info = "pls:bg:not such job";
                        print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                        return cr;
                    }
                }
            }

            c::job::mark_job_as_running( sh, gid, true );
            cr
        }
    }
    
    pub mod cd
    {
        use ::
        {
            path::{ Path },
            print::{ print_stderr_with_capture },
            types::{Command, CommandLine, CommandResult},
            *,
        };

        pub fn run( sh:&mut shell::Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();
            let args = parsers::line::tokens_to_args( &tokens );

            if args.len() > 2 {
                let info = "pls:cd:too many argument";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            let str_current_dir = get::current_directory();

            let mut dir_to = if args.len() == 1 {
                let home = get::user_home();
                home.to_string()
            } else {
                args[1..].join( "" )
            };

            if dir_to == "-" {
                if sh.previous_dir.is_empty() {
                    let info = "no previous dir";
                    print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                    return cr;
                }
                dir_to = sh.previous_dir.clone();
            } else if !dir_to.starts_with( '/' ) {
                dir_to = format!( "{}/{}", str_current_dir, dir_to );
            }

            if !Path::new( &dir_to ).exists() {
                let info = format!( "pls:cd:{}:No such file or directory", &args[1] );
                print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                return cr;
            }

            match Path::new( &dir_to ).canonicalize()
            {
                Ok( p ) => {
                    dir_to = p.as_path().to_string_lossy().to_string();
                }
                Err( e ) => {
                    let info = format!( "pls:cd:error:{}", e );
                    print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                    return cr;
                }
            }

            match env::set_current_dir( &dir_to )
            {
                Ok( _ ) => {
                    sh.current_dir = dir_to.clone();
                    if str_current_dir != dir_to {
                        sh.previous_dir = str_current_dir.clone();
                        env::set_var( "PWD", &sh.current_dir );
                    };
                    cr.status = 0;
                    cr
                }
                Err( e ) => {
                    let info = format!( "pls:cd:{}", e );
                    print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                    cr
                }
            }
        }
    }
    
    pub mod cinfo
    {
        use ::
        {
            print::{ print_stdout_with_capture },
            shell::{ Shell },
            types::{ Command, CommandLine, CommandResult },
            rc::{ file },
            *,
        };

        pub fn run( _sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut info = vec![];
            const VERSION:&str = "0.0.0"; //env!( "CARGO_PKG_VERSION" );
            info.push( ( "version", VERSION ) );

            let os_name = get::os_name();
            info.push( ( "os-name", &os_name ) );

            let hfile = get::history_file();
            info.push( ( "history-file", &hfile ) );

            let rcf = rc::file::get_rc_file();
            info.push( ( "rc-file", &rcf ) );

            let git_hash = std::env::var( "GIT_HASH" ); // env!( "GIT_HASH" );
            if !git_hash.is_empty()
            {
                //info.push( ( "git-commit", env!( "GIT_HASH" ) ) );
                info.push( ( "git-commit", env::var( "GIT_HASH" ) ) );
            }

            let git_branch = env::var( "GIT_BRANCH" ); //env!( "GIT_BRANCH" );
            let mut branch = String::new();
            if !git_branch.is_empty()
            {
                branch.push_str( git_branch );
                let git_status = env::var( "GIT_STATUS" ); //env!( "GIT_STATUS" );
                if git_status != "0" { branch.push_str( " ( dirty )" ); }
                info.push( ( "git-branch", &branch ) );
            }

            //info.push( ( "built-with", env!( "BUILD_RUSTC_VERSION" ) ) );
            info.push( ( "built-with", env::var( "BUILD_RUSTC_VERSION" ) ) );
            //info.push( ( "built-at", env!( "BUILD_DATE" ) ) );
            info.push( ( "built-with", env::var( "BUILD_DATE" ) ) );

            let mut lines = Vec::new();
            for ( k, v ) in &info {
                // longest key above is 12-char length
                lines.push( format!( "{:>12}:{}", k, v ) );
            }
            let buffer = lines.join( "\n" );
            let mut cr = CommandResult::new();
            print_stdout_with_capture( &buffer, &mut cr, cl, cmd, capture );
            cr
        }
    }
    
    pub mod exec
    {
        use ::
        {
            print::{ print_stderr_with_capture },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *,
        };
        /**/
        pub fn run( _sh:&Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();
            let args = parsers::line::tokens_to_args( &tokens );
            let len = args.len();
            if len == 1
            {
                print_stderr_with_capture( "invalid usage", &mut cr, cl, cmd, capture );
                return cr;
            }

            let mut _cmd = now::Command::new( &args[1] );
            let err = _cmd.args( &args[2..len] ).exec();
            let info = format!( "pls:exec:{}", err );
            print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
            cr
        }
    }
    
    pub mod exit
    {
        use ::
        {
            print::{ print_stderr_with_capture },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *
        };
        /**/
        pub fn run( sh:&Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();
            if tokens.len() > 2 {
                let info = "pls:exit:too many arguments";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            if tokens.len() == 2 {
                let _code = &tokens[1].1;
                match _code.parse::<i32>() {
                    Ok( x ) => {
                        process::exit( x );
                    }
                    Err( _ ) => {
                        let info = format!( "pls:exit:{}:numeric argument required", _code );
                        print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                        process::exit( 255 );
                    }
                }
            }

            for ( _i, job ) in sh.jobs.iter() {
                if !job.cmd.starts_with( "nohup " ) {
                    let mut info = String::new();
                    info.push_str( "There are background jobs." );
                    info.push_str( "Run `jobs` to see details; `exit 1` to force quit." );
                    print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                    return cr;
                }
            }

            process::exit( 0 );
            cr
        }
    }
    
    pub mod export
    {
        use ::
        {
            regex::{ Regex },
            shell::{ Shell },
            print::{ print_stderr_with_capture },
            types::{ CommandResult, CommandLine, Command },
            *,
        };

        pub fn run( _sh:&Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();

            let re_name_ptn = Regex::new( r"^( [a-zA-Z_][a-zA-Z0-9_]* )=( .* )$" ).unwrap();
            for ( _, text ) in tokens.iter() {
                if text == "export" {
                    continue;
                }

                if !is::environment( text ) {
                    let mut info = String::new();
                    info.push_str( "export:invalid command\n" );
                    info.push_str( "usage:export XXX=YYY" );
                    print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                    return cr;
                }

                if !re_name_ptn.is_match( text ) {
                    let mut info = String::new();
                    info.push_str( "export:invalid command\n" );
                    info.push_str( "usage:export XXX=YYY ZZ=123" );
                    print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                    return cr;
                }

                for cap in re_name_ptn.captures_iter( text ) {
                    let name = cap[1].to_string();
                    let token = parsers::line::unquote( &cap[2] );
                    let value = expand::home( &token );
                    env::set_var( name, &value );
                }
            }
            cr
        }
    }
    
    pub mod fg
    {
        use ::
        {
            c::{ job },
            print::{ print_stderr_with_capture },
            shell::{ self, Shell },
            types::{ CommandResult, CommandLine, Command },
            *
        };

        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if sh.jobs.is_empty() {
                let info = "pls:fg:no job found";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            let mut job_id = -1;
            if tokens.len() == 1 {
                if let Some( ( gid, _ ) ) = sh.jobs.iter().next() {
                    job_id = *gid;
                }
            }

            if tokens.len() >= 2 {
                let mut job_str = tokens[1].1.clone();
                if job_str.starts_with( "%" ) {
                    job_str = job_str.trim_start_matches( '%' ).to_string();
                }

                match job_str.parse::<i32>() {
                    Ok( n ) => job_id = n,
                    Err( _ ) => {
                        let info = "pls:fg:invalid job id";
                        print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                        return cr;
                    }
                }
            }

            if job_id == -1 {
                let info = "pls:not job id found";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            let gid:i32;
            let pid_list:Vec<i32>;

            {
                let mut result = sh.get_job_by_id( job_id );
                // fall back to find job by using prcess group id
                if result.is_none() {
                    result = sh.get_job_by_gid( job_id );
                }

                match result {
                    Some( job ) => {
                        print_stderr_with_capture( &job.cmd, &mut cr, cl, cmd, capture );
                        cr.status = 0;

                        unsafe {
                            if !shell::give_terminal_to( job.gid ) {
                                return CommandResult::error();
                            }

                            libc::killpg( job.gid, libc::SIGCONT );
                            pid_list = job.pids.clone();
                            gid = job.gid;
                        }
                    }
                    None => {
                        let info = "pls:fg:no such job";
                        print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                        return cr;
                    }
                }
            }

            unsafe {
                c::job::mark_job_as_running( sh, gid, false );

                let cr = c::job::wait_fg_job( sh, gid, &pid_list );

                let gid_shell = libc::getpgid( 0 );
                if !shell::give_terminal_to( gid_shell ) {
                    //log!( "failed to give term to back to shell :{}", gid_shell );
                }

                cr
            }
        }
    }
    
    pub mod history
    {
        use ::
        {
            c::{ time },
            path::{ Path },
            print::{ print_stderr_with_capture, print_stdout_with_capture, },
            //rusqlite::{ Connection as Conn },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *
        };


        /*
        #[derive( Debug, StructOpt )]
        #[structopt( name = "history", about = "History in pls shell" )]
        struct OptMain {
            #[structopt( short, long, help = "For current session only" )]
            session:bool,

            #[structopt( short, long, help = "Search old items first" )]
            asc:bool,

            #[structopt( short, long, help = "For current directory only" )]
            pwd:bool,

            #[structopt( short, long, help = "Only show ROWID" )]
            only_id:bool,

            #[structopt( short, long, help = "Do not show ROWID" )]
            no_id:bool,

            #[structopt( short="d", long, help = "Show date" )]
            show_date:bool,

            #[structopt( short, long, default_value = "20" )]
            limit:i32,

            #[structopt( name = "PATTERN", default_value = "", help = "You can use % to match anything" )]
            pattern:String,

            #[structopt( subcommand )]
            cmd:Option<SubCommand>
        }
        */
        #[derive( Debug )]
        pub struct OptMain();
        /*
        #[derive( StructOpt, Debug )]
        enum SubCommand {
            #[structopt( about="Add new item into history" )]
            Add {
                #[structopt( short="t", long, help = "Specify a timestamp for the new item" )]
                timestamp:Option<f64>,

                #[structopt( name="INPUT", help = "input to be added into history" )]
                input:String,
            },
            #[structopt( about="Delete item from history" )]
            Delete {
                #[structopt( name="ROWID", help = "Row IDs of item to delete" )]
                rowid:Vec<usize>,
            }
        }
        */
        #[derive( Debug )]
        pub enum SubCommand
        {
            Add,
            Delete,
        }

        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            let hfile = get::history_file();
            let path = Path::new( hfile.as_str() );
            if !path.exists() {
                let info = "no history file";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }
            let conn = match Conn::open( &hfile )
            {
                Ok( x ) => x,
                Err( e ) => {
                    let info = format!( "history:sqlite error:{:?}", e );
                    print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                    return cr;
                }
            };

            let tokens = cmd.tokens.clone();
            let args = parsers::line::tokens_to_args( &tokens );

            let show_usage = args.len() > 1 && ( args[1] == "-h" || args[1] == "--help" );
            let opt = OptMain::from_iter_safe( args );
            match opt
            {
                Ok( opt ) => {
                    match opt.cmd {
                        Some( SubCommand::Delete {rowid:rowids} ) => {
                            let mut _count = 0;
                            for rowid in rowids {
                                let _deleted = delete_history_item( &conn, rowid );
                                if _deleted {
                                    _count += 1;
                                }
                            }
                            if _count > 0 {
                                let info = format!( "deleted {} items", _count );
                                print_stdout_with_capture( &info, &mut cr, cl, cmd, capture );
                            }
                            cr
                        }
                        Some( SubCommand::Add {timestamp:ts, input} ) => {
                            let ts = ts.unwrap_or( 0 as f64 );
                            add_history( sh, ts, &input );
                            cr
                        }
                        None => {
                            let ( str_out, str_err ) = list_current_history( sh, &conn, &opt );
                            if !str_out.is_empty() {
                                print_stdout_with_capture( &str_out, &mut cr, cl, cmd, capture );
                            }
                            if !str_err.is_empty() {
                                print_stderr_with_capture( &str_err, &mut cr, cl, cmd, capture );
                            }
                            cr
                        }
                    }
                }
                Err( e ) => {
                    let info = format!( "{}", e );
                    if show_usage {
                        print_stdout_with_capture( &info, &mut cr, cl, cmd, capture );
                        cr.status = 0;
                    } else {
                        print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                        cr.status = 1;
                    }
                    cr
                }
            }
        }

        pub fn add_history( sh:&Shell, ts:f64, input:&str )
        {
            let ( tsb, tse ) = ( ts, ts + 1.0 );
            history::add_raw( sh, input, 0, tsb, tse );
        }

        pub fn list_current_history( sh:&Shell, conn:&Conn, opt:&OptMain ) -> ( String, String )
        {
            let mut result_stderr = String::new();
            let result_stdout = String::new();

            let history_table = get::history_table();
            let mut sql = format!( "SELECT ROWID, inp, tsb FROM {} WHERE ROWID > 0",
                                  history_table );
            if !opt.pattern.is_empty() {
                sql = format!( "{} AND inp LIKE '%{}%'", sql, opt.pattern )
            }
            if opt.session {
                sql = format!( "{} AND sessionid = '{}'", sql, sh.session_id )
            }
            if opt.pwd {
                sql = format!( "{} AND info like '%dir:{}|%'", sql, sh.current_dir )
            }

            if opt.asc {
                sql = format!( "{} ORDER BY tsb", sql );
            } else {
                sql = format!( "{} order by tsb desc", sql );
            };
            sql = format!( "{} limit {} ", sql, opt.limit );

            let mut stmt = match conn.prepare( &sql )
            {
                Ok( x ) => x,
                Err( e ) => {
                    let info = format!( "history:prepare select error:{:?}", e );
                    result_stderr.push_str( &info );
                    return ( result_stdout, result_stderr );
                }
            };

            let mut rows = match stmt.query( [] )
            {
                Ok( x ) => x,
                Err( e ) => {
                    let info = format!( "history:query error:{:?}", e );
                    result_stderr.push_str( &info );
                    return ( result_stdout, result_stderr );
                }
            };

            let mut lines = Vec::new();
            loop {
                match rows.next() {
                    Ok( _rows ) => {
                        if let Some( row ) = _rows {
                            let row_id:i32 = match row.get( 0 ) {
                                Ok( x ) => x,
                                Err( e ) => {
                                    let info = format!( "history:error:{:?}", e );
                                    result_stderr.push_str( &info );
                                    return ( result_stdout, result_stderr );
                                }
                            };
                            let inp:String = match row.get( 1 ) {
                                Ok( x ) => x,
                                Err( e ) => {
                                    let info = format!( "history:error:{:?}", e );
                                    result_stderr.push_str( &info );
                                    return ( result_stdout, result_stderr );
                                }
                            };

                            if opt.no_id {
                                lines.push( inp.to_string() );
                            } else if opt.only_id {
                                lines.push( row_id.to_string() );
                            } else if opt.show_date {
                                let tsb:f64 = match row.get( 2 ) {
                                    Ok( x ) => x,
                                    Err( e ) => {
                                        let info = format!( "history:error:{:?}", e );
                                        result_stderr.push_str( &info );
                                        return ( result_stdout, result_stderr );
                                    }
                                };
                                let dt = c::time::DateTime::from_timestamp( tsb );
                                lines.push( format!( "{}:{}:{}", row_id, dt, inp ) );
                            } else {
                                lines.push( format!( "{}:{}", row_id, inp ) );
                            }
                        } else {
                            break;
                        }
                    }
                    Err( e ) => {
                        let info = format!( "history:rows next error:{:?}", e );
                        result_stderr.push_str( &info );
                        return ( result_stdout, result_stderr );
                    }
                }
            }

            let buffer = lines.join( "\n" );

            ( buffer, result_stderr )
        }

        fn delete_history_item( conn:&Conn, rowid:usize ) -> bool
        {
            let history_table = get::history_table();
            let sql = format!( "DELETE from {} where rowid = {}", history_table, rowid );
            match conn.execute( &sql, [] )
            {
                Ok( _ ) => true,
                Err( e ) =>
                {
                    //log!( "history:error when delete:{:?}", e );
                    false
                }
            }
        }
    }
    
    pub mod jobs
    {
        use ::
        {
            c::{ job },
            print::{ print_stdout_with_capture },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *
        };

        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            if sh.jobs.is_empty() {
                return cr;
            }

            // update status of jobs if any
            c::job::try_wait_bg_jobs( sh, false, false );

            let mut lines = Vec::new();
            let jobs = sh.jobs.clone();
            let no_trim = cmd.tokens.len() >= 2 && cmd.tokens[1].1 == "-f";
            for ( _i, job ) in jobs.iter() {
                let line = get::job_line( job, !no_trim );
                lines.push( line );
            }
            let buffer = lines.join( "\n" );

            print_stdout_with_capture( &buffer, &mut cr, cl, cmd, capture );
            cr
        }

    }
    /**/
    pub mod read
    {
        use ::
        {
            print::{ print_stderr_with_capture },
            shell::{ Shell },
            regex::{ re_contains },
            types::{ CommandResult, CommandLine, Command },
            *,
        };

        fn _find_invalid_identifier( name_list:&Vec<String> ) -> Option<String>
        {
            for id_ in name_list
            {
                if !re_contains( id_, r"^[a-zA-Z_][a-zA-Z0-9_]*$" ) {
                    return Some( id_.to_string() );
                }
            }
            None
        }

        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();

            let name_list:Vec<String>;
            if tokens.len() <= 1 {
                name_list = vec!["REPLY".to_string( )];
            } else {
                name_list = tokens[1..].iter().map( |x| x.1.clone() ).collect();
                if let Some( id_ ) = _find_invalid_identifier( &name_list ) {
                    let info = format!( "pls:read:`{}':not a valid identifier", id_ );
                    print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                    return cr;
                }
            }

            let mut buffer = String::new();

            if cmd.has_here_string() {
                if let Some( redirect_from ) = &cmd.redirect_from {
                    buffer.push_str( &redirect_from.1 );
                    buffer.push( '\n' );
                }
            } else {
                match io::stdin().read_line( &mut buffer ) {
                    Ok( _ ) => {}
                    Err( e ) => {
                        let info = format!( "pls:read:error in reading stdin:{:?}", e );
                        print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                        return cr;
                    }
                }
            }

            let envs = cl.envs.clone();
            let value_list = str::split_into_fields( sh, buffer.trim(), &envs );

            let idx_2rd_last = name_list.len() - 1;
            for i in 0..idx_2rd_last {
                let name = name_list.get( i );
                if name.is_none() {
                    let info = "pls:read:name index error";
                    print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                    return cr;
                }
                let name = name.unwrap();

                let value = value_list.get( i ).unwrap_or( &String::new() ).clone();
                sh.set_env( name, &value );
            }

            let name_last = &name_list[idx_2rd_last];
            let value_left:String = if value_list.len() > idx_2rd_last {
                value_list[idx_2rd_last..].join( " " )
            } else {
                String::new()
            };
            sh.set_env( name_last, &value_left );
            cr
        }
    }
    /**/
    pub mod source
    {
        use ::
        {
            print::{ print_stderr_with_capture },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *,
        };

        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            let tokens = &cmd.tokens;
            let args = parsers::line::tokens_to_args( tokens );

            if args.len() < 2 {
                let info = "pls:source:no file specified";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            let status = scripts::run_script( sh, &args );
            cr.status = status;
            cr
        }
    }
    /**/
    pub mod unalias
    {
        use ::
        {
            print::{ print_stderr_with_capture },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *
        };

        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if tokens.len() != 2 {
                let info = "pls:unalias:syntax error";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            let input = &tokens[1].1;
            if !sh.remove_alias( input ) {
                let info = format!( "pls:unalias:{}:not found", input );
                print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                return cr;
            }
            cr
        }
    }
    /**/
    pub mod vox
    {
        use ::
        {
            print::{ print_stderr_with_capture, print_stdout_with_capture, },
            path::{ Path },
            shell::{ self, Shell },
            types::{ self, CommandResult, CommandLine, Command },
            *
        };

        fn in_env() -> bool
        {
            env::var( "VIRTUAL_ENV" ).map_or( false, |x| !x.is_empty() )
        }

        fn enter_env( sh:&Shell, path:&str ) -> String
        {
            if in_env() {
                return "vox:already in env".to_string();
            }

            let home_envs = get::virtual_environments_home();
            let full_path = format!( "{}/{}/bin/activate", home_envs, path );
            if !Path::new( full_path.as_str() ).exists() {
                return format!( "no such env:{}", full_path );
            }

            let path_env = format!( "{}/{}", home_envs, path );
            env::set_var( "VIRTUAL_ENV", &path_env );
            let path_new = String::from( "${VIRTUAL_ENV}/bin:$PATH" );
            let mut tokens:types::Tokens = Vec::new();
            tokens.push( ( String::new(), path_new ) );
            expand::environment( sh, &mut tokens );
            env::set_var( "PATH", &tokens[0].1 );
            String::new()
        }

        fn exit_env( sh:&Shell ) -> String
        {
            if !in_env() {
                return String::from( "vox:not in an env" );
            }

            let env_path = match env::var( "PATH" )
            {
                Ok( x ) => x,
                Err( _ ) => {
                    return String::from( "vox:cannot read PATH env" );
                }
            };

            let mut _tokens:Vec<&str> = env_path.split( ':' ).collect();
            let mut path_virtual_env = String::from( "${VIRTUAL_ENV}/bin" );
            // shell::extend_env( sh, &mut path_virtual_env );
            let mut tokens:types::Tokens = Vec::new();
            tokens.push( ( String::new(), path_virtual_env ) );
            expand::environment( sh, &mut tokens );
            path_virtual_env = tokens[0].1.clone();
            _tokens
                .iter()
                .position( |&n| n == path_virtual_env )
                .map( |e| _tokens.remove( e ) );
            let env_path_new = _tokens.join( ":" );
            env::set_var( "PATH", &env_path_new );
            env::set_var( "VIRTUAL_ENV", "" );

            String::new()
        }

        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            let tokens = cmd.tokens.clone();
            let args = parsers::line::tokens_to_args( &tokens );
            let len = args.len();
            let subcmd = if len > 1 { &args[1] } else { "" };

            if len == 1 || ( len == 2 && subcmd == "ls" ) {
                match get::virtual_environments() {
                    Ok( venvs ) => {
                        let info = venvs.join( "\n" );
                        print_stdout_with_capture( &info, &mut cr, cl, cmd, capture );
                        return cr;
                    }
                    Err( reason ) => {
                        print_stderr_with_capture( &reason, &mut cr, cl, cmd, capture );
                        return cr;
                    }
                }
            }

            if len == 3 && subcmd == "create" {
                let pybin = match env::var( "VIRTUALENV_PYBIN" ) {
                    Ok( x ) => x,
                    Err( _ ) => "python3".to_string(),
                };
                let dir_venv = get::virtual_environments_home();
                let venv_name = args[2].to_string();
                let line = format!( "{} -m venv \"{}/{}\"", pybin, dir_venv, venv_name );
                print_stderr_with_capture( &line, &mut cr, cl, cmd, capture );
                let cr_list = now::run_command_line( sh, &line, false, false );
                return cr_list[0].clone();
            }

            if len == 3 && subcmd == "enter" {
                let _err = enter_env( sh, args[2].as_str() );
                if !_err.is_empty() {
                    print_stderr_with_capture( &_err, &mut cr, cl, cmd, capture );
                }
                cr
            } else if len == 2 && subcmd == "exit" {
                let _err = exit_env( sh );
                if !_err.is_empty() {
                    print_stderr_with_capture( &_err, &mut cr, cl, cmd, capture );
                }
                cr
            } else {
                let info = "pls:vox:invalid option";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                cr
            }
        }
    }
    /**/
    pub mod ulimit
    {
        use ::
        {
            clap::{Parser, CommandFactory},
            io::{ Error },
            print::{ print_stderr_with_capture, print_stdout_with_capture },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *,
        };

        #[derive( Parser )]
        #[command( name = "ulimit", about = "show / modify shell resource limits" )]
        #[allow( non_snake_case )]
        struct App
        {
            #[arg( short, help = "All current limits are reported." )]
            a:bool,
            #[arg( short, value_name = "NEW VALUE", help = "The maximum number of open file descriptors." )]
            n:Option<Option<u64>>,
            #[arg( short, value_name = "NEW VALUE", help = "The maximum size of core files created." )]
            c:Option<Option<u64>>,
            #[arg( short = 'S', help = "Set a soft limit for the given resource. ( default )" )]
            S:bool,
            #[arg( short = 'H', help = "Set a hard limit for the given resource." )]
            H:bool,
        }

        pub fn run( _sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            let tokens = &cmd.tokens;
            let args = parsers::line::tokens_to_args( tokens );

            if args.contains( &"--help".to_string() ) || args.contains( &"-h".to_string() ) {
                App::command().print_help().unwrap();
                println!();
                return cr;
            }

            let app = App::parse_from( args );

            if app.H && app.S {
                println!( "pls:ulimit:Cannot both hard and soft." );
                cr.status = 1;
                return cr;
            }

            let mut all_stdout = String::new();
            let mut all_stderr = String::new();

            if app.a {
                report_all( &app, &mut all_stdout, &mut all_stderr );
            } else if handle_limit( app.n, "open_files", app.H, &mut all_stdout, &mut all_stderr )
                || handle_limit( app.c, "core_file_size", app.H, &mut all_stdout, &mut all_stderr ) {
            } else {
                report_all( &app, &mut all_stdout, &mut all_stderr );
            }

            if !all_stdout.is_empty() {
                print_stdout_with_capture( &all_stdout, &mut cr, cl, cmd, capture );
            }
            if !all_stderr.is_empty() {
                print_stderr_with_capture( &all_stderr, &mut cr, cl, cmd, capture );
            }

            cr
        }

        fn set_limit( limit_name:&str, value:u64, for_hard:bool ) -> String
        {
            let limit_id = match limit_name {
                "open_files" => libc::RLIMIT_NOFILE,
                "core_file_size" => libc::RLIMIT_CORE,
                _ => return String::from( "invalid limit name" ),
            };

            let mut rlp = libc::rlimit { rlim_cur:0, rlim_max:0 };

            unsafe {
                if libc::getrlimit( limit_id, &mut rlp ) != 0 {
                    return format!( "pls:ulimit:error getting limit:{}", Error::last_os_error() );
                }
            }

            // to support armv7-linux-gnueabihf & 32-bit musl systems
            if for_hard {
                #[cfg( all( target_pointer_width = "32", target_env = "gnu" ) )]
                { rlp.rlim_max = value as u32; }
                #[cfg( not( all( target_pointer_width = "32", target_env = "gnu" ) ) )]
                { rlp.rlim_max = value; }
            } else {
                #[cfg( all( target_pointer_width = "32", target_env = "gnu" ) )]
                { rlp.rlim_cur = value as u32; }
                #[cfg( not( all( target_pointer_width = "32", target_env = "gnu" ) ) )]
                { rlp.rlim_cur = value; }
            }

            unsafe {
                if libc::setrlimit( limit_id, &rlp ) != 0 {
                    return format!( "pls:ulimit:error setting limit:{}", Error::last_os_error() );
                }
            }

            String::new()
        }

        fn report_all( app:&App, all_stdout:&mut String, all_stderr:&mut String )
        {
            for limit_name in &["open_files", "core_file_size"]
            {
                let ( out, err ) = get::limit( limit_name, false, app.H );
                all_stdout.push_str( &out );
                all_stderr.push_str( &err );
            }
        }

        fn handle_limit
        ( 
            limit_option:Option<Option<u64>>,
            limit_name:&str,
            for_hard:bool,
            all_stdout:&mut String,
            all_stderr:&mut String
 ) -> bool
        {
            match limit_option
            {
                None => false,
                Some( None ) =>
                {
                    let ( out, err ) = get::limit( limit_name, true, for_hard );
                    all_stdout.push_str( &out );
                    all_stderr.push_str( &err );
                    true
                }
                Some( Some( value ) ) => {
                    let err = set_limit( limit_name, value, for_hard );
                    if !err.is_empty() {
                        all_stderr.push_str( &err );
                    }
                    true
                }
            }
        }
    }
    /**/
    pub mod minfd
    {
        use::
        {
            io::{ Write },
            print::{ print_stdout_with_capture },
            shell::{ Shell },
            types::{CommandResult, CommandLine, Command},
        };

        pub fn run( _sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();

            let fd = nix::fcntl::open( 
                "/dev/null",
                nix::fcntl::OFlag::empty(),
                nix::sys::stat::Mode::empty()
 );
            match fd
            {
                Ok( fd ) => {
                    let info = format!( "{}", fd );
                    print_stdout_with_capture( &info, &mut cr, cl, cmd, capture );
                    unsafe { libc::close( fd ); }
                }
                Err( e ) => {
                    println_stderr!( "pls:minfd:error:{}", e );
                }
            }

            cr
        }

    }
    /**/
    pub mod set
    {
        use ::
        {
            print::{ print_stderr_with_capture, print_stdout_with_capture },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *,
        };

        /*
        #[derive( Debug, StructOpt )]
        #[structopt( name = "set", about = "Set shell options ( BETA )" )]
        struct OptMain {
            #[structopt( short, help = "exit on error status" )]
            exit_on_error:bool,
        }
        */
        #[derive( Debug )]
        struct OptMain();


        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let mut cr = CommandResult::new();
            let tokens = &cmd.tokens;
            let args = parsers::line::tokens_to_args( tokens );
            let show_usage = args.len() > 1 && ( args[1] == "-h" || args[1] == "--help" );

            let opt = OptMain::from_iter_safe( args );
            match opt {
                Ok( opt ) => {
                    if opt.exit_on_error {
                        sh.exit_on_error = true;
                        cr
                    } else {
                        let info = "pls:set:option not implemented";
                        print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                        cr
                    }
                }
                Err( e ) => {
                    let info = format!( "{}", e );
                    if show_usage {
                        print_stdout_with_capture( &info, &mut cr, cl, cmd, capture );
                        cr.status = 0;
                    } else {
                        print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                        cr.status = 1;
                    }
                    cr
                }
            }
        }
    }
    /**/
    pub mod unpath
    {
        use ::
        {
            print::{ print_stderr_with_capture },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *
        };

        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if tokens.len() != 2 {
                let info = "pls:unpath:syntax error";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            let input = &tokens[1].1;
            sh.remove_path( input );
            cr
        }
    }
    /**/
    pub mod unset
    {
        use ::
        {
            print::{ print_stderr_with_capture },
            shell::{ Shell },
            types::{ CommandResult, CommandLine, Command },
            *
        };

        pub fn run( sh:&mut Shell, cl:&CommandLine, cmd:&Command, capture:bool ) -> CommandResult
        {
            let tokens = cmd.tokens.clone();
            let mut cr = CommandResult::new();

            if tokens.len() != 2 {
                let info = "pls:unset:syntax error";
                print_stderr_with_capture( info, &mut cr, cl, cmd, capture );
                return cr;
            }

            let input = &tokens[1].1;
            if !sh.remove_env( input ) {
                let info = format!( "pls:unset:invalid varname:{:?}", input );
                print_stderr_with_capture( &info, &mut cr, cl, cmd, capture );
                return cr;
            }
            cr
        }
    }
}
pub mod c
{
    pub mod time
    {
        use ::
        {
                timing::{ OffsetDateTime },
                *,
        };

        #[derive( Debug, PartialEq, Eq )]
        pub struct DateTime 
        {
            odt:OffsetDateTime,
        }

        impl DateTime
        {
            pub fn now() -> Self
            {
                let odt:OffsetDateTime = match OffsetDateTime::now_local()
                {
                    Ok( dt ) => dt,
                    Err( _ ) => OffsetDateTime::now_utc(),
                };
                DateTime { odt }
            }

            pub fn from_timestamp( ts:f64 ) -> Self
            {
                let dummy_now = Self::now();
                let offset_seconds = dummy_now.odt.offset().whole_minutes() * 60;
                let ts_nano = ( ts + offset_seconds as f64 ) * 1000000000.0;
                let odt:OffsetDateTime = match OffsetDateTime::from_unix_timestamp_nanos( ts_nano as i128 )
                {
                    Ok( x ) => x,
                    Err( _ ) => OffsetDateTime::now_utc(),
                };
                DateTime { odt }
            }

            pub fn unix_timestamp( &self ) -> f64
            {
                self.odt.unix_timestamp_nanos() as f64 / 1000000000.0
            }
        }

        impl fmt::Display for DateTime
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
            {
                write!
                ( 
                    f, 
                    "{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                    self.odt.year(),
                    self.odt.month() as u8,
                    self.odt.day(),
                    self.odt.hour(),
                    self.odt.minute(),
                    self.odt.second(),
                    self.odt.millisecond(),
 )
            }
        }
    }
    /**/
    pub mod job
    {
        use ::
        {
            io::{ Write },
            nix::
            {
                sys::
                {
                    signal::{ Signal },
                    wait::{ waitpid, WaitPidFlag as WF, WaitStatus as WS },
                },
                unistd::{ Pid },
            },
            types::{ self, CommandResult },
            *,
        };

        pub fn print_job( job:&types::Job )
        {
            let line = get::job_line( job, true );
            println_stderr!( "{}", line );
        }

        pub fn mark_job_as_done( sh:&mut shell::Shell, gid:i32, pid:i32, reason:&str )
        {
            if let Some( mut job ) = sh.remove_pid_from_job( gid, pid ) {
                job.status = reason.to_string();
                if job.is_bg {
                    println_stderr!( "" );
                    print_job( &job );
                }
            }
        }

        pub fn mark_job_as_stopped( sh:&mut shell::Shell, gid:i32, report:bool )
        {
            sh.mark_job_as_stopped( gid );
            if !report {
                return;
            }

            // add an extra line to separate output of fg commands if any.
            if let Some( job ) = sh.get_job_by_gid( gid ) {
                println_stderr!( "" );
                print_job( job );
            }
        }

        pub fn mark_job_member_stopped( sh:&mut shell::Shell, pid:i32, gid:i32, report:bool )
        {
            let _gid = if gid == 0 {
                unsafe { libc::getpgid( pid ) }
            } else {
                gid
            };

            if let Some( job ) = sh.mark_job_member_stopped( pid, gid ) {
                if job.all_members_stopped() {
                    mark_job_as_stopped( sh, gid, report );
                }
            }
        }

        pub fn mark_job_member_continued( sh:&mut shell::Shell, pid:i32, gid:i32 )
        {
            let _gid = if gid == 0 {
                unsafe { libc::getpgid( pid ) }
            } else {
                gid
            };

            if let Some( job ) = sh.mark_job_member_continued( pid, gid ) {
                if job.all_members_running() {
                    mark_job_as_running( sh, gid, true );
                }
            }
        }

        pub fn mark_job_as_running( sh:&mut shell::Shell, gid:i32, bg:bool )
        {
            sh.mark_job_as_running( gid, bg );
        }

        pub fn waitpidx( wpid:i32, block:bool ) -> types::WaitStatus
        {
            let options = if block {
                Some( WF::WUNTRACED | WF::WCONTINUED )
            } else {
                Some( WF::WUNTRACED | WF::WCONTINUED | WF::WNOHANG )
            };
            match waitpid( Pid::from_raw( wpid ), options ) {
                Ok( WS::Exited( pid, status ) ) => {
                    let pid = i32::from( pid );
                    types::WaitStatus::from_exited( pid, status )
                }
                Ok( WS::Stopped( pid, sig ) ) => {
                    let pid = i32::from( pid );
                    types::WaitStatus::from_stopped( pid, sig as i32 )
                }
                Ok( WS::Continued( pid ) ) => {
                    let pid = i32::from( pid );
                    types::WaitStatus::from_continuted( pid )
                }
                Ok( WS::Signaled( pid, sig, _core_dumped ) ) => {
                    let pid = i32::from( pid );
                    types::WaitStatus::from_signaled( pid, sig as i32 )
                }
                Ok( WS::StillAlive ) => {
                    types::WaitStatus::empty()
                }
                Ok( _others ) => {
                    // this is for PtraceEvent and PtraceSyscall on Linux,
                    // unreachable on other platforms.
                    types::WaitStatus::from_others()
                }
                Err( e ) => {
                    types::WaitStatus::from_error( e as i32 )
                }
            }
        }

        pub fn wait_fg_job( sh:&mut shell::Shell, gid:i32, pids:&[i32] ) -> CommandResult
        {
            let mut cmd_result = CommandResult::new();
            let mut count_waited = 0;
            let count_child = pids.len();
            if count_child == 0 {
                return cmd_result;
            }
            let pid_last = pids.last().unwrap();

            loop {
                let ws = waitpidx( -1, true );
                // here when we calling waitpidx(), all signals should have
                // been masked. There should no errors ( ECHILD/EINTR etc ) happen.
                if ws.is_error() {
                    let err = ws.get_errno();
                    if err == nix::Error::ECHILD {
                        break;
                    }

                    //log!( "jobc unexpected waitpid error:{}", err );
                    cmd_result = CommandResult::from_status( gid, err as i32 );
                    break;
                }

                let pid = ws.get_pid();
                let is_a_fg_child = pids.contains( &pid );
                if is_a_fg_child && !ws.is_continued() {
                    count_waited += 1;
                }

                if ws.is_exited() {
                    if is_a_fg_child {
                        mark_job_as_done( sh, gid, pid, "Done" );
                    } else {
                        let status = ws.get_status();
                        signals::insert_reap_map( pid, status );
                    }
                } else if ws.is_stopped() {
                    if is_a_fg_child {
                        // for stop signal of fg job ( current job )
                        // i.e. Ctrl-Z is pressed on the fg job
                        mark_job_member_stopped( sh, pid, gid, true );
                    } else {
                        // for stop signal of bg jobs
                        signals::insert_stopped_map( pid );
                        mark_job_member_stopped( sh, pid, 0, false );
                    }
                } else if ws.is_continued() {
                    if !is_a_fg_child {
                        signals::insert_cont_map( pid );
                    }
                    continue;
                } else if ws.is_signaled() {
                    if is_a_fg_child {
                        mark_job_as_done( sh, gid, pid, "Killed" );
                    } else {
                        signals::killed_map_insert( pid, ws.get_signal() );
                    }
                }

                if is_a_fg_child && pid == *pid_last {
                    let status = ws.get_status();
                    cmd_result.status = status;
                }

                if count_waited >= count_child {
                    break;
                }
            }
            cmd_result
        }

        pub fn try_wait_bg_jobs( sh:&mut shell::Shell, report:bool, sig_handler_enabled:bool )
        {
            if sh.jobs.is_empty() {
                return;
            }

            if !sig_handler_enabled {
                // we need to wait pids in case CICADA_ENABLE_SIG_HANDLER=0
                signals::handle_sigchld( Signal::SIGCHLD as i32 );
            }

            let jobs = sh.jobs.clone();
            for ( _i, job ) in jobs.iter() {
                for pid in job.pids.iter() {
                    if let Some( _status ) = signals::pop_reap_map( *pid ) {
                        mark_job_as_done( sh, job.gid, *pid, "Done" );
                        continue;
                    }

                    if let Some( sig ) = signals::killed_map_pop( *pid ) {
                        let reason = if sig == Signal::SIGQUIT as i32 {
                            format!( "Quit:{}", sig )
                        } else if sig == Signal::SIGINT as i32 {
                            format!( "Interrupt:{}", sig )
                        } else if sig == Signal::SIGKILL as i32 {
                            format!( "Killed:{}", sig )
                        } else if sig == Signal::SIGTERM as i32 {
                            format!( "Terminated:{}", sig )
                        } else {
                            format!( "Killed:{}", sig )
                        };
                        mark_job_as_done( sh, job.gid, *pid, &reason );
                        continue;
                    }

                    if signals::pop_stopped_map( *pid ) {
                        mark_job_member_stopped( sh, *pid, job.gid, report );
                    } else if signals::pop_cont_map( *pid ) {
                        mark_job_member_continued( sh, *pid, job.gid );
                    }
                }
            }
        }
    }
}
pub mod cell { pub use std::cell::{ * }; }
pub mod char
{
    pub use std::char::{ * };

    /// Returns the width of a character in the terminal.
    #[inline] pub fn char_width( ch:char ) -> Option<usize>
    {
        use unicode_width::UnicodeWidthChar;
        ch.width()
    }
}
pub mod clone { pub use std::clone::{ * }; }
pub mod cmp { pub use std::cmp::{ * }; }
pub mod collections { pub use std::collections::{ * }; }
pub mod completers
{
    use ::
    {
        path::{ Path },
        regex::{ Regex },
        slice::{ unescape },
        sync::{ Arc },
        *,
    };
    /*
    use linefeed::complete::{Completer, Completion};
    use linefeed::prompter::Prompter;
    use linefeed::terminal::Terminal;
    */
    pub mod dots
    {
        /*
        use linefeed::complete::escape;
        use linefeed::complete::escaped_word_start;
        use linefeed::complete::unescape;
        use linefeed::complete::Suffix;
        use linefeed::complete::{Completer, Completion};
        use linefeed::prompter::Prompter;
        use linefeed::terminal::Terminal;
        use yaml_rust::{Yaml, YamlLoader};
        use yaml_rust::yaml::Hash;
        */
        use ::
        {
            borrow::{ Cow },
            fs::{ File },
            hash::{ Hash },
            io::{ Read, Write },
            path::{ Path },
            slice::{ unescape },
            *,
        };

        /// Performs completion by searching dotfiles
        pub struct DotsCompleter;

        impl<Term:Terminal> Completer<Term> for DotsCompleter
        {
            fn complete
            ( 
                &self,
                word:&str,
                reader:&Prompter<Term>,
                _start:usize,
                _end:usize,
 ) -> Option<Vec<Completion>>
            {
                let line = reader.buffer();
                Some( complete_dots( line, word ) )
            }

            fn word_start( &self, line:&str, end:usize, _reader:&Prompter<Term> ) -> usize
            {
                completers::escaped_word_start( &line[..end] )
            }

            fn quote<'a>( &self, word:&'a str ) -> Cow<'a, str>
            {
                regex::escape( word )
            }

            fn unquote<'a>( &self, word:&'a str ) -> Cow<'a, str>
            {
                unescape( word )
            }
        }

        fn get_dot_file( line:&str ) -> ( String, String )
        {
            let args = parsers::line::line_to_plain_tokens( line );
            let dir = get::user_completer_directory();
            let dot_file = format!( "{}/{}.yaml", dir, args[0] );
            if !Path::new( &dot_file ).exists() {
                return ( String::new(), String::new() );
            }
            let sub_cmd = if ( args.len() >= 3 && !args[1].starts_with( '-' ) )
                || ( args.len() >= 2 && !args[1].starts_with( '-' ) && line.ends_with( ' ' ) )
            {
                args[1].as_str()
            } else {
                ""
            };

            ( dot_file, sub_cmd.to_string() )
        }

        fn handle_lv1_string( res:&mut Vec<Completion>, value:&str, word:&str )
        {
            if !value.starts_with( word ) && !value.starts_with( '`' ) {
                return;
            }

            let linfo = parsers::line::parse_line( value );
            let tokens = linfo.tokens;
            if tokens.len() == 1 && tokens[0].0 == "`" {
                //log!( "run subcmd:{:?}", &tokens[0].1 );
                let cr = now::run( &tokens[0].1 );
                let v:Vec<&str> = cr.stdout.split( |c| c == '\n' || c == ' ' ).collect();
                for s in v {
                    if s.trim().is_empty() {
                        continue;
                    }
                    handle_lv1_string( res, s, word );
                }
                return;
            }

            let display = None;
            let suffix = Suffix::Default;
            res.push( Completion {
                completion:value.to_string(),
                display,
                suffix,
            } );
        }

        fn handle_lv1_hash( res:&mut Vec<Completion>, h:&Hash, word:&str )
        {
            for v in h.values() {
                if let Yaml::Array( ref arr ) = v {
                    for s in arr {
                        if let Yaml::String( value ) = s {
                            if !value.starts_with( word ) && !value.starts_with( '`' ) {
                                continue;
                            }
                            handle_lv1_string( res, value, word );
                        }
                    }
                }
            }
        }

        fn complete_dots( line:&str, word:&str ) -> Vec<Completion>
        {
            let mut res = Vec::new();
            if line.trim().is_empty() {
                return res;
            }
            let ( dot_file, sub_cmd ) = get_dot_file( line );
            if dot_file.is_empty() {
                return res;
            }

            let mut f;
            match File::open( &dot_file ) {
                Ok( x ) => f = x,
                Err( e ) => {
                    println_stderr!( "\ncicada:open dot_file error:{:?}", e );
                    return res;
                }
            }

            let mut s = String::new();
            match f.read_to_string( &mut s ) {
                Ok( _ ) => {}
                Err( e ) => {
                    println_stderr!( "\ncicada:read_to_string error:{:?}", e );
                    return res;
                }
            }

            let docs = match YamlLoader::load_from_str( &s ) {
                Ok( x ) => x,
                Err( e ) => {
                    println_stderr!( "\ncicada:Bad Yaml file:{}:{:?}", dot_file, e );
                    return res;
                }
            };

            for doc in docs.iter() {
                match *doc {
                    Yaml::Array( ref v ) => {
                        for x in v {
                            match *x {
                                Yaml::String( ref name ) => {
                                    if !sub_cmd.is_empty() {
                                        continue;
                                    }
                                    handle_lv1_string( &mut res, name, word );
                                }
                                Yaml::Hash( ref h ) => {
                                    if sub_cmd.is_empty() {
                                        for k in h.keys() {
                                            if let Yaml::String( value ) = k {
                                                handle_lv1_string( &mut res, value, word );
                                            }
                                        }
                                    } else {
                                        let key = Yaml::from_str( &sub_cmd );
                                        if !h.contains_key( &key ) {
                                            continue;
                                        }
                                        handle_lv1_hash( &mut res, h, word );
                                    }
                                }
                                _ => {
                                    println_stderr!( "\nThis yaml file is in bad format:{}", dot_file );
                                }
                            }
                        }
                    }
                    _ => {
                        println_stderr!( "\nThis yaml file is in bad format:{}", dot_file );
                    }
                }
            }
            res
        }
    }

    pub mod environment
    {
        /*
        use linefeed::complete::{Completer, Completion, Suffix};
        use linefeed::prompter::Prompter;
        use linefeed::terminal::Terminal;
        */
        use ::
        {
            sync::{ Arc },
            *,
        };

        pub struct EnvCompleter
        {
            pub sh:Arc<shell::Shell>,
        }

        impl<Term:Terminal> Completer<Term> for EnvCompleter
        {
            fn complete( 
                &self,
                word:&str,
                _reader:&Prompter<Term>,
                _start:usize,
                _end:usize,
 ) -> Option<Vec<Completion>> {
                let sh = Arc::try_unwrap( self.sh.clone() );
                match sh {
                    Ok( x ) => Some( complete_env( &x, word ) ),
                    Err( x ) => Some( complete_env( &x, word ) ),
                }
            }
        }

        fn complete_env( sh:&shell::Shell, path:&str ) -> Vec<Completion>
        {
            let mut res = Vec::new();
            if path.trim().is_empty() {
                return res;
            }
            let mut prefix = path.to_string();
            prefix.remove( 0 );

            for ( key, _ ) in env::vars_os() {
                let env_name = key.to_string_lossy().to_string();
                if env_name.starts_with( &prefix ) {
                    res.push( Completion {
                        completion:format!( "${}", env_name ),
                        display:None,
                        suffix:Suffix::Default,
                    } );
                }
            }

            // sh.envs is a just clone here; see FIXME in main.rs
            for key in sh.envs.keys() {
                if key.starts_with( &prefix ) {
                    res.push( Completion {
                        completion:format!( "${}", key ),
                        display:None,
                        suffix:Suffix::Default,
                    } );
                }
            }

            res
        }
    }

    pub mod make
    {
        /*
        use linefeed::complete::{Completer, Completion, Suffix};
        use linefeed::prompter::Prompter;
        use linefeed::terminal::Terminal; */
        use ::
        {
            fs::{ File },
            io::{ BufRead, BufReader, Write },
            regex::{ Regex },
            *
        };

        pub struct MakeCompleter;

        impl<Term:Terminal> Completer<Term> for MakeCompleter
        {
            fn complete( 
                &self,
                word:&str,
                _reader:&Prompter<Term>,
                _start:usize,
                _end:usize,
 ) -> Option<Vec<Completion>> {
                Some( complete_make( word ) )
            }
        }

        fn handle_file( ci:&mut Vec<Completion>, path:&str, file_path:&str, current_dir:&str )
        {
            if let Ok( f ) = File::open( file_path ) {
                let file = BufReader::new( &f );
                let re_cmd = match Regex::new( r"^ *( [^ ]+ ):" ) {
                    Ok( x ) => x,
                    Err( e ) => {
                        println_stderr!( "pls:regex build error:{:?}", e );
                        return;
                    }
                };

                let re_include = match Regex::new( r"^ *include  *( [^ ]+ ) *$" ) {
                    Ok( x ) => x,
                    Err( e ) => {
                        println_stderr!( "pls:regex build error:{:?}", e );
                        return;
                    }
                };

                for line in file.lines().map_while( Result::ok ) {
                    if re_cmd.is_match( &line ) {
                        for cap in re_cmd.captures_iter( &line ) {
                            if !cap[1].starts_with( path ) {
                                continue;
                            }
                            ci.push( Completion {
                                completion:cap[1].to_string(),
                                display:None,
                                suffix:Suffix::Default,
                            } );
                        }
                    }
                    if re_include.is_match( &line ) {
                        for cap in re_include.captures_iter( &line ) {
                            let _file = &cap[1];
                            if _file.contains( '/' ) {
                                handle_file( ci, path, _file, current_dir );
                            } else {
                                let make_file = current_dir.to_owned() + "/" + _file;
                                handle_file( ci, path, &make_file, current_dir );
                            }
                        }
                    }
                }
            }
        }

        fn complete_make( path:&str ) -> Vec<Completion>
        {
            let mut res = Vec::new();
            let current_dir = match env::current_dir() {
                Ok( dir ) => match dir.to_str() {
                    Some( s ) => s.to_string(),
                    None => {
                        println!( "pls:to_str error" );
                        return res;
                    }
                },
                Err( e ) => {
                    println!( "pls:get current_dir error:{:?}", e );
                    return res;
                }
            };

            let make_file = format!( "{}/Makefile", current_dir );
            handle_file( &mut res, path, &make_file, &current_dir );
            res
        }
    }

    pub mod path
    {
        /*
        use linefeed::complete::{Completer, Completion, Suffix};
        use linefeed::terminal::Terminal;
        use linefeed::Prompter; */
        use ::
        {
            collections::{ HashSet },
            fs::{ read_dir },
            io::{ Write },
            iter::{ FromIterator },
            os::unix::fs::{ PermissionsExt },
            path::{ MAIN_SEPARATOR },
            sync::{ Arc },
            *,
        };

        pub struct BinCompleter
        {
            pub sh:Arc<shell::Shell>,
        }

        pub struct CdCompleter;
        pub struct PathCompleter;

        impl<Term:Terminal> Completer<Term> for BinCompleter
        {
            fn complete( 
                &self,
                word:&str,
                _reader:&Prompter<Term>,
                _start:usize,
                _end:usize,
 ) -> Option<Vec<Completion>> {
                let sh = Arc::try_unwrap( self.sh.clone() );
                match sh {
                    Ok( x ) => Some( complete_bin( &x, word ) ),
                    Err( x ) => Some( complete_bin( &x, word ) ),
                }
            }
        }

        impl<Term:Terminal> Completer<Term> for PathCompleter
        {
            fn complete( 
                &self,
                word:&str,
                _reader:&Prompter<Term>,
                _start:usize,
                _end:usize,
 ) -> Option<Vec<Completion>> {
                Some( complete_path( word, false ) )
            }
        }

        impl<Term:Terminal> Completer<Term> for CdCompleter
        {
            fn complete( 
                &self,
                word:&str,
                _reader:&Prompter<Term>,
                _start:usize,
                _end:usize,
 ) -> Option<Vec<Completion>> {
                Some( complete_path( word, true ) )
            }
        }

        fn needs_expand_home( line:&str ) -> bool
        {
            regex::re_contains( line, r"( +~ + )|( +~/ )|( ^ *~/ )|( +~ *$ )" )
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        pub fn complete_path( word:&str, for_dir:bool ) -> Vec<Completion>
        {
            let is_env = is::env_prefix( word );
            let mut res = Vec::new();
            let linfo = parsers::line::parse_line( word );
            let tokens = linfo.tokens;
            let ( path, path_sep ) = if tokens.is_empty() {
                ( String::new(), String::new() )
            } else {
                let ( ref _path_sep, ref _path ) = tokens[tokens.len() - 1];
                ( _path.clone(), _path_sep.clone() )
            };

            let ( _, _dir_orig, _f ) = split_pathname( &path, "" );
            let dir_orig = if _dir_orig.is_empty() {
                String::new()
            } else {
                _dir_orig.clone()
            };
            let mut path_extended = path.clone();
            if needs_expand_home( &path_extended ) { expand::home_string( &mut path_extended ) }
            expand::environment_string( &mut path_extended );

            let ( _, _dir_lookup, file_name ) = split_pathname( &path_extended, "" );
            let dir_lookup = if _dir_lookup.is_empty() {
                ".".to_string()
            } else {
                _dir_lookup.clone()
            };
            // let dir_lookup = _dir_lookup.unwrap_or( "." );
            if let Ok( entries ) = read_dir( dir_lookup ) {
                for entry in entries.flatten() {
                    let pathbuf = entry.path();
                    let is_dir = pathbuf.is_dir();
                    if for_dir && !is_dir {
                        continue;
                    }

                    let entry_name = entry.file_name();
                    // TODO:Deal with non-UTF8 paths in some way
                    if let Ok( _path ) = entry_name.into_string() {
                        if _path.starts_with( &file_name ) {
                            let ( name, display ) = if !dir_orig.is_empty() {
                                ( 
                                    format!( "{}{}{}", dir_orig, MAIN_SEPARATOR, _path ),
                                    Some( _path ),
 )
                            } else {
                                ( _path, None )
                            };
                            let mut name = str::replace( name.as_str(), "//", "/" );
                            if path_sep.is_empty() && !is_env {
                                name = path::escape_path( &name );
                            }
                            let mut quoted = false;
                            if !path_sep.is_empty() {
                                name = str::wrap_sep_string( &path_sep, &name );
                                quoted = true;
                            }
                            let suffix = if is_dir {
                                if quoted {
                                    name.pop();
                                }
                                Suffix::Some( MAIN_SEPARATOR )
                            } else {
                                Suffix::Default
                            };
                            res.push( Completion {
                                completion:name,
                                display,
                                suffix,
                            } );
                        }
                    }
                }
            }
            res.sort_by( |a, b| a.completion.cmp( &b.completion ) );
            res
        }

        // Split optional directory and prefix. ( see its test cases for more details )
        fn split_pathname( path:&str, prefix:&str ) -> ( String, String, String )
        {
            if is::pipelined( path ) {
                let tokens:Vec<&str> = path.rsplitn( 2, '|' ).collect();
                let prefix = format!( "{}|", tokens[1] );
                return split_pathname( tokens[0], &prefix );
            }
            match path.rfind( '/' ) {
                Some( pos ) => ( 
                    prefix.to_string(),
                    path[..=pos].to_string(),
                    path[pos + 1..].to_string(),
 ),
                None => ( prefix.to_string(), String::new(), path.to_string() ),
            }
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        fn complete_bin( sh:&shell::Shell, path:&str ) -> Vec<Completion>
        {
            let mut res = Vec::new();
            let ( prefix, _, fname ) = split_pathname( path, "" );
            let env_path = match env::var( "PATH" ) {
                Ok( x ) => x,
                Err( e ) => {
                    println_stderr!( "pls:env error when complete_bin:{:?}", e );
                    return res;
                }
            };

            let mut checker:HashSet<String> = HashSet::new();

            // handle alias, builtins, and functions
            for func in sh.funcs.keys() {
                if !func.starts_with( &fname ) {
                    continue;
                }
                if checker.contains( func ) {
                    continue;
                }
                checker.insert( func.clone() );
                res.push( Completion {
                    completion:func.to_owned(),
                    display:None,
                    suffix:Suffix::Default,
                } );
            }
            for alias in sh.alias.keys() {
                if !alias.starts_with( &fname ) {
                    continue;
                }
                if checker.contains( alias ) {
                    continue;
                }
                checker.insert( alias.clone() );
                res.push( Completion {
                    completion:alias.to_owned(),
                    display:None,
                    suffix:Suffix::Default,
                } );
            }

            let builtins = vec![
                "alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg",
                "history", "jobs", "read", "source", "ulimit", "unalias", "vox",
                "minfd", "set", "unset", "unpath",
            ];
            for item in &builtins {
                if !item.starts_with( &fname ) {
                    continue;
                }
                if checker.contains( *item ) {
                    continue;
                }
                checker.insert( item.to_string() );
                res.push( Completion {
                    completion:item.to_string(),
                    display:None,
                    suffix:Suffix::Default,
                } );
            }

            let vec_path:Vec<&str> = env_path.split( ':' ).collect();
            let path_list:HashSet<&str> = HashSet::from_iter( vec_path.iter().cloned() );

            for p in &path_list {
                if let Ok( list ) = read_dir( p ) {
                    for entry in list.flatten() {
                        if let Ok( name ) = entry.file_name().into_string() {
                            if name.starts_with( &fname ) {
                                let _mode = match entry.metadata() {
                                    Ok( x ) => x,
                                    Err( e ) => {
                                        println_stderr!( "pls:metadata error:{:?}", e );
                                        continue;
                                    }
                                };
                                let mode = _mode.permissions().mode();
                                if mode & 0o111 == 0 {
                                    // not binary
                                    continue;
                                }
                                if checker.contains( &name ) {
                                    continue;
                                }

                                let display = None;
                                let suffix = Suffix::Default;
                                checker.insert( name.clone() );
                                // TODO:need to handle quoted:`$ "foo#bar"`
                                let name_e = path::escape_path( &name );
                                let name_e = format!( "{}{}", prefix, name_e );
                                res.push( Completion {
                                    completion:name_e,
                                    display,
                                    suffix,
                                } );
                            }
                        }
                    }
                }
            }
            res
        }
    }

    pub mod ssh
    {
        /*
        use linefeed::complete::{Completer, Completion, Suffix};
        use linefeed::terminal::Terminal;
        use linefeed::Prompter;
        */
        use ::
        {
            fs::{ File },
            io::{ BufRead, BufReader },
            regex::{ Regex },
            *,
        };

        pub struct SshCompleter;

        impl<Term:Terminal> Completer<Term> for SshCompleter
        {
            fn complete( 
                &self,
                word:&str,
                _reader:&Prompter<Term>,
                _start:usize,
                _end:usize,
 ) -> Option<Vec<Completion>> {
                Some( complete_ssh( word ) )
            }
        }

        fn complete_ssh( path:&str ) -> Vec<Completion>
        {
            let mut res = Vec::new();
            let home = get::user_home();
            let ssh_config = home + "/.ssh/config";
            if let Ok( f ) = File::open( &ssh_config ) {
                let file = BufReader::new( &f );
                let re = match Regex::new( r"^ *( ?i )host +( [^ ]+ )" ) {
                    Ok( x ) => x,
                    Err( e ) => {
                        println!( "Regex build error:{:?}", e );
                        return res;
                    }
                };
                for line in file.lines().map_while( Result::ok ) {
                    if !re.is_match( &line ) {
                        continue;
                    }
                    for cap in re.captures_iter( &line ) {
                        if !cap[1].starts_with( path ) {
                            continue;
                        }
                        res.push( Completion {
                            completion:cap[1].to_string(),
                            display:None,
                            suffix:Suffix::Default,
                        } );
                    }
                }
            }
            res
        }
    }

    pub struct CicadaCompleter
    {
        pub sh:Arc<shell::Shell>,
    }

    impl<Term:Terminal> Completer<Term> for CicadaCompleter
    {
        fn complete
        ( 
            &self,
            word:&str,
            reader:&Prompter<Term>,
            start:usize,
            _end:usize,
 ) -> Option<Vec<Completion>>
        {
            let line = reader.buffer();
            let completions:Option<Vec<Completion>>;
            if for_dots( line )
            {
                let cpl = Arc::new( dots::DotsCompleter );
                completions = cpl.complete( word, reader, start, _end );
            }
            else if for_ssh( line )
            {
                let cpl = Arc::new( ssh::SshCompleter );
                completions = cpl.complete( word, reader, start, _end );
            }

            else if for_make( line )
            {
                let cpl = Arc::new( make::MakeCompleter );
                completions = cpl.complete( word, reader, start, _end );
            }
            else if for_bin( line )
            {
                let cpl = Arc::new( path::BinCompleter {
                    sh:self.sh.clone(),
                } );
                completions = cpl.complete( word, reader, start, _end );
            }
            else if for_env( line )
            {
                let cpl = Arc::new( completers::environment::EnvCompleter {
                    sh:self.sh.clone(),
                } );
                completions = cpl.complete( word, reader, start, _end );
            }
            else if for_cd( line )
            {
                // `for_cd` should be put a bottom position, so that
                // `cd $SOME_ENV_<TAB>` works as expected.
                let cpl = Arc::new( path::CdCompleter );
                // completions for `cd` should not fail back to path-completion
                return cpl.complete( word, reader, start, _end );
            }
            else { completions = None; }

            if let Some( x ) = completions
            {
                if !x.is_empty()
                {
                    return Some( x );
                }
            }

            // empty completions should fail to path-completion, so that
            // `$ make generate /path/to/fi<Tab>` still works.
            let cpl = Arc::new( path::PathCompleter );
            cpl.complete( word, reader, start, _end )
        }

        fn word_start( &self, line:&str, end:usize, _reader:&Prompter<Term> ) -> usize
        { escaped_word_start( &line[..end] ) }
    }

    pub fn for_make( line:&str ) -> bool
    {
        regex::re_contains( line, r"^ *make " )
    }

    pub fn for_env( line:&str ) -> bool
    {
        regex::re_contains( line, r" *\$[_a-zA-Z0-9]*$" )
    }

    pub fn for_ssh( line:&str ) -> bool
    {
        regex::re_contains( line, r"^ *( ssh|scp ).* +[^ \./]+ *$" )
    }

    pub fn for_cd( line:&str ) -> bool
    {
        regex::re_contains( line, r"^ *cd +" )
    }

    pub fn for_bin( line:&str ) -> bool
    {
        let ptn = r"( ^ *( sudo|which|nohup )? *[a-zA-Z0-9_\.-]+$ )|( ^.+\| *( sudo|which|nohup )? *[a-zA-Z0-9_\.-]+$ )";
        regex::re_contains( line, ptn )
    }

    pub fn for_dots( line:&str ) -> bool
    {
        let args = parsers::line::line_to_plain_tokens( line );
        let len = args.len();
        if len == 0 { return false; }
        let dir = get::user_completer_directory();
        let dot_file = format!( "{}/{}.yaml", dir, args[0] );
        Path::new( dot_file.as_str() ).exists()
    }

    pub fn escaped_word_start( line:&str ) -> usize
    {
        let mut start_position:usize = 0;
        let mut found_bs = false;
        let mut found_space = false;
        let mut with_quote = false;
        let mut ch_quote = '\0';
        let mut extra_bytes = 0;
        for ( i, c ) in line.chars().enumerate()
        {
            if found_space
            {
                found_space = false;
                start_position = i + extra_bytes;
            }

            if c == '\\'
            {
                found_bs = true;
                continue;
            }
            
            if c == ' ' && !found_bs && !with_quote
            {
                found_space = true;
                continue;
            }

            if !with_quote && !found_bs && ( c == '"' || c == '\'' )
            {
                with_quote = true;
                ch_quote = c;
            }

            else if with_quote && !found_bs && ch_quote == c
            {
                with_quote = false;
            }

            let bytes_c = c.len_utf8();
            if bytes_c > 1 { extra_bytes += bytes_c - 1; }
            found_bs = false;
        }
        
        if found_space { start_position = line.len(); }
        start_position
    }
}
pub mod convert { pub use std::convert::{ * }; }
pub mod default { pub use std::default::{ * }; }
pub mod env
{
    pub use std::env::{ * };
    use ::
    {
        *
    };
    /* init_path_env( ... ) */
    pub fn initialize_path_environment()
    {
        // order matters. took from `runc spec`
        let mut paths:Vec<String> = vec![];
        for x in
        [
            "/usr/local/sbin",
            "/usr/local/bin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
        ]
        {
            if path::Path::new( x ).exists() { paths.push( x.to_string() ); }
        }

        if let Ok( env_path ) = var( "PATH" )
        {
            for x in env_path.split( ":" )
            {
                if !paths.contains( &x.to_string() ) { paths.push( x.to_string() ); }
            }
        }

        let paths = paths.join( ":" );
        set_var( "PATH", paths );
    }
    /* env_args_to_command_line( ... ) -> String */
    pub fn arguments_to_command_line() -> String
    {
        let mut result = String::new();
        let env_args = args();
        if env_args.len() <= 1
        {
            return result;
        }
        for ( i, arg ) in env_args.enumerate()
        {
            if i == 0 || arg == "-c" { continue; }
            result.push_str( arg.as_str() );
        }
        result
    }
}
pub mod expand
{
    use ::
    {
        shell::{ brace_getitem, Shell },
        regex::{ Regex },
        *
    };
    /*
    pub fn expand_alias( ... )*/
    pub fn alias( sh:&Shell, tokens:&mut types::Tokens )
    {
        let mut idx:usize = 0;
        let mut buff = Vec::new();
        let mut is_head = true;
        for ( sep, text ) in tokens.iter()
        {
            if sep.is_empty() && text == "|" {
                is_head = true;
                idx += 1;
                continue;
            }
            if is_head && text == "xargs" {
                idx += 1;
                continue;
            }

            if !is_head || !sh.is_alias( text ) {
                idx += 1;
                is_head = false;
                continue;
            }

            if let Some( value ) = sh.get_alias_content( text ) {
                buff.push( ( idx, value.clone() ) );
            }

            idx += 1;
            is_head = false;
        }

        for ( i, text ) in buff.iter().rev()
        {
            let linfo = parsers::line::parse_line( text );
            let tokens_ = linfo.tokens;
            tokens.remove( *i );
            for item in tokens_.iter().rev()
            {
                tokens.insert( *i, item.clone() );
            }
        }
    }
    /*
    pub fn expand_arguments( ... )*/
    pub fn arguments( line:&str, args:&[String] ) -> String
    {
        let linfo = parsers::line::parse_line( line );
        let mut tokens = linfo.tokens;
        arguments_in_tokens( &mut tokens, args );
        parsers::line::tokens_to_line( &tokens )
    }
    /*
    pub fn expand_args_for_single_token( ... )*/
    pub fn arguments_for_token( token:&str, args:&[String] ) -> String
    {
        let re = Regex::new( r"^( .*? )\$\{?( [0-9]+|@ )\}?( .* )$" ).unwrap();
        if !re.is_match( token ) { return token.to_string(); }

        let mut result = String::new();
        let mut _token = token.to_string();
        let mut _head = String::new();
        let mut _output = String::new();
        let mut _tail = String::new();
        loop
        {
            if !re.is_match( &_token )
            {
                if !_token.is_empty()
                {
                    result.push_str( &_token );
                }
                break;
            }

            for cap in re.captures_iter( &_token )
            {
                _head = cap[1].to_string();
                _tail = cap[3].to_string();
                let _key = cap[2].to_string();
                if _key == "@"
                { result.push_str( format!( "{}{}", _head, args[1..].join( " " ) ).as_str() ); } 
                
                else if let Ok( arg_idx ) = _key.parse::<usize>()
                {
                    if arg_idx < args.len()
                    {
                        result.push_str( format!( "{}{}", _head, args[arg_idx] ).as_str() );
                    } 
                    else
                    {
                        result.push_str( &_head );
                    }
                } 
                else
                { result.push_str( &_head ); }
            }

            if _tail.is_empty() {
                break;
            }
            _token = _tail.clone();
        }
        result
    }
    /*
    pub fn expand_args_in_tokens( ... )*/
    pub fn arguments_in_tokens( tokens:&mut types::Tokens, args:&[String] )
    {
        let mut idx:usize = 0;
        let mut buff = Vec::new();

        for ( sep, token ) in tokens.iter()
        {
            if sep == "`" || sep == "'" || !is::arguments_in_token( token )
            {
                idx += 1;
                continue;
            }

            let _token = arguments_for_token( token, args );
            buff.push( ( idx, _token ) );
            idx += 1;
        }

        for ( i, text ) in buff.iter().rev()
        {
            tokens[*i].1 = text.to_string();
        }
    }
    /*
    pub fn expand_brace( ... )*/
    pub fn brace( tokens:&mut types::Tokens )
    {
        let mut idx:usize = 0;
        let mut buff = Vec::new();
        for ( sep, token ) in tokens.iter()
        {
            if !sep.is_empty() || !is::brace_expandable( token )
            {
                idx += 1;
                continue;
            }

            let mut result:Vec<String> = Vec::new();
            let items = brace_getitem( token, 0 );
            for x in items.0
            { result.push( x.clone() ); }
            buff.push( ( idx, result ) );
            idx += 1;
        }

        for ( i, items ) in buff.iter().rev()
        {
            tokens.remove( *i );
            for ( j, token ) in items.iter().enumerate()
            {
                let sep = if token.contains( ' ' ) { "\"" } else { "" };
                tokens.insert( *i + j, ( sep.to_string(), token.clone() ) );
            }
        }
    }
    /*
    pub fn expand_brace_range( ... )*/
    pub fn brace_range( tokens:&mut types::Tokens )
    {
        let re;
        if let Ok( x ) = Regex::new( r#"\{( -?[0-9]+ )\.\.( -?[0-9]+ )( \.\. )?( [0-9]+ )?\}"# ) { re = x; }

        else
        {
            println_stderr!( "pls:re new error" );
            return;
        }

        let mut idx:usize = 0;
        let mut buff:Vec<( usize, Vec<String> )> = Vec::new();
        for ( sep, token ) in tokens.iter()
        {
            if !sep.is_empty() || !re.is_match( token )
            {
                idx += 1;
                continue;
            }

            // safe to unwrap here, since the `is_match` above already validated
            let caps = re.captures( token ).unwrap();
            let start = match caps[1].to_string().parse::<i32>()
            {
                Ok( x ) => x,
                Err( e ) =>
                {
                    println_stderr!( "pls:{}", e );
                    return;
                }
            };

            let end = match caps[2].to_string().parse::<i32>()
            {
                Ok( x ) => x,
                Err( e ) =>
                {
                    println_stderr!( "pls:{}", e );
                    return;
                }
            };

            // incr is always positive
            let mut incr = if caps.get( 4 ).is_none() { 1 }
            else
            {
                match caps[4].to_string().parse::<i32>()
                {
                    Ok( x ) => x,
                    Err( e ) =>
                    {
                        println_stderr!( "pls:{}", e );
                        return;
                    }
                }
            };

            if incr <= 1
            {
                incr = 1;
            }

            let mut result:Vec<String> = Vec::new();
            let mut n = start;
            if start > end
            {
                while n >= end
                {
                    result.push( format!( "{}", n ) );
                    n -= incr;
                }
            }

            else
            {
                while n <= end
                {
                    result.push( format!( "{}", n ) );
                    n += incr;
                }
            }

            buff.push( ( idx, result ) );
            idx += 1;
        }

        for ( i, items ) in buff.iter().rev()
        {
            tokens.remove( *i );
            for ( j, token ) in items.iter().enumerate()
            {
                let sep = if token.contains( ' ' ) { "\"" } else { "" };
                tokens.insert( *i + j, ( sep.to_string(), token.clone() ) );
            }
        }
    }
    /*
    pub fn expand_env( ... )*/
    pub fn environment( sh:&Shell, tokens:&mut types::Tokens )
    {
        let mut idx:usize = 0;
        let mut buff = Vec::new();

        for ( sep, token ) in tokens.iter()
        {
            if sep == "`" || sep == "'"
            {
                idx += 1;
                continue;
            }

            if !is::environment_in_token( token )
            {
                idx += 1;
                continue;
            }

            let mut _token = token.clone();
            while is::environment_in_token( &_token ) 
            { _token = single_environment( sh, &_token ); }
            buff.push( ( idx, _token ) );
            idx += 1;
        }

        for ( i, text ) in buff.iter().rev()
        {
            tokens[*i].1 = text.to_string();
        }
    }
    /*
    pub fn expand_env_string( ... )*/
    pub fn environment_string( text:&mut String )
    {
        // expand "$HOME/.local/share" to "/home/tom/.local/share"
        if !text.starts_with( '$' ) { return; }

        let ptn = r"^\$( [A-Za-z_][A-Za-z0-9_]* )";
        let mut env_value = String::new();
        match regex::find_first_group( ptn, text )
        {
            Some( x ) =>
            {
                if let Ok( val ) = env::var( &x )
                { env_value = val; }
            }
            None => { return; }
        }

        if env_value.is_empty() { return; }
        let t = text.clone();
        *text = regex::replace_all( &t, ptn, &env_value );
    }
    /*
    pub fn expand_glob( ... )*/
    pub fn glob( tokens:&mut types::Tokens )
    {
        let mut idx:usize = 0;
        let mut buff = Vec::new();
        for ( sep, text ) in tokens.iter()
        {
            if !sep.is_empty() || !is::globable( text )
            {
                idx += 1;
                continue;
            }

            let mut result:Vec<String> = Vec::new();
            let item = text.as_str();
            if !item.contains( '*' ) || item.trim().starts_with( '\'' ) || item.trim().starts_with( '"' )
            {
                result.push( item.to_string() );
            }

            else
            {
                let _basename = path::basename( item );
                let show_hidden = _basename.starts_with( ".*" );
                match glob::glob( item )
                {
                    Ok( paths ) =>
                    {
                        let mut is_empty = true;
                        for entry in paths
                        {
                            match entry
                            {
                                Ok( path ) =>
                                {
                                    let file_path = path.to_string_lossy();
                                    let _basename = path::basename( &file_path );
                                    if _basename == ".." || _basename == "." { continue; }
                                    if _basename.starts_with( '.' ) && !show_hidden { continue; }
                                    result.push( file_path.to_string() );
                                    is_empty = false;
                                }

                                Err( e ) => { /*log!( "glob error:{:?}", e );*/ }
                            }
                        }

                        if is_empty  { result.push( item.to_string() ); }
                    }

                    Err( e ) =>
                    {
                        println!( "glob error:{:?}", e );
                        result.push( item.to_string() );
                        return;
                    }
                }
            }

            buff.push( ( idx, result ) );
            idx += 1;
        }

        for ( i, result ) in buff.iter().rev()
        {
            tokens.remove( *i );
            for ( j, token ) in result.iter().enumerate()
            {
                let sep = if token.contains( ' ' ) { "\"" } else { "" };
                tokens.insert( *i + j, ( sep.to_string(), token.clone() ) );
            }
        }
    }
    /*
    pub fn expand_arguments( ... )*/
    pub fn home( text:&str ) -> String
    {
        let mut s:String = text.to_string();
        let v = vec!
        [
            r"( ?P<head> + )~( ?P<tail> + )",
            r"( ?P<head> + )~( ?P<tail>/ )",
            r"^( ?P<head> * )~( ?P<tail>/ )",
            r"( ?P<head> + )~( ?P<tail> *$ )",
        ];

        for item in &v
        {
            let re;
            if let Ok( x ) = Regex::new( item ) { re = x; }
            else { return String::new(); }
            let home = get::user_home();
            let ss = s.clone();
            let to = format!( "$head{}$tail", home );
            let result = re.replace_all( ss.as_str(), to.as_str() );
            s = result.to_string();
        }
        s
    }
    /*
    pub fn expands_home( ... )*/
    pub fn house( tokens:&mut types::Tokens )
    {
        let mut idx:usize = 0;
        let mut buff = Vec::new();
        for ( sep, text ) in tokens.iter()
        {
            if !sep.is_empty() || !text.starts_with( "~" )
            {
                idx += 1;
                continue;
            }

            let mut s:String = text.clone();
            let ptn = r"^~( ?P<tail>.* )";
            let re = Regex::new( ptn ).expect( "invalid re ptn" );
            let home = get::user_home();
            let ss = s.clone();
            let to = format!( "{}$tail", home );
            let result = re.replace_all( ss.as_str(), to.as_str() );
            s = result.to_string();

            buff.push( ( idx, s.clone() ) );
            idx += 1;
        }

        for ( i, text ) in buff.iter().rev()
        {
            tokens[*i].1 = text.to_string();
        }
    }
    /*
    pub fn expand_home_string( ... )*/
    pub fn home_string( text:&mut String )
    {
        let v = vec!
        [
            r"( ?P<head> + )~( ?P<tail> + )",
            r"( ?P<head> + )~( ?P<tail>/ )",
            r"^( ?P<head> * )~( ?P<tail>/ )",
            r"( ?P<head> + )~( ?P<tail> *$ )",
        ];

        for item in &v
        {
            let re;
            if let Ok( x ) = Regex::new( item ) { re = x; }
            else { return; }

            let home = get::user_home();
            let ss = text.clone();
            let to = format!( "$head{}$tail", home );
            let result = re.replace_all( ss.as_str(), to.as_str() );
            *text = result.to_string();
        }
    }
    /*
    pub fn expand_line_to_toknes( ... )*/
    pub fn line_to_tokens( line:&str, args:&[String], sh:&mut shell::Shell ) -> types::Tokens
    {
        let linfo = parsers::line::parse_line( line );
        let mut tokens = linfo.tokens;
        arguments_in_tokens( &mut tokens, args );
        shell::do_expansion( sh, &mut tokens );
        tokens
    }
    /*
    pub fn expand_one_env( ... )*/
    pub fn single_environment( sh:&Shell, token:&str ) -> String
    {
        unsafe
        {
            // do not combine these two into one:`\{?..\}?`,
            // otherwize `}` in `{print $NF}` would gone.
            let re1 = Regex::new( r"^( .*? )\$( [A-Za-z0-9_]+|\$|\? )( .* )$" ).unwrap();
            let re2 = Regex::new( r"( .*? )\$\{( [A-Za-z0-9_]+|\$|\? )\}( .* )$" ).unwrap();
            if !re1.is_match( token ) && !re2.is_match( token ){ return token.to_string(); }

            let mut result = String::new();
            let match_re1 = re1.is_match( token );
            let match_re2 = re2.is_match( token );
            if !match_re1 && !match_re2 { return token.to_string(); }

            let cap_results = if match_re1 { re1.captures_iter( token ) } 
                            else { re2.captures_iter( token ) };

            for cap in cap_results
            {
                let head = cap[1].to_string();
                let tail = cap[3].to_string();
                let key = cap[2].to_string();
                if key == "?"
                { result.push_str( format!( "{}{}", head, sh.previous_status ).as_str() ); } 
                else if key == "$" 
                {
                    let val = libc::getpid();
                    result.push_str( format!( "{}{}", head, val ).as_str() );
                } 
                else if let Ok( val ) = env::var( &key )
                { result.push_str( format!( "{}{}", head, val ).as_str() ); }
                else if let Some( val ) = sh.get_env( &key )
                { result.push_str( format!( "{}{}", head, val ).as_str() ); } 
                else
                { result.push_str( &head ); }

                result.push_str( &tail );
            }

            result
        }
    }
}
pub mod error
{
    pub use std::error::{ * };
    /*
    errno v0.3.10 */
    pub mod no
    {
        //! Cross-platform interface to the `errno` variable.
        use ::
        {
            error::{ Error },
            *,
        };

        mod sys
        {
            //! Implementation of `errno` functionality for Unix systems.
            use ::
            {
                libc::{self, c_int, size_t, strerror_r, strlen},
                *,
            };

            use super::Errno;            
            
            pub const STRERROR_NAME:&str = "strerror_r";            

            extern "C"
            {
                #[cfg_attr( 
                    any( 
                        target_os = "macos",
                        target_os = "ios",
                        target_os = "tvos",
                        target_os = "watchos",
                        target_os = "visionos",
                        target_os = "freebsd"
 ),
                    link_name = "__error"
 )]
                #[cfg_attr( 
                    any( 
                        target_os = "openbsd",
                        target_os = "netbsd",
                        target_os = "android",
                        target_os = "espidf",
                        target_os = "vxworks",
                        target_os = "cygwin",
                        target_env = "newlib"
 ),
                    link_name = "__errno"
 )]
                #[cfg_attr( 
                    any( target_os = "solaris", target_os = "illumos" ),
                    link_name = "___errno"
 )]
                #[cfg_attr( target_os = "haiku", link_name = "_errnop" )]
                #[cfg_attr( 
                    any( 
                        target_os = "linux",
                        target_os = "hurd",
                        target_os = "redox",
                        target_os = "dragonfly",
                        target_os = "emscripten",
 ),
                    link_name = "__errno_location"
 )]
                #[cfg_attr( target_os = "aix", link_name = "_Errno" )]
                #[cfg_attr( target_os = "nto", link_name = "__get_errno_ptr" )]
                fn errno_location() -> *mut c_int;
            }

            fn from_utf8_lossy( input:&[u8] ) -> &str
            {
                match str::from_utf8( input )
                {
                    Ok( valid ) => valid,
                    Err( error ) => unsafe { str::from_utf8_unchecked( &input[..error.valid_up_to( )] ) },
                }
            }

            pub fn with_description<F, T>( err:Errno, callback:F ) -> T where
            F:FnOnce( Result<&str, Errno> ) -> T,
            {
                unsafe 
                {
                    let mut buf = [0u8; 1024];
                    let c_str = 
                    {
                        let rc = strerror_r( err.0, buf.as_mut_ptr() as *mut _, buf.len() as size_t );
                        if rc != 0
                        {
                            let fm_err = match rc < 0
                            {
                                true => errno(),
                                false => Errno( rc ),
                            };                            
                            if fm_err != Errno( libc::ERANGE ){ return callback( Err( fm_err ) ); }
                        }
                        let c_str_len = strlen( buf.as_ptr() as *const _ );
                        &buf[..c_str_len]
                    };
                    callback( Ok( from_utf8_lossy( c_str ) ) )
                }
            }
            
            pub fn errno() -> Errno
            { unsafe { Errno( *errno_location() ) } }

            pub fn set_errno( Errno( errno ):Errno )
            { unsafe { *errno_location() = errno; } }
        }
        /// Wraps a platform-specific error code.
        #[derive( Copy, Clone, Eq, Ord, PartialEq, PartialOrd, Hash )]
        pub struct Errno( pub i32 );

        impl fmt::Debug for Errno
        {
            fn fmt( &self, fmt:&mut fmt::Formatter ) -> fmt::Result
            {
                sys::with_description( *self, |desc|
                {
                    fmt.debug_struct( "Errno" )
                    .field( "code", &self.0 )
                    .field( "description", &desc.ok() )
                    .finish()
                } )
            }
        }

        impl fmt::Display for Errno
        {
            fn fmt( &self, fmt:&mut fmt::Formatter ) -> fmt::Result
            {
                sys::with_description( *self, |desc| match desc
                {
                    Ok( desc ) => fmt.write_str( desc ),
                    Err( fm_err ) => write!
                    ( 
                        fmt,
                        "OS error {} ( {} returned error {} )",
                        self.0,
                        sys::STRERROR_NAME,
                        fm_err.0
 ),
                } )
            }
        }

        impl From<Errno> for i32
        {
            fn from( e:Errno ) -> Self { e.0 }
        }
        
        impl Error for Errno
        {
            #[allow( deprecated )] fn description( &self ) -> &str { "system error" }
        }
        
        impl From<Errno> for io::Error
        {
            fn from( errno:Errno ) -> Self
            { io::Error::from_raw_os_error( errno.0 ) }
        }
        /// Returns the platform-specific value of `errno`.
        pub fn errno() -> Errno
        { sys::errno() }
        /// Sets the platform-specific value of `errno`.
        pub fn set_errno( err:Errno )
        { sys::set_errno( err ) }
    }
}
/**/
pub mod connect
{
    use ::
    {
        cell::{ RefCell },
        connect::
        {
            cache::{ CachedStatement, StatementCache },
            column::{ Column },
            error::{ to_sqlite_error, Error },
            ffi::{ ErrorCode },
            load::{ LoadExtensionGuard },
            inner::{ InnerConnection },
            params::{ params_from_iter, Params, ParamsFromIter },
            row::{ AndThenRows, Map, MappedRows, Row, RowIndex, Rows },
            statement::{ Statement, StatementStatus },
            transaction::{ DropBehavior, Savepoint, Transaction, TransactionBehavior, TransactionState },
            types::{ ToSql, ValueRef },
            raw::{ RawStatement },
            version::{ * },
            Connection, InterruptHandle, OpenFlags, PrepFlags, Result, str_for_sqlite, version_number,
        },
        default::{ Default },
        ffi::{ c_char, c_int, c_uint, CStr, CString },
        path::{ Path },
        sync::{ Arc, Mutex },
    };

    pub mod bind
    {

    }

    pub mod cache
    {
        use ::
        {
            cell::{ RefCell },
            connect::
            {
                raw::{ RawStatement },
                Connection, PrepFlags, Result, Statement,
            },
            ops::{ Deref, DerefMut },
            sync::{ Arc },
            *
        };
        /// Prepared statements LRU cache.
        #[derive(Debug)]
        pub struct StatementCache(RefCell<LruCache<Arc<str>, RawStatement>>);
        unsafe impl Send for StatementCache {}
        /// Cacheable statement.
        pub struct CachedStatement<'conn>
        {
            stmt: Option<Statement<'conn>>,
            cache: &'conn StatementCache,
        }

    }

    pub mod column
    {
        use ::
        {
            *,
        };

        #[derive(Debug)]
        pub struct Column<'stmt>
        {
            name: &'stmt str,
            decl_type: Option<&'stmt str>,
        }

        impl Column<'_> 
        {

        }
    }

    pub mod error
    {
        use ::
        {
            connect::
            {
                self as conx,
                ffi::{ alloc },
            },
            *,
        };

        /// Enum listing possible errors from rusqlite.
        #[derive(Debug)] #[non_exhaustive]
        pub enum Error
        {
            /// An error from an underlying SQLite call.
            SqliteFailure( conx::ffi::Error, Option<String>),
            /// Error reported when attempting to open a connection when SQLite was configured 
            /// to allow single-threaded use only.
            SqliteSingleThreadedMode,
            /// Error when the value of a particular column is requested, 
            /// but it cant be converted to the requested Rust type.
            FromSqlConversionFailure(usize, Type, Box<dyn error::Error + Send + Sync + 'static>),
            /// Error when SQLite gives us an integral value outside the range of the requested type.
            IntegralValueOutOfRange(usize, i64),
            /// Error converting a string to UTF-8.
            Utf8Error(str::Utf8Error),
            /// Error converting a string to a C-compatible string because it contained an embedded nul.
            NulError(NulError),
            /// Error when using SQL named parameters and passing a parameter name not present in the SQL.
            InvalidParameterName(String),
            /// Error converting a file path to a string.
            InvalidPath(PathBuf),
            /// Error returned when an [`execute`](crate::Connection::execute) call returns rows.
            ExecuteReturnedResults,
            /// Error when a query that was expected to return at least one row did not return any.
            QueryReturnedNoRows,
            /// Error when the value of a particular column is requested, but the index is out of range for the statement.
            InvalidColumnIndex(usize),
            /// Error when the value of a named column is requested, but no column matches the name for the statement.
            InvalidColumnName(String),
            /// Error when the value of a particular column is requested, 
            /// but the type of the result in that column cannot be converted to the requested Rust type.
            InvalidColumnType(usize, String, Type),
            /// Error when a query that was expected to insert one row did not insert any or insert many.
            StatementChangedRows(usize),
            /// Error returned by functions::Context::get( ... ) when the function argument 
            /// cant be converted to the requested type.
            InvalidFunctionParameterType(usize, Type),
            /// Error returned by vtab::Values::get( ... ) when the filter argument cannot be converted to the requested type.
            InvalidFilterParameterType(usize, Type),
            /// An error case available for implementors of custom user functions.
            UserFunctionError(Box<dyn error::Error + Send + Sync + 'static>),
            /// Error available for the implementors of the ToSql trait.
            ToSqlConversionFailure(Box<dyn error::Error + Send + Sync + 'static>),
            /// Error when the SQL is not a `SELECT`, is not read-only.
            InvalidQuery,
            /// An error case available for implementors of custom modules.
            ModuleError(String),
            /// An unwinding panic occurs in a UDF (user-defined function).
            UnwindingPanic,
            /// An error returned when Context::get_aux attempts to retrieve data of 
            /// a different type than what had been stored using Context::set_aux( ... ).
            GetAuxWrongType,
            /// Error when the SQL contains multiple statements.
            MultipleStatement,
            /// Error when the number of bound parameters does not match the number of parameters in the query.
            InvalidParameterCount(usize, usize),
            /// Returned from various functions in the Blob IO positional API.
            BlobSizeError,
            /// Error referencing a specific token in the input SQL
            SqlInputError
            {
                /// error code
                error: ffi::Error,
                /// error message
                msg: String,
                /// SQL input
                sql: String,
                /// byte offset of the start of invalid token
                offset: c_int,
            },
            /// Loadable extension initialization error
            InitError( conx::ffi::InitError ),
            /// Error when the schema of a particular database is requested, but the index is out of range.
            InvalidDatabaseIndex(usize),
        }

        impl PartialEq for Error
        {
            fn eq(&self, other: &Self) -> bool
            {
                match (self, other)
                {
                    (Self::SqliteFailure(e1, s1), Self::SqliteFailure(e2, s2)) => e1 == e2 && s1 == s2,
                    (Self::SqliteSingleThreadedMode, Self::SqliteSingleThreadedMode) => true,
                    (Self::IntegralValueOutOfRange(i1, n1), Self::IntegralValueOutOfRange(i2, n2)) => { i1 == i2 && n1 == n2 }
                    (Self::Utf8Error(e1), Self::Utf8Error(e2)) => e1 == e2,
                    (Self::NulError(e1), Self::NulError(e2)) => e1 == e2,
                    (Self::InvalidParameterName(n1), Self::InvalidParameterName(n2)) => n1 == n2,
                    (Self::InvalidPath(p1), Self::InvalidPath(p2)) => p1 == p2,
                    (Self::ExecuteReturnedResults, Self::ExecuteReturnedResults) => true,
                    (Self::QueryReturnedNoRows, Self::QueryReturnedNoRows) => true,
                    (Self::InvalidColumnIndex(i1), Self::InvalidColumnIndex(i2)) => i1 == i2,
                    (Self::InvalidColumnName(n1), Self::InvalidColumnName(n2)) => n1 == n2,
                    (Self::InvalidColumnType(i1, n1, t1), Self::InvalidColumnType(i2, n2, t2)) =>
                    { i1 == i2 && t1 == t2 && n1 == n2 }

                    (Self::StatementChangedRows(n1), Self::StatementChangedRows(n2)) => n1 == n2,
                    (
                        Self::InvalidFunctionParameterType(i1, t1),
                        Self::InvalidFunctionParameterType(i2, t2),
                    ) => i1 == i2 && t1 == t2,
                    (
                        Self::InvalidFilterParameterType(i1, t1),
                        Self::InvalidFilterParameterType(i2, t2),
                    ) => i1 == i2 && t1 == t2,
                    (Self::InvalidQuery, Self::InvalidQuery) => true,
                    (Self::ModuleError(s1), Self::ModuleError(s2)) => s1 == s2,
                    (Self::UnwindingPanic, Self::UnwindingPanic) => true,
                    (Self::GetAuxWrongType, Self::GetAuxWrongType) => true,
                    (Self::InvalidParameterCount(i1, n1), Self::InvalidParameterCount(i2, n2)) => { i1 == i2 && n1 == n2 }
                    (Self::BlobSizeError, Self::BlobSizeError) => true,
                    (
                        Self::SqlInputError
                        {
                            error: e1,
                            msg: m1,
                            sql: s1,
                            offset: o1,
                        },

                        Self::SqlInputError
                        {
                            error: e2,
                            msg: m2,
                            sql: s2,
                            offset: o2,
                        },
                    ) => e1 == e2 && m1 == m2 && s1 == s2 && o1 == o2,
                    (Self::InitError(e1), Self::InitError(e2)) => e1 == e2,
                    (Self::InvalidDatabaseIndex(i1), Self::InvalidDatabaseIndex(i2)) => i1 == i2,
                    (..) => false,
                }
            }
        }

        impl From<str::Utf8Error> for Error
        {
            #[cold] fn from(err: str::Utf8Error) -> Self { Self::Utf8Error(err) }
        }

        impl From<NulError> for Error
        {
            #[cold] fn from(err: NulError) -> Self { Self::NulError(err) }
        }

        const UNKNOWN_COLUMN: usize = usize::MAX;
        /// Convenient to have it to allow use of `get_raw(…).as_…()?` in callbacks that take `Error`.
        impl From<FromSqlError> for Error
        {
            #[cold] fn from(err: FromSqlError) -> Self
            {
                match err
                {
                    FromSqlError::OutOfRange(val) => Self::IntegralValueOutOfRange(UNKNOWN_COLUMN, val),
                    FromSqlError::InvalidBlobSize { .. } => 
                    { Self::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Blob, Box::new(err)) }

                    FromSqlError::Other(source) => { Self::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Null, source) }
                    _ => Self::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Null, Box::new(err)),
                }
            }
        }
        
        impl From<conx::ffi::InitError> for Error
        {
            #[cold] fn from(err: conx::ffi::InitError) -> Self { Self::InitError(err) }
        }

        impl fmt::Display for Error
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
            {
                match *self
                {
                    Self::SqliteFailure(ref err, None) => err.fmt(f),
                    Self::SqliteFailure(_, Some(ref s)) => write!(f, "{s}"),
                    Self::SqliteSingleThreadedMode => write!
                    (
                        f,
                        "SQLite was compiled or configured for single-threaded use only"
                    ),
                    Self::FromSqlConversionFailure(i, ref t, ref err) =>
                    {
                        if i != UNKNOWN_COLUMN { write!(f, "Conversion error from type {t} at index: {i}, {err}") }
                        else { err.fmt(f) }
                    }
                    Self::IntegralValueOutOfRange(col, val) =>
                    {
                        if col != UNKNOWN_COLUMN { write!(f, "Integer {val} out of range at index {col}") }
                        else { write!(f, "Integer {val} out of range") }
                    }
                    Self::Utf8Error(ref err) => err.fmt(f),
                    Self::NulError(ref err) => err.fmt(f),
                    Self::InvalidParameterName(ref name) => write!(f, "Invalid parameter name: {name}"),
                    Self::InvalidPath(ref p) => write!(f, "Invalid path: {}", p.to_string_lossy()),
                    Self::ExecuteReturnedResults => { write!(f, "Execute returned results - did you mean to call query?") }
                    
                    Self::QueryReturnedNoRows => write!(f, "Query returned no rows"),
                    Self::InvalidColumnIndex(i) => write!(f, "Invalid column index: {i}"),
                    Self::InvalidColumnName(ref name) => write!(f, "Invalid column name: {name}"),
                    
                    Self::InvalidColumnType(i, ref name, ref t) => 
                    { write!(f, "Invalid column type {t} at index: {i}, name: {name}") }

                    Self::InvalidParameterCount(i1, n1) => 
                    write!(f, "Wrong number of parameters passed to query. Got {i1}, needed {n1}" ),
                    
                    Self::StatementChangedRows(i) => write!(f, "Query changed {i} rows"),
                    
                    Self::InvalidFunctionParameterType(i, ref t) => 
                    { write!(f, "Invalid function parameter type {t} at index {i}") }
                    
                    Self::InvalidFilterParameterType(i, ref t) => 
                    { write!(f, "Invalid filter parameter type {t} at index {i}") }
                    Self::UserFunctionError(ref err) => err.fmt(f),
                    Self::ToSqlConversionFailure(ref err) => err.fmt(f),
                    Self::InvalidQuery => write!(f, "Query is not read-only"),
                    Self::ModuleError(ref desc) => write!(f, "{desc}"),
                    Self::UnwindingPanic => write!(f, "unwinding panic"),
                    Self::GetAuxWrongType => write!(f, "get_aux called with wrong type"),
                    Self::MultipleStatement => write!(f, "Multiple statements provided"),
                    Self::BlobSizeError => "Blob size is insufficient".fmt(f),
                    Self::SqlInputError
                    {
                        ref msg,
                        offset,
                        ref sql,
                        ..
                    } => write!(f, "{msg} in {sql} at offset {offset}"),
                    Self::InitError(ref err) => err.fmt(f),
                    Self::InvalidDatabaseIndex(i) => write!(f, "Invalid database index: {i}"),
                }
            }
        }

        impl error::Error for Error
        {
            fn source(&self) -> Option<&(dyn error::Error + 'static)>
            {
                match *self
                {
                    Self::SqliteFailure(ref err, _) => Some(err),
                    Self::Utf8Error(ref err) => Some(err),
                    Self::NulError(ref err) => Some(err),
                    Self::IntegralValueOutOfRange(..)
                    | Self::SqliteSingleThreadedMode
                    | Self::InvalidParameterName(_)
                    | Self::ExecuteReturnedResults
                    | Self::QueryReturnedNoRows
                    | Self::InvalidColumnIndex(_)
                    | Self::InvalidColumnName(_)
                    | Self::InvalidColumnType(..)
                    | Self::InvalidPath(_)
                    | Self::InvalidParameterCount(..)
                    | Self::StatementChangedRows(_)
                    | Self::InvalidQuery
                    | Self::MultipleStatement => None,                    
                    Self::InvalidFunctionParameterType(..) => None, 
                    Self::InvalidFilterParameterType(..) => None,
                    Self::UserFunctionError(ref err) => Some(&**err),                    
                    Self::FromSqlConversionFailure(_, _, ref err) | 
                    Self::ToSqlConversionFailure(ref err) => Some(&**err),                    
                    Self::ModuleError(_) => None,
                    Self::UnwindingPanic => None,
                    Self::GetAuxWrongType => None,
                    Self::BlobSizeError => None,
                    Self::SqlInputError { ref error, .. } => Some(error),
                    Self::InitError(ref err) => Some(err),
                    Self::InvalidDatabaseIndex(_) => None,
                }
            }
        }

        impl Error
        {
            /// Returns the underlying SQLite error if this is [`Error::SqliteFailure`].
            #[inline] #[must_use] pub fn sqlite_error(&self) -> Option<&conx::ffi::Error>
            {
                match self
                {
                    Self::SqliteFailure(error, _) => Some(error),
                    _ => None,
                }
            }
            /// Returns the underlying SQLite error code if this is [`Error::SqliteFailure`].
            #[inline] #[must_use] pub fn sqlite_error_code(&self) -> Option<conx::ffi::ErrorCode>
            { self.sqlite_error().map(|error| error.code) }
        }
        
        #[cold] pub fn error_from_sqlite_code(code: c_int, message: Option<String>) -> Error
        {
            Error::SqliteFailure( conx::ffi::Error::new(code), message)
        }
        pub fn check(code: c_int) -> Result<()>
        {
            if code != conx::ffi::SQLITE_OK { Err(error_from_sqlite_code(code, None)) } 
            else { Ok(()) }
        }
        /// Transform Rust error to SQLite error (message and code).
        pub unsafe fn to_sqlite_error(e: &Error, err_msg: *mut *mut c_char) -> c_int
        {
            match e {
                Error::SqliteFailure(err, s) => {
                    if let Some(s) = s {
                        *err_msg = alloc(s);
                    }
                    err.extended_code
                }
                err => {
                    *err_msg = alloc(&err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }
    }
    
    pub mod ffi
    {
        use ::
        {
            borrow::{ Cow },
            connect::{ self },
            ffi::{c_char, c_int, CStr},
            marker::{ PhantomData },
            ptr::{ NonNull },
            *,
        };
        
        pub(crate) fn alloc(s: &str) -> *mut c_char
        {
            SqliteMallocString::from_str(s).into_raw()
        }
        /// A string we own that's allocated on the SQLite heap.
        #[repr(transparent)] pub(crate) struct SqliteMallocString
        {
            ptr: NonNull<c_char>,
            _boo: PhantomData<Box<[c_char]>>,
        }

        impl SqliteMallocString
        {
            /// Convert `s` into a SQLite string.
            pub const fn from_str( s:&str ) -> Self 
            {
                unsafe 
                {
                    let s = if s.as_bytes().contains(&0) 
                    { Cow::Owned( make_nonnull( s ) ) } 
                    else { Cow::Borrowed(s) };

                    debug_assert!(!s.as_bytes().contains(&0));

                    let bytes: &[u8] = s.as_ref().as_bytes();
                    let src_ptr: *const c_char = bytes.as_ptr().cast();
                    let src_len = bytes.len();
                    let maybe_len_plus_1 = s.len().checked_add(1).and_then(|v| c_int::try_from(v).ok());
                    let res_ptr = maybe_len_plus_1
                    .and_then(|len_to_alloc| 
                    {
                        debug_assert!(len_to_alloc > 0);
                        debug_assert_eq!((len_to_alloc - 1) as usize, src_len);
                        NonNull::new(connect::ffi::sqlite3_malloc(len_to_alloc).cast::<c_char>())
                    })
                    .unwrap_or_else(|| 
                    {
                        use ::alloc::{handle_alloc_error, Layout};
                        let len = s.len().saturating_add(1).min(isize::MAX as usize);
                        let layout = Layout::from_size_align_unchecked(len, 1);
                        handle_alloc_error(layout);
                    });
                    let buf: *mut c_char = res_ptr.as_ptr().cast::<c_char>();
                    src_ptr.copy_to_nonoverlapping(buf, src_len);
                    buf.add(src_len).write(0);
                    debug_assert_eq!( CStr::from_ptr(res_ptr.as_ptr()).to_bytes(), bytes );
                    Self::from_raw_nonnull(res_ptr)
                }
            }
            #[inline] pub unsafe fn from_raw_nonnull( ptr:NonNull<c_char> ) -> Self
            {
                Self
                {
                    ptr,
                    _boo: PhantomData,
                }
            }
        }
        
        const NUL_REPLACE: &str = "␀";

        //extern crate openssl_sys;
        
        #[must_use] pub fn SQLITE_STATIC() -> sqlite3_destructor_type { None }

        #[must_use] pub fn SQLITE_TRANSIENT() -> sqlite3_destructor_type
        {
            Some(unsafe { mem::transmute::<isize, unsafe extern "C" fn(*mut ::ffi::c_void)>(-1_isize) })
        }
        

        impl Default for sqlite3_vtab
        {
            fn default() -> Self { unsafe { mem::zeroed() } }
        }

        impl Default for sqlite3_vtab_cursor
        {
            fn default() -> Self { unsafe { mem::zeroed() } }
        }

        mod error
        {
            use ::
            {
                os::raw::{ c_int },
                *,
            };
            /// Error Codes
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            #[non_exhaustive] pub enum ErrorCode
            {
                /// Internal logic error in SQLite
                InternalMalfunction,
                /// Access permission denied
                PermissionDenied,
                /// Callback routine requested an abort
                OperationAborted,
                /// The database file is locked
                DatabaseBusy,
                /// A table in the database is locked
                DatabaseLocked,
                /// A `malloc()` failed
                OutOfMemory,
                /// Attempt to write a readonly database
                ReadOnly,
                /// Operation terminated by `sqlite3_interrupt()`
                OperationInterrupted,
                /// Some kind of disk I/O error occurred
                SystemIoFailure,
                /// The database disk image is malformed
                DatabaseCorrupt,
                /// Unknown opcode in `sqlite3_file_control()`
                NotFound,
                /// Insertion failed because database is full
                DiskFull,
                /// Unable to open the database file
                CannotOpen,
                /// Database lock protocol error
                FileLockingProtocolFailed,
                /// The database schema changed
                SchemaChanged,
                /// String or BLOB exceeds size limit
                TooBig,
                /// Abort due to constraint violation
                ConstraintViolation,
                /// Data type mismatch
                TypeMismatch,
                /// Library used incorrectly
                ApiMisuse,
                /// Uses OS features not supported on host
                NoLargeFileSupport,
                /// Authorization denied
                AuthorizationForStatementDenied,
                /// 2nd parameter to `sqlite3_bind` out of range
                ParameterOutOfRange,
                /// File opened that is not a database file
                NotADatabase,
                /// SQL error or missing database
                Unknown,
            }

            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            pub struct Error
            {
                pub code: ErrorCode,
                pub extended_code: c_int,
            }

            impl Error
            {
                #[must_use]
                pub fn new(result_code: c_int) -> Self
                {
                    let code = match result_code & 0xff
                    {
                        super::SQLITE_INTERNAL => ErrorCode::InternalMalfunction,
                        super::SQLITE_PERM => ErrorCode::PermissionDenied,
                        super::SQLITE_ABORT => ErrorCode::OperationAborted,
                        super::SQLITE_BUSY => ErrorCode::DatabaseBusy,
                        super::SQLITE_LOCKED => ErrorCode::DatabaseLocked,
                        super::SQLITE_NOMEM => ErrorCode::OutOfMemory,
                        super::SQLITE_READONLY => ErrorCode::ReadOnly,
                        super::SQLITE_INTERRUPT => ErrorCode::OperationInterrupted,
                        super::SQLITE_IOERR => ErrorCode::SystemIoFailure,
                        super::SQLITE_CORRUPT => ErrorCode::DatabaseCorrupt,
                        super::SQLITE_NOTFOUND => ErrorCode::NotFound,
                        super::SQLITE_FULL => ErrorCode::DiskFull,
                        super::SQLITE_CANTOPEN => ErrorCode::CannotOpen,
                        super::SQLITE_PROTOCOL => ErrorCode::FileLockingProtocolFailed,
                        super::SQLITE_SCHEMA => ErrorCode::SchemaChanged,
                        super::SQLITE_TOOBIG => ErrorCode::TooBig,
                        super::SQLITE_CONSTRAINT => ErrorCode::ConstraintViolation,
                        super::SQLITE_MISMATCH => ErrorCode::TypeMismatch,
                        super::SQLITE_MISUSE => ErrorCode::ApiMisuse,
                        super::SQLITE_NOLFS => ErrorCode::NoLargeFileSupport,
                        super::SQLITE_AUTH => ErrorCode::AuthorizationForStatementDenied,
                        super::SQLITE_RANGE => ErrorCode::ParameterOutOfRange,
                        super::SQLITE_NOTADB => ErrorCode::NotADatabase,
                        _ => ErrorCode::Unknown,
                    };

                    Self
                    {
                        code,
                        extended_code: result_code,
                    }
                }
            }

            impl fmt::Display for Error
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    write!
                    (
                        f,
                        "Error code {}: {}",
                        self.extended_code,
                        code_to_str(self.extended_code)
                    )
                }
            }

            impl error::Error for Error
            {
                fn description(&self) -> &str
                {
                    code_to_str(self.extended_code)
                }
            }

            const SQLITE_ERROR_MISSING_COLLSEQ: c_int = super::SQLITE_ERROR | (1 << 8);
            const SQLITE_ERROR_RETRY: c_int = super::SQLITE_ERROR | (2 << 8);
            const SQLITE_ERROR_SNAPSHOT: c_int = super::SQLITE_ERROR | (3 << 8);
            const SQLITE_IOERR_BEGIN_ATOMIC: c_int = super::SQLITE_IOERR | (29 << 8);
            const SQLITE_IOERR_COMMIT_ATOMIC: c_int = super::SQLITE_IOERR | (30 << 8);
            const SQLITE_IOERR_ROLLBACK_ATOMIC: c_int = super::SQLITE_IOERR | (31 << 8);
            const SQLITE_IOERR_DATA: c_int = super::SQLITE_IOERR | (32 << 8);
            const SQLITE_IOERR_CORRUPTFS: c_int = super::SQLITE_IOERR | (33 << 8);
            const SQLITE_IOERR_IN_PAGE: c_int = super::SQLITE_IOERR | (34 << 8);
            const SQLITE_LOCKED_VTAB: c_int = super::SQLITE_LOCKED | (2 << 8);
            const SQLITE_BUSY_TIMEOUT: c_int = super::SQLITE_BUSY | (3 << 8);
            const SQLITE_CANTOPEN_SYMLINK: c_int = super::SQLITE_CANTOPEN | (6 << 8);
            const SQLITE_CORRUPT_SEQUENCE: c_int = super::SQLITE_CORRUPT | (2 << 8);
            const SQLITE_CORRUPT_INDEX: c_int = super::SQLITE_CORRUPT | (3 << 8);
            const SQLITE_READONLY_CANTINIT: c_int = super::SQLITE_READONLY | (5 << 8);
            const SQLITE_READONLY_DIRECTORY: c_int = super::SQLITE_READONLY | (6 << 8);
            const SQLITE_CONSTRAINT_PINNED: c_int = super::SQLITE_CONSTRAINT | (11 << 8);
            const SQLITE_CONSTRAINT_DATATYPE: c_int = super::SQLITE_CONSTRAINT | (12 << 8);

            #[must_use] pub fn code_to_str(code: c_int) -> &'static str
            {
                match code
                {
                    super::SQLITE_OK        => "Successful result",
                    super::SQLITE_ERROR     => "SQL error or missing database",
                    super::SQLITE_INTERNAL  => "Internal logic error in SQLite",
                    super::SQLITE_PERM      => "Access permission denied",
                    super::SQLITE_ABORT     => "Callback routine requested an abort",
                    super::SQLITE_BUSY      => "The database file is locked",
                    super::SQLITE_LOCKED    => "A table in the database is locked",
                    super::SQLITE_NOMEM     => "A malloc() failed",
                    super::SQLITE_READONLY  => "Attempt to write a readonly database",
                    super::SQLITE_INTERRUPT => "Operation terminated by sqlite3_interrupt()",
                    super::SQLITE_IOERR     => "Some kind of disk I/O error occurred",
                    super::SQLITE_CORRUPT   => "The database disk image is malformed",
                    super::SQLITE_NOTFOUND  => "Unknown opcode in sqlite3_file_control()",
                    super::SQLITE_FULL      => "Insertion failed because database is full",
                    super::SQLITE_CANTOPEN  => "Unable to open the database file",
                    super::SQLITE_PROTOCOL  => "Database lock protocol error",
                    super::SQLITE_EMPTY     => "Database is empty",
                    super::SQLITE_SCHEMA    => "The database schema changed",
                    super::SQLITE_TOOBIG    => "String or BLOB exceeds size limit",
                    super::SQLITE_CONSTRAINT=> "Abort due to constraint violation",
                    super::SQLITE_MISMATCH  => "Data type mismatch",
                    super::SQLITE_MISUSE    => "Library used incorrectly",
                    super::SQLITE_NOLFS     => "Uses OS features not supported on host",
                    super::SQLITE_AUTH      => "Authorization denied",
                    super::SQLITE_FORMAT    => "Auxiliary database format error",
                    super::SQLITE_RANGE     => "2nd parameter to sqlite3_bind out of range",
                    super::SQLITE_NOTADB    => "File opened that is not a database file",
                    super::SQLITE_NOTICE    => "Notifications from sqlite3_log()",
                    super::SQLITE_WARNING   => "Warnings from sqlite3_log()",
                    super::SQLITE_ROW       => "sqlite3_step() has another row ready",
                    super::SQLITE_DONE      => "sqlite3_step() has finished executing",

                    SQLITE_ERROR_MISSING_COLLSEQ   => "SQLITE_ERROR_MISSING_COLLSEQ",
                    SQLITE_ERROR_RETRY   => "SQLITE_ERROR_RETRY",
                    SQLITE_ERROR_SNAPSHOT   => "SQLITE_ERROR_SNAPSHOT",

                    super::SQLITE_IOERR_READ              => "Error reading from disk",
                    super::SQLITE_IOERR_SHORT_READ        => "Unable to obtain number of requested bytes (file truncated?)",
                    super::SQLITE_IOERR_WRITE             => "Error writing to disk",
                    super::SQLITE_IOERR_FSYNC             => "Error flushing data to persistent storage (fsync)",
                    super::SQLITE_IOERR_DIR_FSYNC         => "Error calling fsync on a directory",
                    super::SQLITE_IOERR_TRUNCATE          => "Error attempting to truncate file",
                    super::SQLITE_IOERR_FSTAT             => "Error invoking fstat to get file metadata",
                    super::SQLITE_IOERR_UNLOCK            => "I/O error within xUnlock of a VFS object",
                    super::SQLITE_IOERR_RDLOCK            => "I/O error within xLock of a VFS object (trying to obtain a read lock)",
                    super::SQLITE_IOERR_DELETE            => "I/O error within xDelete of a VFS object",
                    super::SQLITE_IOERR_BLOCKED           => "SQLITE_IOERR_BLOCKED", // no longer used
                    super::SQLITE_IOERR_NOMEM             => "Out of memory in I/O layer",
                    super::SQLITE_IOERR_ACCESS            => "I/O error within xAccess of a VFS object",
                    super::SQLITE_IOERR_CHECKRESERVEDLOCK => "I/O error within then xCheckReservedLock method",
                    super::SQLITE_IOERR_LOCK              => "I/O error in the advisory file locking layer",
                    super::SQLITE_IOERR_CLOSE             => "I/O error within the xClose method",
                    super::SQLITE_IOERR_DIR_CLOSE         => "SQLITE_IOERR_DIR_CLOSE", // no longer used
                    super::SQLITE_IOERR_SHMOPEN           => "I/O error within the xShmMap method (trying to open a new shared-memory segment)",
                    super::SQLITE_IOERR_SHMSIZE           => "I/O error within the xShmMap method (trying to resize an existing shared-memory segment)",
                    super::SQLITE_IOERR_SHMLOCK           => "SQLITE_IOERR_SHMLOCK", // no longer used
                    super::SQLITE_IOERR_SHMMAP            => "I/O error within the xShmMap method (trying to map a shared-memory segment into process address space)",
                    super::SQLITE_IOERR_SEEK              => "I/O error within the xRead or xWrite (trying to seek within a file)",
                    super::SQLITE_IOERR_DELETE_NOENT      => "File being deleted does not exist",
                    super::SQLITE_IOERR_MMAP              => "I/O error while trying to map or unmap part of the database file into process address space",
                    super::SQLITE_IOERR_GETTEMPPATH       => "VFS is unable to determine a suitable directory for temporary files",
                    super::SQLITE_IOERR_CONVPATH          => "cygwin_conv_path() system call failed",
                    super::SQLITE_IOERR_VNODE             => "SQLITE_IOERR_VNODE", // not documented?
                    super::SQLITE_IOERR_AUTH              => "SQLITE_IOERR_AUTH",
                    SQLITE_IOERR_BEGIN_ATOMIC      => "SQLITE_IOERR_BEGIN_ATOMIC",
                    SQLITE_IOERR_COMMIT_ATOMIC     => "SQLITE_IOERR_COMMIT_ATOMIC",
                    SQLITE_IOERR_ROLLBACK_ATOMIC   => "SQLITE_IOERR_ROLLBACK_ATOMIC",
                    SQLITE_IOERR_DATA   => "SQLITE_IOERR_DATA",
                    SQLITE_IOERR_CORRUPTFS   => "SQLITE_IOERR_CORRUPTFS",
                    SQLITE_IOERR_IN_PAGE   => "SQLITE_IOERR_IN_PAGE",

                    super::SQLITE_LOCKED_SHAREDCACHE      => "Locking conflict due to another connection with a shared cache",
                    SQLITE_LOCKED_VTAB             => "SQLITE_LOCKED_VTAB",

                    super::SQLITE_BUSY_RECOVERY           => "Another process is recovering a WAL mode database file",
                    super::SQLITE_BUSY_SNAPSHOT           => "Cannot promote read transaction to write transaction because of writes by another connection",
                    SQLITE_BUSY_TIMEOUT           => "SQLITE_BUSY_TIMEOUT",

                    super::SQLITE_CANTOPEN_NOTEMPDIR      => "SQLITE_CANTOPEN_NOTEMPDIR", // no longer used
                    super::SQLITE_CANTOPEN_ISDIR          => "Attempted to open directory as file",
                    super::SQLITE_CANTOPEN_FULLPATH       => "Unable to convert filename into full pathname",
                    super::SQLITE_CANTOPEN_CONVPATH       => "cygwin_conv_path() system call failed",
                    SQLITE_CANTOPEN_SYMLINK       => "SQLITE_CANTOPEN_SYMLINK",

                    super::SQLITE_CORRUPT_VTAB            => "Content in the virtual table is corrupt",
                    SQLITE_CORRUPT_SEQUENCE        => "SQLITE_CORRUPT_SEQUENCE",
                    SQLITE_CORRUPT_INDEX        => "SQLITE_CORRUPT_INDEX",

                    super::SQLITE_READONLY_RECOVERY       => "WAL mode database file needs recovery (requires write access)",
                    super::SQLITE_READONLY_CANTLOCK       => "Shared-memory file associated with WAL mode database is read-only",
                    super::SQLITE_READONLY_ROLLBACK       => "Database has hot journal that must be rolled back (requires write access)",
                    super::SQLITE_READONLY_DBMOVED        => "Database cannot be modified because database file has moved",
                    SQLITE_READONLY_CANTINIT       => "SQLITE_READONLY_CANTINIT",
                    SQLITE_READONLY_DIRECTORY      => "SQLITE_READONLY_DIRECTORY",

                    super::SQLITE_ABORT_ROLLBACK          => "Transaction was rolled back",

                    super::SQLITE_CONSTRAINT_CHECK        => "A CHECK constraint failed",
                    super::SQLITE_CONSTRAINT_COMMITHOOK   => "Commit hook caused rollback",
                    super::SQLITE_CONSTRAINT_FOREIGNKEY   => "Foreign key constraint failed",
                    super::SQLITE_CONSTRAINT_FUNCTION     => "Error returned from extension function",
                    super::SQLITE_CONSTRAINT_NOTNULL      => "A NOT NULL constraint failed",
                    super::SQLITE_CONSTRAINT_PRIMARYKEY   => "A PRIMARY KEY constraint failed",
                    super::SQLITE_CONSTRAINT_TRIGGER      => "A RAISE function within a trigger fired",
                    super::SQLITE_CONSTRAINT_UNIQUE       => "A UNIQUE constraint failed",
                    super::SQLITE_CONSTRAINT_VTAB         => "An application-defined virtual table error occurred",
                    super::SQLITE_CONSTRAINT_ROWID        => "A non-unique rowid occurred",
                    SQLITE_CONSTRAINT_PINNED        => "SQLITE_CONSTRAINT_PINNED",
                    SQLITE_CONSTRAINT_DATATYPE        => "SQLITE_CONSTRAINT_DATATYPE",

                    super::SQLITE_NOTICE_RECOVER_WAL      => "A WAL mode database file was recovered",
                    super::SQLITE_NOTICE_RECOVER_ROLLBACK => "Hot journal was rolled back",

                    super::SQLITE_WARNING_AUTOINDEX       => "Automatic indexing used - database might benefit from additional indexes",

                    super::SQLITE_AUTH_USER               => "SQLITE_AUTH_USER", // not documented?

                    _ => "Unknown error code",
                }
            }
            /// Loadable extension initialization error
            #[derive(Clone, Copy, Debug, PartialEq, Eq)]
            #[non_exhaustive]
            pub enum InitError
            {
                /// Version mismatch between the extension and the SQLite3 library
                VersionMismatch { compile_time: i32, runtime: i32 },
                /// Invalid function pointer in one of `sqlite3_api_routines` fields
                NullFunctionPointer,
            }

            impl fmt::Display for InitError
            {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match *self
                    {
                        Self::NullFunctionPointer => { write!(f, "Some sqlite3_api_routines fields are null") }
                        Self::VersionMismatch { compile_time, runtime, } => { write!(f, "SQLite version mismatch: {runtime} < {compile_time}") }
                    }
                }
            }

            impl error::Error for InitError {}
        }
        pub use self::error::*;
    }

    pub mod hooks
    {
        
    }

    pub mod inner
    {
        use ::
        {
            boxed::{ Box },
            connect::
            { 
                ffi::{ self },
                hooks::{ self },
            },
            sync::{ Mutex },
            *,
        };

        pub struct InnerConnection
        {
            pub db: *mut ffi::sqlite3,
            interrupt_lock: Arc<Mutex<*mut ffi::sqlite3>>,
            pub free_commit_hook: Option<unsafe fn( *mut ::ffi::c_void )>,
            pub free_rollback_hook: Option<unsafe fn( *mut ::ffi::c_void )>,
            pub free_update_hook: Option<unsafe fn( *mut ::ffi::c_void )>,
            pub progress_handler: Option<Box<dyn FnMut() -> bool + Send>>,
            pub authorizer: Option<hooks::BoxedAuthorizer>,
            pub free_preupdate_hook: Option<unsafe fn( *mut ::ffi::c_void )>,
            owned: bool,
        }

        unsafe impl Send for InnerConnection {}
    }

    pub mod load
    {
        use ::connect::{Connection, Result};

        /// RAII guard temporarily enabling SQLite extensions to be loaded.
        pub struct LoadExtensionGuard<'conn>
        {
            conn: &'conn Connection,
        }

        impl LoadExtensionGuard<'_>
        {
            /// Attempt to enable loading extensions. Loading extensions will be disabled when this guard goes out of scope.
            #[inline] pub unsafe fn new(conn: &Connection) -> Result<LoadExtensionGuard<'_>>
            {
                conn.load_extension_enable().map(|_| LoadExtensionGuard { conn })
            }
        }
    }

    pub mod notify
    {
        //! [Unlock Notification](http://sqlite.org/unlock_notify.html)
        use ::
        {
            connect::{ self },
            ffi::{ c_int, c_void },
            panic::{ AssertUnwindSafe, catch_unwind },
            slice::{ from_raw_parts },
            sync::{ Condvar, Mutex, PoisonError },
            *,
        };

        struct UnlockNotification
        {
            cond: Condvar,
            mutex: Mutex<bool>,
        }
        
        impl UnlockNotification 
        {
            fn new() -> Self
            {
                Self
                {
                    cond: Condvar::new(),
                    mutex: Mutex::new(false),
                }
            }

            fn fired(&self)
            {
                let mut flag = unpoison(self.mutex.lock());
                *flag = true;
                self.cond.notify_one();
            }

            fn wait(&self)
            {
                let mut fired = unpoison(self.mutex.lock());
                while !*fired
                {
                    fired = unpoison(self.cond.wait(fired));
                }
            }
        }

        #[inline] fn unpoison<T>(r: Result<T, PoisonError<T>>) -> T { r.unwrap_or_else( PoisonError::into_inner ) }
        /// This function is an unlock-notify callback
        unsafe extern "C" fn unlock_notify_cb(ap_arg: *mut *mut c_void, n_arg: c_int)
        {
            let args = from_raw_parts(ap_arg as *const &UnlockNotification, n_arg as usize);
            for un in args
            {
                drop(catch_unwind( AssertUnwindSafe(|| un.fired())) );
            }
        }

        pub unsafe fn is_locked(db: *mut connect::ffi::sqlite3, rc: c_int) -> bool 
        {
            rc == connect::ffi::SQLITE_LOCKED_SHAREDCACHE || 
            (rc & 0xFF) == ffi::SQLITE_LOCKED 
            && connect::ffi::sqlite3_extended_errcode(db) == connect::ffi::SQLITE_LOCKED_SHAREDCACHE
        }
        /// This function assumes that an SQLite API call (either `sqlite3_prepare_v2()` or `sqlite3_step()`) 
        /// has just returned `SQLITE_LOCKED`.
        pub unsafe fn wait_for_unlock_notify(db: *mut connect::ffi::sqlite3) -> c_int
        {
            let un = UnlockNotification::new();
            let rc = connect::ffi::sqlite3_unlock_notify
            (
                db,
                Some(unlock_notify_cb),
                &un as *const UnlockNotification as *mut c_void,
            );
            
            debug_assert!
            (
                rc == connect::ffi::SQLITE_LOCKED || 
                rc == connect::ffi::SQLITE_LOCKED_SHAREDCACHE || 
                rc == connect::ffi::SQLITE_OK
            );
            
            if rc == connect::ffi::SQLITE_OK { un.wait(); }

            rc
        }
    }

    pub mod params
    {
        use ::connect::{BindIndex, Result, Statement, ToSql};

        mod sealed
        {
            /// This trait exists just to ensure that the only impls of `trait Params`
            /// that are allowed are ones in this crate.
            pub trait Sealed {}
        }
        use sealed::Sealed;

        macro_rules! single_tuple_impl
        {
            ($count:literal : $(($field:tt $ftype:ident)),* $(,)?) =>
            {
                impl<$($ftype,)*> Sealed for ($($ftype,)*) where $($ftype: ToSql,)* {}
                impl<$($ftype,)*> Params for ($($ftype,)*) where $($ftype: ToSql,)* {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.ensure_parameter_count($count)?;
                        $({
                            debug_assert!($field < $count);
                            stmt.raw_bind_parameter($field + 1, self.$field)?;
                        })+
                        Ok(())
                    }
                }
            }
        }

        macro_rules! impl_for_array_ref
        {
            ($($N:literal)+) => 
            {$(
                impl<T: ToSql + ?Sized> Sealed for &[&T; $N] {}
                impl<T: ToSql + ?Sized> Params for &[&T; $N] {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters(self)
                    }
                }
                impl<S: BindIndex, T: ToSql + ?Sized> Sealed for &[(S, &T); $N] {}
                impl<S: BindIndex, T: ToSql + ?Sized> Params for &[(S, &T); $N] {
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters_named(self)
                    }
                }
                impl<T: ToSql> Sealed for [T; $N] {}
                impl<T: ToSql> Params for [T; $N] {
                    #[inline]
                    fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> {
                        stmt.bind_parameters(&self)
                    }
                }
            )+};
        }
        /// Trait used for [sets of parameter][params] passed into SQL statements/queries.
        pub trait Params: Sealed
        {
            fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()>;
        }
        
        impl Sealed for [&(dyn ToSql + Send + Sync); 0] {}
        impl Params for [&(dyn ToSql + Send + Sync); 0]
        {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> { stmt.ensure_parameter_count(0) }
        }

        impl Sealed for &[&dyn ToSql] {}
        impl Params for &[&dyn ToSql]
        {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> { stmt.bind_parameters(self) }
        }

        impl<S: BindIndex, T: ToSql> Sealed for &[(S, T)] {}
        impl<S: BindIndex, T: ToSql> Params for &[(S, T)]
        {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> { stmt.bind_parameters_named(self) }
        }
            
        impl Sealed for () {}
        impl Params for ()
        {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> { stmt.ensure_parameter_count(0) }
        }
        
        impl<T: ToSql> Sealed for (T,) {}
        impl<T: ToSql> Params for (T,)
        {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()>
            {
                stmt.ensure_parameter_count(1)?;
                stmt.raw_bind_parameter(1, self.0)?;
                Ok(())
            }
        }
        
        single_tuple_impl!(2: (0 A), (1 B));
        single_tuple_impl!(3: (0 A), (1 B), (2 C));
        single_tuple_impl!(4: (0 A), (1 B), (2 C), (3 D));
        single_tuple_impl!(5: (0 A), (1 B), (2 C), (3 D), (4 E));
        single_tuple_impl!(6: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F));
        single_tuple_impl!(7: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G));
        single_tuple_impl!(8: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H));
        single_tuple_impl!(9: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I));
        single_tuple_impl!(10: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J));
        single_tuple_impl!(11: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K));
        single_tuple_impl!(12: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L));
        single_tuple_impl!(13: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M));
        single_tuple_impl!(14: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N));
        single_tuple_impl!(15: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N), (14 O));
        single_tuple_impl!(16: (0 A), (1 B), (2 C), (3 D), (4 E), (5 F), (6 G), (7 H), (8 I), (9 J), (10 K), (11 L), (12 M), (13 N), (14 O), (15 P));
        
        impl_for_array_ref!( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 );

        /// Adapter type which allows any iterator over [`ToSql`] values to implement [`Params`].
        #[derive(Clone, Debug)]
        pub struct ParamsFromIter<I>(I);

        /// Constructor function for a [`ParamsFromIter`]. See its documentation for more.
        #[inline] pub fn params_from_iter<I>(iter: I) -> ParamsFromIter<I> where
        I: IntoIterator,
        I::Item: ToSql
        {
            ParamsFromIter(iter)
        }

        impl<I> Sealed for ParamsFromIter<I> where
        I: IntoIterator,
        I::Item: ToSql
        {}

        impl<I> Params for ParamsFromIter<I> where
        I: IntoIterator,
        I::Item: ToSql
        {
            #[inline] fn __bind_in(self, stmt: &mut Statement<'_>) -> Result<()> { stmt.bind_parameters(self.0) }
        }
    }

    pub mod raw
    {
        use ::
        {
            connect::
            {
                ffi::{ self },
                StatementStatus,
                util::{ ParamIndexCache, SqliteMallocString },

            },
            ffi::{c_int, CStr},
            sync::{ Arc },
            *,
        };

        // Private newtype for raw sqlite3_stmts that finalize themselves when dropped.
        #[derive(Debug)]
        pub struct RawStatement
        {
            ptr: *mut ffi::sqlite3_stmt,
            tail: usize,
            cache: ParamIndexCache,
            statement_cache_key: Option<Arc<str>>,
        }

        impl RawStatement {}
    }

    pub mod row
    {
        use ::
        {
            connect::{ Error, Result, Statement, types::{ FromSql, FromSqlError, ValueRef }, },
            iter::{ FallibleStreamingIterator },
            *,
        };

        macro_rules! tuple_try_from_row 
        {
            ($($field:ident),*) =>
            {
                impl<'a, $($field,)*> convert::TryFrom<&'a Row<'a>> for ($($field,)*) where $($field: FromSql,)* {
                    type Error = crate::Error;
                    #[allow(unused_assignments, unused_variables, unused_mut)]
                    fn try_from(row: &'a Row<'a>) -> Result<Self>
                    {
                        let mut index = 0;
                        $(
                            #[expect(non_snake_case)]
                            let $field = row.get::<_, $field>(index)?;
                            index += 1;
                        )*
                        Ok(($($field,)*))
                    }
                }
            }
        }

        macro_rules! tuples_try_from_row
        {
            () => { tuple_try_from_row!(); };
            ($first:ident $(, $remaining:ident)*) =>
            {
                tuple_try_from_row!($first $(, $remaining)*);
                tuples_try_from_row!($($remaining),*);
            };
        }
        /// A handle (lazy fallible streaming iterator) for the resulting rows of a query.
        #[must_use = "Rows is lazy and will do nothing unless consumed"]
        pub struct Rows<'stmt>
        {
            pub(crate) stmt: Option<&'stmt Statement<'stmt>>,
            row: Option<Row<'stmt>>,
        }

        impl<'stmt> Rows<'stmt>
        {
            #[inline] fn reset(&mut self) -> Result<()>
            {
                if let Some(stmt) = self.stmt.take() { stmt.reset() }
                else { Ok(()) }
            }
            /// Attempt to get the next row from the query.
            #[inline] pub fn next(&mut self) -> Result<Option<&Row<'stmt>>>
            {
                self.advance()?;
                Ok((*self).get())
            }
            /// Map over this `Rows`, converting it to a [`Map`], which implements `FallibleIterator`.
            #[inline] pub fn map<F, B>(self, f: F) -> Map<'stmt, F> where
            F: FnMut(&Row<'_>) -> Result<B>
            { Map { rows: self, f } }
            /// Map over this `Rows`, converting it to a [`MappedRows`], which implements `Iterator`.
            #[inline]
            pub fn mapped<F, B>(self, f: F) -> MappedRows<'stmt, F> where
            F: FnMut(&Row<'_>) -> Result<B>
            { MappedRows { rows: self, map: f } }
            /// Map over this `Rows` with a fallible function, converting it to a AndThenRows, which implements `Iterator`.
            #[inline] pub fn and_then<F, T, E>(self, f: F) -> AndThenRows<'stmt, F> where
            F: FnMut(&Row<'_>) -> Result<T, E>
            { AndThenRows { rows: self, map: f } }
            /// Give access to the underlying statement
            #[must_use] pub fn as_ref(&self) -> Option<&Statement<'stmt>> { self.stmt }
        }

        impl<'stmt> Rows<'stmt>
        {
            #[inline] pub(crate) fn new(stmt: &'stmt Statement<'stmt>) -> Self
            {
                Rows
                {
                    stmt: Some(stmt),
                    row: None,
                }
            }

            #[inline] pub(crate) fn get_expected_row(&mut self) -> Result<&Row<'stmt>>
            {
                match self.next()?
                {
                    Some(row) => Ok(row),
                    None => Err(Error::QueryReturnedNoRows),
                }
            }
        }

        impl Drop for Rows<'_>
        {
            #[expect(unused_must_use)]
            #[inline] fn drop(&mut self) { self.reset(); }
        }
        /// `F` is used to transform the _streaming_ iterator into a _fallible_iterator.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct Map<'stmt, F>
        {
            rows: Rows<'stmt>,
            f: F,
        }

        impl<F, B> FallibleIterator for Map<'_, F> where
        F: FnMut(&Row<'_>) -> Result<B>
        {
            type Error = Error;
            type Item = B;
            #[inline] fn next(&mut self) -> Result<Option<B>>
            {
                match self.rows.next()?
                {
                    Some(v) => Ok(Some((self.f)(v)?)),
                    None => Ok(None),
                }
            }
        }
        
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct MappedRows<'stmt, F>
        {
            rows: Rows<'stmt>,
            map: F,
        }

        impl<T, F> Iterator for MappedRows<'_, F> where
        F: FnMut(&Row<'_>) -> Result<T>
        {
            type Item = Result<T>;
            #[inline] fn next(&mut self) -> Option<Result<T>>
            {
                let map = &mut self.map;
                self.rows
                .next()
                .transpose()
                .map(|row_result| row_result.and_then(map))
            }
        }
        /// An iterator over the mapped resulting rows of a query, with an Error type unifying with Error.
        #[must_use = "iterators are lazy and do nothing unless consumed"]
        pub struct AndThenRows<'stmt, F>
        {
            rows: Rows<'stmt>,
            map: F,
        }

        impl<T, E, F> Iterator for AndThenRows<'_, F> where
        E: From<Error>,
        F: FnMut(&Row<'_>) -> Result<T, E>
        {
            type Item = Result<T, E>;

            #[inline] fn next(&mut self) -> Option<Self::Item>
            {
                let map = &mut self.map;
                self.rows
                .next()
                .transpose()
                .map(|row_result| row_result.map_err(E::from).and_then(map))
            }
        }

        /// `FallibleStreamingIterator` differs from the standard library's `Iterator` in two ways:
        /// * each call to `next` (`sqlite3_step`) can fail.
        /// * returned `Row` is valid until `next` is called again or `Statement` is
        ///   reset or finalized.
        impl<'stmt> FallibleStreamingIterator for Rows<'stmt>
        {
            type Error = Error;
            type Item = Row<'stmt>;

            #[inline] fn advance(&mut self) -> Result<()>
            {
                if let Some(stmt) = self.stmt
                {
                    match stmt.step()
                    {
                        Ok(true) =>
                        {
                            self.row = Some(Row { stmt });
                            Ok(())
                        }
                        
                        Ok(false) =>
                        {
                            let r = self.reset();
                            self.row = None;
                            r
                        }
                        
                        Err(e) =>
                        {
                            let _ = self.reset(); // prevents infinite loop on error
                            self.row = None;
                            Err(e)
                        }
                    }
                }
                
                else
                {
                    self.row = None;
                    Ok(())
                }
            }

            #[inline] fn get(&self) -> Option<&Row<'stmt>> { self.row.as_ref() }
        }
        /// A single result row of a query.
        pub struct Row<'stmt>
        {
            pub(crate) stmt: &'stmt Statement<'stmt>,
        }

        impl Row<'_>
        {
            /// Get the value of a particular column of the result row.
            #[track_caller] pub fn get_unwrap<I: RowIndex, T: FromSql>(&self, idx: I) -> T { self.get(idx).unwrap() }
            /// Get the value of a particular column of the result row.
            #[track_caller] pub fn get<I: RowIndex, T: FromSql>(&self, idx: I) -> Result<T>
            {
                let idx = idx.idx(self.stmt)?;
                let value = self.stmt.value_ref(idx);
                FromSql::column_result(value).map_err(|err| match err
                {
                    FromSqlError::InvalidType => Error::InvalidColumnType
                    (
                        idx,
                        self.stmt.column_name_unwrap(idx).into(),
                        value.data_type(),
                    ),
                    FromSqlError::OutOfRange(i) => Error::IntegralValueOutOfRange(idx, i),
                    FromSqlError::Other(err) => 
                    {
                        Error::FromSqlConversionFailure(idx, value.data_type(), err)
                    }
                    FromSqlError::InvalidBlobSize { .. } => 
                    {
                        Error::FromSqlConversionFailure(idx, value.data_type(), Box::new(err))
                    }
                })
            }
            /// Get the value of a particular column of the result row as a `ValueRef`, 
            /// allowing data to be read out of a row without copying.
            pub fn get_ref<I: RowIndex>(&self, idx: I) -> Result<ValueRef<'_>>
            {
                let idx = idx.idx(self.stmt)?;
                let val_ref = self.stmt.value_ref(idx);
                Ok(val_ref)
            }
            /// Get the value of a particular column of the result row as a `ValueRef`,
            /// allowing data to be read out of a row without copying.
            #[track_caller] pub fn get_ref_unwrap<I: RowIndex>(&self, idx: I) -> ValueRef<'_> { self.get_ref(idx).unwrap() }
        }

        impl<'stmt> AsRef<Statement<'stmt>> for Row<'stmt>
        {
            fn as_ref(&self) -> &Statement<'stmt> { self.stmt }
        }

        /// Debug `Row` with column name as key except that for `Type::Blob` only its size is printed (not its content).
        impl ::fmt::Debug for Row<'_>
        {
            fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
            {
                let mut dm = f.debug_map();
                for c in 0..self.stmt.column_count()
                {
                    let name = self.stmt.column_name(c).expect("valid column index");
                    dm.key(&name);
                    let value = self.get_ref(c);
                    match value
                    {
                        Ok(value) =>
                        {
                            let dt = value.data_type();
                            match value
                            {
                                ValueRef::Null => { dm.value(&(dt, ())); }
                                ValueRef::Integer(i) => { dm.value(&(dt, i)); }
                                ValueRef::Real(f) => { dm.value(&(dt, f)); }
                                ValueRef::Text(s) => { dm.value(&(dt, String::from_utf8_lossy(s))); }
                                ValueRef::Blob(b) => { dm.value(&(dt, b.len())); }
                            }
                        }
                        Err(ref _err) => { dm.value(&value); }
                    }
                }
                dm.finish()
            }
        }

        mod sealed
        {
            /// This trait exists just to ensure that the only impls of `trait RowIndex` that are allowed are ones in this crate.
            pub trait Sealed {}
            impl Sealed for usize {}
            impl Sealed for &str {}
        }
        /// A trait implemented by types that can index into columns of a row.
        pub trait RowIndex: sealed::Sealed
        {
            /// Returns the index of the appropriate column, or `Error` if no such column exists.
            fn idx(&self, stmt: &Statement<'_>) -> Result<usize>;
        }

        impl RowIndex for usize
        {
            #[inline] fn idx(&self, stmt: &Statement<'_>) -> Result<usize>
            {
                if *self >= stmt.column_count() { Err(Error::InvalidColumnIndex(*self)) }
                else { Ok(*self) }
            }
        }

        impl RowIndex for &'_ str
        {
            #[inline] fn idx(&self, stmt: &Statement<'_>) -> Result<usize>
            { stmt.column_index(self) }
        }

        tuples_try_from_row!(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P);
    }

    pub mod session
    {
        //! [Session Extension](https://sqlite.org/sessionintro.html)
        use ::
        {
            connect::
            {
                error::{ check, error_from_sqlite_code, Error },
                hooks::{ Action },
                types::{ ValueRef },
                self, errmsg_to_string, str_to_cstring, Connection, DatabaseName, Result,
            },
            ffi::{ c_char, c_int, c_uchar, c_void, CStr },
            io::{ Read, Write },
            iter::{ FallibleStreamingIterator },
            marker::{ PhantomData },
            panic::{ catch_unwind },
            slice::{from_raw_parts, from_raw_parts_mut},
            *,
        };
        
        type Filter = Option<Box<dyn Fn(&str) -> bool>>;

        /// An instance of this object is a session that can be used to record changes to a database.
        pub struct Session<'conn> {
            phantom: PhantomData<&'conn Connection>,
            s: *mut connect::ffi::sqlite3_session,
            filter: Filter,
        }

        impl Session<'_> {
            /// Create a new session object
            #[inline] pub fn new(db: &Connection) -> Result<Session<'_>> {
                Session::new_with_name(db, DatabaseName::Main)
            }

            /// Create a new session object
            #[inline]
            pub fn new_with_name<'conn>(
                db: &'conn Connection,
                name: DatabaseName<'_>,
            ) -> Result<Session<'conn>> {
                let name = name.as_cstr()?;

                let db = db.db.borrow_mut().db;

                let mut s: *mut connect::ffi::sqlite3_session = ptr::null_mut();
                check(unsafe { connect::ffi::sqlite3session_create(db, name.as_ptr(), &mut s) })?;

                Ok(Session {
                    phantom: PhantomData,
                    s,
                    filter: None,
                })
            }

            /// Set a table filter
            pub fn table_filter<F>(&mut self, filter: Option<F>)
            where
                F: Fn(&str) -> bool + Send + 'static,
            {
                unsafe extern "C" fn call_boxed_closure<F>(
                    p_arg: *mut c_void,
                    tbl_str: *const c_char,
                ) -> c_int
                where
                    F: Fn(&str) -> bool,
                {
                    let tbl_name = CStr::from_ptr(tbl_str).to_str();
                    c_int::from(
                        catch_unwind(|| {
                            let boxed_filter: *mut F = p_arg.cast::<F>();
                            (*boxed_filter)(tbl_name.expect("non-utf8 table name"))
                        })
                        .unwrap_or_default(),
                    )
                }

                match filter {
                    Some(filter) => {
                        let boxed_filter = Box::new(filter);
                        unsafe {
                            connect::ffi::sqlite3session_table_filter(
                                self.s,
                                Some(call_boxed_closure::<F>),
                                &*boxed_filter as *const F as *mut _,
                            );
                        }
                        self.filter = Some(boxed_filter);
                    }
                    _ => {
                        unsafe { connect::ffi::sqlite3session_table_filter(self.s, None, ptr::null_mut()) }
                        self.filter = None;
                    }
                };
            }

            /// Attach a table. `None` means all tables.
            pub fn attach(&mut self, table: Option<&str>) -> Result<()> {
                let table = if let Some(table) = table {
                    Some(str_to_cstring(table)?)
                } else {
                    None
                };
                let table = table.as_ref().map(|s| s.as_ptr()).unwrap_or(ptr::null());
                check(unsafe { connect::ffi::sqlite3session_attach(self.s, table) })
            }

            /// Generate a Changeset
            pub fn changeset(&mut self) -> Result<Changeset> {
                let mut n = 0;
                let mut cs: *mut c_void = ptr::null_mut();
                check(unsafe { connect::ffi::sqlite3session_changeset(self.s, &mut n, &mut cs) })?;
                Ok(Changeset { cs, n })
            }

            /// Write the set of changes represented by this session to `output`.
            #[inline]
            pub fn changeset_strm(&mut self, output: &mut dyn Write) -> Result<()> {
                let output_ref = &output;
                check(unsafe {
                    connect::ffi::sqlite3session_changeset_strm(
                        self.s,
                        Some(x_output),
                        output_ref as *const &mut dyn Write as *mut c_void,
                    )
                })
            }

            /// Generate a Patchset
            #[inline]
            pub fn patchset(&mut self) -> Result<Changeset> {
                let mut n = 0;
                let mut ps: *mut c_void = ptr::null_mut();
                check(unsafe { connect::ffi::sqlite3session_patchset(self.s, &mut n, &mut ps) })?;
                // TODO Validate: same struct
                Ok(Changeset { cs: ps, n })
            }

            /// Write the set of patches represented by this session to `output`.
            #[inline]
            pub fn patchset_strm(&mut self, output: &mut dyn Write) -> Result<()> {
                let output_ref = &output;
                check(unsafe {
                    connect::ffi::sqlite3session_patchset_strm(
                        self.s,
                        Some(x_output),
                        output_ref as *const &mut dyn Write as *mut c_void,
                    )
                })
            }

            /// Load the difference between tables.
            pub fn diff(&mut self, from: DatabaseName<'_>, table: &str) -> Result<()> {
                let from = from.as_cstr()?;
                let table = str_to_cstring(table)?;
                let table = table.as_ptr();
                unsafe {
                    let mut errmsg = ptr::null_mut();
                    let r =
                        connect::ffi::sqlite3session_diff(self.s, from.as_ptr(), table, &mut errmsg as *mut *mut _);
                    if r != connect::ffi::SQLITE_OK {
                        let errmsg: *mut c_char = errmsg;
                        let message = errmsg_to_string(&*errmsg);
                        connect::ffi::sqlite3_free(errmsg as *mut c_void);
                        return Err(error_from_sqlite_code(r, Some(message)));
                    }
                }
                Ok(())
            }

            /// Test if a changeset has recorded any changes
            #[inline]
            pub fn is_empty(&self) -> bool {
                unsafe { connect::ffi::sqlite3session_isempty(self.s) != 0 }
            }

            /// Query the current state of the session
            #[inline]
            pub fn is_enabled(&self) -> bool {
                unsafe { connect::ffi::sqlite3session_enable(self.s, -1) != 0 }
            }

            /// Enable or disable the recording of changes
            #[inline]
            pub fn set_enabled(&mut self, enabled: bool) {
                unsafe {
                    connect::ffi::sqlite3session_enable(self.s, c_int::from(enabled));
                }
            }

            /// Query the current state of the indirect flag
            #[inline]
            pub fn is_indirect(&self) -> bool {
                unsafe { connect::ffi::sqlite3session_indirect(self.s, -1) != 0 }
            }

            /// Set or clear the indirect change flag
            #[inline]
            pub fn set_indirect(&mut self, indirect: bool) {
                unsafe {
                    connect::ffi::sqlite3session_indirect(self.s, c_int::from(indirect));
                }
            }
        }

        impl Drop for Session<'_> {
            #[inline]
            fn drop(&mut self) {
                if self.filter.is_some() {
                    self.table_filter(None::<fn(&str) -> bool>);
                }
                unsafe { connect::ffi::sqlite3session_delete(self.s) };
            }
        }

        /// Invert a changeset
        #[inline]
        pub fn invert_strm(input: &mut dyn Read, output: &mut dyn Write) -> Result<()> {
            let input_ref = &input;
            let output_ref = &output;
            check(unsafe {
                connect::ffi::sqlite3changeset_invert_strm(
                    Some(x_input),
                    input_ref as *const &mut dyn Read as *mut c_void,
                    Some(x_output),
                    output_ref as *const &mut dyn Write as *mut c_void,
                )
            })
        }

        /// Combine two changesets
        #[inline]
        pub fn concat_strm(
            input_a: &mut dyn Read,
            input_b: &mut dyn Read,
            output: &mut dyn Write,
        ) -> Result<()> {
            let input_a_ref = &input_a;
            let input_b_ref = &input_b;
            let output_ref = &output;
            check(unsafe {
                connect::ffi::sqlite3changeset_concat_strm(
                    Some(x_input),
                    input_a_ref as *const &mut dyn Read as *mut c_void,
                    Some(x_input),
                    input_b_ref as *const &mut dyn Read as *mut c_void,
                    Some(x_output),
                    output_ref as *const &mut dyn Write as *mut c_void,
                )
            })
        }

        /// Changeset or Patchset
        pub struct Changeset {
            cs: *mut c_void,
            n: c_int,
        }

        impl Changeset {
            /// Invert a changeset
            #[inline]
            pub fn invert(&self) -> Result<Changeset> {
                let mut n = 0;
                let mut cs = ptr::null_mut();
                check(unsafe {
                    connect::ffi::sqlite3changeset_invert(self.n, self.cs, &mut n, &mut cs as *mut *mut _)
                })?;
                Ok(Changeset { cs, n })
            }

            /// Create an iterator to traverse a changeset
            #[inline]
            pub fn iter(&self) -> Result<ChangesetIter<'_>> {
                let mut it = ptr::null_mut();
                check(unsafe { connect::ffi::sqlite3changeset_start(&mut it as *mut *mut _, self.n, self.cs) })?;
                Ok(ChangesetIter {
                    phantom: PhantomData,
                    it,
                    item: None,
                })
            }

            /// Concatenate two changeset objects
            #[inline]
            pub fn concat(a: &Changeset, b: &Changeset) -> Result<Changeset> {
                let mut n = 0;
                let mut cs = ptr::null_mut();
                check(unsafe {
                    connect::ffi::sqlite3changeset_concat(a.n, a.cs, b.n, b.cs, &mut n, &mut cs as *mut *mut _)
                })?;
                Ok(Changeset { cs, n })
            }
        }

        impl Drop for Changeset {
            #[inline]
            fn drop(&mut self) {
                unsafe {
                    connect::ffi::sqlite3_free(self.cs);
                }
            }
        }

        /// Cursor for iterating over the elements of a changeset
        /// or patchset.
        pub struct ChangesetIter<'changeset> {
            phantom: PhantomData<&'changeset Changeset>,
            it: *mut connect::ffi::sqlite3_changeset_iter,
            item: Option<ChangesetItem>,
        }

        impl ChangesetIter<'_> {
            /// Create an iterator on `input`
            #[inline]
            pub fn start_strm<'input>(input: &&'input mut dyn Read) -> Result<ChangesetIter<'input>> {
                let mut it = ptr::null_mut();
                check(unsafe {
                    connect::ffi::sqlite3changeset_start_strm(
                        &mut it as *mut *mut _,
                        Some(x_input),
                        input as *const &mut dyn Read as *mut c_void,
                    )
                })?;
                Ok(ChangesetIter {
                    phantom: PhantomData,
                    it,
                    item: None,
                })
            }
        }

        impl FallibleStreamingIterator for ChangesetIter<'_> {
            type Error = Error;
            type Item = ChangesetItem;

            #[inline]
            fn advance(&mut self) -> Result<()> {
                let rc = unsafe { connect::ffi::sqlite3changeset_next(self.it) };
                match rc {
                    connect::ffi::SQLITE_ROW => {
                        self.item = Some(ChangesetItem { it: self.it });
                        Ok(())
                    }
                    connect::ffi::SQLITE_DONE => {
                        self.item = None;
                        Ok(())
                    }
                    code => Err(error_from_sqlite_code(code, None)),
                }
            }

            #[inline]
            fn get(&self) -> Option<&ChangesetItem> {
                self.item.as_ref()
            }
        }

        /// Operation
        pub struct Operation<'item> {
            table_name: &'item str,
            number_of_columns: i32,
            code: Action,
            indirect: bool,
        }

        impl Operation<'_> {
            /// Returns the table name.
            #[inline]
            pub fn table_name(&self) -> &str {
                self.table_name
            }

            /// Returns the number of columns in table
            #[inline]
            pub fn number_of_columns(&self) -> i32 {
                self.number_of_columns
            }

            /// Returns the action code.
            #[inline]
            pub fn code(&self) -> Action {
                self.code
            }

            /// Returns `true` for an 'indirect' change.
            #[inline]
            pub fn indirect(&self) -> bool {
                self.indirect
            }
        }

        impl Drop for ChangesetIter<'_> {
            #[inline]
            fn drop(&mut self) {
                unsafe {
                    connect::ffi::sqlite3changeset_finalize(self.it);
                }
            }
        }

        /// An item passed to a conflict-handler by
        /// [`Connection::apply`](Connection::apply), or an item generated by
        /// [`ChangesetIter::next`](ChangesetIter::next).
        // TODO enum ? Delete, Insert, Update, ...
        pub struct ChangesetItem {
            it: *mut connect::ffi::sqlite3_changeset_iter,
        }

        impl ChangesetItem {
            /// Obtain conflicting row values
            ///
            /// May only be called with an `SQLITE_CHANGESET_DATA` or
            /// `SQLITE_CHANGESET_CONFLICT` conflict handler callback.
            #[inline]
            pub fn conflict(&self, col: usize) -> Result<ValueRef<'_>> {
                unsafe {
                    let mut p_value: *mut connect::ffi::sqlite3_value = ptr::null_mut();
                    check( connect::ffi::sqlite3changeset_conflict(
                        self.it,
                        col as i32,
                        &mut p_value,
                    ))?;
                    if p_value.is_null() {
                        Err(Error::InvalidColumnIndex(col))
                    } else {
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }

            /// Determine the number of foreign key constraint violations
            ///
            /// May only be called with an `SQLITE_CHANGESET_FOREIGN_KEY` conflict
            /// handler callback.
            #[inline]
            pub fn fk_conflicts(&self) -> Result<i32> {
                unsafe {
                    let mut p_out = 0;
                    check( connect::ffi::sqlite3changeset_fk_conflicts(self.it, &mut p_out))?;
                    Ok(p_out)
                }
            }

            /// Obtain new.* Values
            ///
            /// May only be called if the type of change is either `SQLITE_UPDATE` or
            /// `SQLITE_INSERT`.
            #[inline]
            pub fn new_value(&self, col: usize) -> Result<ValueRef<'_>> {
                unsafe {
                    let mut p_value: *mut connect::ffi::sqlite3_value = ptr::null_mut();
                    check( connect::ffi::sqlite3changeset_new(self.it, col as i32, &mut p_value))?;
                    if p_value.is_null() {
                        Err(Error::InvalidColumnIndex(col))
                    } else {
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }

            /// Obtain old.* Values
            ///
            /// May only be called if the type of change is either `SQLITE_DELETE` or
            /// `SQLITE_UPDATE`.
            #[inline]
            pub fn old_value(&self, col: usize) -> Result<ValueRef<'_>> {
                unsafe {
                    let mut p_value: *mut connect::ffi::sqlite3_value = ptr::null_mut();
                    check( connect::ffi::sqlite3changeset_old(self.it, col as i32, &mut p_value))?;
                    if p_value.is_null() {
                        Err(Error::InvalidColumnIndex(col))
                    } else {
                        Ok(ValueRef::from_value(p_value))
                    }
                }
            }

            /// Obtain the current operation
            #[inline]
            pub fn op(&self) -> Result<Operation<'_>> {
                let mut number_of_columns = 0;
                let mut code = 0;
                let mut indirect = 0;
                let tab = unsafe {
                    let mut pz_tab: *const c_char = ptr::null();
                    check( connect::ffi::sqlite3changeset_op(
                        self.it,
                        &mut pz_tab,
                        &mut number_of_columns,
                        &mut code,
                        &mut indirect,
                    ))?;
                    CStr::from_ptr(pz_tab)
                };
                let table_name = tab.to_str()?;
                Ok(Operation {
                    table_name,
                    number_of_columns,
                    code: Action::from(code),
                    indirect: indirect != 0,
                })
            }

            /// Obtain the primary key definition of a table
            #[inline]
            pub fn pk(&self) -> Result<&[u8]> {
                let mut number_of_columns = 0;
                unsafe {
                    let mut pks: *mut c_uchar = ptr::null_mut();
                    check( connect::ffi::sqlite3changeset_pk(
                        self.it,
                        &mut pks,
                        &mut number_of_columns,
                    ))?;
                    Ok(from_raw_parts(pks, number_of_columns as usize))
                }
            }
        }

        /// Used to combine two or more changesets or
        /// patchsets
        pub struct Changegroup {
            cg: *mut connect::ffi::sqlite3_changegroup,
        }

        impl Changegroup {
            /// Create a new change group.
            #[inline]
            pub fn new() -> Result<Self> {
                let mut cg = ptr::null_mut();
                check(unsafe { connect::ffi::sqlite3changegroup_new(&mut cg) })?;
                Ok(Changegroup { cg })
            }

            /// Add a changeset
            #[inline]
            pub fn add(&mut self, cs: &Changeset) -> Result<()> {
                check(unsafe { connect::ffi::sqlite3changegroup_add(self.cg, cs.n, cs.cs) })
            }

            /// Add a changeset read from `input` to this change group.
            #[inline]
            pub fn add_stream(&mut self, input: &mut dyn Read) -> Result<()> {
                let input_ref = &input;
                check(unsafe {
                    connect::ffi::sqlite3changegroup_add_strm(
                        self.cg,
                        Some(x_input),
                        input_ref as *const &mut dyn Read as *mut c_void,
                    )
                })
            }

            /// Obtain a composite Changeset
            #[inline]
            pub fn output(&mut self) -> Result<Changeset> {
                let mut n = 0;
                let mut output: *mut c_void = ptr::null_mut();
                check(unsafe { connect::ffi::sqlite3changegroup_output(self.cg, &mut n, &mut output) })?;
                Ok(Changeset { cs: output, n })
            }

            /// Write the combined set of changes to `output`.
            #[inline]
            pub fn output_strm(&mut self, output: &mut dyn Write) -> Result<()> {
                let output_ref = &output;
                check(unsafe {
                    connect::ffi::sqlite3changegroup_output_strm(
                        self.cg,
                        Some(x_output),
                        output_ref as *const &mut dyn Write as *mut c_void,
                    )
                })
            }
        }

        impl Drop for Changegroup {
            #[inline]
            fn drop(&mut self) {
                unsafe {
                    connect::ffi::sqlite3changegroup_delete(self.cg);
                }
            }
        }

        impl Connection {
            /// Apply a changeset to a database
            pub fn apply<F, C>(&self, cs: &Changeset, filter: Option<F>, conflict: C) -> Result<()>
            where
                F: Fn(&str) -> bool + Send + 'static,
                C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
            {
                let db = self.db.borrow_mut().db;

                let filtered = filter.is_some();
                let tuple = &mut (filter, conflict);
                check(unsafe {
                    if filtered {
                        connect::ffi::sqlite3changeset_apply(
                            db,
                            cs.n,
                            cs.cs,
                            Some(call_filter::<F, C>),
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    } else {
                        connect::ffi::sqlite3changeset_apply(
                            db,
                            cs.n,
                            cs.cs,
                            None,
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    }
                })
            }

            /// Apply a changeset to a database
            pub fn apply_strm<F, C>(
                &self,
                input: &mut dyn Read,
                filter: Option<F>,
                conflict: C,
            ) -> Result<()>
            where
                F: Fn(&str) -> bool + Send + 'static,
                C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
            {
                let input_ref = &input;
                let db = self.db.borrow_mut().db;

                let filtered = filter.is_some();
                let tuple = &mut (filter, conflict);
                check(unsafe {
                    if filtered {
                        connect::ffi::sqlite3changeset_apply_strm(
                            db,
                            Some(x_input),
                            input_ref as *const &mut dyn Read as *mut c_void,
                            Some(call_filter::<F, C>),
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    } else {
                        ffi::sqlite3changeset_apply_strm(
                            db,
                            Some(x_input),
                            input_ref as *const &mut dyn Read as *mut c_void,
                            None,
                            Some(call_conflict::<F, C>),
                            tuple as *mut (Option<F>, C) as *mut c_void,
                        )
                    }
                })
            }
        }

        /// Constants passed to the conflict handler
        /// See [here](https://sqlite.org/session.html#SQLITE_CHANGESET_CONFLICT) for details.
        #[allow(missing_docs)]
        #[repr(i32)]
        #[derive(Debug, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum ConflictType {
            UNKNOWN = -1,
            SQLITE_CHANGESET_DATA = connect::ffi::SQLITE_CHANGESET_DATA,
            SQLITE_CHANGESET_NOTFOUND = connect::ffi::SQLITE_CHANGESET_NOTFOUND,
            SQLITE_CHANGESET_CONFLICT = connect::ffi::SQLITE_CHANGESET_CONFLICT,
            SQLITE_CHANGESET_CONSTRAINT = connect::ffi::SQLITE_CHANGESET_CONSTRAINT,
            SQLITE_CHANGESET_FOREIGN_KEY = connect::ffi::SQLITE_CHANGESET_FOREIGN_KEY,
        }
        impl From<i32> for ConflictType {
            fn from(code: i32) -> ConflictType {
                match code {
                    connect::ffi::SQLITE_CHANGESET_DATA => ConflictType::SQLITE_CHANGESET_DATA,
                    connect::ffi::SQLITE_CHANGESET_NOTFOUND => ConflictType::SQLITE_CHANGESET_NOTFOUND,
                    connect::ffi::SQLITE_CHANGESET_CONFLICT => ConflictType::SQLITE_CHANGESET_CONFLICT,
                    connect::ffi::SQLITE_CHANGESET_CONSTRAINT => ConflictType::SQLITE_CHANGESET_CONSTRAINT,
                    connect::ffi::SQLITE_CHANGESET_FOREIGN_KEY => ConflictType::SQLITE_CHANGESET_FOREIGN_KEY,
                    _ => ConflictType::UNKNOWN,
                }
            }
        }

        /// Constants returned by the conflict handler
        /// See [here](https://sqlite.org/session.html#SQLITE_CHANGESET_ABORT) for details.
        #[allow(missing_docs)]
        #[repr(i32)]
        #[derive(Debug, PartialEq, Eq)]
        #[non_exhaustive]
        pub enum ConflictAction {
            SQLITE_CHANGESET_OMIT = connect::ffi::SQLITE_CHANGESET_OMIT,
            SQLITE_CHANGESET_REPLACE = connect::ffi::SQLITE_CHANGESET_REPLACE,
            SQLITE_CHANGESET_ABORT = connect::ffi::SQLITE_CHANGESET_ABORT,
        }

        unsafe extern "C" fn call_filter<F, C>(p_ctx: *mut c_void, tbl_str: *const c_char) -> c_int
        where
            F: Fn(&str) -> bool + Send + 'static,
            C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
        {
            let tbl_name = CStr::from_ptr(tbl_str).to_str();
            c_int::from(
                catch_unwind(|| {
                    let tuple: *mut (Option<F>, C) = p_ctx.cast::<(Option<F>, C)>();
                    if let Some(ref filter) = (*tuple).0 {
                        filter(tbl_name.expect("illegal table name"))
                    } else {
                        true
                    }
                })
                .unwrap_or_default(),
            )
        }

        unsafe extern "C" fn call_conflict<F, C>(
            p_ctx: *mut c_void,
            e_conflict: c_int,
            p: *mut connect::ffi::sqlite3_changeset_iter,
        ) -> c_int
        where
            F: Fn(&str) -> bool + Send + 'static,
            C: Fn(ConflictType, ChangesetItem) -> ConflictAction + Send + 'static,
        {
            let conflict_type = ConflictType::from(e_conflict);
            let item = ChangesetItem { it: p };
            if let Ok(action) = catch_unwind(|| {
                let tuple: *mut (Option<F>, C) = p_ctx.cast::<(Option<F>, C)>();
                (*tuple).1(conflict_type, item)
            }) {
                action as c_int
            } else {
                connect::ffi::SQLITE_CHANGESET_ABORT
            }
        }

        unsafe extern "C" fn x_input(p_in: *mut c_void, data: *mut c_void, len: *mut c_int) -> c_int {
            if p_in.is_null() {
                return connect::ffi::SQLITE_MISUSE;
            }
            let bytes: &mut [u8] = from_raw_parts_mut(data as *mut u8, *len as usize);
            let input = p_in as *mut &mut dyn Read;
            match (*input).read(bytes) {
                Ok(n) => {
                    *len = n as i32; // TODO Validate: n = 0 may not mean the reader will always no longer be able to
                                    // produce bytes.
                    connect::ffi::SQLITE_OK
                }
                Err(_) => connect::ffi::SQLITE_IOERR_READ, // TODO check if err is a (ru)sqlite Error => propagate
            }
        }

        unsafe extern "C" fn x_output(p_out: *mut c_void, data: *const c_void, len: c_int) -> c_int {
            if p_out.is_null() {
                return connect::ffi::SQLITE_MISUSE;
            }
            // The sessions module never invokes an xOutput callback with the third
            // parameter set to a value less than or equal to zero.
            let bytes: &[u8] = from_raw_parts(data as *const u8, len as usize);
            let output = p_out as *mut &mut dyn Write;
            match (*output).write_all(bytes) {
                Ok(_) => connect::ffi::SQLITE_OK,
                Err(_) => connect::ffi::SQLITE_IOERR_WRITE, // TODO check if err is a (ru)sqlite Error => propagate
            }
        }
    }

    pub mod statement
    {
        use ::
        {
            connect::
            {
                self, 
                bind::{ BindIndex },
                types::{ToSql, ToSqlOutput},
                vtab::array::{free_array, ARRAY_TYPE},
                len_as_c_int, str_for_sqlite,
                AndThenRows, Connection, Error, MappedRows, Params, RawStatement, Result, Row, Rows, ValueRef,
            },
            ffi::{ c_int, c_void },
            rc::{ Rc },
            slice::{ from_raw_parts },
            *,
        };
        /// A prepared statement.
        pub struct Statement<'conn>
        {
            conn: &'conn Connection,
            pub(crate) stmt: RawStatement,
        }

        impl Statement<'_>
        {
            /// Execute the prepared statement.
            #[inline] pub fn execute<P: Params>(&mut self, params: P) -> Result<usize>
            {
                params.__bind_in(self)?;
                self.execute_with_bound_parameters()
            }

            /// Execute an INSERT and return the ROWID.
            #[inline] pub fn insert<P: Params>(&mut self, params: P) -> Result<i64>
            {
                let changes = self.execute(params)?;
                match changes
                {
                    1 => Ok(self.conn.last_insert_rowid()),
                    _ => Err(Error::StatementChangedRows(changes)),
                }
            }
            /// Execute the prepared statement, returning a handle to the resulting rows.
            #[inline] pub fn query<P: Params>(&mut self, params: P) -> Result<Rows<'_>>
            {
                params.__bind_in(self)?;
                Ok(Rows::new(self))
            }
            /// Executes the prepared statement and maps a function over the resulting rows, 
            /// returning an iterator over the mapped function results.
            pub fn query_map<T, P, F>(&mut self, params: P, f: F) -> Result<MappedRows<'_, F>> where
            P: Params,
            F: FnMut(&Row<'_>) -> Result<T>
            { self.query(params).map(|rows| rows.mapped(f)) }
            /// Executes the prepared statement and maps a function over the resulting
            /// rows, where the function returns a `Result` with `Error` type
            /// implementing `std::convert::From<Error>` so errors can be unified.
            #[inline]
            pub fn query_and_then<T, E, P, F>(&mut self, params: P, f: F) -> Result<AndThenRows<'_, F>> where
            P: Params,
            E: From<Error>,
            F: FnMut(&Row<'_>) -> Result<T, E>
            {
                self.query(params).map(|rows| rows.and_then(f))
            }

            /// Return `true` if a query in the SQL statement it executes returns one
            /// or more rows and `false` if the SQL returns an empty set.
            #[inline] pub fn exists<P: Params>(&mut self, params: P) -> Result<bool>
            {
                let mut rows = self.query(params)?;
                let exists = rows.next()?.is_some();
                Ok(exists)
            }
            /// Convenience method to execute a query that is expected to return a single row.
            pub fn query_row<T, P, F>(&mut self, params: P, f: F) -> Result<T> where
            P: Params,
            F: FnOnce(&Row<'_>) -> Result<T>
            {
                let mut rows = self.query(params)?;
                rows.get_expected_row().and_then(f)
            }

            /// Consumes the statement.
            #[inline] pub fn finalize(mut self) -> Result<()> { self.finalize_() }
            /// Return the (one-based) index of an SQL parameter given its name.
            #[inline] pub fn parameter_index(&self, name: &str) -> Result<Option<usize>>
            { Ok(self.stmt.bind_parameter_index(name)) }
            /// Return the SQL parameter name given its (one-based) index (the inverse of [`Statement::parameter_index`]).
            #[inline] pub fn parameter_name(&self, index: usize) -> Option<&'_ str>
            {
                self.stmt.bind_parameter_name(index as i32).map(|name|
                {
                    name.to_str().expect("Invalid UTF-8 sequence in parameter name")
                })
            }

            #[inline] pub(crate) fn bind_parameters<P>(&mut self, params: P) -> Result<()> where
            P: IntoIterator,
            P::Item: ToSql
            {
                let expected = self.stmt.bind_parameter_count();
                let mut index = 0;
                for p in params {
                    index += 1; // The leftmost SQL parameter has an index of 1.
                    if index > expected {
                        break;
                    }
                    self.bind_parameter(&p, index)?;
                }
                if index != expected {
                    Err(Error::InvalidParameterCount(index, expected))
                } else {
                    Ok(())
                }
            }

            #[inline] pub(crate) fn ensure_parameter_count(&self, n: usize) -> Result<()>
            {
                let count = self.parameter_count();
                if count != n { Err(Error::InvalidParameterCount(n, count)) } 
                else { Ok(()) }
            }

            #[inline] pub(crate) fn bind_parameters_named<S: BindIndex, T: ToSql>( &mut self, params: &[(S, T)] ) -> 
            Result<()> 
            {
                for (name, value) in params
                {
                    let i = name.idx(self)?;
                    let ts: &dyn ToSql = &value;
                    self.bind_parameter(ts, i)?;
                }
                Ok(())
            }
            /// Return the number of parameters that can be bound to this statement.
            #[inline] pub fn parameter_count(&self) -> usize { self.stmt.bind_parameter_count() }
            /// Low level API to directly bind a parameter to a given index.
            #[inline] pub fn raw_bind_parameter<I: BindIndex, T: ToSql>( &mut self, one_based_index: I, param: T ) ->
            Result<()>
            {
                self.bind_parameter(&param, one_based_index.idx(self)?)
            }
            /// API to execute a statement given that all parameters bound explicitly with the `Statement::raw_bind_parameter` API.
            #[inline] pub fn raw_execute(&mut self) -> Result<usize> { self.execute_with_bound_parameters() }
            /// Low level API to get `Rows` for this query given that all parameters
            /// were bound explicitly with the [`Statement::raw_bind_parameter`] API.
            #[inline] pub fn raw_query(&mut self) -> Rows<'_> { Rows::new(self) }
            
            fn bind_parameter<P: ?Sized + ToSql>(&self, param: &P, ndx: usize) -> Result<()>
            {
                unsafe
                {
                    let value = param.to_sql()?;
                    let ptr = self.stmt.ptr();
                    let value = match value
                    {
                        ToSqlOutput::Borrowed(v) => v,
                        ToSqlOutput::Owned(ref v) => ValueRef::from( v ),
                        ToSqlOutput::ZeroBlob(len) =>
                        {
                            return self
                            .conn
                            .decode_result( connect::ffi::sqlite3_bind_zeroblob( ptr, ndx as c_int, len ) );
                        }
                        
                        ToSqlOutput::Arg(_) =>
                        { return Err(err!( connect::ffi::SQLITE_MISUSE, "Unsupported value \"{value:?}\"")); }
                        
                        ToSqlOutput::Array(a) =>
                        {
                            return self.conn.decode_result( connect::ffi::sqlite3_bind_pointer
                            (
                                ptr,
                                ndx as c_int,
                                Rc::into_raw(a) as *mut c_void,
                                ARRAY_TYPE,
                                Some(free_array),
                            ));
                        }
                    };

                    self.conn.decode_result(match value
                    {
                        ValueRef::Null => connect::ffi::sqlite3_bind_null( ptr, ndx as c_int ),
                        ValueRef::Integer(i) => connect::ffi::sqlite3_bind_int64(ptr, ndx as c_int, i),
                        ValueRef::Real(r) => connect::ffi::sqlite3_bind_double(ptr, ndx as c_int, r),
                        ValueRef::Text(s) =>
                        {
                            let (c_str, len, destructor) = str_for_sqlite(s)?;
                            connect::ffi::sqlite3_bind_text(ptr, ndx as c_int, c_str, len, destructor)
                        },

                        ValueRef::Blob(b) =>
                        {
                            let length = len_as_c_int(b.len())?;
                            if length == 0 { connect::ffi::sqlite3_bind_zeroblob(ptr, ndx as c_int, 0) }
                            
                            else
                            {
                                connect::ffi::sqlite3_bind_blob
                                (
                                    ptr,
                                    ndx as c_int,
                                    b.as_ptr().cast::<c_void>(),
                                    length,
                                    connect::ffi::SQLITE_TRANSIENT(),
                                )
                            }
                        },
                    })
                }
            }

            #[inline] fn execute_with_bound_parameters(&mut self) -> Result<usize>
            {
                self.check_update()?;
                let r = self.stmt.step();
                let rr = self.stmt.reset();
                match r
                {
                    connect::ffi::SQLITE_DONE => match rr
                    {
                        connect::ffi::SQLITE_OK => Ok(self.conn.changes() as usize),
                        _ => Err(self.conn.decode_result(rr).unwrap_err()),
                    },
                    connect::ffi::SQLITE_ROW => Err(Error::ExecuteReturnedResults),
                    _ => Err(self.conn.decode_result(r).unwrap_err()),
                }
            }

            #[inline] fn finalize_(&mut self) -> Result<()>
            {
                unsafe
                {
                    let mut stmt = RawStatement::new( null_mut(), 0 );
                    swap(&mut stmt, &mut self.stmt);
                    self.conn.decode_result(stmt.finalize())
                }
            }
            
            #[inline] fn check_update(&self) -> Result<()>
            {
                if self.column_count() > 0 && self.stmt.readonly() { return Err(Error::ExecuteReturnedResults); }
                Ok(())
            }
            
            #[inline] fn check_update(&self) -> Result<()> { Ok(()) }
            /// Returns a string containing the SQL text of prepared statement with bound parameters expanded.
            pub fn expanded_sql(&self) -> Option<String>
            {
                self.stmt
                .expanded_sql()
                .map(|s| s.to_string_lossy().to_string())
            }
            /// Get the value for one of the status counters for this statement.
            #[inline]
            pub fn get_status(&self, status: StatementStatus) -> i32 { self.stmt.get_status(status, false) }
            /// Reset the value of one of the status counters for this statement,
            #[inline]
            /// returning the value it had before resetting.
            pub fn reset_status(&self, status: StatementStatus) -> i32 { self.stmt.get_status(status, true) }
            /// Returns 1 if the prepared statement is an EXPLAIN statement,
            /// or 2 if the statement is an EXPLAIN QUERY PLAN,
            /// or 0 if it is an ordinary statement or a NULL pointer.
            #[inline] pub fn is_explain(&self) -> i32 { self.stmt.is_explain() }
            /// Returns true if the statement is read only.
            #[inline] pub fn readonly(&self) -> bool { self.stmt.readonly() }
            
            #[inline] pub(crate) fn check_no_tail(&self) -> Result<()>
            {
                if self.stmt.has_tail() { Err(Error::MultipleStatement) } 
                else { Ok(()) }
            }
            
            #[inline] pub(crate) unsafe fn into_raw(mut self) -> RawStatement
            {
                let mut stmt = RawStatement::new( null_mut(), 0);
                swap(&mut stmt, &mut self.stmt);
                stmt
            }

            /// Reset all bindings
            pub fn clear_bindings(&mut self) { self.stmt.clear_bindings(); }

            pub(crate) unsafe fn ptr(&self) -> *mut connect::ffi::sqlite3_stmt { self.stmt.ptr() }
        }

        impl fmt::Debug for Statement<'_>
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
            {
                let sql = if self.stmt.is_null() { Ok("") } 
                else { self.stmt.sql().unwrap().to_str() };
                f.debug_struct("Statement")
                .field("conn", self.conn)
                .field("stmt", &self.stmt)
                .field("sql", &sql)
                .finish()
            }
        }

        impl Drop for Statement<'_>
        {
            #[expect(unused_must_use)]
            #[inline] fn drop(&mut self) { self.finalize_(); }
        }

        impl Statement<'_>
        {
            #[inline] pub fn new(conn: &Connection, stmt: RawStatement) -> Statement<'_>
            {
                Statement { conn, stmt }
            }

            pub fn value_ref(&self, col: usize) -> ValueRef<'_>
            {
                unsafe
                {
                    let raw = self.stmt.ptr();

                    match self.stmt.column_type(col)
                    {
                        connect::ffi::SQLITE_NULL => ValueRef::Null,
                        connect::ffi::SQLITE_INTEGER => 
                        { ValueRef::Integer( connect::ffi::sqlite3_column_int64(raw, col as c_int) ) }
                        
                        connect::ffi::SQLITE_FLOAT => 
                        { ValueRef::Real( connect::ffi::sqlite3_column_double(raw, col as c_int) ) }

                        connect::ffi::SQLITE_TEXT =>
                        {
                            let s =
                            {
                                let text = connect::ffi::sqlite3_column_text(raw, col as c_int);
                                let len = connect::ffi::sqlite3_column_bytes(raw, col as c_int);
                                assert!( !text.is_null(), "unexpected SQLITE_TEXT column type with NULL data" );
                                from_raw_parts(text.cast::<u8>(), len as usize)
                            };

                            ValueRef::Text(s)
                        }

                        connect::ffi::SQLITE_BLOB => 
                        {
                            let (blob, len) = 
                            (
                                connect::ffi::sqlite3_column_blob(raw, col as c_int),
                                connect::ffi::sqlite3_column_bytes(raw, col as c_int),
                            );

                            assert!( len >= 0, "unexpected negative return from sqlite3_column_bytes" );

                            if len > 0
                            {
                                assert!( !blob.is_null(), "unexpected SQLITE_BLOB column type with NULL data" );
                                ValueRef::Blob(unsafe { from_raw_parts(blob.cast::<u8>(), len as usize) })
                            }
                            else { ValueRef::Blob(&[]) }
                        }
                        _ => unreachable!("sqlite3_column_type returned invalid value"),
                    }
                }
            }

            #[inline] pub fn step(&self) -> Result<bool> 
            {
                match self.stmt.step() 
                {
                    connect::ffi::SQLITE_ROW => Ok(true),
                    connect::ffi::SQLITE_DONE => Ok(false),
                    code => Err(self.conn.decode_result(code).unwrap_err()),
                }
            }

            #[inline] pub fn reset(&self) -> Result<()>
            {
                match self.stmt.reset()
                {
                    connect::ffi::SQLITE_OK => Ok(()),
                    code => Err(self.conn.decode_result(code).unwrap_err()),
                }
            }
        }
        /// Prepared statement status counters.
        #[repr(i32)] #[derive(Clone, Copy, PartialEq, Eq)] #[non_exhaustive]
        pub enum StatementStatus
        {
            /// Equivalent to `SQLITE_STMTSTATUS_FULLSCAN_STEP`
            FullscanStep = 1,
            /// Equivalent to `SQLITE_STMTSTATUS_SORT`
            Sort = 2,
            /// Equivalent to `SQLITE_STMTSTATUS_AUTOINDEX`
            AutoIndex = 3,
            /// Equivalent to `SQLITE_STMTSTATUS_VM_STEP`
            VmStep = 4,
            /// Equivalent to `SQLITE_STMTSTATUS_REPREPARE` (3.20.0)
            RePrepare = 5,
            /// Equivalent to `SQLITE_STMTSTATUS_RUN` (3.20.0)
            Run = 6,
            /// Equivalent to `SQLITE_STMTSTATUS_FILTER_MISS`
            FilterMiss = 7,
            /// Equivalent to `SQLITE_STMTSTATUS_FILTER_HIT`
            FilterHit = 8,
            /// Equivalent to `SQLITE_STMTSTATUS_MEMUSED` (3.20.0)
            MemUsed = 99,
        }
    }

    pub mod trace
    {
        //! Tracing and profiling functions. Error and warning log.
        use ::
        {
            connect::{ self, Connection, DatabaseName, StatementStatus },
            borrow::{ Cow },
            ffi::{ c_char, c_int, c_uint, c_void, CStr, CString },
            marker::{ PhantomData },
            mem::{ transmute },
            panic::{ catch_unwind },
            ptr::{ null_mut },
            time::{ Duration },
            *,
        };
        /// Set up the process-wide SQLite error logging callback.
        pub unsafe fn config_log(callback: Option<fn(c_int, &str)>) -> connect::Result<()>
        {
            extern "C" fn log_callback(p_arg: *mut c_void, err: c_int, msg: *const c_char)
            {
                let s = unsafe { CStr::from_ptr(msg).to_string_lossy() };
                let callback: fn(c_int, &str) = transmute( p_arg );
                drop( catch_unwind(|| callback(err, &s)) );
            }

            let rc = if let Some(f) = callback
            {
                connect::ffi::sqlite3_config
                ( connect::ffi::SQLITE_CONFIG_LOG, log_callback as extern "C" fn(_, _, _), f as *mut c_void )
            }
            
            else
            {
                let nullptr: *mut c_void = null_mut();
                connect::ffi::sqlite3_config( connect::ffi::SQLITE_CONFIG_LOG, nullptr, nullptr )
            };

            if rc == connect::ffi::SQLITE_OK { Ok(()) } 
            else { Err( connect::error::error_from_sqlite_code( rc, None )) }
        }
        /// Write a message into the error log established by `config_log`.
        #[inline] pub fn log(err_code: c_int, msg: &str)
        {
            unsafe
            {
                let msg = CString::new(msg).expect("SQLite log messages cannot contain embedded zeroes");
                connect::ffi::sqlite3_log(err_code, b"%s\0" as *const _ as *const c_char, msg.as_ptr());
            }
        }

        bitflags::bitflags!
        {
            /// Trace event codes
            #[derive(Clone, Copy, Debug, Eq, PartialEq)]
            #[non_exhaustive]
            #[repr(C)]
            pub struct TraceEventCodes: c_uint
            {
                /// When a prepared statement first begins running and possibly at other times during the execution 
                /// of the prepared statement, such as at the start of each trigger subprogram
                const SQLITE_TRACE_STMT = ffi::SQLITE_TRACE_STMT;
                /// when the statement finishes
                const SQLITE_TRACE_PROFILE = ffi::SQLITE_TRACE_PROFILE;
                /// whenever a prepared statement generates a single row of result
                const SQLITE_TRACE_ROW = ffi::SQLITE_TRACE_ROW;
                /// when a database connection closes
                const SQLITE_TRACE_CLOSE = ffi::SQLITE_TRACE_CLOSE;
            }
        }
        /// Trace event
        #[non_exhaustive]
        pub enum TraceEvent<'s>
        {
            /// when a prepared statement first begins running and possibly at other times during the execution
            /// of the prepared statement, such as at the start of each trigger subprogram
            Stmt(StmtRef<'s>, &'s str),
            /// when the statement finishes
            Profile(StmtRef<'s>, Duration),
            /// whenever a prepared statement generates a single row of result
            Row(StmtRef<'s>),
            /// when a database connection closes
            Close(ConnRef<'s>),
        }
        /// Statement reference
        pub struct StmtRef<'s>
        {
            ptr: *mut connect::ffi::sqlite3_stmt,
            phantom: PhantomData<&'s ()>,
        }

        impl StmtRef<'_>
        {
            fn new(ptr: *mut connect::ffi::sqlite3_stmt) -> Self
            {
                StmtRef
                {
                    ptr,
                    phantom: PhantomData,
                }
            }
            /// SQL text
            pub fn sql(&self) -> Cow<'_, str> 
            { unsafe { CStr::from_ptr( connect::ffi::sqlite3_sql(self.ptr)).to_string_lossy() } }
            /// Expanded SQL text
            pub fn expanded_sql(&self) -> Option<String> 
            { unsafe { connect::raw::expanded_sql(self.ptr).map(|s| s.to_string_lossy().to_string()) } }
            /// Get the value for one of the status counters for this statement.
            pub fn get_status(&self, status: StatementStatus) -> i32 
            { unsafe { connect::raw::stmt_status(self.ptr, status, false) } }
        }
        /// Connection reference
        pub struct ConnRef<'s>
        {
            ptr: *mut connect::ffi::sqlite3,
            phantom: PhantomData<&'s ()>,
        }

        impl ConnRef<'_>
        {
            /// Test for auto-commit mode.
            pub fn is_autocommit(&self) -> bool { unsafe { connect::inner::get_autocommit(self.ptr) } }
            /// the path to the database file, if one exists and is known.
            pub fn db_filename(&self) -> Option<&str> 
            { unsafe { connect::inner::db_filename(self.ptr, DatabaseName::Main) } }
        }

        impl Connection
        {
            /// Register or clear a callback function that can be used for tracing the execution of SQL statements.
            pub fn trace( &mut self, trace_fn:Option<fn(&str)> )
            {
                unsafe
                {
                    
                    unsafe extern "C" fn trace_callback(p_arg: *mut c_void, z_sql: *const c_char)
                    {
                        let trace_fn: fn(&str) = transmute(p_arg);
                        let s = CStr::from_ptr(z_sql).to_string_lossy();
                        drop(catch_unwind(|| trace_fn(&s)));
                    }

                    let c = self.db.borrow_mut();
                    match trace_fn
                    {
                        Some(f) => unsafe { connect::ffi::sqlite3_trace(c.db(), Some(trace_callback), f as *mut c_void); },
                        None => unsafe { connect::ffi::sqlite3_trace(c.db(), None, ptr::null_mut()); },
                    }
                }
            }
            /// Register or clear a callback function that can be used for profiling the execution of SQL statements.
            pub fn profile( &mut self, profile_fn:Option<fn(&str, Duration)> )
            {
                unsafe extern "C" fn profile_callback( p_arg: *mut c_void, z_sql: *const c_char, nanoseconds: u64 )
                {
                    let profile_fn: fn(&str, Duration) = transmute(p_arg);
                    let s = CStr::from_ptr(z_sql).to_string_lossy();
                    let duration = Duration::from_nanos(nanoseconds);
                    drop(catch_unwind(|| profile_fn(&s, duration)));
                }

                let c = self.db.borrow_mut();
                match profile_fn 
                {
                    Some(f) => unsafe { connect::ffi::sqlite3_profile(c.db(), Some(profile_callback), f as *mut c_void) },
                    None => unsafe { connect::ffi::sqlite3_profile(c.db(), None, null_mut()) },
                };
            }
            /// Register or clear a trace callback function
            pub fn trace_v2( &self, mask:TraceEventCodes, trace_fn:Option<fn(TraceEvent<'_>)> )
            {
                unsafe 
                {
                    unsafe extern "C" fn trace_callback( evt:c_uint, ctx:*mut c_void, p:*mut c_void, x:*mut c_void ) -> c_int
                    {
                        let trace_fn: fn(TraceEvent<'_>) = transmute(ctx);
                        drop(catch_unwind(|| match evt
                        {
                            connect::ffi::SQLITE_TRACE_STMT => 
                            {
                                let str = CStr::from_ptr(x as *const c_char).to_string_lossy();
                                trace_fn(TraceEvent::Stmt
                                (
                                    StmtRef::new(p as *mut connect::ffi::sqlite3_stmt),
                                    &str,
                                ))
                            }
                            connect::ffi::SQLITE_TRACE_PROFILE => 
                            {
                                let ns = *(x as *const i64);
                                trace_fn(TraceEvent::Profile
                                (
                                    StmtRef::new(p as *mut connect::ffi::sqlite3_stmt),
                                    Duration::from_nanos(u64::try_from(ns).unwrap_or_default()),
                                ))
                            }
                            connect::ffi::SQLITE_TRACE_ROW => 
                            { trace_fn(TraceEvent::Row(StmtRef::new(p as *mut connect::ffi::sqlite3_stmt))) }

                            connect::ffi::SQLITE_TRACE_CLOSE => trace_fn(TraceEvent::Close(ConnRef 
                            {
                                ptr: p as *mut connect::ffi::sqlite3,
                                phantom: PhantomData,
                            })),
                            _ => {}
                        }));
                        
                        connect::ffi::SQLITE_OK
                    }

                    let c = self.db.borrow_mut();
                    if let Some(f) = trace_fn { connect::ffi::sqlite3_trace_v2(c.db(), mask.bits(), Some(trace_callback), f as *mut c_void); } 
                    else { connect::ffi::sqlite3_trace_v2(c.db(), 0, None, null_mut()); }
                }
            }
        }
    }

    pub mod transaction
    {
        use ::
        {
            connect::{ Connection, Result },
            ops::{ Deref },
            *,
        };
        /// Options for transaction behavior.
        #[derive(Copy, Clone)] #[non_exhaustive]
        pub enum TransactionBehavior
        {
            /// DEFERRED means that the transaction does not actually start until the database is first accessed.
            Deferred,
            /// IMMEDIATE cause the database connection to start a new write immediately, without waiting for a writes statement.
            Immediate,
            /// EXCLUSIVE prevents other database connections from reading the database while the transaction is underway.
            Exclusive,
        }
        /// Options for how a Transaction or Savepoint should behave when it is dropped.
        #[derive(Copy, Clone, Debug, PartialEq, Eq)] #[non_exhaustive]
        pub enum DropBehavior
        {
            /// Roll back the changes. This is the default.
            Rollback,
            /// Commit the changes.
            Commit,
            /// Do not commit or roll back changes; should be used with care.
            Ignore,
            /// Panic. Used to enforce intentional behavior during development.
            Panic,
        }
        /// Represents a transaction on a database connection.
        #[derive(Debug)] 
        pub struct Transaction<'conn>
        {
            conn: &'conn Connection,
            drop_behavior: DropBehavior,
        }
        /// Represents a savepoint on a database connection.
        #[derive(Debug)]
        pub struct Savepoint<'conn>
        {
            conn: &'conn Connection,
            name: String,
            drop_behavior: DropBehavior,
            committed: bool,
        }

        impl Transaction<'_>
        {
            /// Begin a new transaction. Cannot be nested; see `savepoint` for nested transactions.
            #[inline] pub fn new(conn: &mut Connection, behavior: TransactionBehavior) -> Result<Transaction<'_>>
            { Self::new_unchecked(conn, behavior) }
            /// Begin a new transaction, failing if a transaction is open.
            #[inline]
            pub fn new_unchecked( conn: &Connection, behavior: TransactionBehavior ) -> Result<Transaction<'_>>
            {
                let query = match behavior
                {
                    TransactionBehavior::Deferred => "BEGIN DEFERRED",
                    TransactionBehavior::Immediate => "BEGIN IMMEDIATE",
                    TransactionBehavior::Exclusive => "BEGIN EXCLUSIVE",
                };
                
                conn.execute_batch(query).map(move |()| Transaction
                {
                    conn,
                    drop_behavior: DropBehavior::Rollback,
                })
            }
            /// Starts a new savepoint, allowing nested transactions.
            #[inline] pub fn savepoint(&mut self) -> Result<Savepoint<'_>> { Savepoint::new_(self.conn) }
            /// Create a new savepoint with a custom savepoint name. See `savepoint()`.
            #[inline] pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>>
            { Savepoint::with_name_(self.conn, name) }
            /// Get the current setting for what happens to the transaction when it is dropped.
            #[inline] #[must_use] pub fn drop_behavior(&self) -> DropBehavior { self.drop_behavior }
            /// Configure the transaction to perform the specified action when it is dropped.
            #[inline] pub fn set_drop_behavior(&mut self, drop_behavior: DropBehavior)
            { self.drop_behavior = drop_behavior; }
            /// A convenience method which consumes and commits a transaction.
            #[inline] pub fn commit(mut self) -> Result<()> { self.commit_() }

            #[inline] fn commit_(&mut self) -> Result<()>
            {
                self.conn.execute_batch("COMMIT")?;
                Ok(())
            }
            /// A convenience method which consumes and rolls back a transaction.
            #[inline] pub fn rollback(mut self) -> Result<()>{ self.rollback_() }

            #[inline] fn rollback_(&mut self) -> Result<()>
            {
                self.conn.execute_batch("ROLLBACK")?;
                Ok(())
            }
            /// Consumes the transaction, committing or rolling back according to the current setting (see `drop_behavior`).
            #[inline] pub fn finish(mut self) -> Result<()> { self.finish_() }

            #[inline] fn finish_(&mut self) -> Result<()>
            {
                if self.conn.is_autocommit() { return Ok(()); }

                match self.drop_behavior()
                {
                    DropBehavior::Commit => self.commit_().or_else(|_| self.rollback_()),
                    DropBehavior::Rollback => self.rollback_(),
                    DropBehavior::Ignore => Ok(()),
                    DropBehavior::Panic => panic!("Transaction dropped unexpectedly."),
                }
            }
        }

        impl Deref for Transaction<'_>
        {
            type Target = Connection;
            #[inline] fn deref(&self) -> &Connection { self.conn }
        }

        #[expect(unused_must_use)]
        impl Drop for Transaction<'_>
        {
            #[inline] fn drop(&mut self) { self.finish_(); }
        }

        impl Savepoint<'_>
        {
            #[inline] fn with_name_<T: Into<String>>(conn: &Connection, name: T) -> Result<Savepoint<'_>>
            {
                let name = name.into();
                conn.execute_batch(&format!("SAVEPOINT {name}"))
                    .map(|()| Savepoint
                    {
                        conn,
                        name,
                        drop_behavior: DropBehavior::Rollback,
                        committed: false,
                    })
            }

            #[inline] fn new_(conn: &Connection) -> Result<Savepoint<'_>> { Savepoint::with_name_(conn, "_rusqlite_sp") }
            /// Begin a new savepoint. Can be nested.
            #[inline] pub fn new(conn: &mut Connection) -> Result<Savepoint<'_>> { Savepoint::new_(conn) }
            /// Begin a new savepoint with a user-provided savepoint name.
            #[inline] pub fn with_name<T: Into<String>>(conn: &mut Connection, name: T) -> Result<Savepoint<'_>>
            { Savepoint::with_name_(conn, name) }
            /// Begin a nested savepoint.
            #[inline] pub fn savepoint(&mut self) -> Result<Savepoint<'_>> { Savepoint::new_(self.conn) }
            /// Begin a nested savepoint with a user-provided savepoint name.
            #[inline] pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>>
            { Savepoint::with_name_(self.conn, name) }
            /// Get the current setting for what happens to the savepoint when it is dropped.
            #[inline] #[must_use] pub fn drop_behavior(&self) -> DropBehavior { self.drop_behavior }
            /// Configure the savepoint to perform the specified action when it is dropped.
            #[inline] pub fn set_drop_behavior(&mut self, drop_behavior: DropBehavior)
            { self.drop_behavior = drop_behavior; }
            /// A convenience method which consumes and commits a savepoint.
            #[inline] pub fn commit(mut self) -> Result<()> { self.commit_() }

            #[inline] fn commit_(&mut self) -> Result<()>
            {
                self.conn.execute_batch(&format!("RELEASE {}", self.name))?;
                self.committed = true;
                Ok(())
            }

            /// A convenience method which rolls back a savepoint.
            #[inline] pub fn rollback(&mut self) -> Result<()>
            { self.conn.execute_batch(&format!("ROLLBACK TO {}", self.name)) }
            /// Consumes the savepoint, committing or rolling back according to the current setting.
            #[inline] pub fn finish(mut self) -> Result<()> { self.finish_() }

            #[inline] fn finish_(&mut self) -> Result<()>
            {
                if self.committed { return Ok(()); }

                match self.drop_behavior()
                {
                    DropBehavior::Commit => self
                    .commit_()
                    .or_else(|_| self.rollback().and_then(|()| self.commit_())),
                    DropBehavior::Rollback => self.rollback().and_then(|()| self.commit_()),
                    DropBehavior::Ignore => Ok(()),
                    DropBehavior::Panic => panic!("Savepoint dropped unexpectedly."),
                }
            }
        }

        impl Deref for Savepoint<'_>
        {
            type Target = Connection;
            #[inline] fn deref(&self) -> &Connection { self.conn }
        }

        #[expect(unused_must_use)]
        impl Drop for Savepoint<'_>
        {
            #[inline] fn drop(&mut self) { self.finish_(); }
        }
        /// Transaction state of a database
        #[derive(Clone, Copy, Debug, PartialEq, Eq)] #[non_exhaustive]
        pub enum TransactionState
        {
            /// Equivalent to `SQLITE_TXN_NONE`
            None,
            /// Equivalent to `SQLITE_TXN_READ`
            Read,
            /// Equivalent to `SQLITE_TXN_WRITE`
            Write,
        }

        impl Connection
        {
            /// Begin a new transaction with the default behavior.
            #[inline]
            pub fn transaction(&mut self) -> Result<Transaction<'_>> { Transaction::new(self, self.transaction_behavior) }

            /// Begin a new transaction with a specified behavior.
            #[inline] pub fn transaction_with_behavior( &mut self, behavior:TransactionBehavior ) -> Result<Transaction<'_>>
            { Transaction::new(self, behavior) }
            /// Begin a new transaction with the default behavior.
            pub fn unchecked_transaction(&self) -> Result<Transaction<'_>>
            { Transaction::new_unchecked(self, self.transaction_behavior) }
            /// Begin a new savepoint with the default behavior.
            #[inline] pub fn savepoint(&mut self) -> Result<Savepoint<'_>>
            { Savepoint::new(self) }
            /// Begin a new savepoint with a specified name.
            #[inline] pub fn savepoint_with_name<T: Into<String>>(&mut self, name: T) -> Result<Savepoint<'_>>
            { Savepoint::with_name(self, name) }
            /// Determine the transaction state of a database
            pub fn transaction_state( &self, db_name: Option<crate::DatabaseName<'_>> ) -> Result<TransactionState>
            { self.db.borrow().txn_state(db_name) }
            /// Set the default transaction behavior for the connection.
            pub fn set_transaction_behavior(&mut self, behavior: TransactionBehavior) 
            { self.transaction_behavior = behavior; }
        }
    }

    pub mod types
    {
        use ::
        {
            borrow::{ Cow },
            connect::
            {  
                vtab::array::{ Array },
                Error, Null, Result, Value, ValueRef,
            },
            rc::{ Rc },
            sync::{ Arc },
            *,
        };

        macro_rules! from_value
        (
            ($t:ty) =>
            (
                impl From<$t> for ToSqlOutput<'_>
                {
                    #[inline] fn from(t: $t) -> Self { ToSqlOutput::Owned(t.into())}
                }
            );

            (non_zero $t:ty) =>
            (
                impl From<$t> for ToSqlOutput<'_>
                {
                    #[inline] fn from(t: $t) -> Self { ToSqlOutput::Owned(t.get().into())}
                }
            )
        );
        
        macro_rules! to_sql_self
        (
            ($t:ty) =>
            (
                impl ToSql for $t
                {
                    #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { Ok(ToSqlOutput::from(*self)) }
                }
            )
        );

        macro_rules! to_sql_self_fallible
        (
            ($t:ty) =>
            (
                impl ToSql for $t
                {
                    #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>>
                    {
                        Ok(ToSqlOutput::Owned(Value::Integer
                        (
                            i64::try_from( *self ).map_err( | err | Error::ToSqlConversionFailure( err.into() ) )?
                        )))
                    }
                }
            );

            (non_zero $t:ty) =>
            (
                impl ToSql for $t
                {
                    #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>>
                    {
                        Ok(ToSqlOutput::Owned(Value::Integer(
                            i64::try_from(self.get()).map_err( | err | Error::ToSqlConversionFailure( err.into() ) )?
                        )))
                    }
                }
            )
        );
        /// A non-owning SQLite dynamic type value.
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub enum ValueRef<'a>
        {
            /// The value is a `NULL` value.
            Null,
            /// The value is a signed integer.
            Integer(i64),
            /// The value is a floating point number.
            Real(f64),
            /// The value is a text string.
            Text(&'a [u8]),
            /// The value is a blob of data
            Blob(&'a [u8]),
        }

        impl ValueRef<'_> {}
        /// `ToSqlOutput` represents the possible output types for implementers of the [`ToSql`] trait.
        #[derive(Clone, Debug, PartialEq)] #[non_exhaustive]
        pub enum ToSqlOutput<'a>
        {
            /// A borrowed SQLite-representable value.
            Borrowed(ValueRef<'a>),
            /// An owned SQLite-representable value.
            Owned(Value),
            /// A BLOB of the given length that is filled with zeroes.
            ZeroBlob(i32),
            /// n-th arg of an SQL scalar function.
            Arg(usize),
            Array(Array),
        }
        
        impl<'a, T: ?Sized> From<&'a T> for ToSqlOutput<'a> where
        &'a T: Into<ValueRef<'a>>,
        {
            #[inline] fn from(t: &'a T) -> Self { ToSqlOutput::Borrowed(t.into()) }
        }

        from_value!(String);
        from_value!(Null);
        from_value!(bool);
        from_value!(i8);
        from_value!(i16);
        from_value!(i32);
        from_value!(i64);
        from_value!(isize);
        from_value!(u8);
        from_value!(u16);
        from_value!(u32);
        from_value!(f32);
        from_value!(f64);
        from_value!(Vec<u8>);

        from_value!(non_zero std::num::NonZeroI8);
        from_value!(non_zero std::num::NonZeroI16);
        from_value!(non_zero std::num::NonZeroI32);
        from_value!(non_zero std::num::NonZeroI64);
        from_value!(non_zero std::num::NonZeroIsize);
        from_value!(non_zero std::num::NonZeroU8);
        from_value!(non_zero std::num::NonZeroU16);
        from_value!(non_zero std::num::NonZeroU32);
        from_value!(i128);
        from_value!(non_zero std::num::NonZeroI128);
        from_value!(uuid::Uuid);

        impl ToSql for ToSqlOutput<'_>
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>>
            {
                Ok(match *self
                {
                    ToSqlOutput::Borrowed(v) => ToSqlOutput::Borrowed(v),
                    ToSqlOutput::Owned(ref v) => ToSqlOutput::Borrowed(ValueRef::from(v)),
                    ToSqlOutput::ZeroBlob(i) => ToSqlOutput::ZeroBlob(i),
                    ToSqlOutput::Arg(i) => ToSqlOutput::Arg(i),
                    ToSqlOutput::Array(ref a) => ToSqlOutput::Array(a.clone()),
                })
            }
        }
        /// A trait for types that can be converted into SQLite values.if the conversion fails.
        pub trait ToSql
        {
            /// Converts Rust value to SQLite value
            fn to_sql(&self) -> Result<ToSqlOutput<'_>>;
        }

        impl<T: ToSql + ToOwned + ?Sized> ToSql for Cow<'_, T>
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { self.as_ref().to_sql() }
        }

        impl<T: ToSql + ?Sized> ToSql for Box<T>
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { self.as_ref().to_sql() }
        }

        impl<T: ToSql + ?Sized> ToSql for Rc<T>
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { self.as_ref().to_sql() }
        }

        impl<T: ToSql + ?Sized> ToSql for Arc<T>
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { self.as_ref().to_sql() }
        }

        to_sql_self!(Null);
        to_sql_self!(bool);
        to_sql_self!(i8);
        to_sql_self!(i16);
        to_sql_self!(i32);
        to_sql_self!(i64);
        to_sql_self!(isize);
        to_sql_self!(u8);
        to_sql_self!(u16);
        to_sql_self!(u32);
        to_sql_self!(f32);
        to_sql_self!(f64);

        to_sql_self!(std::num::NonZeroI8);
        to_sql_self!(std::num::NonZeroI16);
        to_sql_self!(std::num::NonZeroI32);
        to_sql_self!(std::num::NonZeroI64);
        to_sql_self!(std::num::NonZeroIsize);
        to_sql_self!(std::num::NonZeroU8);
        to_sql_self!(std::num::NonZeroU16);
        to_sql_self!(std::num::NonZeroU32);
        
        to_sql_self!(i128);
        to_sql_self!(std::num::NonZeroI128);
        to_sql_self!(uuid::Uuid);
        
        to_sql_self_fallible!(u64);
        to_sql_self_fallible!(usize);
        to_sql_self_fallible!(non_zero std::num::NonZeroU64);
        to_sql_self_fallible!(non_zero std::num::NonZeroUsize);

        impl<T: ?Sized> ToSql for &'_ T where
        T:ToSql
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { (*self).to_sql() }
        }

        impl ToSql for String
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { Ok(ToSqlOutput::from(self.as_str())) }
        }

        impl ToSql for str
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { Ok(ToSqlOutput::from(self)) }
        }

        impl ToSql for Vec<u8>
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { Ok(ToSqlOutput::from(self.as_slice())) }
        }

        impl<const N: usize> ToSql for [u8; N]
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { Ok(ToSqlOutput::from(&self[..])) }
        }

        impl ToSql for [u8]
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { Ok(ToSqlOutput::from(self)) }
        }

        impl ToSql for Value
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>> { Ok(ToSqlOutput::from(self)) }
        }

        impl<T: ToSql> ToSql for Option<T>
        {
            #[inline] fn to_sql(&self) -> Result<ToSqlOutput<'_>>
            {
                match *self
                {
                    None => Ok(ToSqlOutput::from(Null)),
                    Some(ref t) => t.to_sql(),
                }
            }
        }
    }

    pub mod version
    {
        use ::
        {
            connect::{ self },
            *,
        };
        /// Returns the SQLite version as an integer; e.g., `3016002` for version 3.16.2.
        #[inline] #[must_use]
        pub fn version_number() -> i32
        {
            unsafe { connect::ffi::sqlite3_libversion_number() }
        }
        /// Returns the SQLite version as a string; e.g., `"3.16.2"` for version 3.16.2.
        #[inline] #[must_use]
        pub fn version() -> &'static str
        {
            unsafe
            { 
                let cstr = CStr::from_ptr( connect::ffi::sqlite3_libversion());
                cstr.to_str().expect("SQLite version string is not valid UTF8 ?!")
            };
        }
    }

    pub mod vtab
    {

    }
    /// A connection to a SQLite database.
    pub struct Connection
    {
        db: RefCell<InnerConnection>,
        cache: StatementCache,
        transaction_behavior: TransactionBehavior,
    }   

    impl Connection
    {
        /// Prepare a SQL statement for execution, returning a previously prepared statement if one is available.
        #[inline] pub fn prepare_cached(&self, sql: &str) -> Result<CachedStatement<'_>> { self.cache.get(self, sql) }

        /// Set the maximum number of cached prepared statements this connection will hold.
        #[inline] pub fn set_prepared_statement_cache_capacity(&self, capacity: usize) { self.cache.set_capacity(capacity); }

        /// Remove/finalize all prepared statements currently in the cache.
        #[inline] pub fn flush_prepared_statement_cache(&self) { self.cache.flush(); }
    }
}
pub mod f32 { pub use std::f32::{ * }; }
pub mod f64 { pub use std::f64::{ * }; }
pub mod ffi { pub use std::ffi::{ * }; }
pub mod fmt { pub use std::fmt::{ * }; }
pub mod fs
{
    pub use std::fs::{ * };
    /**/
    pub fn create_raw_fd_from_file( file_name:&str, append:bool ) -> Result<i32, String>
    {
        let mut oos = OpenOptions::new();
        if append { oos.append( true ); }
        else
        {
            oos.write( true );
            oos.truncate( true );
        }
        match oos.create( true ).open( file_name )
        {
            Ok( x ) =>
            {
                let fd = x.into_raw_fd();
                Ok( fd )
            }

            Err( e ) => Err( format!( "{}", e ) ),
        }
    }
    /**/
    pub fn close( fd:i32 )
    { unsafe { libc::close( fd ); } }
    /**/
    pub fn dup( fd:i32 ) -> i32
    { unsafe { libc::dup( fd ) } }
    /**/
    pub fn dup2( src:i32, dst:i32 )
    { unsafe { libc::dup2( src, dst ); } }
}
pub mod futures { pub use std::future::{ * }; }
/*
State Reading */
pub mod get
{
    use ::
    {
        error::{ no },
        libc::{ c_int, c_ulong, STDERR_FILENO, STDIN_FILENO, STDOUT_FILENO,  winsize },
        os::
        {
            fd::{ RawFd },
        },
        parsers::{ self },
        path::{ Path, PathBuf },
        types::{ CommandLine, Redirection },
        *
    };
    
    #[cfg( any( target_os = "linux", target_os = "android" ) )]
    static TIOCGWINSZ:c_ulong = 0x5413;

    #[cfg
    ( 
        any
        ( 
            target_os = "macos",
            target_os = "ios",
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "netbsd",
            target_os = "openbsd"
 )
 )]
    static TIOCGWINSZ:c_ulong = 0x40087468;

    #[cfg( target_os = "solaris" )]
    static TIOCGWINSZ:c_ulong = 0x5468;

    extern "C"
    {
        fn gethostname( name:*mut libc::c_char, size:libc::size_t ) -> libc::c_int;
        fn ioctl( fd:c_int, request:c_ulong, ... ) -> libc::c_int;
    }
    /*
    get_user_home( ... ) -> String */
    pub fn user_home() -> String
    {
        match env::var( "HOME" )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println_stderr!( "pls:env HOME error:{}", e );
                String::new()
            }
        }
    }
    /*
    get_config_dir( ... ) -> String */
    pub fn configuration_directory() -> String
    {
        if let Ok( x ) = env::var( "XDG_CONFIG_HOME" ) { format!( "{}/pls", x ) }
        else
        {
            let home = user_home();
            format!( "{}/.config/pls", home )
        }
    }
    /*
    get_user_completer_dir( ... ) -> String */
    pub fn user_completer_directory() -> String
    {
        let dir_config = ::get::configuration_directory();
        format!( "{}/completers", dir_config )
    }
    /*
    get_fd_from_file( ... ) -> i32 */
    pub fn descriptor_from_file( file_name:&str ) -> i32
    {
        let path = path::Path::new( file_name );
        let display = path.display();
        let file = match fs::File::open( path )
        {
            Err( why ) =>
            {
                println_stderr!( "pls:{}:{}", display, why );
                return -1;
            }

            Ok( file ) => file,
        };

        file.into_raw_fd()
    }
    /*
    get_current_dir( ... ) -> String */
    pub fn current_directory() -> String
    {
        let mut current_dir = path::PathBuf::new();
        match env::current_dir()
        {
            Ok( x ) => current_dir = x,
            Err( e ) =>
            {
                println_stderr!( "env current_dir() failed:{}", e );
            }
        }

        let mut str_current_dir = "";
        match current_dir.to_str()
        {
            Some( x ) => str_current_dir = x,
            None => { println_stderr!( "current_dir to str failed." ); }
        }

        str_current_dir.to_string()
    }
    /*
    get_hostname( ... ) -> String
    https://gist.github.com/conradkleinespel/6c8174aee28fa22bfe26 */
    pub fn hostname() -> String
    {
        unsafe
        {
            let len = 255;
            let mut buf = Vec::<u8>::with_capacity( len );
            let ptr = buf.as_mut_slice().as_mut_ptr();
            let err = gethostname( ptr as *mut libc::c_char, len as libc::size_t ) as i32;

            match err
            {
                0 =>
                {
                    let real_len;
                    let mut i = 0;
                    loop
                    {
                        let byte = unsafe { *( ( ( ptr as u64 ) + ( i as u64 ) ) as *const u8 ) };
                        if byte == 0
                        {
                            real_len = i;
                            break;
                        }

                        i += 1;
                    }
                    buf.set_len( real_len );
                    String::from_utf8_lossy( buf.as_slice() ).into_owned()
                }
                _ => String::from( "unknown" ),
            }
        }
    }
    /*
    get_limit( ... ) -> ( String, String ) */
    pub fn limit( limit_name:&str, single_print:bool, for_hard:bool ) -> ( String, String )
    {
        unsafe
        {
            let ( desc, limit_id ) = match limit_name
            {
                "open_files" => ( "open files", libc::RLIMIT_NOFILE ),
                "core_file_size" => ( "core file size", libc::RLIMIT_CORE ),
                _ => return ( String::new(), String::from( "ulimit:error:invalid limit name" ) ),
            };

            let mut rlp = libc::rlimit { rlim_cur:0, rlim_max:0 };
            let mut result_stdout = String::new();
            let mut result_stderr = String::new();            
            if libc::getrlimit( limit_id, &mut rlp ) != 0
            {
                result_stderr.push_str( &format!( "error getting limit:{}", Error::last_os_error() ) );
                return ( result_stdout, result_stderr );
            }

            let to_print = if for_hard { rlp.rlim_max } else { rlp.rlim_cur };
            let info = if to_print == libc::RLIM_INFINITY 
            { if single_print { "unlimited\n".to_string() } else { format!( "{}\t\tunlimited\n", desc ) } }
            else if single_print
            { format!( "{}\n", to_print ) }
            else
            { format!( "{}\t\t{}\n", desc, to_print ) };

            result_stdout.push_str( &info );
            ( result_stdout, result_stderr )
        }

        
    }
    /*
    get_user_name( ... ) -> String */
    pub fn username() -> String
    {
        match env::var( "USER" )
        {
            Ok( x ) => { return x; }
            Err( e ) =>
            {
                //log!( "pls:env USER error:{}", e );
            }
        }
        let cmd_result = now::run( "whoami" );
        return cmd_result.stdout.trim().to_string();
    }
    /*
    get_envs_home( ... ) -> String */
    pub fn virtual_environments_home() -> String
    {
        env::var( "VIRTUALENV_HOME" ).unwrap_or_default()
    }
    /*
    get_all_venvs( ... ) -> Result<Vec<String>, String> */
    pub fn virtual_environments() -> Result<Vec<String>, String>
    {
        let home_envs = virtual_environments_home();
        if home_envs.is_empty()
        {
            let info = String::from( "you need to set VIRTUALENV_HOME to use vox" );
            return Err( info );
        }

        if !Path::new( home_envs.as_str() ).exists()
        {
            match fs::create_dir_all( home_envs.as_str() )
            {
                Ok( _ ) => {}
                Err( e ) =>
                {
                    let info = format!( "fs create_dir_all failed:{:?}", e );
                    return Err( info );
                }
            }
        }

        let mut venvs = Vec::new();
        let pdir = home_envs.clone();
        if let Ok( list ) = fs::read_dir( home_envs )
        {
            for ent in list.flatten()
            {
                let ent_name = ent.file_name();
                if let Ok( path ) = ent_name.into_string()
                {
                    let full_path = format!( "{}/{}/bin/activate", pdir, path );
                    if !Path::new( full_path.as_str() ).exists(){ continue; }
                    venvs.push( path );
                }
            }
        }

        Ok( venvs )
    }
    /*
    _get_std_fds( ... ) -> ( Option<RawFd>, Option<RawFd> ) */
    pub fn std_fds( redirects:&[Redirection] ) -> ( Option<RawFd>, Option<RawFd> )
    {
        if redirects.is_empty(){ return ( None, None ); }
        let mut fd_out = None;
        let mut fd_err = None;

        for i in 0..redirects.len()
        {
            let item = &redirects[i];
            if item.0 == "1"
            {
                let mut _fd_candidate = None;
                if item.2 == "&2"
                {
                    let ( _fd_out, _fd_err ) = std_fds( &redirects[i+1..] );
                    if let Some( fd ) = _fd_err {
                        _fd_candidate = Some( fd );
                    } else {
                        _fd_candidate = unsafe { Some( libc::dup( 2 ) ) };
                    }
                }

                else
                {  
                    let append = item.1 == ">>";
                    if let Ok( fd ) = fs::create_raw_fd_from_file( &item.2, append )
                    { _fd_candidate = Some( fd ); }
                }
                /*
                For command like this:`alias > a.txt > b.txt > c.txt`, 
                we need to return the last one, but close the previous two. */
                if let Some( fd ) = fd_out { unsafe { libc::close( fd ); } }
                fd_out = _fd_candidate;
            }

            if item.0 == "2" {
                let mut _fd_candidate = None;

                if item.2 == "&1" {
                    if let Some( fd ) = fd_out {
                        _fd_candidate = unsafe { Some( libc::dup( fd ) ) };
                    }
                } else {
                    let append = item.1 == ">>";
                    if let Ok( fd ) = fs::create_raw_fd_from_file( &item.2, append ) {
                        _fd_candidate = Some( fd );
                    }
                }

                if let Some( fd ) = fd_err {
                    unsafe { libc::close( fd ); }
                }

                fd_err = _fd_candidate;
            }
        }

        ( fd_out, fd_err )
    }
    /*
    _get_dupped_stdout_fd( ... ) -> Result<Vec<String>, String> */
    pub fn dupped_stdout_fd( cmd:&Command, cl:&CommandLine ) -> RawFd
    {
        /*
        If with pipeline, e.g. `history | grep foo`,
        Then we don't need to dup stdout since it is running in a sperated process. */
        unsafe
        {
            if cl.with_pipeline() { return 1; }
            let ( _fd_out, _fd_err ) = get::std_fds( &cmd.redirects_to );
            if let Some( fd ) = _fd_err { libc::close( fd ); }
            if let Some( fd ) = _fd_out { fd }
            else
            {
                let fd = libc::dup( 1 );
                if fd == -1
                {
                    let eno = no::errno();
                    println_stderr!( "pls:dup:{}", eno );
                }
                fd
            }
        }
    }
    /*
    _get_dupped_stderr_fd( ... ) -> Result<Vec<String>, String> */
    pub fn dupped_stderr_fd( cmd:&Command, cl:&CommandLine ) -> RawFd
    {
        unsafe
        {
            if cl.with_pipeline(){ return 2; }
            let ( _fd_out, _fd_err ) = get::std_fds( &cmd.redirects_to );
            if let Some( fd ) = _fd_out { libc::close( fd ); }
            if let Some( fd ) = _fd_err { fd } 
            else
            {
                let fd = libc::dup( 2 );
                if fd == -1
                {
                    let eno = no::errno();
                    println_stderr!( "pls:dup:{}", eno );
                }
                fd
            }
        }
    }
    /*
    get_osx_version( ... ) -> String */
    pub fn osx_version() -> String
    {
        let cr = now::run( "sw_vers -productVersion" );
        return cr.stdout.trim().to_string();
    }
    /*
    get_osx_codename( ... ) -> String */
    pub fn osx_codename() -> String
    {
        let cr = now::run( "grep -o 'SOFTWARE LICENSE AGREEMENT FOR .*[a-zA-Z]' '/System/Library/CoreServices/Setup Assistant.app/Contents/Resources/en.lproj/OSXSoftwareLicense.rtf' | sed 's/SOFTWARE LICENSE AGREEMENT FOR *//'" );
        return cr.stdout.trim().to_string();
    }
    /*
    get_macos_name( ... ) -> String */
    pub fn macos_name() -> String
    {
        let mut os_name = osx_codename();
        let ver = osx_version();
        if !ver.is_empty()
        {
            os_name.push( ' ' );
            os_name.push_str( &ver );
        }
        os_name
    }
    /*
    get_uname_mo( ... ) -> String */
    pub fn uname_mo() -> String
    {
        let cr = now::run( "uname -m -o" );
        return cr.stdout.trim().to_string();
    }
    /*
    get_uname( ... ) -> String */
    pub fn uname() -> String
    {
        let cr = now::run( "uname" );
        return cr.stdout.trim().to_string();
    }
    /*
    get_release_value( ... ) -> String */
    pub fn release_value( ptn:&str ) -> String
    {
        let line = format!( 
            "grep -i '{}' /etc/*release* 2>&1 | grep -o '=.*' | tr '\"=' ' '",
            ptn
 );
        let cr = now::run( &line );
        return cr.stdout.trim().to_string();
    }
    /*
    get_other_os_name( ... ) -> String */
    pub fn other_os_name() -> String
    {
        let mut name = release_value( "PRETTY_NAME" );
        if !name.is_empty() {
            return name;
        }
        name = release_value( "DISTRIB_DESCRIPTION" );
        if !name.is_empty() {
            return name;
        }
        name = release_value( "IMAGE_DESCRIPTION" );
        if !name.is_empty() {
            return name;
        }
        uname_mo()
    }
    /*
    get_os_name( ... ) -> String */
    pub fn os_name() -> String
    {
        let uname = uname();
        if uname.to_lowercase() == "darwin" {
           macos_name()
        } else {
            other_os_name()
        }
    }
    /*
    get_dimensions_any( ... ) -> winsize
    Runs the ioctl command. 
    Returns ( 0, 0 ) if all of the streams are not to a terminal, or there is an error.
    ( 0, 0 ) is an invalid size to have anyway, which is why it can be used as a nil value. */
    unsafe fn any_dimensions() -> winsize
    {
        let mut window:winsize = ::mem::zeroed();
        let mut result = ioctl( STDOUT_FILENO, TIOCGWINSZ, &mut window );
        if result == -1
        {
            window = ::mem::zeroed();
            result = ioctl( STDIN_FILENO, TIOCGWINSZ, &mut window );
            if result == -1
            {
                window = ::mem::zeroed();
                result = ioctl( STDERR_FILENO, TIOCGWINSZ, &mut window );
                if result == -1
                {
                    return ::mem::zeroed();
                }
            }
        }
        window
    }
    /*
    Query the current processes's output ( `stdout` ), input ( `stdin` ), and error ( `stderr` ) in that order,
    in the attempt to dtermine terminal width. */
    pub fn dimensions() -> Option<( usize, usize )>
    {
        let w = unsafe { any_dimensions() };
        if w.ws_col == 0 || w.ws_row == 0
        { None }
        else
        { Some( ( w.ws_col as usize, w.ws_row as usize ) ) }
    }
    /*
    get_prompt_len( ... ) -> i32 */
    pub fn prompt_len( prompt:&str ) -> i32
    {
        let mut count = 0;
        let mut met_x01 = false;
        for c in prompt.chars() {
            if c == '\x01' {
                met_x01 = true;
                continue;
            } else if c == '\x02' {
                met_x01 = false;
                continue;
            }
            if !met_x01 {
                count += 1;
            }
        }
        count
    }
    /*
    get_prompt( ... ) -> String */
    pub fn prompt( sh:&shell::Shell ) -> String
    {
        let ps = prompt_string();
        let mut prompt = prompt::main::render_prompt( sh, &ps );
        if let Some( ( w, _h ) ) = dimensions()
        {
            if prompt_len( &prompt ) > ( w / 2 ) as i32 && !regex::re_contains( &ps, r#"( ?i )\$\{?newline.\}?"# )
            {
                prompt.push_str( "\n$ " );
            }
        } 
        else 
        {
            //log!( "ERROR:Failed to get term size" );
        }
        prompt
    }
    /*
    get_prompt_string( ... ) -> String */
    pub fn prompt_string() -> String
    {
        if let Ok( x ) = env::var( "PROMPT" ) { return x; }
        DEFAULT_PROMPT.to_string()
    }
    /*
    get_for_result_from_init( ... ) -> Vec<String> */
    pub fn for_result_from_init
    ( 
        sh:&mut shell::Shell,
        pair_init:Pair<parsers::locust::Rule>,
        args:&[String]
 ) -> Vec<String>
    {
        let mut result:Vec<String> = Vec::new();
        /*
        let pairs = pair_init.into_inner();
        for pair in pairs
        {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::TEST
            {
                let line = pair.as_str().trim();
                let tokens = expand_line_to_toknes( line, &args[1..], sh );
                for ( sep, token ) in tokens {
                    if sep.is_empty() {
                        for x in token.split_whitespace() {
                            result.push( x.to_string() );
                        }
                    } else {
                        result.push( token.clone() );
                    }
                }
            }
        }
        */
        result
    }
    /*
    get_for_result_list( ... ) -> Vec<String> */
    pub fn for_result_list
    ( 
        sh:&mut shell::Shell,
        pair_head:Pair<parsers::locust::Rule>,
        args:&[String]
 ) -> Vec<String>
    {
        /*
        let pairs = pair_head.into_inner();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_INIT {
                return get_for_result_from_init( sh, pair, args );
            }
        }
        */
        Vec::new()
    }
    /*
    get_for_var_name( ... ) -> String */
    pub fn for_var_name( pair_head:Pair<parsers::locust::Rule> ) -> String
    {
        /*
        let pairs = pair_head.into_inner();
        for pair in pairs
        {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_INIT
            {
                let pairs_init = pair.into_inner();
                for pair_init in pairs_init {
                    let rule_init = pair_init.as_rule();
                    if rule_init == parsers::locust::Rule::FOR_VAR {
                        let line = pair_init.as_str().trim();
                        return line.to_string();
                    }
                }
            }
        }
        */
        String::new()
    }
    /*
    get::history_file( ... ) -> String */
    pub fn history_file() -> String
    {
        if let Ok( hfile ) = env::var( "HISTORY_FILE" ){ hfile } 
        else if let Ok( d ) = env::var( "XDG_DATA_HOME" ){ format!( "{}/{}", d, "pls/history.sqlite" ) } 
        else
        {
            let home = get::user_home();
            format!( "{}/{}", home, ".local/share/pls/history.sqlite" )
        }
    }
    /*
    get_history_table( ... ) -> String */
    pub fn history_table() -> String
    {
        if let Ok( hfile ) = env::var( "HISTORY_TABLE" ){ hfile } 
        else { String::from( "cicada_history" ) }
    }
    /*
    get_job_line( ... ) -> String */
    pub fn job_line( job:&types::Job, trim:bool ) -> String
    {
        let mut cmd = job.cmd.clone();
        if trim && cmd.len() > 50
        {
            cmd.truncate( 50 );
            cmd.push_str( " ..." );
        }

        let _cmd = if job.is_bg && job.status == "Running"
        {
            format!( "{} &", cmd )
        }
        else { cmd };
        format!( "[{}] {}  {}   {}", job.id, job.gid, job.status, _cmd )
    }
}
/*
glob v0.0.0*/
pub mod glob
{

}
pub mod hint { pub use std::hint::{ * }; }
pub mod history
{
    /*
    use linefeed::terminal::DefaultTerminal;
    use linefeed::Interface;
    use rusqlite::Connection as Conn;
    use rusqlite::Error::SqliteFailure;
    */
    use ::
    {
        collections::{ HashMap },
        io::{ Write },
        path::{ Path },
        *,
    };

    pub fn init_db( hfile:&str, htable:&str )
    {
        let path = Path::new( hfile );
        if !path.exists() {
            let _parent = match path.parent() {
                Some( x ) => x,
                None => {
                    println_stderr!( "pls:history init - no parent found" );
                    return;
                }
            };
            let parent = match _parent.to_str() {
                Some( x ) => x,
                None => {
                    println_stderr!( "pls:parent to_str is None" );
                    return;
                }
            };
            match fs::create_dir_all( parent ) {
                Ok( _ ) => {}
                Err( e ) => {
                    println_stderr!( "pls:histdir create error:{}", e );
                    return;
                }
            }
            match fs::File::create( hfile ) {
                Ok( _ ) => {
                    println!( "pls:created history file:{}", hfile );
                }
                Err( e ) => {
                    println_stderr!( "pls:history:file create failed:{}", e );
                }
            }
        }

        let conn = match Conn::open( hfile ) {
            Ok( x ) => x,
            Err( e ) => {
                println_stderr!( "pls:history:open db error:{}", e );
                return;
            }
        };
        let sql = format!( 
            "
            CREATE TABLE IF NOT EXISTS {}
                ( inp TEXT,
                 rtn INTEGER,
                 tsb REAL,
                 tse REAL,
                 sessionid TEXT,
                 out TEXT,
                 info TEXT
 );
        ",
            htable
 );
        match conn.execute( &sql, [] ) {
            Ok( _ ) => {}
            Err( e ) => println_stderr!( "pls:history:query error:{}", e ),
        }
    }

    pub fn init( rl:&mut Interface<DefaultTerminal> )
    {
        let mut hist_size:usize = 99999;
        if let Ok( x ) = env::var( "HISTORY_SIZE" ) {
            if let Ok( y ) = x.parse::<usize>() {
                hist_size = y;
            }
        }
        rl.set_history_size( hist_size );

        let history_table = get::history_table();
        let hfile = get::history_file();

        if !Path::new( &hfile ).exists() {
            init_db( &hfile, &history_table );
        }

        let mut delete_dups = true;
        if let Ok( x ) = env::var( "HISTORY_DELETE_DUPS" ) {
            if x == "0" {
                delete_dups = false;
            }
        }
        if delete_dups {
            delete_duplicated_histories();
        }

        let conn = match Conn::open( &hfile ) {
            Ok( x ) => x,
            Err( e ) => {
                println_stderr!( "pls:history:conn error:{}", e );
                return;
            }
        };
        let sql = format!( "SELECT inp FROM {} ORDER BY tsb;", history_table );
        let mut stmt = match conn.prepare( &sql ) {
            Ok( x ) => x,
            Err( e ) => {
                println_stderr!( "pls:prepare select error:{}", e );
                return;
            }
        };

        let rows = match stmt.query_map( [], |row| row.get( 0 ) ) {
            Ok( x ) => x,
            Err( e ) => {
                println_stderr!( "pls:query select error:{}", e );
                return;
            }
        };

        let mut dict_helper:HashMap<String, bool> = HashMap::new();
        for x in rows.flatten() {
            let inp:String = x;
            if dict_helper.contains_key( &inp ) {
                continue;
            }
            dict_helper.insert( inp.clone(), true );
            rl.add_history( inp.trim().to_string() );
        }
    }

    pub fn delete_duplicated_histories()
    {
        let hfile = get::history_file();
        let history_table = get::history_table();
        let conn = match Conn::open( &hfile ) {
            Ok( x ) => x,
            Err( e ) => {
                println_stderr!( "pls:history:conn error:{}", e );
                return;
            }
        };
        let sql = format!( 
            "DELETE FROM {} WHERE rowid NOT IN ( 
            SELECT MAX( rowid ) FROM {} GROUP BY inp )",
            history_table, history_table
 );
        match conn.execute( &sql, [] ) {
            Ok( _ ) => {}
            Err( e ) => match e {
                SqliteFailure( ee, msg ) => {
                    if ee.extended_code == 5 {
                        /*log!( 
                            "failed to delete dup histories:{}",
                            msg.unwrap_or( "db is locked?".to_owned() ),
 );*/
                        return;
                    }
                    println_stderr!( 
                        "pls:history:delete dups error:{}:{:?}",
                        &ee,
                        &msg
 );
                }
                _ => {
                    println_stderr!( "pls:history:delete dup error:{}", e );
                }
            },
        }
    }

    pub fn add_raw( sh:&shell::Shell, line:&str, status:i32, tsb:f64, tse:f64 )
    {
        let hfile = get::history_file();
        let history_table = get::history_table();
        if !Path::new( &hfile ).exists() {
            init_db( &hfile, &history_table );
        }

        let conn = match Conn::open( &hfile ) {
            Ok( x ) => x,
            Err( e ) => {
                println_stderr!( "pls:history:conn error:{}", e );
                return;
            }
        };
        let sql = format!( 
            "INSERT INTO \
             {} ( inp, rtn, tsb, tse, sessionid, info ) \
             VALUES( '{}', {}, {}, {}, '{}', 'dir:{}|' );",
            history_table,
            str::replace( line.trim(), "'", "''" ),
            status,
            tsb,
            tse,
            sh.session_id,
            sh.current_dir,
 );
        match conn.execute( &sql, [] ) {
            Ok( _ ) => {}
            Err( e ) => println_stderr!( "pls:history:save error:{}", e ),
        }
    }

    pub fn add( sh:&shell::Shell, rl:&mut Interface<DefaultTerminal>, line:&str, status:i32, tsb:f64, tse:f64 )
    {
        add_raw( sh, line, status, tsb, tse );
        rl.add_history( line.to_string() );
    }
}
pub mod io { pub use std::io::{ * }; }
pub mod hash { pub use std::hash::{ * }; }
/*
State Testing */
pub mod is
{
    use ::
    {
        char::{ char_width },
        regex::{ re_contains, Regex },
        *,
    };
    /*
    is_arithmetic( ... ) -> bool*/
    pub fn arithmetic( line:&str ) -> bool
    {
        if !re_contains( line, r"[0-9]+" )
        { return false; }

        if !re_contains( line, r"\+|\-|\*|/|\^" )
        { return false; }

        re_contains( line, r"^[ 0-9\.\( \ )\+\-\*/\^]+[\.0-9 \ )]$" )
    }
    /*
    is_builtin( ... ) -> bool*/
    pub fn builtin( s:&str ) -> bool
    {
        let builtins =
        [
            "alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg",
            "history", "jobs", "read", "source", "ulimit", "unalias", "vox",
            "minfd", "set", "unset", "unpath",
        ];

        builtins.contains( &s )
    }
    /*
    is_env( ... ) -> bool*/
    pub fn environment( line:&str ) -> bool
    { re_contains( line, r"^[a-zA-Z_][a-zA-Z0-9_]*=.*$" ) }
    /*
    is_shell_altering_command( ... ) -> bool*/
    pub fn shell_altering_command( line:&str ) -> bool
    {
        let line = line.trim();
        if re_contains( line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$" )
        { return true; }

        line.starts_with( "alias " )
        || line.starts_with( "export " )
        || line.starts_with( "unalias " )
        || line.starts_with( "unset " )
        || line.starts_with( "source " )
    }
    /*
    is_signal_handler_enabled( ... ) -> bool*/
    pub fn signal_handler_enabled() -> bool
    {
        env::var( "CICADA_ENABLE_SIG_HANDLER" ).map_or( false, |x| x == "1" )
    }
    /*
    is_login( ... ) -> bool */
    pub fn login( args:&[String] ) -> bool
    {
        if !args.is_empty() && args[0].starts_with( "-" ) {
            return true;
        }

        if args.len() > 1 && ( args[1] == "--login" || args[1] == "-l" ) {
            return true;
        }

        false
    }
    /*
    is_script( ... ) -> bool */
    pub fn script( args:&[String] ) -> bool
    { args.len() > 1 && !args[1].starts_with( "-" ) }
    /*
    is_command_string( ... ) -> bool */
    pub fn command_string( args:&[String] ) -> bool
    { args.len() > 1 && args[1] == "-c" }
    /*
    is_non_tty( ... ) -> bool */
    pub fn non_tty() -> bool
    { unsafe { libc::isatty( 0 ) == 0 } }
    /*
    is::prefix_char( ... ) -> bool */
    pub fn prefix_char( c:char ) -> bool
    {
        c == '[' || c == '{'
    }
    /*
    is::suffix_char( ... ) -> bool */
    pub fn suffix_char( c:char ) -> bool
    {
        c == ']' || c == '}'
    }
    /*
    is::prompt_item_char( ... ) -> bool */
    pub fn prompt_item_char( c:char, token:&str ) -> bool
    {
        let s = c.to_string();
        if token.is_empty() { regex::re_contains( &s, r#"^[a-zA-Z_]$"# ) }
        else { regex::re_contains( &s, r#"^[a-zA-Z0-9_]$"# ) }
    }
    /*
    is_args_in_token( ... ) -> bool */
    pub fn arguments_in_token( token:&str ) -> bool
    {
        ::regex::re_contains( token, r"\$\{?[0-9@]+\}?" )
    }
    /*
    needs_globbing( ... ) -> bool */
    pub fn globable ( line:&str ) -> bool
    {
        let re = Regex::new( r"\*+" ).expect( "Invalid regex ptn" );
        re.is_match( line )
    }
    /*
    need_expand_brace( ... ) -> bool */
    pub fn brace_expandable( line:&str ) -> bool
    {
        regex::re_contains( line, r#"\{[^ "']*,[^ "']*,?[^ "']*\}"# )
    }
    /*
    env_in_token( ... ) -> bool */
    pub fn environment_in_token( token:&str ) -> bool
    {
        if regex::re_contains( token, r"\$\{?[\$\?]\}?" ){ return true; }
        let ptn_env_name = r"[a-zA-Z_][a-zA-Z0-9_]*";
        let ptn_env = format!( r"\$\{{?{}\}}?", ptn_env_name );
        if !regex::re_contains( token, &ptn_env ) { return false; }
        
        let ptn_cmd_sub1 = format!( r"^{}=`.*`$", ptn_env_name );
        let ptn_cmd_sub2 = format!( r"^{}=\$\( .*\ )$", ptn_env_name );
        if regex::re_contains( token, &ptn_cmd_sub1 )
        || regex::re_contains( token, &ptn_cmd_sub2 )
        || regex::re_contains( token, r"^\$\( .+\ )$" )
        {
            return false;
        }
        
        let ptn_env = format!( r"='.*\$\{{?{}\}}?.*'$", ptn_env_name );
        !regex::re_contains( token, &ptn_env )
    }
    /*
    is_env_prefix( ... ) -> bool */
    pub fn env_prefix( line:&str ) -> bool
    { ::regex::re_contains( line, r" *\$[a-zA-Z_][A-Za-z0-9_]*" ) }
    /*
    is_pipelined( ... ) -> bool */
    pub fn pipelined( path:&str ) -> bool
    {
        if !path.contains( '|' ) { return false; }
        !path.starts_with( '"' ) && !path.starts_with( '\'' )
    }
    /*
    is_visible( ... ) -> bool */
    pub fn visible( ch:char ) -> bool
    {
        match ch
        {
            '\t' | '\r' | '\n' => true,
            _ => char_width( ch ).unwrap_or( 0 ) != 0
        }
    }
    /*
    is_combining_mark( ... ) -> bool */
    #[inline] pub fn combining_mark( ch:char ) -> bool
    { unicode_normalization::char::is_combining_mark( ch ) }

    fn is_flag( i:u8 ) -> bool
    {
        i == b' ' || i == b'-' || i == b'+' || i == b'#'
    }    
    /*
    is_alphabetic( ... ) -> bool */
    #[inline] pub fn alphabetic(chr: u8) -> bool { (chr >= 0x41 && chr <= 0x5A) || (chr >= 0x61 && chr <= 0x7A) }

    /// Tests if byte is ASCII digit: 0-9.
    
    /*
    is_digit( ... ) -> bool */
    #[inline] pub fn digit(chr: u8) -> bool  { chr >= 0x30 && chr <= 0x39 }

    /// Tests if byte is ASCII hex digit: 0-9, A-F, a-f.
    #[inline]
    pub fn is_hex_digit(chr: u8) -> bool {
    (chr >= 0x30 && chr <= 0x39) || (chr >= 0x41 && chr <= 0x46) || (chr >= 0x61 && chr <= 0x66)
    }

    /// Tests if byte is ASCII octal digit: 0-7.
    #[inline]
    pub fn is_oct_digit(chr: u8) -> bool {
    chr >= 0x30 && chr <= 0x37
    }

    /// Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9.
    #[inline]
    pub fn is_alphanumeric(chr: u8) -> bool {
    is::alphabetic(chr) || is::digit(chr)
    }

    /// Tests if byte is ASCII space or tab.
    #[inline]
    pub fn is_space(chr: u8) -> bool {
    chr == b' ' || chr == b'\t'
    }

    /// Tests if byte is ASCII newline: \n.
    #[inline]
    pub fn is_newline(chr: u8) -> bool {
    chr == b'\n'
    }
}
pub mod iter
{ 
    pub use std::iter::{ * }; 
    use ::
    {
        boxed::{ Box },
        cmp::{ self, Ordering },
        convert::{ Infallible },
        marker::{ PhantomData },
        *,
    };
    
    enum FoldStop<T, E>
    {
        Break(T),
        Err(E),
    }

    impl<T, E> From<E> for FoldStop<T, E>
    {
        #[inline] fn from(e: E) -> FoldStop<T, E> { FoldStop::Err(e) }
    }

    trait ResultExt<T, E>
    {
        fn unpack_fold(self) -> Result<T, E>;
    }

    impl<T, E> ResultExt<T, E> for Result<T, FoldStop<T, E>>
    {
        #[inline] fn unpack_fold(self) -> Result<T, E>
        {
            match self
            {
                Ok(v) => Ok(v),
                Err(FoldStop::Break(v)) => Ok(v),
                Err(FoldStop::Err(e)) => Err(e),
            }
        }
    }
    /// An `Iterator`-like trait that allows for calculation of items to fail.
    pub trait FallibleIterator
    {
        /// The type being iterated over.
        type Item;
        /// The error type.
        type Error;
        /// Advances the iterator and returns the next value.
        fn next(&mut self) -> Result<Option<Self::Item>, Self::Error>;
        /// Returns bounds on the remaining length of the iterator.
        #[inline] fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }
        /// Consumes the iterator, returning the number of remaining items.
        #[inline] fn count(self) -> Result<usize, Self::Error> where
        Self: Sized
        { self.fold(0, |n, _| Ok(n + 1)) }
        /// Returns the last element of the iterator.
        #[inline] fn last(self) -> Result<Option<Self::Item>, Self::Error> where
        Self: Sized
        { self.fold(None, |_, v| Ok(Some(v))) }
        /// Returns the `n`th element of the iterator.
        #[inline] fn nth(&mut self, mut n: usize) -> Result<Option<Self::Item>, Self::Error>
        {
            while let Some(e) = self.next()?
            {
                if n == 0 { return Ok(Some(e)); }
                n -= 1;
            }

            Ok(None)
        }
        /// Returns an iterator starting at the same point, but stepping by the given amount at each iteration.
        #[inline] fn step_by(self, step: usize) -> StepBy<Self> where
        Self: Sized
        {
            assert!(step != 0);
            StepBy
            {
                it: self,
                step: step - 1,
                first_take: true,
            }
        }
        /// Returns an iterator which yields the elements of this iterator followed by another.
        #[inline] fn chain<I>(self, it: I) -> Chain<Self, I> where
        I: IntoFallibleIterator<Item = Self::Item, Error = Self::Error>,
        Self: Sized
        {
            Chain
            {
                front: self,
                back: it,
                state: ChainState::Both,
            }
        }
        /// Returns an iterator that yields pairs of this iterator's and another iterator's values.
        #[inline] fn zip<I>(self, o: I) -> Zip<Self, I::IntoFallibleIter> where
        Self: Sized,
        I: IntoFallibleIterator<Error = Self::Error>
        { Zip(self, o.into_fallible_iter()) }
        /// Returns an iterator which applies a fallible transform to the elements of the underlying iterator.
        #[inline] fn map<F, B>(self, f: F) -> Map<Self, F> where
        Self: Sized,
        F: FnMut(Self::Item) -> Result<B, Self::Error>
        { Map { it: self, f } }
        /// Calls a fallible closure on each element of an iterator.
        #[inline] fn for_each<F>(self, mut f: F) -> Result<(), Self::Error> where
        Self: Sized,
        F: FnMut(Self::Item) -> Result<(), Self::Error>
        { self.fold((), move |(), item| f(item)) }
        /// Returns an iterator which uses a predicate to determine which values should be yielded.
        #[inline] fn filter<F>(self, f: F) -> Filter<Self, F> where
        Self: Sized,
        F: FnMut(&Self::Item) -> Result<bool, Self::Error>
        { Filter { it: self, f } }
        /// Returns an iterator which both filters and maps.
        #[inline] fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where
        Self: Sized,
        F: FnMut(Self::Item) -> Result<Option<B>, Self::Error> 
        { FilterMap { it: self, f } }
        /// Returns an iterator which yields the current iteration count as well as the value.
        #[inline] fn enumerate(self) -> Enumerate<Self> where
        Self: Sized
        { Enumerate { it: self, n: 0 } }
        /// Returns an iterator that can peek at the next element without consuming it.
        #[inline] fn peekable(self) -> Peekable<Self> where
        Self: Sized,
        {
            Peekable
            {
                it: self,
                next: None,
            }
        }
        /// Returns an iterator that skips elements based on a predicate.
        #[inline] fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where
        Self: Sized,
        P: FnMut(&Self::Item) -> Result<bool, Self::Error>
        {
            SkipWhile
            {
                it: self,
                flag: false,
                predicate,
            }
        }
        /// Returns an iterator that yields elements based on a predicate.
        #[inline] fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where
        Self: Sized,
        P: FnMut(&Self::Item) -> Result<bool, Self::Error>
        {
            TakeWhile
            {
                it: self,
                flag: false,
                predicate,
            }
        }
        /// Returns an iterator which skips the first `n` values of this iterator.
        #[inline] fn skip(self, n: usize) -> Skip<Self> where
        Self: Sized
        { Skip { it: self, n } }

        /// Returns an iterator that yields only the first `n` values of this iterator.
        #[inline] fn take(self, n: usize) -> Take<Self> where
        Self: Sized
        {
            Take
            {
                it: self,
                remaining: n,
            }
        }
        /// Returns an iterator which applies a stateful map to values of this iterator.
        #[inline] fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F> where
        Self: Sized,
        F: FnMut(&mut St, Self::Item) -> Result<Option<B>, Self::Error>
        {
            Scan
            {
                it: self,
                f,
                state: initial_state,
            }
        }
        /// Returns an iterator which maps this iterator's elements to iterators, yielding those iterators' values.
        #[inline] fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F> where
        Self: Sized,
        U: IntoFallibleIterator<Error = Self::Error>,
        F: FnMut(Self::Item) -> Result<U, Self::Error>
        {
            FlatMap
            {
                it: self.map(f),
                cur: None,
            }
        }
        /// Returns an iterator which flattens an iterator of iterators, yielding those iterators' values.
        #[inline] fn flatten(self) -> Flatten<Self> where
        Self: Sized,
        Self::Item: IntoFallibleIterator<Error = Self::Error>
        {
            Flatten {
                it: self,
                cur: None,
            }
        }
        /// Returns an iterator which yields this iterator's elements and ends after the first `Ok(None)`.
        #[inline] fn fuse(self) -> Fuse<Self> where
        Self: Sized
        {
            Fuse
            {
                it: self,
                done: false,
            }
        }
        /// Returns an iterator which passes each element to a closure before returning it.
        #[inline] fn inspect<F>(self, f: F) -> Inspect<Self, F> where
        Self: Sized,
        F: FnMut(&Self::Item) -> Result<(), Self::Error>
        { Inspect { it: self, f } }
        /// Borrow an iterator rather than consuming it.
        #[inline] fn by_ref(&mut self) -> &mut Self where
        Self: Sized
        { self }
        /// Transforms the iterator into a collection.
        #[inline] fn collect<T>(self) -> Result<T, Self::Error> where
        T: iter::FromIterator<Self::Item>,
        Self: Sized
        { self.iterator().collect() }
        /// Transforms the iterator into two collections, partitioning elements by a closure.
        #[inline] fn partition<B, F>(self, mut f: F) -> Result<(B, B), Self::Error> where
        Self: Sized,
        B: Default + Extend<Self::Item>,
        F: FnMut(&Self::Item) -> Result<bool, Self::Error>
        {
            let mut a = B::default();
            let mut b = B::default();

            self.for_each(|i|
            {
                if f(&i)? { a.extend(Some(i)); }
                else { b.extend(Some(i)); }

                Ok(())
            })?;

            Ok((a, b))
        }
        /// Applies a function over the elements of the iterator, producing a single final value.
        #[inline] fn fold<B, F>(mut self, init: B, f: F) -> Result<B, Self::Error> where
        Self: Sized,
        F: FnMut(B, Self::Item) -> Result<B, Self::Error>
        { self.try_fold(init, f) }
        /// Applies a function over the elements of the iterator, producing a single final value.
        #[inline] fn try_fold<B, E, F>(&mut self, mut init: B, mut f: F) -> Result<B, E> where
        Self: Sized,
        E: From<Self::Error>,
        F: FnMut(B, Self::Item) -> Result<B, E>
        {
            while let Some(v) = self.next()?
            {
                init = f(init, v)?;
            }

            Ok(init)
        }
        /// Determines if all elements of this iterator match a predicate.
        #[inline] fn all<F>(&mut self, mut f: F) -> Result<bool, Self::Error> where
        Self: Sized,
        F: FnMut(Self::Item) -> Result<bool, Self::Error>
        {
            self.try_fold((), |(), v| 
            {
                if !f(v)? { return Err(FoldStop::Break(false)); }
                Ok(())
            })
            .map(|()| true)
            .unpack_fold()
        }
        /// Determines if any element of this iterator matches a predicate.
        #[inline] fn any<F>(&mut self, mut f: F) -> Result<bool, Self::Error> where
        Self: Sized,
        F: FnMut(Self::Item) -> Result<bool, Self::Error>
        {
            self.try_fold((), |(), v| {
                if f(v)? { return Err(FoldStop::Break(true)); }
                Ok(())
            })
            .map(|()| false)
            .unpack_fold()
        }
        /// Returns the first element of the iterator that matches a predicate.
        #[inline] fn find<F>(&mut self, mut f: F) -> Result<Option<Self::Item>, Self::Error> where
        Self: Sized,
        F: FnMut(&Self::Item) -> Result<bool, Self::Error>
        {
            self.try_fold((), |(), v|
            {
                if f(&v)? { return Err(FoldStop::Break(Some(v))); }
                Ok(())
            })
            .map(|()| None)
            .unpack_fold()
        }
        /// Applies a function to the elements of the iterator, returning the first non-`None` result.
        #[inline] fn find_map<B, F>(&mut self, f: F) -> Result<Option<B>, Self::Error> where
        Self: Sized,
        F: FnMut(Self::Item) -> Result<Option<B>, Self::Error>
        {
            self.filter_map(f).next()
        }
        /// Returns the position of the first element of this iterator that matches a predicate.
        #[inline] fn position<F>(&mut self, mut f: F) -> Result<Option<usize>, Self::Error> where
        Self: Sized,
        F: FnMut(Self::Item) -> Result<bool, Self::Error>
        {
            self.try_fold(0, |n, v|
            {
                if f(v)? { return Err(FoldStop::Break(Some(n))); }
                Ok(n + 1)
            })
            .map(|_| None)
            .unpack_fold()
        }
        /// Returns the maximal element of the iterator.
        #[inline] fn max(self) -> Result<Option<Self::Item>, Self::Error> where
        Self: Sized,
        Self::Item: Ord
        { self.max_by(|a, b| Ok(a.cmp(b))) }
        /// Returns the element of the iterator which gives the maximum value from the function.
        #[inline] fn max_by_key<B, F>(mut self, mut f: F) -> Result<Option<Self::Item>, Self::Error> where
        Self: Sized,
        B: Ord,
        F: FnMut(&Self::Item) -> Result<B, Self::Error>
        {
            let max = match self.next()?
            {
                Some(v) => (f(&v)?, v),
                None => return Ok(None),
            };

            self.fold(max, |(key, max), v|
            {
                let new_key = f(&v)?;
                if key > new_key { Ok((key, max)) }
                else { Ok((new_key, v)) }
            })
            .map(|v| Some(v.1))
        }
        /// Returns the element that gives the maximum value with respect to the function.
        #[inline] fn max_by<F>(mut self, mut f: F) -> Result<Option<Self::Item>, Self::Error> where
        Self: Sized,
        F: FnMut(&Self::Item, &Self::Item) -> Result<Ordering, Self::Error>
        {
            let max = match self.next()?
            {
                Some(v) => v,
                None => return Ok(None),
            };

            self.fold(max, |max, v|
            {
                if f(&max, &v)? == Ordering::Greater { Ok(max) } 
                else { Ok(v) }
            })
            .map(Some)
        }
        /// Returns the minimal element of the iterator.
        #[inline] fn min(self) -> Result<Option<Self::Item>, Self::Error> where
        Self: Sized,
        Self::Item: Ord
        {
            self.min_by(|a, b| Ok(a.cmp(b)))
        }
        /// Returns the element of the iterator which gives the minimum value from the function.
        #[inline] fn min_by_key<B, F>(mut self, mut f: F) -> Result<Option<Self::Item>, Self::Error> where
        Self: Sized,
        B: Ord,
        F: FnMut(&Self::Item) -> Result<B, Self::Error>
        {
            let min = match self.next()?
            {
                Some(v) => (f(&v)?, v),
                None => return Ok(None),
            };

            self.fold(min, |(key, min), v|
            {
                let new_key = f(&v)?;
                if key < new_key { Ok((key, min)) } 
                else { Ok((new_key, v)) }
            })
            .map(|v| Some(v.1))
        }
        /// Returns the element that gives the minimum value with respect to the function.
        #[inline] fn min_by<F>(mut self, mut f: F) -> Result<Option<Self::Item>, Self::Error> where
        Self: Sized,
        F: FnMut(&Self::Item, &Self::Item) -> Result<Ordering, Self::Error>
        {
            let min = match self.next()?
            {
                Some(v) => v,
                None => return Ok(None),
            };

            self.fold(min, |min, v|
            {
                if f(&min, &v)? == Ordering::Less { Ok(min) } 
                else { Ok(v) }
            })
            .map(Some)
        }
        /// Returns an iterator that yields this iterator's items in the opposite order.
        #[inline] fn rev(self) -> Rev<Self> where
        Self: Sized + DoubleEndedFallibleIterator { Rev(self) }
        /// Converts an iterator of pairs into a pair of containers.
        #[inline] fn unzip<A, B, FromA, FromB>(self) -> Result<(FromA, FromB), Self::Error> where
        Self: Sized + FallibleIterator<Item = (A, B)>,
        FromA: Default + Extend<A>,
        FromB: Default + Extend<B>
        {
            let mut from_a = FromA::default();
            let mut from_b = FromB::default();

            self.for_each(|(a, b)|
            {
                from_a.extend(Some(a));
                from_b.extend(Some(b));
                Ok(())
            })?;

            Ok((from_a, from_b))
        }
        /// Returns an iterator which clones all of its elements.
        #[inline]
        fn cloned<'a, T>(self) -> Cloned<Self> where
        Self: Sized + FallibleIterator<Item = &'a T>,
        T: 'a + Clone
        { Cloned(self) }
        /// Returns an iterator which repeats this iterator endlessly.
        #[inline] fn cycle(self) -> Cycle<Self> where
        Self: Sized + Clone
        {
            Cycle
            {
                it: self.clone(),
                cur: self,
            }
        }
        /// Lexicographically compares the elements of this iterator to that of another.
        #[inline] fn cmp<I>(mut self, other: I) -> Result<Ordering, Self::Error> where
        Self: Sized,
        I: IntoFallibleIterator<Item = Self::Item, Error = Self::Error>,
        Self::Item: Ord
        {
            let mut other = other.into_fallible_iter();
            loop
            {
                match (self.next()?, other.next()?)
                {
                    (None, None) => return Ok(Ordering::Equal),
                    (None, _) => return Ok(Ordering::Less),
                    (_, None) => return Ok(Ordering::Greater),
                    (Some(x), Some(y)) => match x.cmp(&y)
                    {
                        Ordering::Equal => {}
                        o => return Ok(o),
                    },
                }
            }
        }
        /// Lexicographically compares the elements of this iterator to that of another.
        #[inline] fn partial_cmp<I>(mut self, other: I) -> Result<Option<Ordering>, Self::Error> where
        Self: Sized,
        I: IntoFallibleIterator<Error = Self::Error>,
        Self::Item: PartialOrd<I::Item>
        {
            let mut other = other.into_fallible_iter();

            loop
            {
                match (self.next()?, other.next()?)
                {
                    (None, None) => return Ok(Some(Ordering::Equal)),
                    (None, _) => return Ok(Some(Ordering::Less)),
                    (_, None) => return Ok(Some(Ordering::Greater)),
                    (Some(x), Some(y)) => match x.partial_cmp(&y)
                    {
                        Some(Ordering::Equal) => {}
                        o => return Ok(o),
                    },
                }
            }
        }
        /// Determines if the elements of this iterator are equal to those of another.
        #[inline] fn eq<I>(mut self, other: I) -> Result<bool, Self::Error> where
        Self: Sized,
        I: IntoFallibleIterator<Error = Self::Error>,
        Self::Item: PartialEq<I::Item>
        {
            let mut other = other.into_fallible_iter();

            loop
            {
                match (self.next()?, other.next()?)
                {
                    (None, None) => return Ok(true),
                    (None, _) | (_, None) => return Ok(false),
                    (Some(x), Some(y)) =>
                    {
                        if x != y { return Ok(false); }
                    }
                }
            }
        }
        /// Determines if the elements of this iterator are not equal to those of another.
        #[inline]
        fn ne<I>(mut self, other: I) -> Result<bool, Self::Error> where
        Self: Sized,
        I: IntoFallibleIterator<Error = Self::Error>,
        Self::Item: PartialEq<I::Item>
        {
            let mut other = other.into_fallible_iter();

            loop
            {
                match (self.next()?, other.next()?)
                {
                    (None, None) => return Ok(false),
                    (None, _) | (_, None) => return Ok(true),
                    (Some(x), Some(y)) =>
                    {
                        if x != y { return Ok(true); }
                    }
                }
            }
        }
        /// Determines if the elements of this iterator are lexicographically less than those of another.
        #[inline]
        fn lt<I>(mut self, other: I) -> Result<bool, Self::Error> where
        Self: Sized,
        I: IntoFallibleIterator<Error = Self::Error>,
        Self::Item: PartialOrd<I::Item>
        {
            let mut other = other.into_fallible_iter();

            loop
            {
                match (self.next()?, other.next()?)
                {
                    (None, None) => return Ok(false),
                    (None, _) => return Ok(true),
                    (_, None) => return Ok(false),
                    (Some(x), Some(y)) => match x.partial_cmp(&y)
                    {
                        Some(Ordering::Less) => return Ok(true),
                        Some(Ordering::Equal) => {}
                        Some(Ordering::Greater) => return Ok(false),
                        None => return Ok(false),
                    },
                }
            }
        }
        /// Determines if the elements of this iterator are lexicographically less than or equal to those of another.
        #[inline] fn le<I>(mut self, other: I) -> Result<bool, Self::Error> where
        Self: Sized,
        I: IntoFallibleIterator<Error = Self::Error>,
        Self::Item: PartialOrd<I::Item>
        {
            let mut other = other.into_fallible_iter();

            loop
            {
                match (self.next()?, other.next()?)
                {
                    (None, None) => return Ok(true),
                    (None, _) => return Ok(true),
                    (_, None) => return Ok(false),
                    (Some(x), Some(y)) => match x.partial_cmp(&y)
                    {
                        Some(Ordering::Less) => return Ok(true),
                        Some(Ordering::Equal) => {}
                        Some(Ordering::Greater) => return Ok(false),
                        None => return Ok(false),
                    },
                }
            }
        }
        /// Determines if the elements of this iterator are lexicographically greater than those of another.
        #[inline] fn gt<I>(mut self, other: I) -> Result<bool, Self::Error> where
        Self: Sized,
        I: IntoFallibleIterator<Error = Self::Error>,
        Self::Item: PartialOrd<I::Item>
        {
            let mut other = other.into_fallible_iter();

            loop
            {
                match (self.next()?, other.next()?)
                {
                    (None, None) => return Ok(false),
                    (None, _) => return Ok(false),
                    (_, None) => return Ok(true),
                    (Some(x), Some(y)) => match x.partial_cmp(&y)
                    {
                        Some(Ordering::Less) => return Ok(false),
                        Some(Ordering::Equal) => {}
                        Some(Ordering::Greater) => return Ok(true),
                        None => return Ok(false),
                    },
                }
            }
        }
        /// Determines if the elements of this iterator are lexicographically greater than or equal to those of another.
        #[inline] fn ge<I>(mut self, other: I) -> Result<bool, Self::Error> where
        Self: Sized,
        I: IntoFallibleIterator<Error = Self::Error>,
        Self::Item: PartialOrd<I::Item>
        {
            let mut other = other.into_fallible_iter();

            loop
            {
                match (self.next()?, other.next()?)
                {
                    (None, None) => return Ok(true),
                    (None, _) => return Ok(false),
                    (_, None) => return Ok(true),
                    (Some(x), Some(y)) => match x.partial_cmp(&y)
                    {
                        Some(Ordering::Less) => return Ok(false),
                        Some(Ordering::Equal) => {}
                        Some(Ordering::Greater) => return Ok(true),
                        None => return Ok(false),
                    },
                }
            }
        }
        /// Returns a normal (non-fallible) iterator over `Result<Item, Error>`.
        #[inline] fn iterator(self) -> Iterator<Self> where
        Self: Sized
        { Iterator(self) }
        /// Returns an iterator which applies a transform to the errors of the underlying iterator.
        #[inline] fn map_err<B, F>(self, f: F) -> MapErr<Self, F> where
        F: FnMut(Self::Error) -> B,
        Self: Sized
        { MapErr { it: self, f } }
        /// Returns an iterator which unwraps all of its elements.
        #[inline] fn unwrap<T>(self) -> Unwrap<Self> where
        Self: Sized + FallibleIterator<Item = T>,
        Self::Error: core::fmt::Debug
        { Unwrap(self) }
    }

    impl<I: FallibleIterator + ?Sized> FallibleIterator for &mut I
    {
        type Item = I::Item;
        type Error = I::Error;
        #[inline] fn next(&mut self) -> Result<Option<I::Item>, I::Error> { (**self).next() }
        #[inline] fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }
        #[inline] fn nth(&mut self, n: usize) -> Result<Option<I::Item>, I::Error> { (**self).nth(n) }
    }

    impl<I: DoubleEndedFallibleIterator + ?Sized> DoubleEndedFallibleIterator for &mut I
    {
        #[inline] fn next_back(&mut self) -> Result<Option<I::Item>, I::Error> { (**self).next_back() }
    }

    /// Conversion into a `FallibleIterator`.
    pub trait IntoFallibleIterator 
    {
        /// The elements of the iterator.
        type Item;
        /// The error value of the iterator.
        type Error;
        /// The iterator.
        type IntoFallibleIter: FallibleIterator<Item = Self::Item, Error = Self::Error>;
        /// Creates a fallible iterator from a value.
        fn into_fallible_iter(self) -> Self::IntoFallibleIter;
    }

    impl<I> IntoFallibleIterator for I where
    I: FallibleIterator
    {
        type Item = I::Item;
        type Error = I::Error;
        type IntoFallibleIter = I;
        #[inline] fn into_fallible_iter(self) -> I { self }
    }
    /// A fallible, streaming iterator.
    pub trait FallibleStreamingIterator
    {
        /// The type being iterated over.
        type Item: ?Sized;
        /// The error type of iteration.
        type Error;
        /// Advances the iterator to the next position.
        fn advance(&mut self) -> Result<(), Self::Error>;
        /// Returns the current element.
        fn get(&self) -> Option<&Self::Item>;
        /// Advances the iterator, returning the next element.
        #[inline] fn next(&mut self) -> Result<Option<&Self::Item>, Self::Error>
        {
            self.advance()?;
            Ok((*self).get())
        }
        /// Returns bounds on the number of remaining elements in the iterator.
        #[inline] fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }
        /// Determines if all elements of the iterator satisfy a predicate.
        #[inline] fn all<F>(&mut self, mut f: F) -> Result<bool, Self::Error> where
        Self: Sized,
        F: FnMut(&Self::Item) -> bool
        {
            while let Some(e) = self.next()?
            {
                if !f(e) { return Ok(false); }
            }

            Ok(true)
        }
        /// Determines if any elements of the iterator satisfy a predicate.
        #[inline] fn any<F>(&mut self, mut f: F) -> Result<bool, Self::Error> where
        Self: Sized,
        F: FnMut(&Self::Item) -> bool
        { self.all(|e| !f(e)).map(|r| !r) }
        /// Borrows an iterator, rather than consuming it.
        #[inline] fn by_ref(&mut self) -> &mut Self where
        Self: Sized
        { self }
        /// Returns the number of remaining elements in the iterator.
        #[inline] fn count(mut self) -> Result<usize, Self::Error> where
        Self: Sized
        {
            let mut count = 0;
            while let Some(_) = self.next()?
            {
                count += 1;
            }
            
            Ok(count)
        }
        /// Returns an iterator which filters elements by a predicate.
        #[inline] fn filter<F>(self, f: F) -> Filter<Self, F> where
        Self: Sized,
        F: FnMut(&Self::Item) -> bool
        { Filter { it: self, f: f } }
        /// Returns the first element of the iterator which satisfies a predicate.
        #[inline] fn find<F>(&mut self, mut f: F) -> Result<Option<&Self::Item>, Self::Error> where
        Self: Sized,
        F: FnMut(&Self::Item) -> bool
        {
            loop
            {
                self.advance()?;
                match self.get()
                {
                    Some(v) =>
                    {
                        if f(v) { break; }
                    }
                    None => break,
                }
            }
            Ok((*self).get())
        }
        /// Calls a closure on each element of an iterator.
        #[inline] fn for_each<F>(mut self, mut f: F) -> Result<(), Self::Error> where
        Self: Sized,
        F: FnMut(&Self::Item)
        {
            while let Some(value) = self.next()?
            {
                f(value);
            }

            Ok(())
        }
        /// Returns an iterator which is well-behaved at the beginning and end of iteration.
        #[inline] fn fuse(self) -> Fuse<Self> where
        Self: Sized
        {
            Fuse
            {
                it: self,
                state: FuseState::Start,
            }
        }
        /// Returns an iterator which applies a transform to elements.
        #[inline] fn map<F, B>(self, f: F) -> Map<Self, F, B> where
        Self: Sized,
        F: FnMut(&Self::Item) -> B
        {
            Map
            {
                it: self,
                f: f,
                value: None,
            }
        }
        /// Returns an iterator which applies a transform to elements.
        #[inline] fn map_ref<F, B: ?Sized>(self, f: F) -> MapRef<Self, F> where
        Self: Sized,
        F: Fn(&Self::Item) -> &B
        {
            MapRef { it: self, f: f }
        }
        /// Returns an iterator that applies a transform to errors.
        #[inline] fn map_err<F, B>(self, f: F) -> MapErr<Self, F> where
        Self: Sized,
        F: Fn(Self::Error) -> B
        {
            MapErr { it: self, f: f }
        }
        /// Returns the `nth` element of the iterator.
        #[inline] fn nth(&mut self, n: usize) -> Result<Option<&Self::Item>, Self::Error>
        {
            for _ in 0..n
            {
                self.advance()?;
                if let None = self.get() { return Ok(None); }
            }

            self.next()
        }
        /// Returns the position of the first element matching a predicate.
        #[inline] fn position<F>(&mut self, mut f: F) -> Result<Option<usize>, Self::Error> where
        Self: Sized,
        F: FnMut(&Self::Item) -> bool
        {
            let mut pos = 0;
            while let Some(v) = self.next()?
            {
                if f(v) { return Ok(Some(pos)); }
                pos += 1;
            }

            Ok(None)
        }
        /// Returns an iterator which skips the first `n` elements.
        #[inline] fn skip(self, n: usize) -> Skip<Self> where
        Self: Sized
        {
            Skip { it: self, n: n }
        }
        /// Returns an iterator which skips the first sequence of elements matching a predicate.
        #[inline] fn skip_while<F>(self, f: F) -> SkipWhile<Self, F> where
        Self: Sized,
        F: FnMut(&Self::Item) -> bool
        {
            SkipWhile
            {
                it: self,
                f: f,
                done: false,
            }
        }
        /// Returns an iterator which only returns the first `n` elements.
        #[inline] fn take(self, n: usize) -> Take<Self> where
        Self: Sized
        {
            Take
            {
                it: self,
                n: n,
                done: false,
            }
        }
        /// Returns an iterator which only returns the first sequence of elements matching a predicate.
        #[inline] fn take_while<F>(self, f: F) -> TakeWhile<Self, F> where
        Self: Sized,
        F: FnMut(&Self::Item) -> bool
        {
            TakeWhile
            {
                it: self,
                f: f,
                done: false,
            }
        }
    }
}
pub mod marker { pub use std::marker::{ * }; }
pub mod mem { pub use std::mem::{ * }; }
/*
mortal v0.2.4*/
pub mod mortal
{
    //! Platform-independent terminal interface.
    pub use ::
    {
        mortal::
        {
            screen::{ Screen, ScreenReadGuard, ScreenWriteGuard },
            sequence::{ FindResult, SequenceMap },
            signal::{ Signal, SignalSet },
            terminal::
            {
                Color, Cursor, CursorMode, Size, Style, Theme, Event, Key, MouseEvent, MouseInput, MouseButton, 
                ModifierState, PrepareConfig, PrepareState, Terminal, TerminalReadGuard, TerminalWriteGuard,
            }
        },
        *,
    };

    #[macro_use] mod buffer
    {
        use ::
        {
            mem::{ swap },
            mortal::
            {
                terminal::{ Color, Cursor, Size, Style, Theme },
                util::{ char_width, is_combining_mark },
            },
            ops::{ Range },
            str::{ SmallString },
            *,
        };
        
        macro_rules! forward_screen_buffer_methods
        {
            ( |$slf:ident| $field:expr ) =>
            {
                pub fn size(&self) -> ::mortal::terminal::Size
                {
                    let $slf = self;
                    $field.size()
                }

                pub fn cursor(&self) -> ::mortal::terminal::Cursor
                {
                    let $slf = self;
                    $field.cursor()
                }

                pub fn set_cursor(&self, pos: ::mortal::terminal::Cursor)
                {
                    let $slf = self;
                    $field.set_cursor(pos);
                }

                pub fn next_line(&self, column: usize)
                {
                    let $slf = self;
                    $field.next_line(column);
                }

                pub fn clear_screen(&self)
                {
                    let $slf = self;
                    $field.clear_screen();
                }

                pub fn clear_attributes(&self)
                {
                    let $slf = self;
                    $field.clear_attributes();
                }

                pub fn add_style(&self, style: ::mortal::terminal::Style)
                {
                    let $slf = self;
                    $field.add_style(style);
                }

                pub fn remove_style(&self, style: ::mortal::terminal::Style)
                {
                    let $slf = self;
                    $field.remove_style(style);
                }

                pub fn set_style(&self, style: ::mortal::terminal::Style)
                {
                    let $slf = self;
                    $field.set_style(style);
                }

                pub fn set_fg(&self, fg: Option<::mortal::terminal::Color>)
                {
                    let $slf = self;
                    $field.set_fg(fg);
                }

                pub fn set_bg(&self, bg: Option<::mortal::terminal::Color>)
                {
                    let $slf = self;
                    $field.set_bg(bg);
                }

                pub fn set_theme(&self, theme: ::mortal::terminal::Theme)
                {
                    let $slf = self;
                    $field.set_theme(theme)
                }

                pub fn write_char(&self, ch: char)
                {
                    let $slf = self;
                    let _ = $field.write_char(ch);
                }

                pub fn write_str(&self, s: &str)
                {
                    let $slf = self;
                    let _ = $field.write_str(s);
                }

                pub fn write_at(&self, pos: ::mortal::terminal::Cursor, text: &str)
                {
                    let $slf = self;
                    let _ = $field.write_at(pos, text);
                }

                pub fn write_styled
                (
                    &self, 
                    fg: Option<::mortal::terminal::Color>, 
                    bg: Option<::mortal::terminal::Color>, 
                    style: ::mortal::terminal::Style, 
                    text: &str
                )
                {
                    let $slf = self;
                    let _ = $field.write_styled(fg, bg, style, text);
                }

                pub fn write_styled_at
                (
                    &self,
                    pos: ::mortal::terminal::Cursor,
                    fg: Option<::mortal::terminal::Color>,
                    bg: Option<::mortal::terminal::Color>,
                    style: ::mortal::terminal::Style,
                    text: &str
                )
                {
                    let $slf = self;
                    let _ = $field.write_styled_at(pos, fg, bg, style, text);
                }
            }
        }
        
        macro_rules! forward_screen_buffer_mut_methods
        {
            ( |$slf:ident| $field:expr ) =>
            {
                pub fn size(&self) -> ::mortal::terminal::Size
                {
                    let $slf = self;
                    $field.size()
                }

                pub fn cursor(&self) -> ::mortal::terminal::Cursor
                {
                    let $slf = self;
                    $field.cursor()
                }

                pub fn set_cursor(&mut self, pos: ::mortal::terminal::Cursor)
                {
                    let $slf = self;
                    $field.set_cursor(pos);
                }

                pub fn next_line(&mut self, column: usize)
                {
                    let $slf = self;
                    $field.next_line(column);
                }

                pub fn clear_screen(&mut self)
                {
                    let $slf = self;
                    $field.clear_screen();
                }

                pub fn clear_attributes(&mut self)
                {
                    let $slf = self;
                    $field.clear_attributes();
                }

                pub fn add_style(&mut self, style: ::mortal::terminal::Style)
                {
                    let $slf = self;
                    $field.add_style(style);
                }

                pub fn remove_style(&mut self, style: ::mortal::terminal::Style)
                {
                    let $slf = self;
                    $field.remove_style(style);
                }

                pub fn set_style(&mut self, style: ::mortal::terminal::Style)
                {
                    let $slf = self;
                    $field.set_style(style);
                }

                pub fn set_fg(&mut self, fg: Option<::mortal::terminal::Color>)
                {
                    let $slf = self;
                    $field.set_fg(fg);
                }

                pub fn set_bg(&mut self, bg: Option<::mortal::terminal::Color>)
                {
                    let $slf = self;
                    $field.set_bg(bg);
                }

                pub fn set_theme(&mut self, theme: ::mortal::terminal::Theme)
                {
                    let $slf = self;
                    $field.set_theme(theme);
                }

                pub fn write_char(&mut self, ch: char)
                {
                    let $slf = self;
                    let _ = $field.write_char(ch);
                }

                pub fn write_str(&mut self, s: &str)
                {
                    let $slf = self;
                    let _ = $field.write_str(s);
                }

                pub fn write_at(&mut self, pos: ::mortal::terminal::Cursor, text: &str)
                {
                    let $slf = self;
                    let _ = $field.write_at(pos, text);
                }

                pub fn write_styled
                (
                    &mut self,
                    fg: Option<::mortal::terminal::Color>, 
                    bg: Option<::mortal::terminal::Color>,
                    style: ::mortal::terminal::Style, 
                    text: &str
                )
                {
                    let $slf = self;
                    let _ = $field.write_styled(fg, bg, style, text);
                }

                pub fn write_styled_at
                (
                    &mut self, 
                    pos: ::mortal::terminal::Cursor,
                    fg: Option<::mortal::terminal::Color>,
                    bg: Option<::mortal::terminal::Color>,
                    style: ::mortal::terminal::Style, 
                    text: &str
                )
                {
                    let $slf = self;
                    let _ = $field.write_styled_at(pos, fg, bg, style, text);
                }
            }
        }

        const TAB_STOP: usize = 8;

        pub struct ScreenBuffer 
        {
            buffer: Vec<Cell>,
            back_buffer: Vec<Cell>,
            size: Size,
            cursor: Cursor,

            fg: Option<Color>,
            bg: Option<Color>,
            style: Style,
        }

        impl ScreenBuffer
        {
            pub fn new(size: Size) -> ScreenBuffer
            {
                let area = size.area();

                ScreenBuffe
                {
                    buffer: vec![Cell::default(); area],
                    back_buffer: vec![Cell::default(); area],
                    size: size,
                    cursor: Cursor::default(),
                    fg: None,
                    bg: None,
                    style: Style::empty(),
                }
            }

            pub fn cursor(&self) -> Cursor  { self.cursor }

            pub fn size(&self) -> Size { self.size }

            pub fn resize(&mut self, new_size: Size)
            {
                resize_buffer(&mut self.buffer, self.size, new_size);
                new_buffer(&mut self.back_buffer, new_size);
                self.size = new_size;
            }

            pub fn set_cursor(&mut self, pos: Cursor) { self.cursor = pos; }

            pub fn next_line(&mut self, column: usize)
            {
                self.cursor.line += 1;
                self.cursor.column = column;
            }

            pub fn clear_attributes(&mut self)
            {
                self.fg = None;
                self.bg = None;
                self.style = Style::empty();
            }

            pub fn add_style(&mut self, style: Style) { self.style |= style; }

            pub fn remove_style(&mut self, style: Style) { self.style -= style; }

            pub fn set_style(&mut self, style: Style) { self.style = style; }

            pub fn set_fg(&mut self, fg: Option<Color>) { self.fg = fg; }

            pub fn set_bg(&mut self, bg: Option<Color>) { self.bg = bg; }

            pub fn set_theme(&mut self, theme: Theme)
            {
                self.set_fg(theme.fg);
                self.set_bg(theme.bg);
                self.set_style(theme.style);
            }

            pub fn clear_screen(&mut self)
            {
                for cell in &mut self.buffer
                {
                    *cell = Cell::default();
                }
            }

            pub fn indices(&self) -> Range<usize> { 0..self.size.area() }
            
            pub fn next_cell(&mut self, indices: &mut Range<usize>) -> Option<(Cursor, Cell)>
            {
                while let Some(idx) = indices.next()
                {
                    let first = self.buffer[idx].first_char();
                    let width = char_width(first).unwrap_or(0);
                    if width == 2 { let _ = indices.next(); }

                    if self.buffer[idx] != self.back_buffer[idx]
                    {
                        let cell = self.buffer[idx].clone();
                        let line = idx / self.size.columns;
                        let column = idx % self.size.columns;
                        self.back_buffer[idx] = cell.clone();
                        return Some((Cursor{line, column}, cell));
                    }
                }

                None
            }
            
            fn cell_mut(&mut self, pos: Cursor) -> &mut Cell
            {
                let size = self.size;
                &mut self.buffer[pos.as_index(size)]
            }

            fn set_cell(&mut self, pos: Cursor, ch: char)
            {
                let fg = self.fg;
                let bg = self.bg;
                let style = self.style;
                let cell = self.cell_mut(pos);
                cell.fg = fg;
                cell.bg = bg;
                cell.style = style;
                cell.text = ch.into();
            }

            pub fn write_char(&mut self, ch: char) -> Result<(), OutOfBounds>
            {
                if ch == '\t'
                {
                    self.try_cursor()?;
                    let rem = self.size.columns - self.cursor.column;
                    let n = rem.min(TAB_STOP - (self.cursor.column % TAB_STOP));

                    for _ in 0..n
                    {
                        self.write_char(' ')?;
                    }

                }
                else if ch == '\r' { self.cursor.column = 0; } 
                else if ch == '\n'
                {
                    self.cursor.line += 1;
                    self.cursor.column = 0;
                }
                else if is_combining_mark(ch)
                {
                    if let Some(prev) = self.cursor.previous(self.size)
                    {
                        self.try_cursor_at(prev)?;
                        self.cell_mut(prev).text.push(ch);
                    }
                }
                else if is::visible(ch)
                {
                    self.try_cursor()?;
                    if let Some(prev) = self.cursor.previous(self.size)
                    {
                        let cell = self.cell_mut(prev);
                        if cell.is_wide() { *cell = Cell::default(); }
                    }

                    let rem = self.size.columns - self.cursor.column;
                    let width = char_width(ch).unwrap_or(0);
                    
                    if rem < width
                    {
                        self.try_cursor()?;
                        let mut pos = self.cursor;
                        for _ in 0..rem
                        {
                            self.set_cell(pos, ch);
                            pos.column += 1;
                        }

                        self.cursor.column = 0;
                        self.cursor.line += 1;
                    }

                    self.try_cursor()?;
                    let mut pos = self.cursor;
                    self.set_cell(pos, ch);

                    for _ in 1..width
                    {
                        pos.column += 1;
                        self.set_cell(pos, ' ');
                    }

                    self.cursor.column += width;

                    if self.cursor.column >= self.size.columns
                    {
                        self.cursor.line += 1;
                        self.cursor.column = 0;
                    }
                }

                Ok(())
            }

            pub fn write_str(&mut self, s: &str) -> Result<(), OutOfBounds>
            {
                for ch in s.chars()
                {
                    self.write_char(ch)?;
                }

                Ok(())
            }

            pub fn write_at(&mut self, pos: Cursor, text: &str) -> Result<(), OutOfBounds>
            {
                self.try_cursor_at(pos)?;
                self.cursor = pos;
                self.write_str(text)
            }

            pub fn write_styled(&mut self, fg: Option<Color>, bg: Option<Color>, style: Style, text: &str) -> 
            Result<(), OutOfBounds>
            {
                self.fg = fg;
                self.bg = bg;
                self.style = style;
                self.write_str(text)?;
                self.clear_attributes();
                Ok(())
            }

            pub fn write_styled_at(&mut self, pos: Cursor, fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
            -> Result<(), OutOfBounds>
            {
                self.try_cursor_at(pos)?;
                self.cursor = pos;
                self.write_styled(fg, bg, style, text)
            }

            fn try_cursor(&self) -> Result<(), OutOfBounds> { self.try_cursor_at(self.cursor) }

            fn try_cursor_at(&self, pos: Cursor) -> Result<(), OutOfBounds>
            {
                if pos.line >= self.size.lines || pos.column >= self.size.columns { Err(OutOfBounds(())) } 
                else { Ok(()) }
            }
        }

        #[derive(Debug)]
        pub struct OutOfBounds(());

        #[derive(Clone, Debug, Eq, PartialEq)]
        pub struct Cell
        {
            fg: Option<Color>,
            bg: Option<Color>,
            style: Style,
            text: SmallString<[u8; 8]>,
        }

        impl Cell
        {
            fn new(fg: Option<Color>, bg: Option<Color>, style: Style, chr: char) -> Cell
            {
                Cell
                {
                    fg,
                    bg,
                    style,
                    text: chr.into(),
                }
            }

            fn invalid() -> Cell
            {
                Cell
                {
                    fg: None,
                    bg: None,
                    style: Style::empty(),
                    text: SmallString::new(),
                }
            }

            pub fn attrs(&self) -> (Option<Color>, Option<Color>, Style) { (self.fg, self.bg, self.style) }

            pub fn text(&self) -> &str { &self.text }

            fn first_char(&self) -> char { self.text.chars().next().expect("empty cell text") }

            fn is_wide(&self) -> bool { self.text.chars().next().and_then(char_width).unwrap_or(0) == 2 }
        }

        impl Default for Cell
        {
            fn default() -> Cell { Cell::new(None, None, Style::empty(), ' ') }
        }

        fn resize_buffer(buf: &mut Vec<Cell>, old: Size, new: Size)
        {
            if old != new
            {
                let mut new_buf = vec![Cell::default(); new.area()];

                if !buf.is_empty()
                {
                    let n_cols = old.columns.min(new.columns);

                    for (old, new) in buf.chunks_mut(old.columns).zip(new_buf.chunks_mut(new.columns))
                    {
                        for i in 0..n_cols 
                        {
                            swap(&mut new[i], &mut old[i]);
                        }
                    }
                }

                *buf = new_buf;
            }
        }

        fn new_buffer(buf: &mut Vec<Cell>, new_size: Size) { *buf = vec![Cell::invalid(); new_size.area()]; }
    }
    
    #[macro_use] pub mod macros
    {
        //! Provides macros easier printing with colors and styles.
        use ::
        {
            *,
        };
        /// Writes attributes and formatted text to a `Terminal` or `Screen`.
        #[macro_export] macro_rules! term_write 
        {
            // Entry rule
            ( $term:expr , $first:tt $($rest:tt)* ) =>
            {
                match $term.borrow_term_write_guard()
                {
                    mut term =>
                    {
                        let init = ::mortal::macros::Chain::init();
                        term_write!(@_INTERNAL main: term ; init ; $first $($rest)*)
                    }
                }
            };
            // Final rule
            ( @_INTERNAL main: $term:expr ; $result:expr ; ) => { $result };
            // Color/style rules
            ( @_INTERNAL main: $term:expr ; $result:expr ; [ $($tt:tt)* ] $($rest:tt)* ) =>
            {
                term_write!
                (
                    @_INTERNAL main: $term;
                    term_write!(@_INTERNAL style: $term; $result; $($tt)*);
                    $($rest)*
                )
            };
            // Formatting rules
            ( @_INTERNAL main: $term:expr ; $result:expr ; ( $($tt:tt)* ) $($rest:tt)* ) =>
            {
                term_write!
                (
                    @_INTERNAL main: $term;
                    term_write!(@_INTERNAL format: $term; $result; $($tt)*);
                    $($rest)*
                )
            };
            ( @_INTERNAL main: $term:expr ; $result:expr ; $tt:tt $($rest:tt)* ) =>
            {
                term_write!
                (
                    @_INTERNAL main: $term;
                    term_write!(@_INTERNAL literal: $term; $result; $tt);
                    $($rest)*
                )
            };
            // Set foreground color
            ( @_INTERNAL style: $term:expr ; $result:expr ; black ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_fg(::mortal::Color::Black)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; blue ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_fg(::mortal::Color::Blue)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; cyan ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_fg(::mortal::Color::Cyan)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; green ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_fg(::mortal::Color::Green)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; magenta ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_fg(::mortal::Color::Magenta)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; red ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_fg(::mortal::Color::Red)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; white ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_fg(::mortal::Color::White)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; yellow ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_fg(::mortal::Color::Yellow)) };
            // Set background color
            ( @_INTERNAL style: $term:expr ; $result:expr ; # black ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_bg(::mortal::Color::Black)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # blue ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_bg(::mortal::Color::Blue)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # cyan ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_bg(::mortal::Color::Cyan)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # green ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_bg(::mortal::Color::Green)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # magenta ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_bg(::mortal::Color::Magenta)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # red ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_bg(::mortal::Color::Red)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # white ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_bg(::mortal::Color::White)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; # yellow ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_bg(::mortal::Color::Yellow)) };
            // Add style
            ( @_INTERNAL style: $term:expr ; $result:expr ; bold ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.add_style(::mortal::Style::BOLD)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; italic ) =>
            { ::mortal::macros::Chain::chain( $result, || $term.add_style(::mortal::Style::ITALIC)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; reverse ) =>
            { ::mortal::macros::Chain::chain( $result, || $term.add_style(::mortal::Style::REVERSE)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; underline ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.add_style(::mortal::Style::UNDERLINE)) };
            // Remove style
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! bold ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.remove_style(::mortal::Style::BOLD)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! italic ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.remove_style(::mortal::Style::ITALIC)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! reverse ) =>
            { ::mortal::macros::Chain::chain( $result, || $term.remove_style(::mortal::Style::REVERSE)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! underline ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.remove_style(::mortal::Style::UNDERLINE)) };
            // Clear attributes
            ( @_INTERNAL style: $term:expr ; $result:expr ; reset ) =>
            { ::mortal::macros::Chain::chain( $result, || $term.clear_attributes()) };            
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! fg ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_fg(None)) };            
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! bg ) =>
            { ::mortal::macros::Chain::chain( $result, || $term.set_bg(None)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; ! style ) =>
            { ::mortal::macros::Chain::chain( $result, || $term.set_style(None)) };
            // Color/style expressions
            ( @_INTERNAL style: $term:expr ; $result:expr ; fg = $e:expr ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_fg($e)) };            
            ( @_INTERNAL style: $term:expr ; $result:expr ; bg = $e:expr ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.set_bg($e)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; style = $e:expr ) =>
            { ::mortal::macros::Chain::chain( $result, || $term.set_style($e)) };            
            ( @_INTERNAL style: $term:expr ; $result:expr ; style += $e:expr ) => 
            { ::mortal::macros::Chain::chain( $result, || $term.add_style($e)) };            
            ( @_INTERNAL style: $term:expr ; $result:expr ; style -= $e:expr ) =>
            { ::mortal::macros::Chain::chain( $result, || $term.remove_style($e)) };
            ( @_INTERNAL style: $term:expr ; $result:expr ; theme = $e:expr ) =>
            { ::mortal::macros::Chain::chain( $result, || $term.set_theme($e)) };
            // std::fmt formatting
            ( @_INTERNAL format: $term:expr ; $result:expr ; : $e:expr ) =>
            { ::mortal::macros::Chain::chain( $result, || write!($term, "{}", $e)) };            
            ( @_INTERNAL format: $term:expr ; $result:expr ; ? $e:expr ) =>
            { ::mortal::macros::Chain::chain( $result, || write!($term, "{:?}", $e)) };            
            ( @_INTERNAL format: $term:expr ; $result:expr ; $($tt:tt)* ) =>
            { ::mortal::macros::Chain::chain( $result, || write!($term, $($tt)*)) };
            // Literal formatting
            ( @_INTERNAL literal: $term:expr ; $result:expr ; $lit:tt ) =>
            { ::mortal::macros::Chain::chain( $result, || $term.write_str(concat!($lit))) };
        }
        /// Writes attributes and formatted text to a `Terminal` or `Screen`.
        #[macro_export] macro_rules! term_writeln
        {
            ( $term:expr ) => { term_write!($term, "\n") };
            ( $term:expr , $($tt:tt)* ) => { term_write!($term, $($tt)* "\n") };
        }
        /// Facilitates chaining calls from either a `Terminal` or `Screen` lock.
        pub trait Chain: Sized
        {
            fn chain<F: FnOnce() -> Self>(self, f: F) -> Self;
            fn init() -> Self;
        }

        impl Chain for ()
        {
            fn chain<F: FnOnce() -> Self>(self, f: F) -> Self { f() }
            fn init() -> Self { }
        }

        impl Chain for io::Result<()>
        {
            fn chain<F: FnOnce() -> Self>(self, f: F) -> Self { self.and_then(|_| f()) }
            fn init() -> Self { Ok(()) }
        }
    }

    mod priv_util
    {
        use ::
        {
            mortal::
            {
                screen::{ Screen, ScreenReadGuard },
                terminal::{ Terminal, TerminalReadGuard },
                util::{ char_width },
            },
            sync::{LockResult, PoisonError, TryLockError, TryLockResult},
            *,
        };
        /// Private trait used to prevent external crates from implementing extension traits
        pub trait Private {}
        impl Private for Screen {}
        impl<'a> Private for ScreenReadGuard<'a> {}
        impl Private for Terminal {}
        impl<'a> Private for TerminalReadGuard<'a> {}

        pub fn map_lock_result<F, T, U>(res: LockResult<T>, f: F) -> LockResult<U> where F: FnOnce(T) -> U
        {
            match res
            {
                Ok(t) => Ok(f(t)),
                Err(e) => Err(PoisonError::new(f(e.into_inner()))),
            }
        }

        pub fn map_try_lock_result<F, T, U>(res: TryLockResult<T>, f: F) -> TryLockResult<U> where 
        F: FnOnce(T) -> U
        {
            match res
            {
                Ok(t) => Ok(f(t)),
                Err(TryLockError::Poisoned(p)) => Err(TryLockError::Poisoned( PoisonError::new(f(p.into_inner())))),
                Err(TryLockError::WouldBlock) => Err(TryLockError::WouldBlock),
            }
        }

        pub fn map2_lock_result<F, T, U, R>(res: LockResult<T>, res2: LockResult<U>, f: F) -> LockResult<R> where 
        F: FnOnce(T, U) -> R
        {
            match (res, res2)
            {
                (Ok(a), Ok(b)) => Ok(f(a, b)),
                (Ok(a), Err(b)) => Err(PoisonError::new(f(a, b.into_inner()))),
                (Err(a), Ok(b)) => Err(PoisonError::new(f(a.into_inner(), b))),
                (Err(a), Err(b)) => Err(PoisonError::new(f(a.into_inner(), b.into_inner()))),
            }
        }

        pub fn map2_try_lock_result<F, T, U, R>( res: TryLockResult<T>, res2: TryLockResult<U>, f: F) -> 
        TryLockResult<R> where 
        F: FnOnce(T, U) -> R
        {
            match (res, res2)
            {
                (Ok(a), Ok(b)) => Ok(f(a, b)),
                (Err(TryLockError::WouldBlock), _) => Err(TryLockError::WouldBlock),
                (_, Err(TryLockError::WouldBlock)) => Err(TryLockError::WouldBlock),
                (Ok(a), Err(TryLockError::Poisoned(b))) => Err(TryLockError::Poisoned(PoisonError::new(f(a, b.into_inner())))),
                (Err(TryLockError::Poisoned(a)), Ok(b)) => Err(TryLockError::Poisoned(PoisonError::new(f(a.into_inner(), b)))),
                
                (Err(TryLockError::Poisoned(a)), Err(TryLockError::Poisoned(b))) => 
                Err(TryLockError::Poisoned(PoisonError::new( f(a.into_inner(), b.into_inner())))),
            }
        }
    }

    pub mod screen
    {
        //! Provides a drawable buffer on terminal devices
        use ::
        {
            mortal::
            {
                priv_util::{ map_lock_result, map_try_lock_result },
                sys::{ self },
                terminal::{ Color, Cursor, CursorMode, Event, PrepareConfig, Size, Style, Theme, Terminal }
            },
            sync::{ LockResult, TryLockResult },
            time::{ Duration },
            *,
        };
        /// Provides operations on an underlying terminal device in screen mode.
        pub struct Screen(sys::Screen);
        /// Holds an exclusive lock for read operations on a `Screen`.
        pub struct ScreenReadGuard<'a>(sys::ScreenReadGuard<'a>);
        /// Holds an exclusive lock for write operations on a `Screen`.
        pub struct ScreenWriteGuard<'a>(sys::ScreenWriteGuard<'a>);

        impl Screen
        {
            /// Opens a new screen interface on `stdout`.
            pub fn new(config: PrepareConfig) -> io::Result<Screen> { sys::Screen::stdout(config).map(Screen) }
            /// Opens a new screen interface on `stderr`.
            pub fn stderr(config: PrepareConfig) -> io::Result<Screen> { sys::Screen::stderr(config).map(Screen) }
            /// Begins a new screen session using the given `Terminal` instance.
            pub fn with_terminal(term: Terminal, config: PrepareConfig) -> io::Result<Screen>
            { sys::Screen::new(term.0, config).map(Screen) }
            /// Returns the name of the terminal.
            #[inline] pub fn name(&self) -> &str { self.0.name() }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn lock_read(&self) -> LockResult<ScreenReadGuard> 
            { map_lock_result(self.0.lock_read(), ScreenReadGuard) }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn lock_write(&self) -> LockResult<ScreenWriteGuard> 
            { map_lock_result(self.0.lock_write(), ScreenWriteGuard) }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard> 
            { map_try_lock_result(self.0.try_lock_read(), ScreenReadGuard) }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard>
            { map_try_lock_result(self.0.try_lock_write(), ScreenWriteGuard) }
        }

        /// # Locking
        /// The following methods internally acquire the read lock. The lock is released before the method returns.
        impl Screen
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> { self.0.wait_event(timeout) }
            /// Reads an event from the terminal.
            pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> { self.0.read_event(timeout) }
        }
        /// # Locking
        /// The following methods internally acquire the write lock. The lock is released before the method returns.
        impl Screen
        {
            /// Returns the current size of the terminal screen.
            #[inline] pub fn size(&self) -> Size { self.0.size() }
            /// Returns the current cursor position.
            #[inline] pub fn cursor(&self) -> Cursor { self.0.cursor() }
            /// Sets the cursor position.
            #[inline] pub fn set_cursor<C: Into<Cursor>>(&self, pos: C) { self.0.set_cursor(pos.into()); }
            /// Moves the cursor to the given column on the next line.
            #[inline] pub fn next_line(&self, column: usize) { self.0.next_line(column); }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> { self.0.set_cursor_mode(mode) }
            /// Clears the internal screen buffer.
            pub fn clear_screen(&self) { self.0.clear_screen(); }
            /// Adds a set of `Style` flags to the current style setting.
            #[inline] pub fn add_style(&self, style: Style) { self.0.add_style(style); }
            /// Removes a set of `Style` flags to the current style setting.
            #[inline] pub fn remove_style(&self, style: Style) { self.0.remove_style(style); }
            /// Sets the current style setting to the given set of flags.
            #[inline] pub fn set_style<S: Into<Option<Style>>>(&self, style: S)
            { self.0.set_style(style.into().unwrap_or_default()); }
            /// Sets or removes foreground text color.
            #[inline] pub fn set_fg<C: Into<Option<Color>>>(&self, fg: C) { self.0.set_fg(fg.into()); }
            /// Sets or removes background text color.
            #[inline] pub fn set_bg<C: Into<Option<Color>>>(&self, bg: C) { self.0.set_bg(bg.into()); }
            /// Sets all attributes for the screen.
            #[inline] pub fn set_theme(&self, theme: Theme) { self.0.set_theme(theme) }
            /// Removes color and style attributes.
            #[inline] pub fn clear_attributes(&self) { self.0.clear_attributes(); }
            /// Adds bold to the current style setting.
            #[inline] pub fn bold(&self) { self.add_style(Style::BOLD); }
            /// Adds italic to the current style setting.
            #[inline] pub fn italic(&self) { self.add_style(Style::ITALIC); }
            /// Adds underline to the current style setting.
            #[inline] pub fn underline(&self) { self.add_style(Style::UNDERLINE); }
            /// Adds reverse to the current style setting.
            #[inline] pub fn reverse(&self) { self.add_style(Style::REVERSE); }
            /// Renders the internal buffer to the terminal screen.
            pub fn refresh(&self) -> io::Result<()> { self.0.refresh() }
            /// Writes text at the given position within the screen buffer.
            pub fn write_at<C>(&self, position: C, text: &str) where 
            C: Into<Cursor>
            { self.0.write_at(position.into(), text); }
            /// Writes text with the given attributes at the current cursor position.
            pub fn write_styled<F, B, S>(&self, fg: F, bg: B, style: S, text: &str) where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), text); }
            /// Writes text with the given attributes at the given position within the screen buffer.
            pub fn write_styled_at<C, F, B, S>(&self, position: C, fg: F, bg: B, style: S, text: &str) where
            C: Into<Cursor>,
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { self.0.write_styled_at(position.into(), fg.into(), bg.into(), style.into().unwrap_or_default(), text); }
            /// Writes a single character at the cursor position using the current style and color settings.
            pub fn write_char(&self, ch: char) { self.0.write_char(ch); }
            /// Writes a string at the cursor position using the current style and color settings.
            pub fn write_str(&self, s: &str) { self.0.write_str(s); }
            /// Writes formatted text at the cursor position using the current style and color settings.
            pub fn write_fmt(&self, args: fmt::Arguments)
            {
                let s = args.to_string();
                self.write_str(&s)
            }
            
            pub fn borrow_term_write_guard(&self) -> ScreenWriteGuard { self.lock_write().unwrap() }
        }

        impl<'a> ScreenReadGuard<'a>
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> { self.0.wait_event(timeout) }
            /// Reads an event from the terminal.
            pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
            { self.0.read_event(timeout) }
        }

        impl<'a> ScreenWriteGuard<'a> 
        {
            /// Returns the current size of the terminal screen.
            #[inline] pub fn size(&self) -> Size { self.0.size() }
            /// Sets the cursor position.
            #[inline] pub fn cursor(&self) -> Cursor { self.0.cursor() }
            /// Moves the cursor to the given column on the next line.
            #[inline] pub fn set_cursor<C: Into<Cursor>>(&mut self, pos: C) { self.0.set_cursor(pos.into()); }
            /// Set the current cursor mode.
            #[inline] pub fn next_line(&mut self, column: usize) { self.0.next_line(column); }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> { self.0.set_cursor_mode(mode) }
            /// Adds a set of `Style` flags to the current style setting.
            pub fn clear_screen(&mut self) { self.0.clear_screen(); }
            /// Removes a set of `Style` flags to the current style setting,
            /// then adds a set of `Style` flags to the current style setting.
            #[inline] pub fn add_style(&mut self, style: Style) { self.0.add_style(style) }
            /// Sets the current style setting to the given set of flags.
            #[inline] pub fn remove_style(&mut self, style: Style) { self.0.remove_style(style) }
            /// Sets or removes foreground text color.
            #[inline] pub fn set_style<S: Into<Option<Style>>>(&mut self, style: S)
            { self.0.set_style(style.into().unwrap_or_default()) }
            /// Sets or removes background text color.
            #[inline] pub fn set_fg<C: Into<Option<Color>>>(&mut self, fg: C) { self.0.set_fg(fg.into()) }
            /// Removes color and style attributes.
            #[inline] pub fn set_bg<C: Into<Option<Color>>>(&mut self, bg: C) { self.0.set_bg(bg.into()) }
            /// Sets all attributes for the screen.
            #[inline] pub fn set_theme(&mut self, theme: Theme) { self.0.set_theme(theme) }
            /// Adds bold to the current style setting.
            #[inline] pub fn clear_attributes(&mut self) { self.0.clear_attributes() }
            /// Adds bold to the current style setting.
            #[inline] pub fn bold(&mut self) { self.add_style(Style::BOLD) }
            /// Adds italic to the current style setting.
            #[inline] pub fn italic(&mut self) { self.add_style(Style::ITALIC); }
            /// Adds underline to the current style setting.
            #[inline] pub fn underline(&mut self) { self.add_style(Style::UNDERLINE) }
            /// Adds reverse to the current style setting.
            pub fn reverse(&mut self) { self.add_style(Style::REVERSE) }
            /// Renders the internal buffer to the terminal screen.
            pub fn refresh(&mut self) -> io::Result<()> { self.0.refresh() }
            /// Writes text at the given position within the screen buffer.
            pub fn write_at<C>(&mut self, position: C, text: &str) where
            C: Into<Cursor>
            { self.0.write_at(position.into(), text) }
            /// Writes text with the given attributes at the current cursor position.
            pub fn write_styled<F, B, S>(&mut self, fg: F, bg: B, style: S, text: &str) where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), text) }
            /// Writes text with the given attributes at the given position within the screen buffer.
            pub fn write_styled_at<C, F, B, S>(&mut self, position: C, fg: F, bg: B, style: S, text: &str) where
            C: Into<Cursor>,
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { self.0.write_styled_at(position.into(), fg.into(), bg.into(), style.into().unwrap_or_default(), text) }
            /// Writes a single character at the cursor position using the current style and color settings.
            pub fn write_char(&mut self, ch: char) { self.0.write_char(ch) }
            /// Writes a string at the cursor position using the current style and color settings.
            pub fn write_str(&mut self, s: &str) { self.0.write_str(s) }
            /// Writes formatted text at the cursor position using the current style and color settings.
            pub fn write_fmt(&mut self, args: fmt::Arguments) 
            {
                let s = args.to_string();
                self.write_str(&s)
            }
            
            pub fn borrow_term_write_guard(&mut self) -> &mut Self { self }
        }
        
        impl ::mortal::unix::TerminalExt for Screen
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
            { self.0.read_raw(buf, timeout) }
        }
        
        impl<'a> ::mortal::unix::TerminalExt for ScreenReadGuard<'a>
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
            { self.0.read_raw(buf, timeout) }
        }
        /*
            #[cfg(windows)]
            impl crate::windows::TerminalExt for Screen {
                fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.0.read_raw(buf, timeout)
                }

                fn read_raw_event(&mut self, events: &mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.0.read_raw_event(events, timeout)
                }
            }

            #[cfg(windows)]
            impl<'a> crate::windows::TerminalExt for ScreenReadGuard<'a> {
                fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.0.read_raw(buf, timeout)
                }

                fn read_raw_event(&mut self, events: &mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.0.read_raw_event(events, timeout)
                }
            } 
        */  
    }

    pub mod sequence
    {
        //! Utilities for manipulating raw input sequences
        use ::
        {
            iter::{ FromIterator },
            mem::{ replace },
            *,
        };
        /// Contains a set of string sequences, mapped to a value.
        #[derive(Clone, Debug, Default)]
        pub struct SequenceMap<K, V>
        {
            sequences: Vec<(K, V)>,
        }
        /// Represents the result of a `SequenceMap::find` operation.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum FindResult<V>
        {
            /// No contained sequences begin with the provided input sequence.
            NotFound,
            /// One or more sequences begin with the provided input sequence,
            /// but the sequence does not represent a complete sequence.
            Incomplete,
            /// A sequence was found exactly matching the input sequence;
            /// additionally, one or more sequences begin with the input sequence.
            Undecided(V),
            /// A sequence was found exactly matching the input sequence;
            /// no additional partially-matching sequences exist.
            Found(V),
        }

        impl<'a, V: Clone> FindResult<&'a V>
        {
            /// Maps `FindResult<&V>` to `FindResult<V>` by cloning the contents of the result value.
            pub fn cloned(self) -> FindResult<V>
            {
                match self
                {
                    FindResult::NotFound => FindResult::NotFound,
                    FindResult::Incomplete => FindResult::Incomplete,
                    FindResult::Undecided(v) => FindResult::Undecided(v.clone()),
                    FindResult::Found(v) => FindResult::Found(v.clone()),
                }
            }
        }

        impl<K: AsRef<str>, V> SequenceMap<K, V>
        {
            /// Creates an empty `SequenceMap`.
            pub fn new() -> SequenceMap<K, V> { SequenceMap::with_capacity(0) }
            /// Creates an empty `SequenceMap` with allocated capacity for `n` elements.
            pub fn with_capacity(n: usize) -> SequenceMap<K, V>
            {
                SequenceMap
                {
                    sequences: Vec::with_capacity(n),
                }
            }
            /// Returns a slice of all contained sequences, sorted by key.
            pub fn sequences(&self) -> &[(K, V)] { &self.sequences }
            /// Returns a mutable slice of all contained sequences, sorted by key.
            pub fn sequences_mut(&mut self) -> &mut [(K, V)]
            {
                &mut self.sequences
            }
            /// Returns an `Entry` for the given key.
            pub fn entry(&mut self, key: K) -> Entry<K, V>
            {
                match self.search(key.as_ref())
                {
                    Ok(n) => Entry::Occupied(OccupiedEntry
                    {
                        map: self,
                        index: n,
                    }),
                    
                    Err(n) => Entry::Vacant(VacantEntry
                    {
                        map: self,
                        key,
                        index: n,
                    })
                }
            }
            /// Performs a search for a partial or complete sequence match.
            pub fn find(&self, key: &str) -> FindResult<&V>
            {
                let (n, found) = match self.search(key)
                {
                    Ok(n) => (n, true),
                    Err(n) => (n, false)
                };

                let incomplete = self.sequences.get(n + (found as usize))
                .map_or(false, |&( ref next, _)| next.as_ref().starts_with(key));

                match (found, incomplete)
                {
                    (false, false) => FindResult::NotFound,
                    (false, true) => FindResult::Incomplete,
                    (true, false) => FindResult::Found(&self.sequences[n].1),
                    (true, true) => FindResult::Undecided(&self.sequences[n].1),
                }
            }
            /// Returns the corresponding value for the given sequence.
            pub fn get(&self, key: &str) -> Option<&V>
            {
                match self.search(key)
                {
                    Ok(n) => Some(&self.sequences[n].1),
                    Err(_) => None
                }
            }
            /// Returns a mutable reference to the corresponding value for the given sequence.
            pub fn get_mut(&mut self, key: &str) -> Option<&mut V>
            {
                match self.search(key)
                {
                    Ok(n) => Some(&mut self.sequences[n].1),
                    Err(_) => None
                }
            }
            /// Inserts a key-value pair into the map.
            pub fn insert(&mut self, key: K, value: V) -> Option<V>
            {
                match self.search(key.as_ref())
                {
                    Ok(n) => Some(replace(&mut self.sequences[n], (key, value)).1),
                    Err(n) =>
                    {
                        self.sequences.insert(n, (key, value));
                        None
                    }
                }
            }
            /// Removes a key-value pair from the map.
            pub fn remove(&mut self, key: &str) -> Option<(K, V)>
            {
                match self.search(key)
                {
                    Ok(n) => Some(self.sequences.remove(n)),
                    Err(_) => None
                }
            }

            fn search(&self, key: &str) -> Result<usize, usize>
            { self.sequences.binary_search_by_key(&key, |&( ref k, _)| &k.as_ref()) }
        }

        impl<K: AsRef<str>, V> From<Vec<(K, V)>> for SequenceMap<K, V>
        {
            /// Creates a `SequenceMap` from a `Vec` of key-value pairs.
            fn from(mut sequences: Vec<(K, V)>) -> SequenceMap<K, V>
            {
                sequences.sort_by(|a, b| a.0.as_ref().cmp(b.0.as_ref()));
                sequences.dedup_by(|a, b| a.0.as_ref() == b.0.as_ref());
                SequenceMap{sequences}
            }
        }

        impl<K: AsRef<str>, V> FromIterator<(K, V)> for SequenceMap<K, V>
        {
            /// Creates a `SequenceMap` from an iterator of key-value pairs.
            fn from_iter<I: IntoIterator<Item=(K, V)>>(iter: I) -> Self
            {
                let iter = iter.into_iter();
                let mut map = SequenceMap::with_capacity(iter.size_hint().0);

                for (k, v) in iter
                {
                    map.insert(k, v);
                }

                map
            }
        }
        /// A view into a single entry of a `SequenceMap`, which may be either occupied or vacant.
        pub enum Entry<'a, K: 'a, V: 'a>
        {
            /// An occupied entry
            Occupied(OccupiedEntry<'a, K, V>),
            /// A vacant entry
            Vacant(VacantEntry<'a, K, V>),
        }
        /// A view into an occupied entry in a `SequenceMap`.
        pub struct OccupiedEntry<'a, K: 'a, V: 'a>
        {
            map: &'a mut SequenceMap<K, V>,
            index: usize,
        }
        /// A view into a vacant entry in a `SequenceMap`.
        pub struct VacantEntry<'a, K: 'a, V: 'a>
        {
            map: &'a mut SequenceMap<K, V>,
            key: K,
            index: usize,
        }

        impl<'a, K, V> Entry<'a, K, V>
        {
            /// Provides in-place mutable access to an occupied entry before any potential inserts into the map.
            pub fn and_modify<F: FnOnce(&mut V)>(self, f: F) -> Self
            {
                match self 
                {
                    Entry::Occupied(mut ent) =>
                    {
                        f(ent.get_mut());
                        Entry::Occupied(ent)
                    }
                    Entry::Vacant(ent) => Entry::Vacant(ent)
                }
            }
            /// Returns a mutable reference to the entry value, inserting the provided default if the entry is vacant.
            pub fn or_insert(self, default: V) -> &'a mut V
            {
                match self
                {
                    Entry::Occupied(ent) => ent.into_mut(),
                    Entry::Vacant(ent) => ent.insert(default)
                }
            }
            /// Returns a mutable reference to the entry value, 
            /// inserting a value using the provided closure if the entry is vacant.
            pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V
            {
                match self
                {
                    Entry::Occupied(ent) => ent.into_mut(),
                    Entry::Vacant(ent) => ent.insert(default())
                }
            }
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K
            {
                match *self
                {
                    Entry::Occupied( ref ent) => ent.key(),
                    Entry::Vacant( ref ent) => ent.key(),
                }
            }
        }

        impl<'a, K, V> OccupiedEntry<'a, K, V> 
        {
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K { &self.map.sequences[self.index].0 }
            /// Returns a borrowed reference to the entry value.
            pub fn get(&self) -> &V { &self.map.sequences[self.index].1 }
            /// Returns a mutable reference to the entry value.
            pub fn get_mut(&mut self) -> &mut V { &mut self.map.sequences[self.index].1 }
            /// Converts the `OccupiedEntry` into a mutable reference whose lifetime is bound to the `SequenceMap`.
            pub fn into_mut(self) -> &'a mut V { &mut self.map.sequences[self.index].1 }
            /// Replaces the entry value with the given value, returning the previous value.
            pub fn insert(&mut self, value: V) -> V { replace(self.get_mut(), value) }
            /// Removes the entry and returns the value.
            pub fn remove(self) -> V { self.map.sequences.remove(self.index).1 }
            /// Removes the entry and returns the key-value pair.
            pub fn remove_entry(self) -> (K, V) { self.map.sequences.remove(self.index) }
        }

        impl<'a, K, V> VacantEntry<'a, K, V>
        {
            /// Returns a borrowed reference to the entry key.
            pub fn key(&self) -> &K { &self.key }
            /// Consumes the `VacantEntry` and returns ownership of the key.
            pub fn into_key(self) -> K { self.key }
            /// Consumes the `VacantEntry` and inserts a value, 
            /// returning a mutable reference to its place in the `SequenceMap`.
            pub fn insert(self, value: V) -> &'a mut V
            {
                self.map.sequences.insert(self.index, (self.key, value));
                &mut self.map.sequences[self.index].1
            }
        }

        impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for Entry<'a, K, V>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                match *self
                {
                    Entry::Occupied( ref ent) => f.debug_tuple("Entry").field(ent).finish(),
                    Entry::Vacant( ref ent) => f.debug_tuple("Entry").field(ent).finish()
                }
            }
        }

        impl<'a, K: fmt::Debug, V: fmt::Debug> fmt::Debug for OccupiedEntry<'a, K, V>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
            { f.debug_struct("OccupiedEntry").field("key", self.key()).field("value", self.get()).finish() }
        }

        impl<'a, K: fmt::Debug, V> fmt::Debug for VacantEntry<'a, K, V>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { f.debug_tuple("VacantEntry").field(self.key()).finish() }
        }
    }

    pub mod signal
    {
        //! Contains types relating to operating system signals
        use ::
        {
            iter::{ FromIterator },
            *,
        };
        
        const NUM_SIGNALS: u8 = 6;

        macro_rules! impl_op
        {
            ( $tr:ident , $tr_meth:ident , $method:ident ) =>
            {
                impl ops::$tr for SignalSet
                {
                    type Output = SignalSet;
                    fn $tr_meth(self, rhs: SignalSet) -> SignalSet { self.$method(rhs) }
                }
            }
        }

        macro_rules! impl_mut_op
        {
            ( $tr:ident , $tr_meth:ident , $method:ident ) =>
            {
                impl ops::$tr for SignalSet
                {
                    fn $tr_meth(&mut self, rhs: SignalSet) { *self = self.$method(rhs); }
                }
            }
        }

        macro_rules! impl_unary_op
        {
            ( $tr:ident , $tr_meth:ident , $method:ident ) =>
            {
                impl ops::$tr for SignalSet
                {
                    type Output = SignalSet;
                    fn $tr_meth(self) -> SignalSet { self.$method() }
                }
            }
        }
        /// Signal received through a terminal device
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Signal
        {
            /// Break signal (`CTRL_BREAK_EVENT`); Windows only
            Break,
            /// Continue signal (`SIGCONT`); Unix only
            Continue,
            /// Interrupt signal (`SIGINT` on Unix, `CTRL_C_EVENT` on Windows)
            Interrupt,
            /// Terminal window resize (`SIGWINCH` on Unix,
            /// `WINDOW_BUFFER_SIZE_EVENT` on Windows)
            ///
            /// When this signal is received, it will be translated into an
            /// `Event::Resize(_)` value containing the new size of the terminal.
            Resize,
            /// Suspend signal (`SIGTSTP`); Unix only
            Suspend,
            /// Quit signal (`SIGQUIT`); Unix only
            Quit,
        }
        
        impl Signal
        {
            fn as_bit(&self) -> u8 { 1 << (*self as u8) }
            fn all_bits() -> u8 { (1 << NUM_SIGNALS) - 1 }
        }

        impl ops::BitOr for Signal 
        {
            type Output = SignalSet;
            fn bitor(self, rhs: Signal) -> SignalSet
            {
                let mut set = SignalSet::new();
                set.insert(self);
                set.insert(rhs);
                set
            }
        }

        impl ops::Not for Signal 
        {
            type Output = SignalSet;
            fn not(self) -> SignalSet { !SignalSet::from(self) }
        }
        /// Represents a set of `Signal` values
        #[derive(Copy, Clone, Default, Eq, PartialEq)]
        pub struct SignalSet( u8 );

        impl SignalSet
        {
            /// Returns an empty `SignalSet`.
            pub fn new() -> SignalSet { SignalSet(0) }
            /// Returns a `SignalSet` containing all available signals.
            pub fn all() -> SignalSet { SignalSet(Signal::all_bits()) }
            /// Returns whether this set contains the given `Signal`.
            pub fn contains(&self, sig: Signal) -> bool { self.0 & sig.as_bit() != 0 }
            /// Returns whether this set contains all signals present in another set.
            pub fn contains_all(&self, other: SignalSet) -> bool { self.0 & other.0 == other.0 }
            /// Returns whether this set contains any signals present in another set.
            pub fn intersects(&self, other: SignalSet) -> bool { self.0 & other.0 != 0 }
            /// Returns whether this set contains any signals.
            pub fn is_empty(&self) -> bool { self.0 == 0 }
            /// Inserts a `Signal` into this set.
            pub fn insert(&mut self, sig: Signal) { self.0 |= sig.as_bit(); }
            /// Removes a `Signal` from this set.
            pub fn remove(&mut self, sig: Signal) { self.0 &= !sig.as_bit(); }
            /// Sets whether this set contains the given `Signal`.
            pub fn set(&mut self, sig: Signal, set: bool)
            {
                if set { self.insert(sig); } 
                else { self.remove(sig); }
            }
            /// Returns the difference of two sets.
            pub fn difference(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 & !other.0) }
            /// Returns the symmetric difference of two sets.
            pub fn symmetric_difference(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 ^ other.0) }
            /// Returns the intersection of two sets.
            pub fn intersection(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 & other.0) }
            /// Returns the union of two sets.
            pub fn union(&self, other: SignalSet) -> SignalSet { SignalSet(self.0 | other.0) }
            /// Returns the inverse of the set.
            pub fn inverse(&self) -> SignalSet { SignalSet(!self.0 & Signal::all_bits()) }
        }

        impl fmt::Debug for SignalSet
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
            {
                const SIGNALS: &[Signal] = &
                [
                    Signal::Break,
                    Signal::Continue,
                    Signal::Interrupt,
                    Signal::Resize,
                    Signal::Suspend,
                    Signal::Quit,
                ];

                let mut first = true;
                f.write_str("SignalSet(")?;

                for &sig in SIGNALS 
                {
                    if self.contains(sig)
                    {
                        if !first { f.write_str(" | ")?; }
                        write!(f, "{:?}", sig)?;
                        first = false;
                    }
                }

                f.write_str(")")
            }
        }

        impl From<Signal> for SignalSet 
        {
            fn from(sig: Signal) -> SignalSet
            {
                let mut set = SignalSet::new();
                set.insert(sig);
                set
            }
        }

        impl Extend<Signal> for SignalSet
        {
            fn extend<I: IntoIterator<Item=Signal>>(&mut self, iter: I)
            {
                for sig in iter 
                { 
                    self.insert(sig); 
                }
            }
        }

        impl FromIterator<Signal> for SignalSet
        {
            fn from_iter<I: IntoIterator<Item=Signal>>(iter: I) -> SignalSet
            {
                let mut set = SignalSet::new();
                set.extend(iter);
                set
            }
        }

        impl_op!{ BitAnd, bitand, intersection }
        impl_op!{ BitOr, bitor, union }
        impl_op!{ BitXor, bitxor, symmetric_difference }
        impl_op!{ Sub, sub, difference }

        impl_unary_op!{ Not, not, inverse }

        impl_mut_op!{ BitAndAssign, bitand_assign, intersection }
        impl_mut_op!{ BitOrAssign, bitor_assign, union }
        impl_mut_op!{ BitXorAssign, bitxor_assign, symmetric_difference }
        impl_mut_op!{ SubAssign, sub_assign, difference }
    }

    pub mod terminal
    {
        //! Provides an interface to terminal devices
        use ::
        {
            mortal::
            {
                priv_util::{ map_lock_result, map_try_lock_result },
                signal::{ Signal, SignalSet },
                sys,
            },
            path::{ Path },
            sync::{ LockResult, TryLockResult },
            time::{ Duration },
            *,
        };
        /// Represents a color attribute applied to text foreground or background.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Color
        {
            /// Black
            Black,
            /// Blue
            Blue,
            /// Cyan
            Cyan,
            /// Green
            Green,
            /// Magenta
            Magenta,
            /// Red
            Red,
            /// White
            White,
            /// Yellow
            Yellow,
        }

        bitflags!
        {
            /// Represents a set of style attributes applied to text.
            #[derive(Copy, Clone, Debug, Default, Eq, PartialEq, Hash)]
            pub struct Style: u8
            {
                /// Bold
                const BOLD      = 1 << 0;
                /// Italic
                const ITALIC    = 1 << 1;
                /// Reverse; foreground and background color swapped
                const REVERSE   = 1 << 2;
                /// Underline
                const UNDERLINE = 1 << 3;
            }
        }

        /// Represents a terminal output theme.
        #[derive(Copy, Clone, Debug, Default)]
        pub struct Theme
        {
            /// Foreground color
            pub fg: Option<Color>,
            /// Background color
            pub bg: Option<Color>,
            /// Style
            pub style: Style,
        }

        impl Theme
        {
            /// Creates a new theme with given values.
            pub fn new<F,B,S>(fg: F, bg: B, style: S) -> Theme where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>> 
            {
                Theme
                {
                    fg: fg.into(),
                    bg: bg.into(),
                    style: style.into().unwrap_or_default(),
                }
            }
            /// Sets the foreground color on the given Theme and returns the new.
            pub fn fg<F>(mut self, fg: F) -> Theme where 
            F: Into<Option<Color>>
            {
                self.fg = fg.into();
                self
            }
            /// Sets the background color on the given Theme and returns the new.
            pub fn bg<B>(mut self, bg: B) -> Theme where B: Into<Option<Color>>
            {
                self.bg = bg.into();
                self
            }
            /// Sets the style on the given Theme and returns the new.
            pub fn style<S>(mut self, style: S) -> Theme where 
            S: Into<Option<Style>>
            {
                self.style = style.into().unwrap_or_default();
                self
            }
        }

        /// Represents the cursor position in a terminal device
        #[derive(Copy, Clone, Debug, Default, Eq, PartialEq)]
        pub struct Cursor
        {
            /// Index of line in terminal, beginning at `0`.
            pub line: usize,
            /// Index of column in terminal, beginning at `0`.
            pub column: usize,
        }

        impl Cursor
        {
            /// Returns the position of the next cell within a terminal of the given size.
            #[inline] pub fn next(&self, size: Size) -> Option<Cursor>
            {
                let mut line = self.line;
                let mut column = self.column + 1;

                if column >= size.columns
                {
                    column = 0;
                    line += 1;
                }

                if line >= size.lines { None } 
                else { Some(Cursor{line, column}) }
            }
            /// Returns the position of the previous cell within a terminal of the given size.
            #[inline] pub fn previous(&self, size: Size) -> Option<Cursor>
            {
                if self.column == 0
                {
                    if self.line == 0 { None } 
                    else { Some(Cursor{line: self.line - 1, column: size.columns - 1}) }
                }
                
                else { Some(Cursor{line: self.line, column: self.column - 1}) }
            }
            /// Returns a `Cursor` pointing to the first cell, i.e. `(0, 0)`.
            #[inline] pub fn first() -> Cursor
            {
                Cursor
                {
                    line: 0,
                    column: 0,
                }
            }
            /// Returns a `Cursor` pointing to the last cell of a screen of the given size.
            #[inline] pub fn last(size: Size) -> Cursor
            {
                Cursor
                {
                    line: size.lines - 1,
                    column: size.columns - 1,
                }
            }
            /// Returns whether the cursor is out of bounds of the given size.
            #[inline] pub fn is_out_of_bounds(&self, size: Size) -> bool 
            { self.line >= size.lines || self.column >= size.columns }

            /// Returns the index of the cursor position within a one-dimensional array of the given size.
            pub(crate) fn as_index(&self, size: Size) -> usize { self.line * size.columns + self.column }
        }

        impl From<(usize, usize)> for Cursor
        {
            /// Returns a `Cursor` value from a `(line, column)` or `(y, x)` tuple.
            fn from((line, column): (usize, usize)) -> Cursor { Cursor{line, column} }
        }
        /// Represents the visual appearance of the cursor in the terminal.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum CursorMode
        {
            /// Normal mode
            Normal,
            /// Invisible mode
            Invisible,
            /// Overwrite mode
            Overwrite,
        }
        /// Represents an event generated from a terminal interface
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Event
        {
            /// Keyboard event
            Key(Key),
            /// Mouse event
            Mouse(MouseEvent),
            /// Raw data read.
            Raw(usize),
            /// Terminal window size changed; contained value is the new size.
            Resize(Size),
            /// Terminal signal received
            Signal(Signal),
            /// No event.
            NoEvent,
        }
        /// Represents a keyboard key press event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Key
        {
            /// Backspace
            Backspace,
            /// Enter
            Enter,
            /// Escape
            Escape,
            /// Tab
            Tab,
            /// Up arrow
            Up,
            /// Down arrow
            Down,
            /// Left arrow
            Left,
            /// Right arrow
            Right,
            /// Delete
            Delete,
            /// Insert
            Insert,
            /// Home
            Home,
            /// End
            End,
            /// PageUp
            PageUp,
            /// PageDown
            PageDown,
            /// Character key
            Char(char),
            /// Control character.
            Ctrl(char),
            /// Function `n` key; e.g. F1, F2, ...
            F(u32),
        }

        impl From<char> for Key 
        {
            fn from(ch: char) -> Key {
                use ::mortal::util::{is_ctrl, unctrl_lower};

                match ch 
                {
                    '\x1b' => Key::Escape,
                    '\x7f' => Key::Backspace,
                    '\r' | '\n' => Key::Enter,
                    '\t' => Key::Tab,
                    _ if is_ctrl(ch) => Key::Ctrl(unctrl_lower(ch)),
                    _ => Key::Char(ch),
                }
            }
        }
        /// Represents a mouse event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub struct MouseEvent 
        {
            /// The position of the mouse within the terminal when the event occurred
            pub position: Cursor,
            /// The input event that occurred
            pub input: MouseInput,
            /// Modifier keys held when the input event occurred.
            pub modifiers: ModifierState,
        }
        /// Represents the type of mouse input event
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum MouseInput
        {
            /// The mouse cursor was moved
            Motion,
            /// A mouse button was pressed
            ButtonPressed(MouseButton),
            /// A mouse button was released
            ButtonReleased(MouseButton),
            /// The mouse wheel was scrolled up
            WheelUp,
            /// The mouse wheel was scrolled down
            WheelDown,
        }
        /// Represents a button on a mouse device
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum MouseButton
        {
            /// Left mouse button
            Left,
            /// Right mouse button
            Right,
            /// Middle mouse button
            Middle,
            /// Other mouse button
            Other(u32),
        }

        bitflags!
        {
            /// Represents a set of modifier keys
            #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
            pub struct ModifierState: u8
            {
                /// Alt key
                const ALT   = 1 << 0;
                /// Ctrl key
                const CTRL  = 1 << 1;
                /// Shift key
                const SHIFT = 1 << 2;
            }
        }
        /// Configures a [`Terminal`] or [`Screen`] instance to read special input.
        #[derive(Copy, Clone, Debug)]
        pub struct PrepareConfig
        {
            /// Whether to block signals that result from user input.
            pub block_signals: bool,
            /// Whether to enable control flow characters.
            pub enable_control_flow: bool,
            pub enable_keypad: bool,
            pub enable_mouse: bool,
            pub always_track_motion: bool,
            /// For each signal in the set, a signal handler will intercept the signal
            /// and report it by returning an `Event::Signal(_)` value.
            pub report_signals: SignalSet,
        }

        impl Default for PrepareConfig 
        {
            fn default() -> PrepareConfig
            {
                PrepareConfig
                {
                    block_signals: true,
                    enable_control_flow: false,
                    enable_keypad: true,
                    enable_mouse: false,
                    always_track_motion: false,
                    report_signals: SignalSet::new(),
                }
            }
        }
        /// Represents a previous device state of a [`Terminal`].
        pub struct PrepareState(sys::PrepareState);
        /// Represents the size of a terminal window
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub struct Size
        {
            /// Number of lines in the terminal
            pub lines: usize,
            /// Number of columns in the terminal
            pub columns: usize,
        }

        impl Size
        {
            /// Returns the total number of cells in a terminal of the given size.
            #[inline] pub fn area(&self) -> usize 
            { self.checked_area().unwrap_or_else( || panic!("overflow in Size::area {:?}", self)) }
            /// Returns the total number of cells in a terminal of the given size.
            #[inline] pub fn checked_area(&self) -> Option<usize> { self.lines.checked_mul(self.columns) }
        }
        /// Provides concurrent read and write access to a terminal device.
        pub struct Terminal(pub(crate) sys::Terminal);
        /// Holds an exclusive lock for read operations on a `Terminal`.
        pub struct TerminalReadGuard<'a>(sys::TerminalReadGuard<'a>);
        /// Holds an exclusive lock for write operations on a `Terminal`.
        pub struct TerminalWriteGuard<'a>(sys::TerminalWriteGuard<'a>);

        impl Terminal 
        {
            /// Opens a new interface to the terminal on `stdout`.
            pub fn new() -> io::Result<Terminal> { Ok(Terminal(sys::Terminal::stdout()?)) }
            /// Opens a new interface to the terminal on `stderr`.
            pub fn stderr() -> io::Result<Terminal> { Ok(Terminal(sys::Terminal::stderr()?)) }
            /// Returns the name of the terminal.
            #[inline] pub fn name(&self) -> &str { self.0.name() }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn lock_read(&self) -> LockResult<TerminalReadGuard> 
            { map_lock_result(self.0.lock_read(), TerminalReadGuard) }

            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn lock_write(&self) -> LockResult<TerminalWriteGuard>
            { map_lock_result(self.0.lock_write(), TerminalWriteGuard) }
            /// Attempts to acquire an exclusive lock on terminal read operations.
            #[inline] pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard>
            { map_try_lock_result(self.0.try_lock_read(), TerminalReadGuard) }
            /// Attempts to acquire an exclusive lock on terminal write operations.
            #[inline] pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard>
            { map_try_lock_result(self.0.try_lock_write(), TerminalWriteGuard) }
        }
        /// # Locking
        /// The following methods internally acquire both the read and write locks.
        /// The locks are released before the method returns.
        impl Terminal
        {
            /// Prepares the terminal to read input.
            pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState> 
            { self.0.prepare(config).map(PrepareState) }
            /// Restores the terminal to its previous state.
            pub fn restore(&self, state: PrepareState) -> io::Result<()> { self.0.restore(state.0) }
        }
        /// # Locking
        /// The following methods internally acquire the read lock.
        /// The lock is released before the method returns.
        impl Terminal
        {
            /// Waits for an event from the terminal.
            pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> { self.0.wait_event(timeout) }
            /// Waits for input and reads an event from the terminal.
            pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> { self.0.read_event(timeout) }
        }
        /// # Locking
        /// The following methods internally acquire the write lock.
        /// The lock is released before the method returns.
        impl Terminal
        {
            /// Returns the size of the terminal.
            #[inline] pub fn size(&self) -> io::Result<Size> { self.0.size() }
            /// Clears the terminal screen, placing the cursor at the first line and column.
            pub fn clear_screen(&self) -> io::Result<()> { self.0.clear_screen() }
            /// Clears the current line, starting at cursor position.
            pub fn clear_to_line_end(&self) -> io::Result<()> { self.0.clear_to_line_end() }
            /// Clears the screen, starting at cursor position.
            pub fn clear_to_screen_end(&self) -> io::Result<()> { self.0.clear_to_screen_end() }
            /// Moves the cursor up `n` lines.
            pub fn move_up(&self, n: usize) -> io::Result<()> { self.0.move_up(n) }
            /// Moves the cursor down `n` lines.
            pub fn move_down(&self, n: usize) -> io::Result<()> { self.0.move_down(n) }
            /// Moves the cursor left `n` columns.
            pub fn move_left(&self, n: usize) -> io::Result<()> { self.0.move_left(n) }
            /// Moves the cursor right `n` columns.
            pub fn move_right(&self, n: usize) -> io::Result<()> { self.0.move_right(n) }
            /// Moves the cursor to the first column of the current line
            pub fn move_to_first_column(&self) -> io::Result<()> { self.0.move_to_first_column() }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> { self.0.set_cursor_mode(mode) }
            /// Adds a set of `Style` flags to the current style setting.
            pub fn add_style(&self, style: Style) -> io::Result<()> { self.0.add_style(style) }
            /// Removes a set of `Style` flags from the current style setting.
            pub fn remove_style(&self, style: Style) -> io::Result<()> { self.0.remove_style(style) }
            /// Sets the current style to the given set of flags.
            pub fn set_style<S>(&self, style: S) -> io::Result<()> where 
            S: Into<Option<Style>> 
            { self.0.set_style(style.into().unwrap_or_default()) }
            /// Sets all attributes for the terminal.
            pub fn set_theme(&self, theme: Theme) -> io::Result<()> { self.0.set_theme(theme) }
            /// Sets the foreground text color.
            pub fn set_fg<C: Into<Option<Color>>>(&self, fg: C) -> io::Result<()> { self.0.set_fg(fg.into()) }
            /// Sets the background text color.
            pub fn set_bg<C: Into<Option<Color>>>(&self, bg: C) -> io::Result<()> { self.0.set_bg(bg.into()) }
            /// Removes color and style attributes.
            pub fn clear_attributes(&self) -> io::Result<()> { self.0.clear_attributes() }
            /// Adds bold to the current style setting.
            pub fn bold(&self) -> io::Result<()> { self.add_style(Style::BOLD) }
            /// Adds italic to the current style setting.
            pub fn italic(&self) -> io::Result<()> { self.add_style(Style::ITALIC) }
            /// Adds underline to the current style setting.
            pub fn underline(&self) -> io::Result<()> { self.add_style(Style::UNDERLINE) }
            /// Adds reverse to the current style setting.
            pub fn reverse(&self) -> io::Result<()> { self.add_style(Style::REVERSE) }
            /// Writes output to the terminal with the given color and style.
            pub fn write_styled<F, B, S>(&self, fg: F, bg: B, style: S, s: &str) -> io::Result<()> where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), s) }
            /// Writes a single character to the terminal using the current style and color settings.
            pub fn write_char(&self, ch: char) -> io::Result<()> { self.0.write_char(ch) }
            /// Writes a string to the terminal using the current style and color settings.
            pub fn write_str(&self, s: &str) -> io::Result<()> { self.0.write_str(s) }
            /// Writes formatted text to the terminal using the current style and color settings.
            pub fn write_fmt(&self, args: fmt::Arguments) -> io::Result<()>
            {
                let s = args.to_string();
                self.write_str(&s)
            }
            
            pub fn borrow_term_write_guard(&self) -> TerminalWriteGuard { self.lock_write().unwrap() }
        }

        impl<'a> TerminalReadGuard<'a>
        {
            /// Prepares the terminal to read input.
            pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState>
            { self.0.prepare(config).map(PrepareState) }
            /// Performs terminal preparation using both [`Terminal`] locks.
            pub fn prepare_with_lock(&mut self, writer: &mut TerminalWriteGuard, config: PrepareConfig) -> 
            io::Result<PrepareState>
            { self.0.prepare_with_lock(&mut writer.0, config).map(PrepareState) }
            /// Restores the terminal to its previous state.
            pub fn restore(&mut self, state: PrepareState) -> io::Result<()> { self.0.restore(state.0) }
            /// Performs terminal state restoration using both [`Terminal`] locks.
            pub fn restore_with_lock(&mut self, writer: &mut TerminalWriteGuard, state: PrepareState) -> io::Result<()>
            { self.0.restore_with_lock(&mut writer.0, state.0) }
            /// Waits for an event from the terminal.
            pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool> { self.0.wait_event(timeout) }
            /// Waits for input and reads an event from the terminal.
            pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>> 
            { self.0.read_event(timeout) }
        }

        impl<'a> TerminalWriteGuard<'a>
        {
            /// Flush all output to the terminal device.
            pub fn flush(&mut self) -> io::Result<()> { self.0.flush() }
            /// Returns the size of the terminal.
            #[inline] pub fn size(&self) -> io::Result<Size> { self.0.size() }
            /// Clears the terminal screen, placing the cursor at the first line and column.
            pub fn clear_screen(&mut self) -> io::Result<()> { self.0.clear_screen() }
            /// Clears the current line, starting at cursor position.
            pub fn clear_to_line_end(&mut self) -> io::Result<()> { self.0.clear_to_line_end() }
            /// Clears the screen, starting at cursor position.
            pub fn clear_to_screen_end(&mut self) -> io::Result<()> { self.0.clear_to_screen_end() }
            /// Moves the cursor up `n` lines.
            pub fn move_up(&mut self, n: usize) -> io::Result<()> { self.0.move_up(n) }
            /// Moves the cursor down `n` lines.
            pub fn move_down(&mut self, n: usize) -> io::Result<()> { self.0.move_down(n) }
            /// Moves the cursor left `n` columns.
            pub fn move_left(&mut self, n: usize) -> io::Result<()> { self.0.move_left(n) }
            /// Moves the cursor right `n` columns.
            pub fn move_right(&mut self, n: usize) -> io::Result<()> { self.0.move_right(n) }
            /// Moves the cursor to the first column of the current line
            pub fn move_to_first_column(&mut self) -> io::Result<()> { self.0.move_to_first_column() }
            /// Set the current cursor mode.
            pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> { self.0.set_cursor_mode(mode) }
            /// Adds a set of `Style` flags to the current style setting.
            pub fn add_style(&mut self, style: Style) -> io::Result<()> { self.0.add_style(style) }
            /// Removes a set of `Style` flags from the current style setting.
            pub fn remove_style(&mut self, style: Style) -> io::Result<()> { self.0.remove_style(style) }
            /// Sets the current style to the given set of flags.
            pub fn set_style<S>(&mut self, style: S) -> io::Result<()> where 
            S: Into<Option<Style>> 
            { self.0.set_style(style.into().unwrap_or_default()) }
            /// Sets all attributes for the terminal.
            pub fn set_theme(&mut self, theme: Theme) -> io::Result<()> { self.0.set_theme(theme) }
            /// Sets the background text color.
            pub fn set_fg<C: Into<Option<Color>>>(&mut self, fg: C) -> io::Result<()> { self.0.set_fg(fg.into()) }
            /// Removes color and style attributes.
            pub fn set_bg<C: Into<Option<Color>>>(&mut self, bg: C) -> io::Result<()> { self.0.set_bg(bg.into()) }
            /// Adds bold to the current style setting.
            pub fn clear_attributes(&mut self) -> io::Result<()> { self.0.clear_attributes() }
            /// Adds bold to the current style setting.
            pub fn bold(&mut self) -> io::Result<()> { self.add_style(Style::BOLD) }
            /// Adds italic to the current style setting.
            pub fn italic(&mut self) -> io::Result<()> { self.add_style(Style::ITALIC) }
            /// Adds underline to the current style setting.
            pub fn underline(&mut self) -> io::Result<()> { self.add_style(Style::UNDERLINE) }
            /// Adds reverse to the current style setting.
            pub fn reverse(&mut self) -> io::Result<()> { self.add_style(Style::REVERSE) }
            /// Writes output to the terminal with the given color and style added.
            pub fn write_styled<F, B, S>(&mut self, fg: F, bg: B, style: S, s: &str) -> io::Result<()> where
            F: Into<Option<Color>>,
            B: Into<Option<Color>>,
            S: Into<Option<Style>>,
            { self.0.write_styled(fg.into(), bg.into(), style.into().unwrap_or_default(), s) }
            /// Writes a single character to the terminal using the current style and color settings.
            pub fn write_char(&mut self, ch: char) -> io::Result<()> { self.0.write_char(ch) }
            /// Writes a string to the terminal using the current style and color settings.
            pub fn write_str(&mut self, s: &str) -> io::Result<()> { self.0.write_str(s) }
            /// Writes formatted text to the terminal using the current style and color settings.
            pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()>
            {
                let s = args.to_string();
                self.write_str(&s)
            }

            pub fn borrow_term_write_guard(&mut self) -> &mut Self { self }
        }
        
        impl ::mortal::unix::OpenTerminalExt for Terminal
        {
            fn from_path<P: AsRef<Path>>(path: P) -> io::Result<Self> { sys::Terminal::open(path).map(Terminal) }
        }
        
        impl ::mortal::unix::TerminalExt for Terminal
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
            { self.0.read_raw(buf, timeout) }
        }
        
        impl<'a> ::mortal::unix::TerminalExt for TerminalReadGuard<'a>
        {
            fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> 
            { self.0.read_raw(buf, timeout) }
        }
        /*
            #[cfg(windows)]
            impl crate::windows::TerminalExt for Terminal {
                fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.0.read_raw(buf, timeout)
                }

                fn read_raw_event(&mut self, events: &mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.0.read_raw_event(events, timeout)
                }
            }

            #[cfg(windows)]
            impl<'a> crate::windows::TerminalExt for TerminalReadGuard<'a> {
                fn read_raw(&mut self, buf: &mut [u16], timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.0.read_raw(buf, timeout)
                }

                fn read_raw_event(&mut self, events: &mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout: Option<Duration>) -> io::Result<Option<Event>> {
                    self.0.read_raw_event(events, timeout)
                }
        } */
    } 

    pub mod util
    {
        //! Miscellaneous utility functions
        use ::
        {
            str::{ CharIndices },
            *,
        };
        
        const CTRL_MASK: u8 = 0x1f;
        const UNCTRL_BIT: u8 = 0x40;

        /// Returns the width of a character in the terminal.
        #[inline] pub fn char_width(ch: char) -> Option<usize>
        {
            use unicode_width::UnicodeWidthChar;
            ch.width()
        }
        /// Returns whether the given character is a combining mark.
        #[inline] pub fn is_combining_mark(ch: char) -> bool
        {
            use unicode_normalization::char::is_combining_mark;
            is_combining_mark(ch)
        }
        /// Returns the control character corresponding to the given character.
        #[inline] pub fn ctrl(ch: char) -> char { ((ch as u8) & CTRL_MASK) as char }

        /// Returns whether the given character is a control character.
        #[inline] pub fn is_ctrl(ch: char) -> bool 
        {
            let ch = ch as u32;
            ch & (CTRL_MASK as u32) == ch
        }
        /// Returns the ASCII character corresponding to the given control character.
        #[inline] pub fn unctrl_upper(ch: char) -> char { ((ch as u8) | UNCTRL_BIT) as char }
        /// Returns the lowercase ASCII character corresponding to the given control character.
        #[inline] pub fn unctrl_lower(ch: char) -> char { unctrl_upper(ch).to_ascii_lowercase() }
        /// Iterator over string prefixes.
        pub struct Prefixes<'a>
        {
            s: &'a str,
            iter: CharIndices<'a>,
        }
        /// Returns an iterator over all non-empty prefixes of `s`, beginning with the shortest.
        #[inline] pub fn prefixes(s: &str) -> Prefixes
        {
            Prefixes
            {
                s,
                iter: s.char_indices(),
            }
        }

        impl<'a> Iterator for Prefixes<'a>
        {
            type Item = &'a str;
            fn next(&mut self) -> Option<&'a str> { self.iter.next().map(|(idx, ch)| &self.s[..idx + ch.len_utf8()]) }
        }
    }

    pub mod sys
    {
        pub use self::screen::{ Screen, ScreenReadGuard, ScreenWriteGuard, };
        pub use self::terminal::{ PrepareState, Terminal, TerminalReadGuard, TerminalWriteGuard, };

        pub mod ext
        {
            //! Unix extension trait
            use ::
            {
                mortal::
                {
                    priv_util::{ Private },
                    terminal::{ Event },
                },
                path::{ Path },
                time::{ Duration },
                *,
            };
            /// Implements Unix-only extensions for terminal interfaces.
            pub trait OpenTerminalExt: Sized + Private
            {
                /// Opens a terminal interface on the device at the given path.
                fn from_path<P: AsRef<Path>>(path: P) -> io::Result<Self>;
            }
            /// Implements Unix-only extensions for terminal interfaces.
            pub trait TerminalExt: Private
            {
                /// Reads raw data from the terminal.
                fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>;
            }
        }

        mod screen
        {
            use ::
            {
                mortal::
                {
                    buffer::{ ScreenBuffer },
                    priv_util::{ map_lock_result, map_try_lock_result, map2_lock_result, map2_try_lock_result },
                    sys::{ Terminal, TerminalReadGuard, TerminalWriteGuard, PrepareState },
                    terminal::{ Color, Cursor, CursorMode, Event, Size, Style, PrepareConfig },
                },
                sync::{ LockResult, Mutex, MutexGuard, TryLockResult },
                time::{ Duration },
                *,
            };

            pub struct Screen
            {
                term: Terminal,
                state: Option<PrepareState>,
                writer: Mutex<Writer>,
            }

            impl Screen
            {
                pub fn new(term: Terminal, config: PrepareConfig) -> io::Result<Screen>
                {
                    let size = term.size()?;
                    let state = term.prepare(config)?;
                    let screen = Screen
                    {
                        term: term,
                        state: Some(state),
                        writer: Mutex::new(Writer
                        {
                            buffer: ScreenBuffer::new(size),
                            clear_screen: false,
                            real_cursor: Cursor::default(),
                        }),
                    };
                    screen.term.enter_screen()?;
                    Ok(screen)
                }
                pub fn stdout(config: PrepareConfig) -> io::Result<Screen> { Screen::new(Terminal::stdout()?, config) }
                pub fn stderr(config: PrepareConfig) -> io::Result<Screen> { Screen::new(Terminal::stderr()?, config) }

                forward_screen_buffer_methods!{ |slf| slf.lock_write_data().buffer }

                pub fn lock_read(&self) -> LockResult<ScreenReadGuard> 
                { map_lock_result(self.term.lock_read(), |r| ScreenReadGuard::new(self, r)) }

                pub fn try_lock_read(&self) -> TryLockResult<ScreenReadGuard>
                {
                    map_try_lock_result(self.term.try_lock_read(), |r| ScreenReadGuard::new(self, r))
                }

                pub fn lock_write(&self) -> LockResult<ScreenWriteGuard>
                {
                    map2_lock_result(self.term.lock_write(), self.writer.lock(), |a, b| ScreenWriteGuard::new(a, b))
                }

                pub fn try_lock_write(&self) -> TryLockResult<ScreenWriteGuard>
                {
                    map2_try_lock_result
                    (
                        self.term.try_lock_write(),
                        self.writer.try_lock(), 
                        |a, b| ScreenWriteGuard::new(a, b)
                    )
                }

                fn lock_reader(&self) -> ScreenReadGuard { self.lock_read().expect("Screen::lock_reader") }

                fn lock_writer(&self) -> ScreenWriteGuard { self.lock_write().expect("Screen::lock_writer") }

                fn lock_write_data(&self) -> MutexGuard<Writer> { self.writer.lock().expect("Screen::lock_write_data") }

                pub fn name(&self) -> &str { self.term.name() }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> { self.term.set_cursor_mode(mode) }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> 
                { self.lock_reader().wait_event(timeout) }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                { self.lock_reader().read_event(timeout) }

                pub fn read_raw(&self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
                { self.lock_reader().read_raw(buf, timeout) }

                pub fn refresh(&self) -> io::Result<()> { self.lock_writer().refresh() }
            }

            impl Drop for Screen
            {
                fn drop(&mut self) 
                {
                    let res = if let Some(state) = self.state.take() 
                    { self.term.restore(state) } 
                    else { Ok(()) };

                    if let Err(e) = res.and_then(|_| self.term.exit_screen()) 
                    { eprintln!("failed to restore terminal: {}", e); }
                }
            }

            pub struct ScreenReadGuard<'a>
            {
                screen: &'a Screen,
                reader: TerminalReadGuard<'a>,
            }

            impl<'a> ScreenReadGuard<'a> 
            {
                fn new(screen: &'a Screen, reader: TerminalReadGuard<'a>) -> ScreenReadGuard<'a> 
                { ScreenReadGuard{screen, reader} }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool>
                { self.reader.wait_event(timeout) }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let r = self.reader.read_event(timeout)?;
                    if let Some(Event::Resize(size)) = r  { self.screen.lock_write_data().update_size(size); }
                    Ok(r)
                }

                pub fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    let r = self.reader.read_raw(buf, timeout)?;
                    if let Some(Event::Resize(size)) = r { self.screen.lock_write_data().update_size(size); }
                    Ok(r)
                }
            }

            pub struct ScreenWriteGuard<'a>
            {
                writer: TerminalWriteGuard<'a>,
                data: MutexGuard<'a, Writer>,
            }

            impl<'a> ScreenWriteGuard<'a>
            {
                fn new(writer: TerminalWriteGuard<'a>, data: MutexGuard<'a, Writer>) -> ScreenWriteGuard<'a>
                { ScreenWriteGuard{writer, data} }

                forward_screen_buffer_mut_methods!{ |slf| slf.data.buffer }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> { self.writer.set_cursor_mode(mode) }

                pub fn refresh(&mut self) -> io::Result<()>
                {
                    if self.data.clear_screen
                    {
                        self.writer.clear_screen()?;
                        self.data.clear_screen = false;
                    }

                    self.writer.clear_attributes()?;
                    let mut indices = self.data.buffer.indices();

                    while let Some((pos, cell)) = self.data.buffer.next_cell(&mut indices)
                    {
                        self.move_cursor(pos)?;
                        self.apply_attrs(cell.attrs())?;
                        self.writer.write_str(cell.text())?;
                        self.data.real_cursor.column += 1;
                    }

                    self.writer.clear_attributes()?;
                    let size = self.data.buffer.size();
                    let pos = self.data.buffer.cursor();

                    if pos.is_out_of_bounds(size) { self.move_cursor(Cursor::last(size))?; } 
                    else { self.move_cursor(pos)?; }

                    self.writer.flush()
                }

                fn move_cursor(&mut self, pos: Cursor) -> io::Result<()>
                {
                    if self.data.real_cursor != pos
                    {
                        self.writer.move_cursor(pos)?;
                        self.data.real_cursor = pos;
                    }

                    Ok(())
                }

                fn apply_attrs(&mut self, (fg, bg, style): (Option<Color>, Option<Color>, Style)) -> io::Result<()>
                { self.writer.set_attrs(fg, bg, style) }
            }

            impl<'a> Drop for ScreenWriteGuard<'a> 
            {
                fn drop(&mut self) 
                {
                    if let Err(e) = self.refresh() { eprintln!("failed to refresh screen: {}", e); }
                }
            }

            struct Writer
            {
                buffer: ScreenBuffer,
                clear_screen: bool,
                real_cursor: Cursor,
            }

            impl Writer
            {
                fn update_size(&mut self, new_size: Size) 
                {
                    if self.real_cursor.is_out_of_bounds(new_size) { self.real_cursor = (!0, !0).into(); }
                    self.buffer.resize(new_size);
                    self.clear_screen = true;
                }
            }
        }

        mod terminal
        {
            use ::
            {
                convert::{ TryFrom },
                fs::{ File },
                libc::
                {
                    ioctl, c_int, c_ushort, termios, STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO, TIOCGWINSZ,
                },
                mem::{ replace, zeroed },
                mortal::
                {
                    priv_util::{ map_lock_result, map_try_lock_result },
                    sequence::{ FindResult, SequenceMap },
                    signal::{ Signal, SignalSet },
                    terminal::
                    { 
                        Color, Cursor, CursorMode, Event, Key, PrepareConfig, Size, Style, Theme, MouseButton, MouseEvent,
                        MouseInput, ModifierState
                    },
                    util::{ prefixes },
                },
                nix::
                {
                    errno::Errno,
                    sys::select::{ select, FdSet },
                    sys::signal::{ sigaction, SaFlags, SigAction, SigHandler, Signal as NixSignal, SigSet, },
                    sys::termios::{ tcgetattr, tcsetattr, SetArg, InputFlags, LocalFlags, SpecialCharacterIndices, },
                    sys::time::{ TimeVal, TimeValLike },
                    unistd::{ read, write },
                },
                os::unix::io::{ FromRawFd, IntoRawFd, RawFd },
                path::{ Path },
                str::{ from_utf8, from_utf8_unchecked, SmallString },
                sync::
                {
                    atomic::{ AtomicUsize, Ordering },
                    LockResult, Mutex, MutexGuard, TryLockResult,
                },
                terminal::info::{ self as terminfo, capability as cap, Database, capability::Expansion, expand::Context },
                time::{ Duration },
                *,
            };

            use self::SpecialCharacterIndices::*;
            
            const OUT_BUFFER_SIZE: usize = 8192;
            const XTERM_ENABLE_MOUSE: &str = "\x1b[?1006h\x1b[?1002h";
            const XTERM_DISABLE_MOUSE: &str = "\x1b[?1006l\x1b[?1002l";
            const XTERM_ENABLE_MOUSE_MOTION: &str = "\x1b[?1003h";
            const XTERM_DISABLE_MOUSE_MOTION: &str = "\x1b[?1003l";
            const XTERM_MOUSE_INTRO: &str = "\x1b[<";
            const XTERM_SHIFT_MASK: u32 = 0x04;
            const XTERM_META_MASK: u32  = 0x08;
            const XTERM_CTRL_MASK: u32  = 0x10;
            const XTERM_MODIFIER_MASK: u32 = XTERM_SHIFT_MASK | XTERM_META_MASK | XTERM_CTRL_MASK;
            type SeqMap = SequenceMap<SmallString<[u8; 8]>, SeqData>;

            macro_rules! expand_opt
            {
                ( $slf:expr , $cap:path ) => 
                {{
                    if let Some(cap) = $slf.term.info.get::<$cap>() { $slf.expand(cap.expand()) } 
                    else { Ok(()) }
                }};

                ( $slf:expr , $cap:path , |$ex:ident| $expansion:expr ) => 
                {{
                    if let Some(cap) = $slf.term.info.get::<$cap>()
                    {
                        let $ex = cap.expand();
                        $slf.expand($expansion)
                    } 
                    else { Ok(()) }
                } }
            }

            macro_rules! expand_req
            {
                ( $slf:expr , $cap:path , $name:expr ) => 
                {{
                    $slf.term.info.get::<$cap>()
                        .ok_or_else(|| not_supported($name))
                        .and_then(|cap| $slf.expand(cap.expand()))
                }};
                
                ( $slf:expr , $cap:path , $name:expr , |$ex:ident| $expansion:expr ) => 
                {{
                    $slf.term.info.get::<$cap>()
                    .ok_or_else(|| not_supported($name))
                    .and_then(|cap|
                    {
                        let $ex = cap.expand();
                        $slf.expand($expansion)
                    })
                }}
            }

            #[derive(Copy, Clone)]
            enum SeqData
            {
                XTermMouse,
                Key(Key),
            }

            pub struct Terminal
            {
                info: Database,
                out_fd: RawFd,
                in_fd: RawFd,
                owned_fd: bool,
                sequences: SeqMap,
                reader: Mutex<Reader>,
                writer: Mutex<Writer>,
            }

            impl Terminal
            {
                fn new(in_fd: RawFd, out_fd: RawFd, owned_fd: bool) -> io::Result<Terminal>
                {
                    let info = Database::from_env().map_err(ti_to_io)?;
                    let sequences = sequences(&info);
                    Ok
                    (
                        Terminal
                        {
                            info,
                            in_fd,
                            out_fd,
                            owned_fd,
                            sequences,
                            reader: Mutex::new(Reader
                            {
                                in_buffer: Vec::new(),
                                resume: None,
                                report_signals: SignalSet::new(),
                            }),
                            writer: Mutex::new(Writer::new()),
                        }
                    )
                }

                pub fn open<P: AsRef<Path>>(path: P) -> io::Result<Terminal>
                {
                    let fd = open_rw(path)?;
                    let r = Terminal::new(fd, fd, true);
                    if r.is_err() { unsafe { close_fd(fd); } }
                    r
                }

                pub fn stdout() -> io::Result<Terminal> { Terminal::new(STDIN_FILENO, STDOUT_FILENO, false) }

                pub fn stderr() -> io::Result<Terminal> { Terminal::new(STDIN_FILENO, STDERR_FILENO, false) }

                pub fn name(&self) -> &str { self.info.name() }

                fn is_xterm(&self) -> bool { is_xterm(self.name()) }

                pub fn size(&self) -> io::Result<Size> { self.lock_writer().size() }

                pub fn wait_event(&self, timeout: Option<Duration>) -> io::Result<bool> { self.lock_reader().wait_event(timeout) }

                pub fn read_event(&self, timeout: Option<Duration>) -> io::Result<Option<Event>> { self.lock_reader().read_event(timeout) }

                pub fn read_raw(&self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>> { self.lock_reader().read_raw(buf, timeout) }

                pub fn enter_screen(&self) -> io::Result<()> { self.lock_writer().enter_screen() }

                pub fn exit_screen(&self) -> io::Result<()> { self.lock_writer().exit_screen() }

                pub fn prepare(&self, config: PrepareConfig) -> io::Result<PrepareState> { self.lock_reader().prepare(config) }

                pub fn restore(&self, state: PrepareState) -> io::Result<()> { self.lock_reader().restore(state) }

                pub fn clear_screen(&self) -> io::Result<()> { self.lock_writer().clear_screen() }

                pub fn clear_to_line_end(&self) -> io::Result<()> { self.lock_writer().clear_to_line_end() }

                pub fn clear_to_screen_end(&self) -> io::Result<()> { self.lock_writer().clear_to_screen_end() }

                pub fn move_up(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_up(n)?; }
                    Ok(())
                }

                pub fn move_down(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_down(n)?; }
                    Ok(())
                }

                pub fn move_left(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_left(n)?; }
                    Ok(())
                }

                pub fn move_right(&self, n: usize) -> io::Result<()>
                {
                    if n != 0 { self.lock_writer().move_right(n)?; }
                    Ok(())
                }

                pub fn move_to_first_column(&self) -> io::Result<()> { self.lock_writer().move_to_first_column() }

                pub fn set_cursor_mode(&self, mode: CursorMode) -> io::Result<()> { self.lock_writer().set_cursor_mode(mode) }

                pub fn write_char(&self, ch: char) -> io::Result<()> { self.write_str(ch.encode_utf8(&mut [0; 4])) }

                pub fn write_str(&self, s: &str) -> io::Result<()> { self.lock_writer().write_str(s) }

                pub fn write_styled(&self, fg: Option<Color>, bg: Option<Color>, style: Style, text: &str) -> io::Result<()>
                { self.lock_writer().write_styled(fg, bg, style, text) }

                pub fn clear_attributes(&self) -> io::Result<()> { self.lock_writer().clear_attributes() }

                pub fn set_fg(&self, fg: Option<Color>) -> io::Result<()> { self.lock_writer().set_fg(fg) }

                pub fn set_bg(&self, bg: Option<Color>) -> io::Result<()> { self.lock_writer().set_bg(bg) }

                pub fn add_style(&self, style: Style) -> io::Result<()> { self.lock_writer().add_style(style) }

                pub fn remove_style(&self, style: Style) -> io::Result<()> { self.lock_writer().remove_style(style) }

                pub fn set_style(&self, style: Style) -> io::Result<()> { self.lock_writer().set_style(style) }

                pub fn set_theme(&self, theme: Theme) -> io::Result<()> { self.lock_writer().set_theme(theme) }

                pub fn lock_read(&self) -> LockResult<TerminalReadGuard> 
                { map_lock_result(self.reader.lock(), |r| TerminalReadGuard::new(self, r)) }

                pub fn lock_write(&self) -> LockResult<TerminalWriteGuard>
                { map_lock_result(self.writer.lock(), |w| TerminalWriteGuard::new(self, w)) }

                pub fn try_lock_read(&self) -> TryLockResult<TerminalReadGuard>
                { map_try_lock_result(self.reader.try_lock(), |r| TerminalReadGuard::new(self, r)) }

                pub fn try_lock_write(&self) -> TryLockResult<TerminalWriteGuard>
                { map_try_lock_result(self.writer.try_lock(), |w| TerminalWriteGuard::new(self, w)) }

                fn lock_reader(&self) -> TerminalReadGuard { self.lock_read().expect("Terminal::lock_reader") }

                fn lock_writer(&self) -> TerminalWriteGuard { self.lock_write().expect("Terminal::lock_writer") }
            }

            impl Drop for Terminal
            {
                fn drop(&mut self)
                {
                    if let Err(e) = self.set_cursor_mode(CursorMode::Normal) 
                    { eprintln!("failed to restore terminal: {}", e); }

                    if self.owned_fd { unsafe { close_fd(self.out_fd); } }
                }
            }

            pub struct TerminalReadGuard<'a>
            {
                term: &'a Terminal,
                reader: MutexGuard<'a, Reader>,
            }

            impl<'a> TerminalReadGuard<'a>
            {
                fn new(term: &'a Terminal, reader: MutexGuard<'a, Reader>) -> TerminalReadGuard<'a> 
                { TerminalReadGuard{term, reader} }

                pub fn prepare(&mut self, config: PrepareConfig) -> io::Result<PrepareState>
                {
                    let mut writer = self.term.lock_writer();
                    self.prepare_with_lock(&mut writer, config)
                }

                pub fn prepare_with_lock(&mut self, writer: &mut TerminalWriteGuard, config: PrepareConfig) -> 
                io::Result<PrepareState>
                {
                    let old_tio = tcgetattr(self.term.in_fd).map_err(nix_to_io)?;
                    let mut tio = old_tio.clone();
                    let mut state = PrepareState
                    {
                        old_tio: old_tio.into(),
                        old_sigcont: None,
                        old_sigint: None,
                        old_sigtstp: None,
                        old_sigquit: None,
                        old_sigwinch: None,
                        restore_keypad: false,
                        restore_mouse: false,
                        prev_resume: self.reader.resume,
                    };

                    tio.input_flags.remove(
                        InputFlags::INLCR | InputFlags::ICRNL
                    );

                    tio.local_flags.remove(
                        LocalFlags::ICANON | LocalFlags::ECHO
                    );

                    if config.block_signals {
                        tio.local_flags.remove(LocalFlags::ISIG);
                    } else {
                        tio.local_flags.insert(LocalFlags::ISIG);
                    }
                    
                    if config.enable_control_flow {
                        tio.input_flags.insert(InputFlags::IXON);
                    } else {
                        tio.input_flags.remove(InputFlags::IXON);
                    }
                    
                    tio.control_chars[VMIN as usize] = 0;
                    tio.control_chars[VTIME as usize] = 0;

                    tcsetattr(self.term.in_fd, SetArg::TCSANOW, &tio).map_err(nix_to_io)?;

                    if config.enable_mouse {
                        if writer.enable_mouse(config.always_track_motion)? {
                            state.restore_mouse = true;
                        }
                    }

                    if config.enable_keypad {
                        if writer.enable_keypad()? {
                            state.restore_keypad = true;
                        }
                    }

                    writer.flush()?;

                    let action = SigAction::new(SigHandler::Handler(handle_signal),
                        SaFlags::empty(), SigSet::all());
                        
                    state.old_sigcont = Some(unsafe { sigaction(NixSignal::SIGCONT, &action).map_err(nix_to_io)? });
                    state.old_sigwinch = Some(unsafe { sigaction(NixSignal::SIGWINCH, &action).map_err(nix_to_io)? });

                    if config.report_signals.contains(Signal::Interrupt) {
                        state.old_sigint = Some(unsafe { sigaction(NixSignal::SIGINT, &action).map_err(nix_to_io)? });
                    }
                    if config.report_signals.contains(Signal::Suspend) {
                        state.old_sigtstp = Some(unsafe { sigaction(NixSignal::SIGTSTP, &action).map_err(nix_to_io)? });
                    }
                    if config.report_signals.contains(Signal::Quit) {
                        state.old_sigquit = Some(unsafe { sigaction(NixSignal::SIGQUIT, &action).map_err(nix_to_io)? });
                    }

                    self.reader.report_signals = config.report_signals;
                    self.reader.resume = Some(Resume{config});

                    Ok(state)
                }

                pub fn restore(&mut self, state: PrepareState) -> io::Result<()>
                {
                    let mut writer = self.term.lock_writer();
                    self.restore_with_lock(&mut writer, state)
                }

                pub fn restore_with_lock(&mut self, writer: &mut TerminalWriteGuard, state: PrepareState) -> io::Result<()>
                {
                    unsafe 
                    {
                        self.reader.resume = state.prev_resume;

                        if state.restore_mouse { writer.disable_mouse()?; }

                        if state.restore_keypad { writer.disable_keypad()?; }

                        writer.flush()?;
                        tcsetattr(self.term.in_fd, SetArg::TCSANOW, &state.old_tio.into()).map_err(nix_to_io)?;

                        if let Some( ref old) = state.old_sigcont {
                            sigaction(NixSignal::SIGCONT, old).map_err(nix_to_io)?;
                        }
                        if let Some( ref old) = state.old_sigint {
                            sigaction(NixSignal::SIGINT, old).map_err(nix_to_io)?;
                        }
                        if let Some( ref old) = state.old_sigtstp {
                            sigaction(NixSignal::SIGTSTP, old).map_err(nix_to_io)?;
                        }
                        if let Some( ref old) = state.old_sigquit {
                            sigaction(NixSignal::SIGQUIT, old).map_err(nix_to_io)?;
                        }
                        if let Some( ref old) = state.old_sigwinch {
                            sigaction(NixSignal::SIGWINCH, old).map_err(nix_to_io)?;
                        }

                        Ok(())
                    }
                }

                pub fn wait_event(&mut self, timeout: Option<Duration>) -> io::Result<bool>
                {
                    if get_signal().is_some() { return Ok(true); }

                    if peek_event(&self.reader.in_buffer, &self.term.sequences)?.is_some() { return Ok(true); }

                    let mut timeout = timeout.map(to_timeval);

                    let n = loop
                    {
                        let in_fd = self.term.in_fd;
                        let mut r_fds = FdSet::new();
                        r_fds.insert(in_fd);
                        let mut e_fds = FdSet::new();
                        e_fds.insert(in_fd);

                        match select(in_fd + 1, Some(&mut r_fds), None, Some(&mut e_fds), timeout.as_mut())
                        {
                            Ok(n) => break n,
                            Err(Errno::EINTR) => if get_signal().is_some() { return Ok(true); }                            
                            Err(e) => return Err(nix_to_io(e))
                        }
                    };

                    Ok(n != 0)
                }

                pub fn read_event(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    if let Some(ev) = self.try_read()? { return Ok(Some(ev)); }

                    match self.read_into_buffer(timeout)? 
                    {
                        Some(Event::Raw(_)) => self.try_read(),
                        Some(Event::Signal(sig)) =>
                        {
                            if let Some(ev) = self.handle_signal(sig)?  { Ok(Some(ev)) } 
                            else { Ok(None) }
                        }
                        r => Ok(r)
                    }
                }

                pub fn read_raw(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    if !self.reader.in_buffer.is_empty()
                    {
                        let n = buf.len().min(self.reader.in_buffer.len());
                        buf[..n].copy_from_slice(&self.reader.in_buffer[..n]);
                        let _ = self.reader.in_buffer.drain(..n);
                        return Ok(Some(Event::Raw(n)));
                    }

                    match self.read_input(buf, timeout)?
                    {
                        Some(Event::Signal(sig)) =>
                        {
                            if let Some(event) = self.handle_signal(sig)? { Ok(Some(event)) }
                            else { Ok(None) }
                        }
                        r => Ok(r)
                    }
                }

                fn read_into_buffer(&mut self, timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    unsafe 
                    {
                        let mut buf = replace(&mut self.reader.in_buffer, Vec::new());
                        buf.reserve(128);
                        let len = buf.len();
                        let cap = buf.capacity();
                        let r;
                        buf.set_len(cap);
                        r = self.read_input(&mut buf[len..], timeout);

                        match r
                        {
                            Ok(Some(Event::Raw(n))) => buf.set_len(len + n),
                            _ => buf.set_len(len)
                        }
                        
                        self.reader.in_buffer = buf;
                        r
                    }
                }

                fn read_input(&mut self, buf: &mut [u8], timeout: Option<Duration>) -> io::Result<Option<Event>>
                {
                    if let Some(sig) = take_signal() { return Ok(Some(Event::Signal(sig))); }

                    if !self.wait_event(timeout)? { return Ok(None); }
                    
                    if let Some(sig) = take_signal() { return Ok(Some(Event::Signal(sig))); }

                    loop
                    {
                        match read(self.term.in_fd, buf)
                        {
                            Ok(n) => break Ok(Some(Event::Raw(n))),
                            Err(Errno::EINTR) =>
                            {
                                if let Some(sig) = take_signal() { return Ok(Some(Event::Signal(sig))); }
                            }
                            Err(e) => return Err(nix_to_io(e))
                        }
                    }
                }

                fn try_read(&mut self) -> io::Result<Option<Event>>
                {
                    let in_buffer = &mut self.reader.in_buffer;
                    
                    if in_buffer.is_empty() { Ok(None) }                    
                    else
                    {
                        match peek_event(&in_buffer, &self.term.sequences)
                        {
                            Ok(Some((ev, n))) =>
                            {
                                let _ = in_buffer.drain(..n);
                                Ok(Some(ev))
                            }
                            Ok(None) => Ok(None),
                            Err(e) => Err(e)
                        }
                    }
                }

                fn handle_signal(&mut self, sig: Signal) -> io::Result<Option<Event>>
                {
                    match sig
                    {
                        Signal::Continue => { self.resume()?; }

                        Signal::Resize =>
                        {
                            let size = self.term.size()?;
                            return Ok(Some(Event::Resize(size)));
                        }
                        _ => ()
                    }

                    if self.reader.report_signals.contains(sig) { Ok(Some(Event::Signal(sig))) }

                    else { Ok(None) }
                }

                fn resume(&mut self) -> io::Result<()>
                {
                    if let Some(resume) = self.reader.resume { let _ = self.prepare(resume.config)?; }

                    Ok(())
                }
            }

            pub struct TerminalWriteGuard<'a>
            {
                term: &'a Terminal,
                writer: MutexGuard<'a, Writer>,
            }

            impl<'a> TerminalWriteGuard<'a> 
            {
                fn new(term: &'a Terminal, writer: MutexGuard<'a, Writer>) -> TerminalWriteGuard<'a> {
                    TerminalWriteGuard{term, writer}
                }

                pub fn size(&self) -> io::Result<Size> {
                    get_winsize(self.term.out_fd)
                }

                fn disable_keypad(&mut self) -> io::Result<()> {
                    if let Some(local) = self.term.info.get::<cap::KeypadLocal>() {
                        self.expand(local.expand())?;
                    }
                    Ok(())
                }

                fn enable_keypad(&mut self) -> io::Result<bool> {
                    if let Some(xmit) = self.term.info.get::<cap::KeypadXmit>() {
                        self.expand(xmit.expand())?;
                        Ok(true)
                    } else {
                        Ok(false)
                    }
                }

                fn disable_mouse(&mut self) -> io::Result<()> {
                    self.write_bytes(XTERM_DISABLE_MOUSE.as_bytes())?;
                    self.write_bytes(XTERM_DISABLE_MOUSE_MOTION.as_bytes())
                }

                fn enable_mouse(&mut self, track_motion: bool) -> io::Result<bool> {
                    if self.term.is_xterm() {
                        self.write_bytes(XTERM_ENABLE_MOUSE.as_bytes())?;
                        if track_motion {
                            self.write_bytes(XTERM_ENABLE_MOUSE_MOTION.as_bytes())?;
                        }
                        Ok(true)
                    } else {
                        Ok(false)
                    }
                }

                fn enter_screen(&mut self) -> io::Result<()> {
                    match (self.term.info.get::<cap::EnterCaMode>(),
                            self.term.info.get::<cap::ChangeScrollRegion>(),
                            self.term.info.get::<cap::CursorHome>()) {
                        (enter, Some(scroll), Some(home)) => {
                            let size = self.size()?;

                            if let Some(enter) = enter {
                                self.expand(enter.expand())?;
                            }

                            self.expand(scroll.expand()
                                .parameters(0, to_u32(size.lines - 1)))?;
                            self.expand(home.expand())?;
                        }
                        (_, None, _) => return Err(not_supported("change_scroll_region")),
                        (_, _, None) => return Err(not_supported("cursor_home")),
                    }

                    self.clear_attributes()?;
                    self.clear_screen()?;

                    Ok(())
                }

                fn exit_screen(&mut self) -> io::Result<()> {
                    if let Some(exit) = self.term.info.get::<cap::ExitCaMode>() {
                        self.expand(exit.expand())?;
                        self.flush()?;
                    }

                    Ok(())
                }

                pub fn clear_attributes(&mut self) -> io::Result<()> {
                    if self.writer.fg.is_some() || self.writer.bg.is_some() ||
                            !self.writer.cur_style.is_empty() {
                        self.writer.fg = None;
                        self.writer.bg = None;
                        self.writer.cur_style = Style::empty();
                        expand_opt!(self, cap::ExitAttributeMode)?;
                    }

                    Ok(())
                }

                pub fn set_fg(&mut self, fg: Option<Color>) -> io::Result<()> {
                    if self.writer.fg == fg {
                        Ok(())
                    } else {
                        if let Some(fg) = fg {
                            self.set_fg_color(fg)?;
                        } else {
                            self.clear_fg()?;
                        }

                        self.writer.fg = fg;
                        Ok(())
                    }
                }

                pub fn set_bg(&mut self, bg: Option<Color>) -> io::Result<()> {
                    if self.writer.bg == bg {
                        Ok(())
                    } else {
                        if let Some(bg) = bg {
                            self.set_bg_color(bg)?;
                        } else {
                            self.clear_bg()?;
                        }

                        self.writer.bg = bg;
                        Ok(())
                    }
                }

                pub fn add_style(&mut self, style: Style) -> io::Result<()> {
                    let add = style - self.writer.cur_style;

                    if add.contains(Style::BOLD) {
                        expand_opt!(self, cap::EnterBoldMode)?;
                    }
                    if add.contains(Style::ITALIC) {
                        expand_opt!(self, cap::EnterItalicsMode)?;
                    }
                    if add.contains(Style::REVERSE) {
                        expand_opt!(self, cap::EnterReverseMode)?;
                    }
                    if add.contains(Style::UNDERLINE) {
                        expand_opt!(self, cap::EnterUnderlineMode)?;
                    }

                    self.writer.cur_style |= add;

                    Ok(())
                }

                pub fn remove_style(&mut self, style: Style) -> io::Result<()> {
                    let remove = style & self.writer.cur_style;

                    if remove.intersects(Style::BOLD | Style::REVERSE) {
                        let new_style = self.writer.cur_style - remove;
                        let fg = self.writer.fg;
                        let bg = self.writer.bg;
                        self.clear_attributes()?;
                        self.add_style(new_style)?;
                        self.set_fg(fg)?;
                        self.set_bg(bg)?;
                    } else {
                        if remove.contains(Style::ITALIC) {
                            expand_opt!(self, cap::ExitItalicsMode)?;
                        }
                        if remove.contains(Style::UNDERLINE) {
                            expand_opt!(self, cap::ExitUnderlineMode)?;
                        }

                        self.writer.cur_style -= remove;
                    }

                    Ok(())
                }

                pub fn set_style(&mut self, style: Style) -> io::Result<()> {
                    let add = style - self.writer.cur_style;
                    let remove = self.writer.cur_style - style;

                    if remove.intersects(Style::BOLD | Style::REVERSE) {
                        let fg = self.writer.fg;
                        let bg = self.writer.bg;
                        self.clear_attributes()?;
                        self.set_fg(fg)?;
                        self.set_bg(bg)?;
                        self.add_style(style)?;
                    } else {
                        self.add_style(add)?;
                        self.remove_style(remove)?;
                    }

                    Ok(())
                }

                pub fn set_theme(&mut self, theme: Theme) -> io::Result<()> {
                    self.set_attrs(theme.fg, theme.bg, theme.style)
                }

                pub fn set_attrs(&mut self, fg: Option<Color>, bg: Option<Color>, style: Style) -> io::Result<()> {
                    if (self.writer.fg.is_some() && fg.is_none()) ||
                            (self.writer.bg.is_some() && bg.is_none()) {
                        self.clear_attributes()?;
                    }

                    self.set_style(style)?;
                    self.set_fg(fg)?;
                    self.set_bg(bg)?;

                    Ok(())
                }

                fn clear_fg(&mut self) -> io::Result<()> {
                    let bg = self.writer.bg;
                    let style = self.writer.cur_style;

                    self.clear_attributes()?;
                    self.set_bg(bg)?;
                    self.set_style(style)
                }

                fn clear_bg(&mut self) -> io::Result<()> {
                    let fg = self.writer.fg;
                    let style = self.writer.cur_style;

                    self.clear_attributes()?;
                    self.set_fg(fg)?;
                    self.set_style(style)
                }

                fn set_fg_color(&mut self, fg: Color) -> io::Result<()> {
                    expand_opt!(self, cap::SetAForeground,
                        |ex| ex.parameters(color_code(fg)))
                }

                fn set_bg_color(&mut self, bg: Color) -> io::Result<()> {
                    expand_opt!(self, cap::SetABackground,
                        |ex| ex.parameters(color_code(bg)))
                }

                pub fn clear_screen(&mut self) -> io::Result<()> {
                    expand_req!(self, cap::ClearScreen, "clear_screen")
                }

                pub fn clear_to_line_end(&mut self) -> io::Result<()> {
                    expand_req!(self, cap::ClrEol, "clr_eol")
                }

                pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
                    expand_req!(self, cap::ClrEos, "clr_eos")
                }

                pub fn move_up(&mut self, n: usize) -> io::Result<()> {
                    if n == 1 {
                        expand_req!(self, cap::CursorUp, "cursor_up")?;
                    } else if n != 0 {
                        expand_req!(self, cap::ParmUpCursor, "parm_cursor_up",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_down(&mut self, n: usize) -> io::Result<()> {
                    if n != 0 {
                        expand_req!(self, cap::ParmDownCursor, "parm_cursor_down",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_left(&mut self, n: usize) -> io::Result<()> {
                    if n == 1 {
                        expand_req!(self, cap::CursorLeft, "cursor_left")?;
                    } else if n != 0 {
                        expand_req!(self, cap::ParmLeftCursor, "parm_cursor_left",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_right(&mut self, n: usize) -> io::Result<()> {
                    if n == 1 {
                        expand_req!(self, cap::CursorRight, "cursor_right")?;
                    } else if n != 0 {
                        expand_req!(self, cap::ParmRightCursor, "parm_cursor_right",
                            |ex| ex.parameters(to_u32(n)))?;
                    }
                    Ok(())
                }

                pub fn move_to_first_column(&mut self) -> io::Result<()> {
                    self.write_bytes(b"\r")
                }

                pub fn move_cursor(&mut self, pos: Cursor) -> io::Result<()> {
                    match (self.term.info.get::<cap::CursorAddress>(),
                            self.term.info.get::<cap::CursorHome>()) {
                        (_, Some( ref home)) if pos == Cursor::default() => {
                            self.expand(home.expand())?;
                        }
                        (Some(addr), _) => {
                            self.expand(addr.expand()
                                .parameters(to_u32(pos.line), to_u32(pos.column)))?;
                        }
                        (None, _) => return Err(not_supported("cursor_address"))
                    }

                    Ok(())
                }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> {
                    match mode {
                        CursorMode::Normal | CursorMode::Overwrite => {
                            expand_opt!(self, cap::CursorNormal)?;
                        }
                        CursorMode::Invisible => {
                            expand_opt!(self, cap::CursorInvisible)?;
                        }
                    }

                    Ok(())
                }

                pub fn write_char(&mut self, ch: char) -> io::Result<()> {
                    self.write_str(ch.encode_utf8(&mut [0; 4]))
                }

                pub fn write_str(&mut self, s: &str) -> io::Result<()> {
                    self.write_bytes(s.as_bytes())
                }

                pub fn write_styled(&mut self,
                        fg: Option<Color>, bg: Option<Color>, style: Style, text: &str)
                        -> io::Result<()> {
                    self.set_attrs(fg, bg, style)?;

                    self.write_str(text)?;
                    self.clear_attributes()
                }

                fn write_bytes(&mut self, buf: &[u8]) -> io::Result<()> {
                    if buf.len() + self.writer.out_buffer.len() > self.writer.out_buffer.capacity() {
                        self.flush()?;
                    }

                    if buf.len() > self.writer.out_buffer.capacity() {
                        self.write_data(buf).1
                    } else {
                        self.writer.out_buffer.extend(buf);
                        Ok(())
                    }
                }

                pub fn flush(&mut self) -> io::Result<()> {
                    let (n, res) = self.write_data(&self.writer.out_buffer);
                    self.writer.out_buffer.drain(..n);
                    res
                }

                fn write_data(&self, buf: &[u8]) -> (usize, io::Result<()>) {
                    let mut offset = 0;

                    let r = loop {
                        if offset == buf.len() {
                            break Ok(());
                        }

                        match write(self.term.out_fd, buf) {
                            Ok(0) => break Err(io::Error::from(io::ErrorKind::WriteZero)),
                            Ok(n) => offset += n,
                            Err(Errno::EINTR) => continue,
                            Err(e) => break Err(nix_to_io(e))
                        }
                    };

                    (offset, r)
                }

                fn expand<T: AsRef<[u8]>>(&mut self, exp: Expansion<T>) -> io::Result<()> {
                    let writer = &mut *self.writer;
                    exp
                        .with(&mut writer.context)
                        .to(&mut writer.out_buffer)
                        .map_err(ti_to_io)
                }
            }

            impl<'a> Drop for TerminalWriteGuard<'a> 
            {
                fn drop(&mut self) {
                    if let Err(e) = self.flush() {
                        eprintln!("failed to flush terminal: {}", e);
                    }
                }
            }

            struct Reader
            {
                in_buffer: Vec<u8>,
                resume: Option<Resume>,
                report_signals: SignalSet,
            }

            struct Writer
            {
                context: Context,
                out_buffer: Vec<u8>,
                fg: Option<Color>,
                bg: Option<Color>,
                cur_style: Style,
            }

            impl Writer
            {
                fn new() -> Writer
                {
                    Writer
                    {
                        context: Context::default(),
                        out_buffer: Vec::with_capacity(OUT_BUFFER_SIZE),
                        fg: None,
                        bg: None,
                        cur_style: Style::empty(),
                    }
                }
            }

            fn is_xterm(name: &str) -> bool { name == "xterm" || name.starts_with("xterm-") }

            fn sequences(info: &Database) -> SeqMap
            {
                let mut sequences = SequenceMap::new();

                macro_rules! add {
                    ( $seq:ty , $key:expr ) => { {
                        if let Some(seq) = info.get::<$seq>() {
                            if let Some(s) = ascii_str(seq.as_ref()) {
                                sequences.insert(s.into(), SeqData::Key($key));
                            }
                        }
                    } }
                }

                add!(cap::KeyUp,        Key::Up);
                add!(cap::KeyDown,      Key::Down);
                add!(cap::KeyLeft,      Key::Left);
                add!(cap::KeyRight,     Key::Right);
                add!(cap::KeyHome,      Key::Home);
                add!(cap::KeyEnd,       Key::End);
                add!(cap::KeyNPage,     Key::PageDown);
                add!(cap::KeyPPage,     Key::PageUp);
                add!(cap::KeyDc,        Key::Delete);
                add!(cap::KeyIc,        Key::Insert);
                add!(cap::KeyF1,        Key::F(1));
                add!(cap::KeyF2,        Key::F(2));
                add!(cap::KeyF3,        Key::F(3));
                add!(cap::KeyF4,        Key::F(4));
                add!(cap::KeyF5,        Key::F(5));
                add!(cap::KeyF6,        Key::F(6));
                add!(cap::KeyF7,        Key::F(7));
                add!(cap::KeyF8,        Key::F(8));
                add!(cap::KeyF9,        Key::F(9));
                add!(cap::KeyF10,       Key::F(10));
                add!(cap::KeyF11,       Key::F(11));
                add!(cap::KeyF12,       Key::F(12));

                if is_xterm(info.name()) {
                    sequences.insert(XTERM_MOUSE_INTRO.into(), SeqData::XTermMouse);
                }

                sequences
            }

            pub struct PrepareState 
            {
                old_tio: termios,
                old_sigcont: Option<SigAction>,
                old_sigint: Option<SigAction>,
                old_sigtstp: Option<SigAction>,
                old_sigquit: Option<SigAction>,
                old_sigwinch: Option<SigAction>,
                restore_keypad: bool,
                restore_mouse: bool,
                prev_resume: Option<Resume>,
            }

            #[derive(Copy, Clone, Debug)]
            struct Resume 
            {
                config: PrepareConfig,
            }

            unsafe fn close_fd(fd: RawFd)  { drop(File::from_raw_fd(fd)); }

            fn open_rw<P: AsRef<Path>>(path: P) -> io::Result<RawFd> 
            {
                use std::fs::OpenOptions;
                let file = OpenOptions::new()
                .read(true)
                .write(true)
                .open(path)?;

                Ok(file.into_raw_fd())
            }

            #[repr(C)]
            struct Winsize 
            {
                ws_row: c_ushort,
                ws_col: c_ushort,
                ws_xpixel: c_ushort,
                ws_ypixel: c_ushort,
            }

            fn get_winsize(fd: c_int) -> io::Result<Size> 
            {
                let mut winsz: Winsize = unsafe { zeroed() };
                let res = unsafe { ioctl(fd, TIOCGWINSZ.into(), &mut winsz) };

                if res == -1 { Err(io::Error::last_os_error()) } 
                else
                {
                    let size = Size
                    {
                        lines: winsz.ws_row as usize,
                        columns: winsz.ws_col as usize,
                    };
                    Ok(size)
                }
            }

            fn nix_to_io(e: nix::Error) -> io::Error  { io::Error::from_raw_os_error(e as i32) }

            fn ti_to_io(e: terminfo::Error) -> io::Error 
            {
                match e 
                {
                    terminfo::Error::Io(e) => e,
                    terminfo::Error::NotFound => io::Error::new( io::ErrorKind::NotFound, "terminfo entry not found"),
                    terminfo::Error::Parse => io::Error::new( io::ErrorKind::Other, "failed to parse terminfo entry"),
                    terminfo::Error::Expand(_) => io::Error::new( io::ErrorKind::Other, "failed to expand terminfo entry"),
                }
            }

            fn to_timeval(d: Duration) -> TimeVal
            {
                const MAX_SECS: i64 = i64::max_value() / 1_000;

                let secs = match d.as_secs()
                {
                    n if n > MAX_SECS as u64 => MAX_SECS,
                    n => n as i64,
                };

                let millis = d.subsec_millis() as i64;
                TimeVal::milliseconds(secs * 1_000 + millis)
            }

            fn peek_event(buf: &[u8], sequences: &SeqMap) -> io::Result<Option<(Event, usize)>>
            {
                let (res, n) =
                {
                    let s = utf8_prefix(buf)?;
                    
                    if s.is_empty() { return Ok(None); }

                    let mut last_match = None;

                    for pfx in prefixes(s)
                    {
                        match sequences.find(pfx)
                        {
                            FindResult::NotFound => break,
                            FindResult::Found(value) =>
                            {
                                last_match = Some((pfx, *value));
                                break;
                            }
                            FindResult::Incomplete => (),
                            FindResult::Undecided(value ) => { last_match = Some((pfx, *value)); }
                        }
                    }

                    let res = last_match.and_then(|(seq, value)|
                    {
                        match value
                        {
                            SeqData::Key(key) => Some((Event::Key(key), seq.len())),
                            SeqData::XTermMouse =>
                            {
                                if let Some((data, len)) = parse_mouse_data(&buf[seq.len()..]) 
                                { Some((Event::Mouse(data), seq.len() + len)) }
                                
                                else { None }
                            }
                        }
                    });

                    if let Some(res) = res { res }
                    
                    else
                    {
                        let ch = s.chars().next().unwrap();
                        (Event::Key(ch.into()), ch.len_utf8())
                    }
                };

                Ok(Some((res, n)))
            }

            fn parse_mouse_data(mut buf: &[u8]) -> Option<(MouseEvent, usize)>
            {
                let orig_len = buf.len();
                let (mut input, end) = parse_integer(&mut buf)?;

                if end != b';' { return None; }

                let (column, end) = parse_integer(&mut buf)?;
                if end != b';' { return None; }

                let (line, end) = parse_integer(&mut buf)?;
                let is_pressed = match end
                {
                    b'M' => true,
                    b'm' => false,
                    _ => return None
                };

                let mut mods = ModifierState::empty();
                if (input & XTERM_SHIFT_MASK) != 0 { mods |= ModifierState::SHIFT; }

                if (input & XTERM_META_MASK) != 0 { mods |= ModifierState::ALT; }

                if (input & XTERM_CTRL_MASK) != 0 { mods |= ModifierState::CTRL; }

                input &= !XTERM_MODIFIER_MASK;

                let input = match input
                {
                    0 ..= 3 => mouse_button_event(input, is_pressed),
                    64 => MouseInput::WheelUp,
                    65 => MouseInput::WheelDown,
                    _ => MouseInput::Motion,
                };

                let position = Cursor
                {
                    line: (line - 1) as usize,
                    column: (column - 1) as usize,
                };

                Some((MouseEvent
                {
                    position,
                    input,
                    modifiers: mods,
                }, orig_len - buf.len()))
            }

            fn parse_integer(buf: &mut &[u8]) -> Option<(u32, u8)>
            {
                let mut n = 0u32;
                let mut iter = buf.iter();

                while let Some(&b) = iter.next()
                {
                    match b
                    {
                        b'0' ..= b'9' =>
                        {
                            n = n.checked_mul(10)?
                                .checked_add((b - b'0') as u32)?;
                        }
                        
                        _ =>
                        {
                            *buf = iter.as_slice();
                            return Some((n, b));
                        }
                    }
                }

                None
            }

            fn mouse_button_event(input: u32, is_pressed: bool) -> MouseInput
            {
                let button = match input
                {
                    0 => MouseButton::Left,
                    1 => MouseButton::Middle,
                    2 => MouseButton::Right,
                    _ => MouseButton::Other(input)
                };

                if is_pressed { MouseInput::ButtonPressed(button) }

                else { MouseInput::ButtonReleased(button) }
            }

            fn utf8_prefix(buf: &[u8]) -> io::Result<&str>
            {
                match from_utf8(buf)
                {
                    Ok(s) => Ok(s),
                    Err(e) =>
                    {
                        if e.valid_up_to() != 0 { from_utf8(&buf[..e.valid_up_to()]).map_err(|_| unreachable!()) }
                        else if e.error_len().is_some()
                        { Err(io::Error::new(io::ErrorKind::Other, "read invalid utf-8 data from terminal")) } 
                        else { Ok("") }
                    }
                }
            }

            static LAST_SIGNAL: AtomicUsize = AtomicUsize::new(0);

            extern "C" fn handle_signal(signum: c_int)
            {
                LAST_SIGNAL.store(signum as usize, Ordering::Relaxed);
            }

            fn conv_signal(sig: c_int) -> Option<Signal>
            {
                match NixSignal::try_from(sig).ok()
                {
                    Some(NixSignal::SIGCONT)  => Some(Signal::Continue),
                    Some(NixSignal::SIGINT)   => Some(Signal::Interrupt),
                    Some(NixSignal::SIGQUIT)  => Some(Signal::Quit),
                    Some(NixSignal::SIGTSTP)  => Some(Signal::Suspend),
                    Some(NixSignal::SIGWINCH) => Some(Signal::Resize),
                    _ => None
                }
            }

            fn get_signal() -> Option<Signal> { conv_signal(LAST_SIGNAL.load(Ordering::Relaxed) as c_int) }

            fn take_signal() -> Option<Signal> { conv_signal(LAST_SIGNAL.swap(0, Ordering::Relaxed) as c_int) }

            fn ascii_str(s: &[u8]) -> Option<&str>
            {
                if s.is_ascii() { Some(unsafe { from_utf8_unchecked(s) }) }
                else { None }
            }

            fn color_code(color: Color) -> u8
            {
                match color
                {
                    Color::Black =>     0,
                    Color::Red =>       1,
                    Color::Green =>     2,
                    Color::Yellow =>    3,
                    Color::Blue =>      4,
                    Color::Magenta =>   5,
                    Color::Cyan =>      6,
                    Color::White =>     7,
                }
            }

            fn not_supported(op: &str) -> io::Error
            {
                io::Error::new(io::ErrorKind::Other, format!("operation not supported: {}", op))
            }
            
            fn to_u32(u: usize) -> u32
            {
                if u > u32::max_value() as usize { u32::max_value() } 
                else { u as u32 }
            }
        }
    }

    pub use ::mortal::sys::ext as unix;
    /*
        #[cfg(unix)]
        #[path = "unix/mod.rs"]

        #[cfg(windows)]
        #[path = "windows/mod.rs"]
        mod sys;

        #[cfg(windows)]
        pub use sys::ext as windows;
    */
}
pub mod net { pub use std::net::{ * }; }
/*
nom v7.1.3*/
pub mod nom
{
    //! # nom, eating data byte by byte
    pub use self::bits::*;
    pub use self::internal::*;
    pub use self::traits::*;
    /**/
    #[macro_use] mod macros
    {
        macro_rules! succ
        ( 
            ( 0, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 1, $( $rest )* ) );
            ( 1, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 2, $( $rest )* ) );
            ( 2, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 3, $( $rest )* ) );
            ( 3, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 4, $( $rest )* ) );
            ( 4, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 5, $( $rest )* ) );
            ( 5, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 6, $( $rest )* ) );
            ( 6, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 7, $( $rest )* ) );
            ( 7, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 8, $( $rest )* ) );
            ( 8, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 9, $( $rest )* ) );
            ( 9, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 10, $( $rest )* ) );
            ( 10, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 11, $( $rest )* ) );
            ( 11, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 12, $( $rest )* ) );
            ( 12, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 13, $( $rest )* ) );
            ( 13, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 14, $( $rest )* ) );
            ( 14, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 15, $( $rest )* ) );
            ( 15, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 16, $( $rest )* ) );
            ( 16, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 17, $( $rest )* ) );
            ( 17, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 18, $( $rest )* ) );
            ( 18, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 19, $( $rest )* ) );
            ( 19, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 20, $( $rest )* ) );
            ( 20, $submac:ident ! ( $( $rest:tt )* ) ) => ( $submac!( 21, $( $rest )* ) );
        );
    }
    /**/
    #[macro_use] pub mod error
    {
        //! Error management
        use super::internal::{Err, IResult, Parser};
        use ::
        {
            error::{ Error as StdError },
            fmt::{ self, Debug, Display, Write },
            nom::{ HexDisplay, traits::{ Offset } },
            ops::{ Deref, DerefMut },
            string::{ String },
            *,
        };
        /// Creates a parse error from a `nom::ErrorKind` and the position in the input
        #[macro_export( local_inner_macros )] macro_rules! error_position
        (( $input:expr, $code:expr ) => ({ $crate::nom::error::make_error( $input, $code ) }););
        /// Creates a parse error from a `nom::ErrorKind`, the position in the input and the next error in the parsing tree
        #[macro_export( local_inner_macros )] macro_rules! error_node_position
        (( $input:expr, $code:expr, $next:expr ) => ({ $crate::nom::error::append_error( $input, $code, $next ) } ););
        /// This trait must be implemented by the error type of a nom parser.
        pub trait ParseError<I>:Sized
        {
            /// Creates an error from the input position and an [ErrorKind]
            fn from_error_kind( input:I, kind:ErrorKind ) -> Self;
            /// Combines an existing error with a new one created from the input position and an [ErrorKind].
            fn append( input:I, kind:ErrorKind, other:Self ) -> Self;
            /// Creates an error from an input position and an expected character
            fn from_char( input:I, _:char ) -> Self { Self::from_error_kind( input, ErrorKind::Char ) }
            /// Combining two existing errors, this is used to compare errors generated in various branches of `alt`.
            fn or( self, other:Self ) -> Self { other }
        }
        /// This trait is required by the `context` combinator to add a static string to an existing error
        pub trait ContextError<I>:Sized
        {
            /// Creates a new error from an input position, a static string and an existing error.
            fn add_context( _input:I, _ctx:&'static str, other:Self ) -> Self { other }
        }
        /// Required by the `map_res` combinator to integrate error types from external functions.
        pub trait FromExternalError<I, E>
        {
            /// Creates a new error from an input position, an [ErrorKind] indicating the
            /// wrapping parser, and an external error
            fn from_external_error( input:I, kind:ErrorKind, e:E ) -> Self;
        }
        /// default error type, only contains the error' location and code
        #[derive( Debug, PartialEq )]
        pub struct Error<I>
        {
            /// position of the error in the input data
            pub input:I,
            /// nom error code
            pub code:ErrorKind,
        }

        impl<I> Error<I>
        {
            /// creates a new basic error
            pub fn new( input:I, code:ErrorKind ) -> Error<I> { Error { input, code } }
        }

        impl<I> ParseError<I> for Error<I>
        {
            fn from_error_kind( input:I, kind:ErrorKind ) -> Self { Error { input, code:kind } }
            fn append( _:I, _:ErrorKind, other:Self ) -> Self { other }
        }

        impl<I> ContextError<I> for Error<I> {}

        impl<I, E> FromExternalError<I, E> for Error<I>
        {
            /// Create a new error from an input position and an external error
            fn from_external_error( input:I, kind:ErrorKind, _e:E ) -> Self { Error { input, code:kind } }
        }
        /// The Display implementation allows the std::error::Error implementation
        impl<I:Debug + Display> StdError for Error<I> {}
        impl<I:Display> Display for Error<I>
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { write!(f, "error {:?} @:{}", self.code, self.input) }
        }
        /// Indicates which parser returned an error
        #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub enum ErrorKind
        {
            Tag,
            MapRes,
            MapOpt,
            Alt,
            IsNot,
            IsA,
            SeparatedList,
            SeparatedNonEmptyList,
            Many0,
            Many1,
            ManyTill,
            Count,
            TakeUntil,
            LengthValue,
            TagClosure,
            Alpha,
            Digit,
            HexDigit,
            OctDigit,
            AlphaNumeric,
            Space,
            MultiSpace,
            LengthValueFn,
            Eof,
            Switch,
            TagBits,
            OneOf,
            NoneOf,
            Char,
            CrLf,
            RegexpMatch,
            RegexpMatches,
            RegexpFind,
            RegexpCapture,
            RegexpCaptures,
            TakeWhile1,
            Complete,
            Fix,
            Escaped,
            EscapedTransform,
            NonEmpty,
            ManyMN,
            Not,
            Permutation,
            Verify,
            TakeTill1,
            TakeWhileMN,
            TooLarge,
            Many0Count,
            Many1Count,
            Float,
            Satisfy,
            Fail,
        }

        impl ErrorKind
        {
            /// Converts an ErrorKind to a text description
            pub fn description( &self ) -> &str 
            {
                match *self
                {
                    ErrorKind::Tag                   => "Tag",
                    ErrorKind::MapRes                => "Map on Result",
                    ErrorKind::MapOpt                => "Map on Option",
                    ErrorKind::Alt                   => "Alternative",
                    ErrorKind::IsNot                 => "IsNot",
                    ErrorKind::IsA                   => "IsA",
                    ErrorKind::SeparatedList         => "Separated list",
                    ErrorKind::SeparatedNonEmptyList => "Separated non empty list",
                    ErrorKind::Many0                 => "Many0",
                    ErrorKind::Many1                 => "Many1",
                    ErrorKind::Count                 => "Count",
                    ErrorKind::TakeUntil             => "Take until",
                    ErrorKind::LengthValue           => "Length followed by value",
                    ErrorKind::TagClosure            => "Tag closure",
                    ErrorKind::Alpha                 => "Alphabetic",
                    ErrorKind::Digit                 => "Digit",
                    ErrorKind::AlphaNumeric          => "AlphaNumeric",
                    ErrorKind::Space                 => "Space",
                    ErrorKind::MultiSpace            => "Multiple spaces",
                    ErrorKind::LengthValueFn         => "LengthValueFn",
                    ErrorKind::Eof                   => "End of file",
                    ErrorKind::Switch                => "Switch",
                    ErrorKind::TagBits               => "Tag on bitstream",
                    ErrorKind::OneOf                 => "OneOf",
                    ErrorKind::NoneOf                => "NoneOf",
                    ErrorKind::Char                  => "Char",
                    ErrorKind::CrLf                  => "CrLf",
                    ErrorKind::RegexpMatch           => "RegexpMatch",
                    ErrorKind::RegexpMatches         => "RegexpMatches",
                    ErrorKind::RegexpFind            => "RegexpFind",
                    ErrorKind::RegexpCapture         => "RegexpCapture",
                    ErrorKind::RegexpCaptures        => "RegexpCaptures",
                    ErrorKind::TakeWhile1            => "TakeWhile1",
                    ErrorKind::Complete              => "Complete",
                    ErrorKind::Fix                   => "Fix",
                    ErrorKind::Escaped               => "Escaped",
                    ErrorKind::EscapedTransform      => "EscapedTransform",
                    ErrorKind::NonEmpty              => "NonEmpty",
                    ErrorKind::ManyMN                => "Many( m, n )",
                    ErrorKind::HexDigit              => "Hexadecimal Digit",
                    ErrorKind::OctDigit              => "Octal digit",
                    ErrorKind::Not                   => "Negation",
                    ErrorKind::Permutation           => "Permutation",
                    ErrorKind::ManyTill              => "ManyTill",
                    ErrorKind::Verify                => "predicate verification",
                    ErrorKind::TakeTill1             => "TakeTill1",
                    ErrorKind::TakeWhileMN           => "TakeWhileMN",
                    ErrorKind::TooLarge              => "Needed data size is too large",
                    ErrorKind::Many0Count            => "Count occurrence of >=0 patterns",
                    ErrorKind::Many1Count            => "Count occurrence of >=1 patterns",
                    ErrorKind::Float                 => "Float",
                    ErrorKind::Satisfy               => "Satisfy",
                    ErrorKind::Fail                  => "Fail",
                }
            }
        }
        
        impl<I> ParseError<I> for ( I, ErrorKind )
        {
            fn from_error_kind( input:I, kind:ErrorKind ) -> Self { ( input, kind ) }
            fn append( _:I, _:ErrorKind, other:Self ) -> Self { other }
        }

        impl<I> ContextError<I> for ( I, ErrorKind ) {}
        impl<I, E> FromExternalError<I, E> for ( I, ErrorKind )
        {
            fn from_external_error( input:I, kind:ErrorKind, _e:E ) -> Self { ( input, kind ) }
        }

        impl<I> ParseError<I> for ()
        {
            fn from_error_kind( _:I, _:ErrorKind ) -> Self {}
            fn append( _:I, _:ErrorKind, _:Self ) -> Self {}
        }

        impl<I> ContextError<I> for () {}

        impl<I, E> FromExternalError<I, E> for ()
        {
            fn from_external_error( _input:I, _kind:ErrorKind, _e:E ) -> Self {}
        }
        /// Creates an error from the input position and an [ErrorKind]
        pub fn make_error<I, E:ParseError<I>>( input:I, kind:ErrorKind ) -> E
        {
            E::from_error_kind( input, kind )
        }
        /// Combines an existing error with a new one created from the input position and an [ErrorKind].
        pub fn append_error<I, E:ParseError<I>>( input:I, kind:ErrorKind, other:E ) -> E { E::append( input, kind, other ) }
        /// This error type accumulates errors and their position when backtracking through a parse tree.
        #[derive( Clone, Debug, PartialEq )]
        pub struct VerboseError<I>
        {
            /// List of errors accumulated by `VerboseError`, containing the affected part of input data, and some context
            pub errors:Vec<( I, VerboseErrorKind )>
        }
        /// Error context for `VerboseError`
        #[derive( Clone, Debug, PartialEq )]
        pub enum VerboseErrorKind
        {
            /// Static string added by the `context` function
            Context( &'static str ),
            /// Indicates which character was expected by the `char` function
            Char( char ),
            /// Error kind given by various nom parsers
            Nom( ErrorKind ),
        }
        
        impl<I> ParseError<I> for VerboseError<I>
        {
            fn from_error_kind( input:I, kind:ErrorKind ) -> Self
            {
                VerboseError
                {
                    errors:vec![( input, VerboseErrorKind::Nom( kind ) )],
                }
            }

            fn append( input:I, kind:ErrorKind, mut other:Self ) -> Self
            {
                other.errors.push( ( input, VerboseErrorKind::Nom( kind ) ) );
                other
            }

            fn from_char( i:I, c:char ) -> Self { VerboseError { errors:vec![( i, VerboseErrorKind::Char( c ) )], } }
        }
        
        impl<I> ContextError<I> for VerboseError<I>
        {
            fn add_context( input:I, ctx:&'static str, mut other:Self ) -> Self
            {
                other.errors.push( ( input, VerboseErrorKind::Context( ctx ) ) );
                other
            }
        }
        
        impl<I, E> FromExternalError<I, E> for VerboseError<I>
        {
            /// Create a new error from an input position and an external error
            fn from_external_error( input:I, kind:ErrorKind, _e:E ) -> Self { Self::from_error_kind( input, kind ) }
        }
        
        impl<I:Display> Display for VerboseError<I>
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
            {
                writeln!( f, "Parse error:" )?;
                for ( input, error ) in &self.errors
                {
                    match error
                    {
                        VerboseErrorKind::Nom( e ) => writeln!( f, "{:?} at:{}", e, input )?,
                        VerboseErrorKind::Char( c ) => writeln!( f, "expected '{}' at:{}", c, input )?,
                        VerboseErrorKind::Context( s ) => writeln!( f, "in section '{}', at:{}", s, input )?,
                    }
                }
                Ok( () )
            }
        }
        
        impl<I:Debug + Display> StdError for VerboseError<I> {}
        /// Create a new error from an input position, a static string and an existing error.
        pub fn context<I:Clone, E:ContextError<I>, F, O> ( ctx:&'static str, mut f:F ) -> impl FnMut( I ) -> IResult<I, O, E>
        where F:Parser<I, O, E>,
        {
            move |i:I| match f.parse( i.clone() )
            {
                Ok( o ) => Ok( o ),
                Err( Err::Incomplete( i ) ) => Err( Err::Incomplete( i ) ),
                Err( Err::Error( e ) ) => Err( Err::Error( E::add_context( i, ctx, e ) ) ),
                Err( Err::Failure( e ) ) => Err( Err::Failure( E::add_context( i, ctx, e ) ) ),
            }
        }
        /// Transforms a `VerboseError` into a trace with input position information
        pub fn convert_error<I:Deref<Target = str>>( input:I, e:VerboseError<I>, ) -> String
        {
            let mut result = String::new();

            for ( i, ( substring, kind ) ) in e.errors.iter().enumerate()
            {
                let offset = input.offset( substring );
                if input.is_empty()
                {
                    match kind
                    {
                        VerboseErrorKind::Char( c ) => { write!( &mut result, "{}:expected '{}', got empty input\n\n", i, c ) }
                        VerboseErrorKind::Context( s ) => write!( &mut result, "{}:in {}, got empty input\n\n", i, s ),
                        VerboseErrorKind::Nom( e ) => write!( &mut result, "{}:in {:?}, got empty input\n\n", i, e ),
                    }
                }

                else
                {
                    let p = &input.as_bytes()[..offset];
                    let line_no = p.iter().filter( |&&b| b == b'\n' ).count() + 1;
                    let line_begin = p.iter().rev().position( |&b| b == b'\n' ).map( |pos| offset - pos ).unwrap_or( 0 );
                    let line = input[line_begin..].lines().next().unwrap_or( &input[line_begin..] ).trim_end();
                    let column_number = line.offset( substring ) + 1;

                    match kind
                    {
                        VerboseErrorKind::Char( c ) =>
                        {
                            if let Some( found ) = substring.chars().next()
                            {
                                write!
                                (
                                    &mut result,
                                    "{i}:@line {line_no}:\n{line}\n{caret:>column$}\nneeds '{needs}', found {found}\n\n",
                                    i = i,
                                    line_no = line_no,
                                    line = line,
                                    caret = '^',
                                    column = column_number,
                                    needs = c,
                                    found = found,
                                )
                            } 
                            else
                            {
                                write!
                                ( 
                                    &mut result,
                                    "{i}:@line {line_no}:\n{line}\n{caret:>column$}\nneeds '{needs}', got end of input\n\n",
                                    i = i,
                                    line_no = line_no,
                                    line = line,
                                    caret = '^',
                                    column = column_number,
                                    needs = c,
                                )
                            }
                        }

                        VerboseErrorKind::Context( s ) =>
                        {
                            write!
                            (
                                &mut result,
                                "{i}:@line {line_no}, in {ctx}:\n{line}\n{caret:>column$}\n\n",
                                i = i,
                                line_no = line_no,
                                ctx = s,
                                line = line,
                                caret = '^',
                                column = column_number,
                            )
                        }
                        
                        VerboseErrorKind::Nom( e ) =>
                        {
                            write!
                            (
                                &mut result,
                                "{i}:@line {line_no}, in {nom_err:?}:\n{line}\n{caret:>column$}\n\n",
                                i = i,
                                line_no = line_no,
                                nom_err = e,
                                line = line,
                                caret = '^',
                                column = column_number,
                            )
                        }
                    }
                }.unwrap();
            }

            result
        }
        /// Converts an ErrorKind to a number
        pub fn error_to_u32( e:&ErrorKind ) -> u32
        {
            match *e
            {
                ErrorKind::Tag                   => 1,
                ErrorKind::MapRes                => 2,
                ErrorKind::MapOpt                => 3,
                ErrorKind::Alt                   => 4,
                ErrorKind::IsNot                 => 5,
                ErrorKind::IsA                   => 6,
                ErrorKind::SeparatedList         => 7,
                ErrorKind::SeparatedNonEmptyList => 8,
                ErrorKind::Many1                 => 9,
                ErrorKind::Count                 => 10,
                ErrorKind::TakeUntil             => 12,
                ErrorKind::LengthValue           => 15,
                ErrorKind::TagClosure            => 16,
                ErrorKind::Alpha                 => 17,
                ErrorKind::Digit                 => 18,
                ErrorKind::AlphaNumeric          => 19,
                ErrorKind::Space                 => 20,
                ErrorKind::MultiSpace            => 21,
                ErrorKind::LengthValueFn         => 22,
                ErrorKind::Eof                   => 23,
                ErrorKind::Switch                => 27,
                ErrorKind::TagBits               => 28,
                ErrorKind::OneOf                 => 29,
                ErrorKind::NoneOf                => 30,
                ErrorKind::Char                  => 40,
                ErrorKind::CrLf                  => 41,
                ErrorKind::RegexpMatch           => 42,
                ErrorKind::RegexpMatches         => 43,
                ErrorKind::RegexpFind            => 44,
                ErrorKind::RegexpCapture         => 45,
                ErrorKind::RegexpCaptures        => 46,
                ErrorKind::TakeWhile1            => 47,
                ErrorKind::Complete              => 48,
                ErrorKind::Fix                   => 49,
                ErrorKind::Escaped               => 50,
                ErrorKind::EscapedTransform      => 51,
                ErrorKind::NonEmpty              => 56,
                ErrorKind::ManyMN                => 57,
                ErrorKind::HexDigit              => 59,
                ErrorKind::OctDigit              => 61,
                ErrorKind::Many0                 => 62,
                ErrorKind::Not                   => 63,
                ErrorKind::Permutation           => 64,
                ErrorKind::ManyTill              => 65,
                ErrorKind::Verify                => 66,
                ErrorKind::TakeTill1             => 67,
                ErrorKind::TakeWhileMN           => 69,
                ErrorKind::TooLarge              => 70,
                ErrorKind::Many0Count            => 71,
                ErrorKind::Many1Count            => 72,
                ErrorKind::Float                 => 73,
                ErrorKind::Satisfy               => 74,
                ErrorKind::Fail                  => 75,
            }
        }
        /// Prints a message and the input if the parser fails.
        pub fn dbg_dmp<'a, F, O, E:Debug>( f:F, ctx:&'static str ) -> impl Fn( &'a [u8] ) -> IResult<&'a [u8], O, E> where
        F:Fn( &'a [u8] ) -> IResult<&'a [u8], O, E>,
        {
            move |i:&'a [u8]| match f( i )
            {
                Err( e ) =>
                {
                    println!( "{}:Error( {:?} ) at:\n{}", ctx, e, i.to_hex( 8 ) );
                    Err( e )
                }
                a => a,
            }
        }
    }
    /**/
    pub mod branch
    {
        //! Choice combinators
        use ::
        {
            nom::
            {
                error::{ ErrorKind, ParseError },
                internal::{ Err, IResult, Parser },
            },
            *,
        };        

        macro_rules! alt_trait
        (
            ($first:ident $second:ident $($id: ident)+) => ( alt_trait!(__impl $first $second; $($id)+); );
            (__impl $($current:ident)*; $head:ident $($id: ident)+) =>
            
            (
                alt_trait_impl!($($current)*);
                alt_trait!(__impl $($current)* $head; $($id)+);
            );
            
            (__impl $($current:ident)*; $head:ident) =>
            (
                alt_trait_impl!($($current)*);
                alt_trait_impl!($($current)* $head);
            );
        );

        macro_rules! alt_trait_impl
        (
            ($($id:ident)+) =>
            (
                impl
                <
                    Input: Clone, Output, Error: ParseError<Input>,
                    $($id: Parser<Input, Output, Error>),+
                > Alt<Input, Output, Error> for ( $($id),+ )
                {
                    fn choice(&mut self, input: Input) -> IResult<Input, Output, Error>
                    {
                        match self.0.parse(input.clone()) 
                        {
                            Err(Err::Error(e)) => alt_trait_inner!(1, self, input, e, $($id)+),
                            res => res,
                        }
                    }
                }
            );
        );

        macro_rules! alt_trait_inner
        (
            ($it:tt, $self:expr, $input:expr, $err:expr, $head:ident $($id:ident)+) => 
            (
                match $self.$it.parse($input.clone())
                {
                    Err(Err::Error(e)) =>
                    {
                        let err = $err.or(e);
                        succ!($it, alt_trait_inner!($self, $input, err, $($id)+))
                    }
                    res => res,
                }
            );

            ($it:tt, $self:expr, $input:expr, $err:expr, $head:ident) => 
            ( Err(Err::Error(Error::append($input, ErrorKind::Alt, $err))) );
        );

        macro_rules! permutation_trait
        (
            (
                $name1:ident $ty1:ident $item1:ident
                $name2:ident $ty2:ident $item2:ident
                $($name3:ident $ty3:ident $item3:ident)*
            ) => ( permutation_trait!(__impl $name1 $ty1 $item1, $name2 $ty2 $item2; $($name3 $ty3 $item3)*); );

            (
                __impl $($name:ident $ty:ident $item:ident),+;
                $name1:ident $ty1:ident $item1:ident $($name2:ident $ty2:ident $item2:ident)*
            ) => 
            (
                permutation_trait_impl!($($name $ty $item),+);
                permutation_trait!(__impl $($name $ty $item),+ , $name1 $ty1 $item1; $($name2 $ty2 $item2)*);
            );

            (__impl $($name:ident $ty:ident $item:ident),+;) => ( permutation_trait_impl!($($name $ty $item),+); );
        );

        macro_rules! permutation_trait_impl
        (
            ($($name:ident $ty:ident $item:ident),+) =>
            (
                impl
                <
                Input: Clone, $($ty),+ , Error: ParseError<Input>,
                $($name: Parser<Input, $ty, Error>),+
                > Permutation<Input, ( $($ty),+ ), Error> for ( $($name),+ )
                {

                    fn permutation(&mut self, mut input: Input) -> IResult<Input, ( $($ty),+ ), Error>
                    {
                        let mut res = ($(Option::<$ty>::None),+);

                        loop
                        {
                            let mut err: Option<Error> = None;
                            permutation_trait_inner!(0, self, input, res, err, $($name)+);

                            if let Some(err) = err 
                            { return Err(Err::Error(Error::append(input, ErrorKind::Permutation, err))); }
                            
                            match res
                            {
                                ($(Some($item)),+) => return Ok((input, ($($item),+))),
                                _ => unreachable!(),
                            }
                        }
                    }
                }
            );
        );

        macro_rules! permutation_trait_inner
        (
            ($it:tt, $self:expr, $input:ident, $res:expr, $err:expr, $head:ident $($id:ident)*) => 
            (
                if $res.$it.is_none()
                {
                    match $self.$it.parse($input.clone())
                    {
                        Ok((i, o)) =>
                        {
                            $input = i;
                            $res.$it = Some(o);
                            continue;
                        }

                        Err(Err::Error(e)) =>
                        {
                            $err = Some(match $err {
                                Some(err) => err.or(e),
                                None => e,
                            });
                        }

                        Err(e) => return Err(e),
                    };
                }

                succ!($it, permutation_trait_inner!($self, $input, $res, $err, $($id)*));
            );

            ($it:tt, $self:expr, $input:ident, $res:expr, $err:expr,) => ();
        );
        /// Helper trait for the [alt( )] combinator.
        pub trait Alt<I, O, E>
        {
            /// Tests each parser in the tuple and returns the result of the first one that succeeds
            fn choice(&mut self, input: I) -> IResult<I, O, E>;
        }
        /// Tests a list of parsers one by one until one succeeds.
        pub fn alt<I: Clone, O, E: ParseError<I>, List: Alt<I, O, E>>( mut l: List ) -> impl FnMut(I) -> IResult<I, O, E>
        { move |i: I| l.choice(i) }
        /// Helper trait for the [permutation( )] combinator.
        pub trait Permutation<I, O, E> 
        {
            /// Tries to apply all parsers in the tuple in various orders until all of them succeed
            fn permutation(&mut self, input: I) -> IResult<I, O, E>;
        }
        /// Applies a list of parsers in any order.
        pub fn permutation<I: Clone, O, E: ParseError<I>, List: Permutation<I, O, E>>( mut l: List ) -> 
        impl FnMut(I) -> IResult<I, O, E>
        { move |i: I| l.permutation(i) }

        alt_trait!(A B C D E F G H I J K L M N O P Q R S T U);
        
        impl<Input, Output, Error: ParseError<Input>, A: Parser<Input, Output, Error>>
        Alt<Input, Output, Error> for (A,)
        {
            fn choice(&mut self, input: Input) -> IResult<Input, Output, Error> { self.0.parse(input) }
        }

        permutation_trait!
        (
            FnA A a
            FnB B b
            FnC C c
            FnD D d
            FnE E e
            FnF F f
            FnG G g
            FnH H h
            FnI I i
            FnJ J j
            FnK K k
            FnL L l
            FnM M m
            FnN N n
            FnO O o
            FnP P p
            FnQ Q q
            FnR R r
            FnS S s
            FnT T t
            FnU U u
        );
    }
    /**/
    pub mod combinator
    {
        //! General purpose combinators
        use ::
        {
            borrow::{ Borrow },
            convert::{ Into },
            boxed::{ Box },
            fmt::{ Debug },
            mem::{ transmute },
            ops::{Range, RangeFrom, RangeTo},
            nom::
            {
                error::{ ErrorKind, FromExternalError, ParseError },
                internal::{ * },
                traits::
                { 
                    AsChar, Compare, CompareResult, InputIter, InputLength, InputTakeAtPosition, Offset, ParseTo, Slice,
                }
            },
            *,
        };
        /// Return the remaining input.
        #[inline] pub fn rest<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
        T: Slice<RangeFrom<usize>>,
        T: InputLength
        { Ok((input.slice(input.input_len()..), input)) }
        /// Return the length of the remaining input.
        #[inline] pub fn rest_len<T, E: ParseError<T>>(input: T) -> IResult<T, usize, E> where
        T: InputLength
        {
            let len = input.input_len();
            Ok((input, len))
        }
        /// Maps a function on the result of a parser.
        pub fn map<I, O1, O2, E, F, G>(mut parser: F, mut f: G) -> impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: FnMut(O1) -> O2
        {
            move |input: I|
            {
                let (input, o1) = parser.parse(input)?;
                Ok((input, f(o1)))
            }
        }
        /// Applies a function returning a `Result` over the result of a parser.
        pub fn map_res<I: Clone, O1, O2, E: FromExternalError<I, E2>, E2, F, G>( mut parser: F, mut f: G ) -> 
        impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: FnMut(O1) -> Result<O2, E2>
        {
            move |input: I|
            {
                let i = input.clone();
                let (input, o1) = parser.parse(input)?;
                match f(o1)
                {
                    Ok(o2) => Ok((input, o2)),
                    Err(e) => Err(Err::Error(E::from_external_error(i, ErrorKind::MapRes, e))),
                }
            }
        }
        /// Applies a function returning an `Option` over the result of a parser.
        pub fn map_opt<I: Clone, O1, O2, E: ParseError<I>, F, G>( mut parser: F, mut f: G ) -> impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: FnMut(O1) -> Option<O2>
        {
            move |input: I|
            {
                let i = input.clone();
                let (input, o1) = parser.parse(input)?;
                match f(o1)
                {
                    Some(o2) => Ok((input, o2)),
                    None => Err(Err::Error(E::from_error_kind(i, ErrorKind::MapOpt))),
                }
            }
        }
        /// Applies a parser over the result of another one.
        pub fn map_parser<I, O1, O2, E: ParseError<I>, F, G>( mut parser: F, mut applied_parser: G ) -> 
        impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: Parser<O1, O2, E>
        {
            move |input: I|
            {
                let (input, o1) = parser.parse(input)?;
                let (_, o2) = applied_parser.parse(o1)?;
                Ok((input, o2))
            }
        }
        /// Creates a new parser from the output of the first parser, then apply that parser over the rest of the input.
        pub fn flat_map<I, O1, O2, E: ParseError<I>, F, G, H>( mut parser: F, mut applied_parser: G ) -> 
        impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: FnMut(O1) -> H,
        H: Parser<I, O2, E>
        {
            move |input: I|
            {
                let (input, o1) = parser.parse(input)?;
                applied_parser(o1).parse(input)
            }
        }
        /// Optional parser, will return `None` on [`Err::Error`].
        pub fn opt<I: Clone, O, E: ParseError<I>, F>( mut f:F ) -> impl FnMut(I) -> IResult<I, Option<O>, E> where
        F: Parser<I, O, E>
        {
            move |input: I|
            {
                let i = input.clone();
                match f.parse(input)
                {
                    Ok((i, o)) => Ok((i, Some(o))),
                    Err(Err::Error(_)) => Ok((i, None)),
                    Err(e) => Err(e),
                }
            }
        }
        /// Calls the parser if the condition is met.
        pub fn cond<I, O, E: ParseError<I>, F>( b: bool, mut f:F ) -> impl FnMut(I) -> IResult<I, Option<O>, E> where
        F: Parser<I, O, E>
        {
            move |input: I|
            {
                if b
                {
                    match f.parse(input)
                    {
                        Ok((i, o)) => Ok((i, Some(o))),
                        Err(e) => Err(e),
                    }
                }
                
                else { Ok((input, None)) }
            }
        }
        /// Tries to apply its parser without consuming the input.
        pub fn peek<I: Clone, O, E: ParseError<I>, F>( mut f:F ) -> impl FnMut(I) -> IResult<I, O, E> where
        F: Parser<I, O, E>
        {
            move |input: I|
            {
                let i = input.clone();
                match f.parse(input)
                {
                    Ok((_, o)) => Ok((i, o)),
                    Err(e) => Err(e),
                }
            }
        }
        /// Returns its input if it is at the end of input data
        pub fn eof<I: InputLength + Clone, E: ParseError<I>>(input: I) -> IResult<I, I, E>
        {
            if input.input_len() == 0
            {
                let clone = input.clone();
                Ok((input, clone))
            }

            else { Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof))) }
        }
        /// Transforms Incomplete into `Error`.
        pub fn complete<I: Clone, O, E: ParseError<I>, F>( mut f:F ) -> impl FnMut(I) -> IResult<I, O, E> where
        F: Parser<I, O, E>
        {
            move |input: I|
            {
                let i = input.clone();
                match f.parse(input)
                {
                    Err(Err::Incomplete(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Complete))),
                    rest => rest,
                }
            }
        }
        /// Succeeds if all the input has been consumed by its child parser.
        pub fn all_consuming<I, O, E: ParseError<I>, F>( mut f:F ) -> impl FnMut(I) -> IResult<I, O, E> where
        I: InputLength,
        F: Parser<I, O, E>
        {
            move |input: I|
            {
                let (input, res) = f.parse(input)?;
                if input.input_len() == 0 { Ok((input, res)) } 
                else { Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof))) }
            }
        }
        /// Returns the result of the child parser if it satisfies a verification function.
        pub fn verify<I: Clone, O1, O2, E: ParseError<I>, F, G>( mut first: F, second: G ) -> 
        impl FnMut(I) -> IResult<I, O1, E> where
        F: Parser<I, O1, E>,
        G: Fn(&O2) -> bool,
        O1: Borrow<O2>,
        O2: ?Sized
        {
            move |input: I|
            {
                let i = input.clone();
                let (input, o) = first.parse(input)?;
                if second(o.borrow()) { Ok((input, o)) } 
                else { Err(Err::Error(E::from_error_kind(i, ErrorKind::Verify))) }
            }
        }
        /// Returns the provided value if the child parser succeeds.
        pub fn value<I, O1: Clone, O2, E: ParseError<I>, F>( val: O1, mut parser: F ) -> 
        impl FnMut(I) -> IResult<I, O1, E> where
        F: Parser<I, O2, E>
        {
            move |input: I| parser.parse(input).map(|(i, _)| (i, val.clone()))
        }
        /// Succeeds if the child parser returns an error.
        pub fn not<I: Clone, O, E: ParseError<I>, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, (), E> where
        F: Parser<I, O, E>
        {
            move |input: I|
            {
                let i = input.clone();
                match parser.parse(input)
                {
                    Ok(_) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Not))),
                    Err(Err::Error(_)) => Ok((i, ())),
                    Err(e) => Err(e),
                }
            }
        }
        /// If the child parser was successful, return the consumed input as produced value.
        pub fn recognize<I: Clone + Offset + Slice<RangeTo<usize>>, O, E: ParseError<I>, F>( mut parser: F ) -> 
        impl FnMut(I) -> IResult<I, I, E> where
        F: Parser<I, O, E>
        {
            move |input: I|
            {
                let i = input.clone();
                match parser.parse(i)
                {
                    Ok((i, _)) =>
                    {
                        let index = input.offset(&i);
                        Ok((i, input.slice(..index)))
                    }
                    Err(e) => Err(e),
                }
            }
        }
        /// If the child parser was successful, return the consumed input with the output as a tuple.
        pub fn consumed<I, O, F, E>(mut parser: F) -> impl FnMut(I) -> IResult<I, (I, O), E> where
        I: Clone + Offset + Slice<RangeTo<usize>>,
        E: ParseError<I>,
        F: Parser<I, O, E>
        {
            move |input: I|
            {
                let i = input.clone();
                match parser.parse(i)
                {
                    Ok((remaining, result)) =>
                    {
                        let index = input.offset(&remaining);
                        let consumed = input.slice(..index);
                        Ok((remaining, (consumed, result)))
                    }
                    
                    Err(e) => Err(e),
                }
            }
        }
        /// Transforms an [`Err::Error`] (recoverable) to [`Err::Failure`] (unrecoverable)
        pub fn cut<I, O, E: ParseError<I>, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, O, E> where
        F: Parser<I, O, E>
        {
            move |input: I| match parser.parse(input)
            {
                Err(Err::Error(e)) => Err(Err::Failure(e)),
                rest => rest,
            }
        }
        /// automatically converts the child parser's result to another type
        pub fn into<I, O1, O2, E1, E2, F>(mut parser: F) -> impl FnMut(I) -> IResult<I, O2, E2> where
        O1: Into<O2>,
        E1: Into<E2>,
        E1: ParseError<I>,
        E2: ParseError<I>,
        F: Parser<I, O1, E1>
        {
            move |input: I| match parser.parse(input)
            {
                Ok((i, o)) => Ok((i, o.into())),
                Err(Err::Error(e)) => Err(Err::Error(e.into())),
                Err(Err::Failure(e)) => Err(Err::Failure(e.into())),
                Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),
            }
        }
        /// Creates an iterator from input data and a parser.
        pub fn iterator<Input, Output, Error, F>(input: Input, f: F) -> ParserIterator<Input, Error, F> where
        F: Parser<Input, Output, Error>,
        Error: ParseError<Input>
        {
            ParserIterator
            {
                iterator: f,
                input,
                state: Some(State::Running),
            }
        }
        /// Main structure associated to the [iterator] function.
        pub struct ParserIterator<I, E, F>
        {
            iterator: F,
            input: I,
            state: Option<State<E>>,
        }

        impl<I: Clone, E, F> ParserIterator<I, E, F> 
        {
            /// Returns the remaining input if parsing was successful, or the error if we encountered an error.
            pub fn finish(mut self) -> IResult<I, (), E> 
            {
                match self.state.take().unwrap()
                {
                    State::Running | State::Done => Ok((self.input, ())),
                    State::Failure(e) => Err(Err::Failure(e)),
                    State::Incomplete(i) => Err(Err::Incomplete(i)),
                }
            }
        }

        impl<'a, Input, Output, Error, F> core::iter::Iterator for &'a mut ParserIterator<Input, Error, F> where
        F: FnMut(Input) -> IResult<Input, Output, Error>,
        Input: Clone
        {
            type Item = Output;
            fn next(&mut self) -> Option<Self::Item>
            {
                if let State::Running = self.state.take().unwrap()
                {
                    let input = self.input.clone();

                    match (self.iterator)(input)
                    {
                        Ok((i, o)) =>
                        {
                            self.input = i;
                            self.state = Some(State::Running);
                            Some(o)
                        }
                        
                        Err(Err::Error(_)) =>
                        {
                            self.state = Some(State::Done);
                            None
                        }

                        Err(Err::Failure(e)) =>
                        {
                            self.state = Some(State::Failure(e));
                            None
                        }

                        Err(Err::Incomplete(i)) =>
                        {
                            self.state = Some(State::Incomplete(i));
                            None
                        }
                    }
                }
                
                else { None }
            }
        }

        enum State<E>
        {
            Running,
            Done,
            Failure(E),
            Incomplete(Needed),
        }
        /// Parser which always succeeds with given value without consuming any input.
        pub fn success<I, O: Clone, E: ParseError<I>>(val: O) -> impl Fn(I) -> IResult<I, O, E>
        {
            move |input: I| Ok((input, val.clone()))
        }
        /// Parser which always fails.
        pub fn fail<I, O, E: ParseError<I>>(i: I) -> IResult<I, O, E>
        {
            Err(Err::Error(E::from_error_kind(i, ErrorKind::Fail)))
        }
    }
    /**/
    pub mod internal
    {
        //! Basic types to build the parsers
        use ::
        {
            borrow::{ ToOwned, },
            boxed::{ Box },
            convert::{ Into as Onto },
            error::{ Error },
            marker::{ Sized, PhantomData },
            nom::
            {
                error::{ self, ErrorKind, ParseError },
                internal::{ Needed::{ * } },
            },
            num::{ NonZeroUsize },
            string::{ String },
            vec::{ Vec },
            *,
        };
        /// Holds the result of parsing functions.
        pub type IResult<I, O, E = error::Error<I>> = Result<(I, O), Err<E>>;

        /// Helper trait to convert a parser's result to a more manageable type
        pub trait Finish<I, O, E>
        {
            /// Converts the parser's result to a type that is more consumable by error management libraries.
            fn finish( self ) -> Result<(I, O), E>;
        }

        impl<I, O, E> Finish<I, O, E> for IResult<I, O, E>
        {
            fn finish( self ) -> Result<(I, O), E> 
            {
                match self 
                {
                    Ok(res) => Ok(res),
                    Err(Err::Error(e)) | Err(Err::Failure(e)) => Err(e),
                    Err(Err::Incomplete(_)) =>
                    {
                        panic!("Cannot call `finish()` on `Err(Err::Incomplete(_))`: this result means that the parser does not have enough data to decide, you should gather more data and try to reapply  the parser instead")
                    }
                }
            }
        }
        /// Contains information on needed data if a parser returned `Incomplete`
        #[derive( Debug, PartialEq, Eq, Clone, Copy )]
        pub enum Needed
        {
            /// Needs more data, but we do not know how much
            Unknown,
            /// Contains the required data size in bytes
            Size(NonZeroUsize),
        }

        impl Needed
        {
            /// Creates `Needed` instance, returns `Needed::Unknown` if the argument is zero
            pub fn new(s: usize) -> Self
            {
                match NonZeroUsize::new(s)
                {
                    Some(sz) => Needed::Size(sz),
                    None => Needed::Unknown,
                }
            }
            /// Indicates if we know how many bytes we need
            pub fn is_known(&self) -> bool { *self != Unknown }
            /// Maps a `Needed` to `Needed` by applying a function to a contained `Size` value.
            #[inline] pub fn map<F: Fn(NonZeroUsize) -> usize>(self, f: F) -> Needed
            {
                match self
                {
                    Unknown => Unknown,
                    Size(n) => Needed::new(f(n)),
                }
            }
        }

        /// The `Err` enum indicates the parser was not successful.
        #[derive( Debug, Clone, PartialEq )] pub enum Err<E>
        {
            /// There was not enough data
            Incomplete(Needed),
            /// The parser had an error (recoverable)
            Error(E),
            /// The parser had an unrecoverable error.
            Failure(E),
        }

        impl<E> Err<E>
        {
            /// Tests if the result is Incomplete
            pub fn is_incomplete(&self) -> bool
            {
                if let Err::Incomplete(_) = self { true }
                else { false }
            }
            /// Applies the given function to the inner error
            pub fn map<E2, F>(self, f: F) -> Err<E2> where
            F: FnOnce(E) -> E2
            {
                match self 
                {
                    Err::Incomplete(n) => Err::Incomplete(n),
                    Err::Failure(t) => Err::Failure(f(t)),
                    Err::Error(t) => Err::Error(f(t)),
                }
            }
            /// Automatically converts between errors if the underlying type supports it
            pub fn convert<F>(e: Err<F>) -> Self where
            E: From<F>
            { e.map( Onto::into ) }
        }

        impl<T> Err<(T, ErrorKind)>
        {
            /// Maps `Err<(T, ErrorKind)>` to `Err<(U, ErrorKind)>` with the given `F: T -> U`
            pub fn map_input<U, F>(self, f: F) -> Err<(U, ErrorKind)> where
            F: FnOnce(T) -> U
            {
                match self
                {
                    Err::Incomplete(n) => Err::Incomplete(n),
                    Err::Failure((input, k)) => Err::Failure((f(input), k)),
                    Err::Error((input, k)) => Err::Error((f(input), k)),
                }
            }
        }

        impl<T> Err<error::Error<T>> 
        {
            /// Maps `Err<error::Error<T>>` to `Err<error::Error<U>>` with the given `F: T -> U`
            pub fn map_input<U, F>(self, f: F) -> Err<error::Error<U>> where
            F: FnOnce(T) -> U
            {
                match self 
                {
                    Err::Incomplete(n) => Err::Incomplete(n),
                    Err::Failure(error::Error { input, code }) => Err::Failure(error::Error
                    {
                        input: f(input),
                        code,
                    }),
                    
                    Err::Error(error::Error { input, code }) => Err::Error(error::Error
                    {
                        input: f(input),
                        code,
                    }),
                }
            }
        }
        
        impl Err<(&[u8], ErrorKind)>
        {
            /// Obtaining ownership
            pub fn to_owned( self ) -> Err<(Vec<u8>, ErrorKind)> { self.map_input(ToOwned::to_owned) }
        }
        
        impl Err<(&str, ErrorKind)>
        {
            /// Obtaining ownership
            pub fn to_owned( self ) -> Err<(String, ErrorKind)> { self.map_input(ToOwned::to_owned) }
        }
        
        impl Err<error::Error<&[u8]>>
        {
            /// Obtaining ownership
            pub fn to_owned( self ) -> Err<error::Error<Vec<u8>>> { self.map_input(ToOwned::to_owned) }
        }
        
        impl Err<error::Error<&str>>
        {
            /// Obtaining ownership
            pub fn to_owned( self ) -> Err<error::Error<String>> { self.map_input(ToOwned::to_owned) }
        }

        impl<E: Eq> Eq for Err<E> {}

        impl<E> fmt::Display for Err<E> where
        E: fmt::Debug
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
            {
                match self
                {
                    Err::Incomplete(Needed::Size(u)) => write!(f, "Parsing requires {} bytes/chars", u),
                    Err::Incomplete(Needed::Unknown) => write!(f, "Parsing requires more data"),
                    Err::Failure(c) => write!(f, "Parsing Failure: {:?}", c),
                    Err::Error(c) => write!(f, "Parsing Error: {:?}", c),
                }
            }
        }
        
        impl<E> Error for Err<E> where
        E: fmt::Debug
        {
            fn source(&self) -> Option<&(dyn Error + 'static)> { None }
        }
        /// All nom parsers implement this trait
        pub trait Parser<I, O, E>
        {
            /// A parser takes in input type, and returns a `Result`
            /// containing either the remaining input and the output value, or an error.
            fn parse(&mut self, input: I) -> IResult<I, O, E>;
            /// Maps a function over the result of a parser
            fn map<G, O2>(self, g: G) -> Map<Self, G, O> where
            G: Fn(O) -> O2,
            Self: Sized
            {
                Map 
                {
                    f: self,
                    g,
                    phantom:PhantomData,
                }
            }
            /// Creates a second parser from the output of the first one, then apply over the rest of the input
            fn flat_map<G, H, O2>(self, g: G) -> FlatMap<Self, G, O> where
            G: FnMut(O) -> H,
            H: Parser<I, O2, E>,
            Self:Sized
            {
                FlatMap
                {
                    f: self,
                    g,
                    phantom:PhantomData,
                }
            }
            /// Applies a second parser over the output of the first one
            fn and_then<G, O2>(self, g: G) -> AndThen<Self, G, O> where
            G: Parser<O, O2, E>,
            Self: Sized
            {
                AndThen
                {
                    f: self,
                    g,
                    phantom: PhantomData,
                }
            }
            /// Applies a second parser after the first one, return their results as a tuple
            fn and<G, O2>(self, g: G) -> And<Self, G> where
            G: Parser<I, O2, E>,
            Self: Sized,
            {
                And { f: self, g }
            }
            /// Applies a second parser over the input if the first one failed
            fn or<G>(self, g: G) -> Or<Self, G> where
            G: Parser<I, O, E>,
            Self: Sized
            {
                Or { f: self, g }
            }
            /// Converts the parser's output and error values to another type, as long as they implement the `From` trait
            fn into<O2: From<O>, E2: From<E>>( self ) -> Into<Self, O, O2, E, E2> where
            Self: Sized
            {
                Into
                {
                    f: self,
                    phantom_out1: PhantomData,
                    phantom_err1: PhantomData,
                    phantom_out2: PhantomData,
                    phantom_err2: PhantomData,
                }
            }
        }

        impl<'a, I, O, E, F> Parser<I, O, E> for F where
        F: FnMut(I) -> IResult<I, O, E> + 'a
        {
            fn parse(&mut self, i: I) -> IResult<I, O, E> { self(i) }
        }

        impl<'a, I, O, E> Parser<I, O, E> for Box<dyn Parser<I, O, E> + 'a>
        {
            fn parse(&mut self, input: I) -> IResult<I, O, E> { (**self).parse(input) }
        }
        /// Implementation of `Parser::map`
        pub struct Map<F, G, O1>
        {
            f: F,
            g: G,
            phantom: PhantomData<O1>,
        }

        impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Fn(O1) -> O2> Parser<I, O2, E> for Map<F, G, O1>
        {
            fn parse(&mut self, i: I) -> IResult<I, O2, E>
            {
                match self.f.parse(i)
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, (self.g)(o))),
                }
            }
        }
        /// Implementation of `Parser::flat_map`
        pub struct FlatMap<F, G, O1>
        {
            f: F,
            g: G,
            phantom: PhantomData<O1>,
        }

        impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Fn(O1) -> H, H: Parser<I, O2, E>> Parser<I, O2, E> 
        for FlatMap<F, G, O1>
        {
            fn parse(&mut self, i: I) -> IResult<I, O2, E>
            {
                let (i, o1) = self.f.parse(i)?;
                (self.g)(o1).parse(i)
            }
        }
        /// Implementation of `Parser::and_then`
        pub struct AndThen<F, G, O1>
        {
            f: F,
            g: G,
            phantom: PhantomData<O1>,
        }

        impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Parser<O1, O2, E>> Parser<I, O2, E> for AndThen<F, G, O1>
        {
            fn parse(&mut self, i: I) -> IResult<I, O2, E>
            {
                let (i, o1) = self.f.parse(i)?;
                let (_, o2) = self.g.parse(o1)?;
                Ok((i, o2))
            }
        }
        /// Implementation of `Parser::and`
        pub struct And<F, G>
        {
            f: F,
            g: G,
        }

        impl<'a, I, O1, O2, E, F: Parser<I, O1, E>, G: Parser<I, O2, E>> Parser<I, (O1, O2), E> for And<F, G>
        {
            fn parse(&mut self, i: I) -> IResult<I, (O1, O2), E>
            {
                let (i, o1) = self.f.parse(i)?;
                let (i, o2) = self.g.parse(i)?;
                Ok((i, (o1, o2)))
            }
        }
        /// Implementation of `Parser::or`
        pub struct Or<F, G>
        {
            f: F,
            g: G,
        }

        impl<'a, I: Clone, O, E: ParseError<I>, F: Parser<I, O, E>, G: Parser<I, O, E>>
        Parser<I, O, E> for Or<F, G>
        {
            fn parse(&mut self, i: I) -> IResult<I, O, E>
            {
                match self.f.parse(i.clone())
                {
                    Err(Err::Error(e1)) => match self.g.parse(i)
                    {
                        Err(Err::Error(e2)) => Err(Err::Error(e1.or(e2))),
                        res => res,
                    },
                    res => res,
                }
            }
        }
        /// Implementation of `Parser::into`
        pub struct Into<F, O1, O2: From<O1>, E1, E2: From<E1>>
        {
            f: F,
            phantom_out1: PhantomData<O1>,
            phantom_err1: PhantomData<E1>,
            phantom_out2: PhantomData<O2>,
            phantom_err2: PhantomData<E2>,
        }

        impl
        <
            'a,
            I: Clone,
            O1,
            O2: From<O1>,
            E1,
            E2: ParseError<I> + From<E1>,
            F: Parser<I, O1, E1>
        > Parser<I, O2, E2> for Into<F, O1, O2, E1, E2>
        {
            fn parse(&mut self, i: I) -> IResult<I, O2, E2>
            {
                match self.f.parse(i)
                {
                    Ok((i, o)) => Ok((i, o.into())),
                    Err(Err::Error(e)) => Err(Err::Error(e.into())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.into())),
                    Err(Err::Incomplete(e)) => Err(Err::Incomplete(e)),
                }
            }
        }
    }
    /*REWRITE*/
    pub mod multi
    {
        //! Combinators applying their child parser multiple times
        use ::
        {
            mem::{ size_of },
            nom::
            {
                error::{ ErrorKind, ParseError },
                internal::{Err, IResult, Needed, Parser},
                traits::{InputLength, InputTake, ToUsize},
                *,
            },
            num::{ NonZeroUsize },
            vec::{ Vec },
            *,
        };
        /// Don't pre-allocate more than 64KiB when calling `Vec::with_capacity`.
        const MAX_INITIAL_CAPACITY_BYTES: usize = 65536;
        /// Repeats the embedded parser, gathering the results in a `Vec`.
        pub fn many0<I, O, E, F>( mut f:F ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        E: ParseError<I>
        {
            move |mut i: I|
            {
                let mut acc = Vec::with_capacity(4);
                loop
                {
                    let len = i.input_len();
                    match f.parse(i.clone())
                    {
                        Err(Err::Error(_)) => return Ok((i, acc)),
                        Err(e) => return Err(e),
                        Ok((i1, o)) =>
                        {                            
                            if i1.input_len() == len { return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many0))); }
                            i = i1;
                            acc.push(o);
                        }
                    }
                }
            }
        }
        /// Runs the embedded parser, gathering the results in a `Vec`.
        pub fn many1<I, O, E, F>( mut f:F ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        E: ParseError<I>
        {
            move |mut i: I| match f.parse(i.clone())
            {
                Err(Err::Error(err)) => Err(Err::Error(E::append(i, ErrorKind::Many1, err))),
                Err(e) => Err(e),
                Ok((i1, o)) =>
                {
                    let mut acc = Vec::with_capacity(4);
                    acc.push(o);
                    i = i1;

                    loop
                    {
                        let len = i.input_len();
                        match f.parse(i.clone())
                        {
                            Err(Err::Error(_)) => return Ok((i, acc)),
                            Err(e) => return Err(e),
                            Ok((i1, o)) =>
                            {
                                if i1.input_len() == len { return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1))); }
                                i = i1;
                                acc.push(o);
                            }
                        }
                    }
                }
            }
        }
        /// Applies the parser `f` until the parser `g` produces a result.
        pub fn many_till<I, O, P, E, F, G>( mut f:F, mut g: G ) -> impl FnMut(I) -> IResult<I, (Vec<O>, P), E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: Parser<I, P, E>,
        E: ParseError<I>
        {
            move |mut i: I|
            {
                let mut res = Vec::new();
                loop
                {
                    let len = i.input_len();
                    match g.parse(i.clone())
                    {
                        Ok((i1, o)) => return Ok((i1, (res, o))),
                        Err(Err::Error(_)) =>
                        {
                            match f.parse(i.clone())
                            {
                                Err(Err::Error(err)) => return Err(Err::Error(E::append(i, ErrorKind::ManyTill, err))),
                                Err(e) => return Err(e),
                                Ok((i1, o)) =>
                                {
                                    if i1.input_len() == len { return Err(Err::Error(E::from_error_kind(i1, ErrorKind::ManyTill))); }
                                    res.push(o);
                                    i = i1;
                                }
                            }
                        }

                        Err(e) => return Err(e),
                    }
                }
            }
        }
        /// Alternates between two parsers to produce a list of elements.
        pub fn separated_list0<I, O, O2, E, F, G>( mut sep: G, mut f:F ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: Parser<I, O2, E>,
        E: ParseError<I>
        {
            move |mut i: I|
            {
                let mut res = Vec::new();

                match f.parse(i.clone())
                {
                    Err(Err::Error(_)) => return Ok((i, res)),
                    Err(e) => return Err(e),
                    Ok((i1, o)) =>
                    {
                        res.push(o);
                        i = i1;
                    }
                }

                loop
                {
                    let len = i.input_len();
                    match sep.parse(i.clone())
                    {
                        Err(Err::Error(_)) => return Ok((i, res)),
                        Err(e) => return Err(e),
                        Ok((i1, _)) =>
                        {
                            if i1.input_len() == len { return Err(Err::Error(E::from_error_kind(i1, ErrorKind::SeparatedList))); }

                            match f.parse(i1.clone())
                            {
                                Err(Err::Error(_)) => return Ok((i, res)),
                                Err(e) => return Err(e),
                                Ok((i2, o)) =>
                                {
                                    res.push(o);
                                    i = i2;
                                }
                            }
                        }
                    }
                }
            }
        }
        /// Alternates between two parsers to produce a list of elements until [`Err::Error`].
        pub fn separated_list1<I, O, O2, E, F, G>( mut sep: G, mut f:F ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: Parser<I, O2, E>,
        E: ParseError<I>
        {
            move |mut i: I|
            {
                let mut res = Vec::new();
                match f.parse(i.clone())
                {
                    Err(e) => return Err(e),
                    Ok((i1, o)) =>
                    {
                        res.push(o);
                        i = i1;
                    }
                }

                loop 
                {
                    let len = i.input_len();
                    match sep.parse(i.clone())
                    {
                        Err(Err::Error(_)) => return Ok((i, res)),
                        Err(e) => return Err(e),
                        Ok((i1, _)) =>
                        {
                            if i1.input_len() == len { return Err(Err::Error(E::from_error_kind(i1, ErrorKind::SeparatedList))); }
                            match f.parse(i1.clone())
                            {
                                Err(Err::Error(_)) => return Ok((i, res)),
                                Err(e) => return Err(e),
                                Ok((i2, o)) =>
                                {
                                    res.push(o);
                                    i = i2;
                                }
                            }
                        }
                    }
                }
            }
        }
        /// Repeats the embedded parser `m..=n` times.
        pub fn many_m_n<I, O, E, F>( min:usize, max: usize, mut parse: F ) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        E: ParseError<I>
        {
            move |mut input: I| 
            {
                if min > max { return Err(Err::Failure(E::from_error_kind(input, ErrorKind::ManyMN))); }

                let max_initial_capacity = MAX_INITIAL_CAPACITY_BYTES / size_of::<O>().max(1);
                let mut res = Vec::with_capacity(min.min(max_initial_capacity));

                for count in 0..max
                {
                    let len = input.input_len();
                    match parse.parse(input.clone())
                    {
                        Ok((tail, value)) => 
                        {
                            if tail.input_len() == len { return Err(Err::Error(E::from_error_kind(input, ErrorKind::ManyMN))); }

                            res.push(value);
                            input = tail;
                        }

                        Err(Err::Error(e)) =>
                        {
                            if count < min { return Err(Err::Error(E::append(input, ErrorKind::ManyMN, e))); } 
                            else { return Ok((input, res)); }
                        }

                        Err(e ) => { return Err(e); }
                    }
                }

                Ok((input, res))
            }
        }
        /// Repeats the embedded parser, counting the results.
        pub fn many0_count<I, O, E, F>( mut f:F ) -> impl FnMut(I) -> IResult<I, usize, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        E: ParseError<I>
        {
            move |i: I|
            {
                let mut input = i;
                let mut count = 0;

                loop
                {
                    let input_ = input.clone();
                    let len = input.input_len();
                    match f.parse(input_)
                    {
                        Ok((i, _)) => 
                        {
                            if i.input_len() == len { return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many0Count))); }

                            input = i;
                            count += 1;
                        }

                        Err(Err::Error(_)) => return Ok((input, count)),

                        Err(e) => return Err(e),
                    }
                }
            }
        }
        /// Runs the embedded parser, counting the results.
        pub fn many1_count<I, O, E, F>( mut f:F ) -> impl FnMut(I) -> IResult<I, usize, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        E: ParseError<I>
        {
            move |i: I|
            {
                let i_ = i.clone();
                match f.parse(i_)
                {
                    Err(Err::Error(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1Count))),
                    Err(i) => Err(i),
                    Ok((i1, _)) =>
                    {
                        let mut count = 1;
                        let mut input = i1;

                        loop
                        {
                            let len = input.input_len();
                            let input_ = input.clone();
                            match f.parse(input_)
                            {
                                Err(Err::Error(_)) => return Ok((input, count)),
                                Err(e) => return Err(e),
                                Ok((i, _)) =>
                                {
                                    if i.input_len() == len { return Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1Count))); }

                                    count += 1;
                                    input = i;
                                }
                            }
                        }
                    }
                }
            }
        }
        /// Runs the embedded parser `count` times, gathering the results in a `Vec`.
        pub fn count<I, O, E, F>( mut f:F, count: usize) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone + PartialEq,
        F: Parser<I, O, E>,
        E: ParseError<I>
        {
            move |i: I|
            {
                let mut input = i.clone();
                let max_initial_capacity = MAX_INITIAL_CAPACITY_BYTES / size_of::<O>().max(1);
                let mut res = Vec::with_capacity(count.min(max_initial_capacity));

                for _ in 0..count
                {
                    let input_ = input.clone();
                    match f.parse(input_)
                    {
                        Ok((i, o)) =>
                        {
                            res.push(o);
                            input = i;
                        }

                        Err(Err::Error(e) ) => { return Err(Err::Error(E::append(i, ErrorKind::Count, e))); }

                        Err(e ) => { return Err(e); }
                    }
                }

                Ok((input, res))
            }
        }
        /// Runs the embedded parser repeatedly, filling the given slice with results.
        pub fn fill<'a, I, O, E, F>( f:F, buf: &'a mut [O]) -> impl FnMut(I) -> IResult<I, (), E> + 'a where
        I: Clone + PartialEq,
        F: Fn(I) -> IResult<I, O, E> + 'a,
        E: ParseError<I>
        {
            move |i: I|
            {
                let mut input = i.clone();

                for elem in buf.iter_mut()
                {
                    let input_ = input.clone();
                    match f(input_)
                    {
                        Ok((i, o)) =>
                        {
                            *elem = o;
                            input = i;
                        }

                        Err(Err::Error(e) ) => { return Err(Err::Error(E::append(i, ErrorKind::Count, e))); }
                        
                        Err(e ) => { return Err(e); }
                    }
                }

                Ok((input, ()))
            }
        }
        /// Repeats the embedded parser, calling `g` to gather the results.
        pub fn fold_many0<I, O, E, F, G, H, R>( mut f:F, mut init: H, mut g: G ) -> impl FnMut(I) -> IResult<I, R, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: FnMut(R, O) -> R,
        H: FnMut() -> R,
        E: ParseError<I>
        {
            move |i: I|
            {
                let mut res = init();
                let mut input = i;

                loop
                {
                    let i_ = input.clone();
                    let len = input.input_len();
                    match f.parse(i_)
                    {
                        Ok((i, o)) => 
                        {
                            if i.input_len() == len { return Err(Err::Error(E::from_error_kind(input, ErrorKind::Many0))); }
                            res = g(res, o);
                            input = i;
                        }

                        Err(Err::Error(_) ) => { return Ok((input, res)); }
                        Err(e ) => { return Err(e); }
                    }
                }
            }
        }
        /// Repeats the embedded parser, calling `g` to gather the results.
        pub fn fold_many1<I, O, E, F, G, H, R>( mut f:F, mut init: H, mut g:G ) -> impl FnMut(I) -> IResult<I, R, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: FnMut(R, O) -> R,
        H: FnMut() -> R,
        E: ParseError<I>
        {
            move |i: I|
            {
                let _i = i.clone();
                let init = init();
                match f.parse(_i)
                {
                    Err(Err::Error(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Many1))),
                    Err(e) => Err(e),
                    Ok((i1, o1)) =>
                    {
                        let mut acc = g(init, o1);
                        let mut input = i1;

                        loop
                        {
                            let _input = input.clone();
                            let len = input.input_len();
                            match f.parse(_input)
                            {
                                Err(Err::Error(_) ) => { break; }
                                Err(e) => return Err(e),
                                Ok((i, o)) => 
                                {
                                    if i.input_len() == len { return Err(Err::Failure(E::from_error_kind(i, ErrorKind::Many1))); }

                                    acc = g(acc, o);
                                    input = i;
                                }
                            }
                        }

                        Ok((input, acc))
                    }
                }
            }
        }
        /// Repeats the embedded parser `m..=n` times, calling `g` to gather the results.
        pub fn fold_many_m_n<I, O, E, F, G, H, R>( min:usize, max: usize, mut parse: F, mut init: H, mut fold: G ) 
        -> impl FnMut(I) -> IResult<I, R, E> where
        I: Clone + InputLength,
        F: Parser<I, O, E>,
        G: FnMut(R, O) -> R,
        H: FnMut() -> R,
        E: ParseError<I>
        {
            move |mut input: I|
            {
                if min > max { return Err(Err::Failure(E::from_error_kind(input, ErrorKind::ManyMN))); }

                let mut acc = init();

                for count in 0..max
                {
                    let len = input.input_len();
                    match parse.parse(input.clone())
                    {
                        Ok((tail, value)) => 
                        {
                            if tail.input_len() == len { return Err(Err::Error(E::from_error_kind(tail, ErrorKind::ManyMN))); } 
                            acc = fold(acc, value);
                            input = tail;
                        }
                        
                        Err(Err::Error(err)) =>
                        {
                            if count < min { return Err(Err::Error(E::append(input, ErrorKind::ManyMN, err))); }
                            else { break; }
                        }

                        Err(e) => return Err(e),
                    }
                }

                Ok((input, acc))
            }
        }
        /// Gets a number from the parser and returns a subslice of the input of that size.
        pub fn length_data<I, N, E, F>( mut f:F ) -> impl FnMut(I) -> IResult<I, I, E> where
        I: InputLength + InputTake,
        N: ToUsize,
        F: Parser<I, N, E>,
        E: ParseError<I>
        {
            move |i: I|
            {
                let (i, length) = f.parse(i)?;
                let length: usize = length.to_usize();
                if let Some(needed) = length
                .checked_sub(i.input_len())
                .and_then(NonZeroUsize::new) { Err(Err::Incomplete(Needed::Size(needed))) } 
                else { Ok(i.take_split(length)) }
            }
        }
        /// Gets a number from the first parser,
        /// takes a subslice of the input of that size,
        /// then applies the second parser on that subslice.
        pub fn length_value<I, O, N, E, F, G>( mut f:F, mut g: G) -> impl FnMut(I) -> IResult<I, O, E> where
        I: Clone + InputLength + InputTake,
        N: ToUsize,
        F: Parser<I, N, E>,
        G: Parser<I, O, E>,
        E: ParseError<I>
        {
            move |i: I|
            {
                let (i, length) = f.parse(i)?;
                let length: usize = length.to_usize();
                if let Some(needed) = length
                .checked_sub(i.input_len())
                .and_then(NonZeroUsize::new) { Err(Err::Incomplete(Needed::Size(needed))) } 
                else
                {
                    let (rest, i) = i.take_split(length);
                    match g.parse(i.clone())
                    {
                        Err(Err::Incomplete(_)) => Err(Err::Error(E::from_error_kind(i, ErrorKind::Complete))),
                        Err(e) => Err(e),
                        Ok((_, o)) => Ok((rest, o)),
                    }
                }
            }
        }
        /// Gets a number from the first parser, then applies the second parser that many times.
        pub fn length_count<I, O, N, E, F, G>( mut f:F, mut g: G) -> impl FnMut(I) -> IResult<I, Vec<O>, E> where
        I: Clone,
        N: ToUsize,
        F: Parser<I, N, E>,
        G: Parser<I, O, E>,
        E: ParseError<I>
        {
            move |i: I|
            {
                let (i, count) = f.parse(i)?;
                let mut input = i.clone();
                let mut res = Vec::new();

                for _ in 0..count.to_usize()
                {
                    let input_ = input.clone();
                    match g.parse(input_)
                    {
                        Ok((i, o)) =>
                        {
                            res.push(o);
                            input = i;
                        }
                        
                        Err(Err::Error(e) ) => { return Err(Err::Error(E::append(i, ErrorKind::Count, e))); }
                        
                        Err(e ) => { return Err(e); }
                    }
                }

                Ok((input, res))
            }
        }
    }
    /**/
    pub mod sequence
    {
        //! Combinators applying parsers in sequence
        use ::
        {
            nom::
            {
                error::{ ParseError },
                internal::{IResult, Parser},
            },
            *,
        };
        
        macro_rules! tuple_trait
        (
            ($name1:ident $ty1:ident, $name2: ident $ty2:ident, $($name:ident $ty:ident),*) =>
            (
                tuple_trait!(__impl $name1 $ty1, $name2 $ty2; $($name $ty),*);
            );

            (__impl $($name:ident $ty: ident),+; $name1:ident $ty1:ident, $($name2:ident $ty2:ident),*) =>
            (
                tuple_trait_impl!($($name $ty),+);
                tuple_trait!(__impl $($name $ty),+ , $name1 $ty1; $($name2 $ty2),*);
            );

            (__impl $($name:ident $ty: ident),+; $name1:ident $ty1:ident) => 
            (
                tuple_trait_impl!($($name $ty),+);
                tuple_trait_impl!($($name $ty),+, $name1 $ty1);
            );
        );

        macro_rules! tuple_trait_impl
        (
            ($($name:ident $ty: ident),+) =>
            (
                impl<
                Input: Clone, $($ty),+ , Error: ParseError<Input>,
                $($name: Parser<Input, $ty, Error>),+
                > Tuple<Input, ( $($ty),+ ), Error> for ( $($name),+ )
                {
                    fn parse(&mut self, input: Input) -> IResult<Input, ( $($ty),+ ), Error>
                    { tuple_trait_inner!(0, self, input, (), $($name)+) }
                }
            );
        );

        macro_rules! tuple_trait_inner
        (
            ($it:tt, $self:expr, $input:expr, (), $head:ident $($id:ident)+) =>
            ({
                let (i, o) = $self.$it.parse($input.clone())?;
                succ!($it, tuple_trait_inner!($self, i, ( o ), $($id)+))
            });

            ($it:tt, $self:expr, $input:expr, ($($parsed:tt)*), $head:ident $($id:ident)+) =>
            ({
                let (i, o) = $self.$it.parse($input.clone())?;
                succ!($it, tuple_trait_inner!($self, i, ($($parsed)* , o), $($id)+))
            });

            ($it:tt, $self:expr, $input:expr, ($($parsed:tt)*), $head:ident) =>
            ({
                let (i, o) = $self.$it.parse($input.clone())?;
                Ok((i, ($($parsed)* , o)))
            });
        );
        /// Gets an object from the first parser, then gets another object from the second parser.
        pub fn pair<I, O1, O2, E: ParseError<I>, F, G>( mut first: F, mut second: G, ) -> 
        impl FnMut(I) -> IResult<I, (O1, O2), E> where
        F: Parser<I, O1, E>,
        G: Parser<I, O2, E>
        {
            move |input: I|
            {
                let (input, o1) = first.parse(input)?;
                second.parse(input).map(|(i, o2)| (i, (o1, o2)))
            }
        }
        /// Matches an object from the first parser and discards it, then gets an object from the second parser.
        pub fn preceded<I, O1, O2, E: ParseError<I>, F, G>( mut first: F, mut second: G ) -> 
        impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: Parser<I, O2, E>
        {
            move |input: I|
            {
                let (input, _) = first.parse(input)?;
                second.parse(input)
            }
        }
        /// Gets an object from the first parser, then matches an object from the second parser and discards it.
        pub fn terminated<I, O1, O2, E: ParseError<I>, F, G>( mut first: F, mut second: G ) -> 
        impl FnMut(I) -> IResult<I, O1, E> where
        F: Parser<I, O1, E>,
        G: Parser<I, O2, E>
        {
            move |input: I|
            {
                let (input, o1) = first.parse(input)?;
                second.parse(input).map(|(i, _)| (i, o1))
            }
        }
        /// Gets an object from the first parser,
        /// then matches an object from the sep_parser and discards it,
        /// then gets another object from the second parser.
        pub fn separated_pair<I, O1, O2, O3, E: ParseError<I>, F, G, H>( mut first: F, mut sep: G, mut second: H ) -> 
        impl FnMut(I) -> IResult<I, (O1, O3), E> where
        F: Parser<I, O1, E>,
        G: Parser<I, O2, E>,
        H: Parser<I, O3, E>
        {
            move |input: I|
            {
                let (input, o1) = first.parse(input)?;
                let (input, _) = sep.parse(input)?;
                second.parse(input).map(|(i, o2)| (i, (o1, o2)))
            }
        }
        /// Matches an object from the first parser and discards it,
        /// then gets an object from the second parser,
        /// and finally matches an object from the third parser and discards it.
        pub fn delimited<I, O1, O2, O3, E: ParseError<I>, F, G, H>( mut first: F, mut second: G, mut third: H ) -> 
        impl FnMut(I) -> IResult<I, O2, E> where
        F: Parser<I, O1, E>,
        G: Parser<I, O2, E>,
        H: Parser<I, O3, E>
        {
            move |input: I|
            {
                let (input, _) = first.parse(input)?;
                let (input, o2) = second.parse(input)?;
                third.parse(input).map(|(i, _)| (i, o2))
            }
        }
        /// Helper trait for the tuple combinator.
        pub trait Tuple<I, O, E>
        {
            /// Parses the input and returns a tuple of results of each parser.
            fn parse(&mut self, input: I) -> IResult<I, O, E>;
        }

        impl<Input, Output, Error: ParseError<Input>, F: Parser<Input, Output, Error>>
        Tuple<Input, (Output,), Error> for (F,)
        {
            fn parse(&mut self, input: Input) -> IResult<Input, (Output,), Error> { self.0.parse(input).map(|(i, o)| (i, (o,))) }
        }
        
        tuple_trait!(FnA A, FnB B, FnC C, FnD D, FnE E, FnF F, FnG G, FnH H, FnI I, FnJ J, FnK K, FnL L,
        FnM M, FnN N, FnO O, FnP P, FnQ Q, FnR R, FnS S, FnT T, FnU U);

        // Special case: implement `Tuple` for `()`, the unit type.
        impl<I, E: ParseError<I>> Tuple<I, (), E> for ()
        {
            fn parse(&mut self, input: I) -> IResult<I, (), E>
            { Ok((input, ())) }
        }
        ///Applies a tuple of parsers one by one and returns their results as a tuple.
        pub fn tuple<I, O, E: ParseError<I>, List: Tuple<I, O, E>>( mut l: List ) -> impl FnMut(I) -> IResult<I, O, E>
        { move |i: I| l.parse(i) }
    }
    /*
    */
    mod traits
    {
        //! Traits input types have to implement to work with nom combinators.
        use ::
        {
            iter::{ Copied, Enumerate },
            ops::{ Range, RangeFrom, RangeFull, RangeTo },
            nom::
            {
                error::{ self, ErrorKind, ParseError },
                internal::{ Err, IResult, Needed },
            },
            slice::{ Iter },
            str::{ Chars, CharIndices, from_utf8, FromStr },
            string::{ String },
            vec::{ Vec },
            *,
        };
        static CHARS: &[u8] = b"0123456789abcdef";

        macro_rules! as_bytes_array_impls
        {
            ($($N:expr)+) =>
            {
                $( 
                    impl<'a> AsBytes for &'a [u8; $N] { #[inline(always )] fn as_bytes(&self) -> &[u8] { *self } }
                    impl AsBytes for [u8; $N] { #[inline(always )] fn as_bytes(&self) -> &[u8] { self } }
                )+
            };
        }
        
        macro_rules! impl_fn_slice
        {
            ( $ty:ty ) => { fn slice(&self, range: $ty) -> Self { &self[range] } };
        }

        macro_rules! slice_range_impl
        {
            ( [ $for_t:ident ], $ty:ty ) => { impl<'a, $for_t> Slice<$ty> for &'a [$for_t] { impl_fn_slice!($ty); } };
            ( $for_t:ty, $ty:ty ) => { impl<'a> Slice<$ty> for &'a $for_t { impl_fn_slice!($ty); } };
        }

        macro_rules! slice_ranges_impl
        {
            ( [ $for_type:ident ] ) =>
            {
                slice_range_impl! {[$for_type], Range<usize>}
                slice_range_impl! {[$for_type], RangeTo<usize>}
                slice_range_impl! {[$for_type], RangeFrom<usize>}
                slice_range_impl! {[$for_type], RangeFull}
            };
            ( $for_type:ty ) =>
            {
                slice_range_impl! {$for_type, Range<usize>}
                slice_range_impl! {$for_type, RangeTo<usize>}
                slice_range_impl! {$for_type, RangeFrom<usize>}
                slice_range_impl! {$for_type, RangeFull}
            };
        }
        
        macro_rules! array_impls
        {
            ($($N:expr)+) =>
            {
                $
                ( 
                    impl InputLength for [u8; $N] { #[inline] fn input_len(&self) -> usize { self.len() } }
                    impl<'a> InputLength for &'a [u8; $N] { #[inline] fn input_len(&self) -> usize { self.len() } }
                    impl<'a> InputIter for &'a [u8; $N]
                    {
                        type Item = u8;
                        type Iter = Enumerate<Self::IterElem>;
                        type IterElem = Copied<Iter<'a, u8>>;
                        fn iter_indices(&self) -> Self::Iter { (&self[..]).iter_indices() }
                        fn iter_elements(&self) -> Self::IterElem { (&self[..]).iter_elements() }
                        fn position<P>(&self, predicate: P) -> Option<usize> where P: Fn(Self::Item) -> bool 
                        { (&self[..]).position(predicate) }
                        fn slice_index(&self, count: usize) -> Result<usize, Needed> { (&self[..]).slice_index(count) }
                    }
                    impl<'a> Compare<[u8; $N]> for &'a [u8]
                    {
                        #[inline(always )] fn compare(&self, t: [u8; $N]) -> CompareResult { self.compare(&t[..]) }
                        #[inline(always )] fn compare_no_case(&self, t: [u8;$N]) -> CompareResult { self.compare_no_case(&t[..]) }
                    }
                    impl<'a,'b> Compare<&'b [u8; $N]> for &'a [u8]
                    {
                        #[inline(always )] fn compare(&self, t: &'b [u8; $N]) -> CompareResult { self.compare(&t[..]) }
                        #[inline(always )] fn compare_no_case(&self, t: &'b [u8;$N]) -> CompareResult { self.compare_no_case(&t[..]) }
                    }
                    impl FindToken<u8> for [u8; $N] { fn find_token(&self, token: u8) -> bool { memchr::memchr(token, &self[..]).is_some() } }
                    impl<'a> FindToken<&'a u8> for [u8; $N] { fn find_token(&self, token: &u8) -> bool { self.find_token(*token) } }
                )+
            };
        }
        /// Abstract method to calculate the input length
        pub trait InputLength
        {
            /// Calculates the input length, as indicated by its name, and the name of the trait itself
            fn input_len(&self) -> usize;
        }

        impl<'a, T> InputLength for &'a [T] { #[inline] fn input_len(&self) -> usize { self.len() } }

        impl<'a> InputLength for &'a str { #[inline] fn input_len(&self) -> usize { self.len() } }

        impl<'a> InputLength for (&'a [u8], usize) 
        {
            #[inline] fn input_len(&self) -> usize
            {
                /*
                println!("bit input length for ({:?}, {}):", self.0, self.1);
                println!("-> {}", self.0.len() * 8 - self.1); */
                self.0.len() * 8 - self.1
            }
        }
        /// Useful functions to calculate the offset between slices and show a hexdump of a slice
        pub trait Offset
        {
            /// Offset between the first byte of self and the first byte of the argument
            fn offset(&self, second: &Self) -> usize;
        }

        impl Offset for [u8]
        {
            fn offset(&self, second: &Self) -> usize
            {
                let fst = self.as_ptr();
                let snd = second.as_ptr();
                snd as usize - fst as usize
            }
        }

        impl<'a> Offset for &'a [u8]
        {
            fn offset(&self, second: &Self) -> usize
            {
                let fst = self.as_ptr();
                let snd = second.as_ptr();
                snd as usize - fst as usize
            }
        }

        impl Offset for str
        {
            fn offset(&self, second: &Self) -> usize
            {
                let fst = self.as_ptr();
                let snd = second.as_ptr();
                snd as usize - fst as usize
            }
        }

        impl<'a> Offset for &'a str
        {
            fn offset(&self, second: &Self) -> usize
            {
                let fst = self.as_ptr();
                let snd = second.as_ptr();
                snd as usize - fst as usize
            }
        }
        /// Helper trait for types that can be viewed as a byte slice
        pub trait AsBytes
        {
            /// Casts the input type to a byte slice
            fn as_bytes(&self) -> &[u8];
        }

        impl<'a> AsBytes for &'a str { #[inline(always )] fn as_bytes(&self) -> &[u8] { (*self).as_bytes() } }

        impl AsBytes for str { #[inline(always )] fn as_bytes(&self) -> &[u8] { self.as_ref() } }

        impl<'a> AsBytes for &'a [u8] { #[inline(always )] fn as_bytes(&self) -> &[u8] { *self } }

        impl AsBytes for [u8] { #[inline(always )] fn as_bytes(&self) -> &[u8] { self } }

        as_bytes_array_impls! { 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 }
        /// Transforms common types to a char for basic token parsing
        pub trait AsChar
        {
            /// makes a char from self
            fn as_char( self ) -> char;
            /// Tests that self is an alphabetic character
            fn is_alpha( self ) -> bool;
            /// Tests that self is an alphabetic character
            /// or a decimal digit
            fn is_alphanum( self ) -> bool;
            /// Tests that self is a decimal digit
            fn is_dec_digit( self ) -> bool;
            /// Tests that self is an hex digit
            fn is_hex_digit( self ) -> bool;
            /// Tests that self is an octal digit
            fn is_oct_digit( self ) -> bool;
            /// Gets the len in bytes for self
            fn len( self ) -> usize;
        }

        impl AsChar for u8
        {
            #[inline] fn as_char( self ) -> char { self as char }
            #[inline] fn is_alpha( self ) -> bool { (self >= 0x41 && self <= 0x5A) || (self >= 0x61 && self <= 0x7A) }
            #[inline] fn is_alphanum( self ) -> bool { self.is_alpha() || self.is_dec_digit() }
            #[inline] fn is_dec_digit( self ) -> bool { self >= 0x30 && self <= 0x39 }
            #[inline] fn is_hex_digit( self ) -> bool 
            { (self >= 0x30 && self <= 0x39) || (self >= 0x41 && self <= 0x46) || (self >= 0x61 && self <= 0x66) }
            #[inline] fn is_oct_digit( self ) -> bool { self >= 0x30 && self <= 0x37 }
            #[inline] fn len( self ) -> usize { 1 }
        }

        impl<'a> AsChar for &'a u8
        {
            #[inline] fn as_char( self ) -> char { *self as char }
            #[inline] fn is_alpha( self ) -> bool { (*self >= 0x41 && *self <= 0x5A) || (*self >= 0x61 && *self <= 0x7A) }
            #[inline] fn is_alphanum( self ) -> bool { self.is_alpha() || self.is_dec_digit() }
            #[inline] fn is_dec_digit( self ) -> bool { *self >= 0x30 && *self <= 0x39 }
            #[inline] fn is_hex_digit( self ) -> bool 
            { (*self >= 0x30 && *self <= 0x39) || (*self >= 0x41 && *self <= 0x46) || (*self >= 0x61 && *self <= 0x66) }
            #[inline] fn is_oct_digit( self ) -> bool { *self >= 0x30 && *self <= 0x37 }
            #[inline] fn len( self ) -> usize { 1 }
        }

        impl AsChar for char
        {
            #[inline] fn as_char( self ) -> char { self }
            #[inline] fn is_alpha( self ) -> bool { self.is_ascii_alphabetic() }
            #[inline] fn is_alphanum( self ) -> bool { self.is_alpha() || self.is_dec_digit() }
            #[inline] fn is_dec_digit( self ) -> bool { self.is_ascii_digit() }
            #[inline] fn is_hex_digit( self ) -> bool { self.is_ascii_hexdigit() }
            #[inline] fn is_oct_digit( self ) -> bool { self.is_digit(8) }
            #[inline] fn len( self ) -> usize { self.len_utf8() }
        }

        impl<'a> AsChar for &'a char
        {
            #[inline] fn as_char( self ) -> char { *self }
            #[inline] fn is_alpha( self ) -> bool { self.is_ascii_alphabetic() }
            #[inline] fn is_alphanum( self ) -> bool { self.is_alpha() || self.is_dec_digit() }
            #[inline] fn is_dec_digit( self ) -> bool { self.is_ascii_digit() }
            #[inline] fn is_hex_digit( self ) -> bool { self.is_ascii_hexdigit() }
            #[inline] fn is_oct_digit( self ) -> bool { self.is_digit(8) }
            #[inline] fn len( self ) -> usize { self.len_utf8() }
        }
        /// Abstracts common iteration operations on the input type
        pub trait InputIter
        {
            /// The current input type is a sequence of that `Item` type.
            type Item;
            /// An iterator over the input type, producing the item and its position for use with [Slice].
            type Iter: Iterator<Item = (usize, Self::Item)>;
            /// An iterator over the input type, producing the item
            type IterElem: Iterator<Item = Self::Item>;
            /// Returns an iterator over the elements and their byte offsets
            fn iter_indices(&self) -> Self::Iter;
            /// Returns an iterator over the elements
            fn iter_elements(&self) -> Self::IterElem;
            /// Finds the byte position of the element
            fn position<P>(&self, predicate: P) -> Option<usize> where
            P: Fn(Self::Item) -> bool;
            /// Get the byte offset from the element's position in the stream
            fn slice_index(&self, count: usize) -> Result<usize, Needed>;
        }
        /// Abstracts slicing operations
        pub trait InputTake: Sized 
        {
            /// Returns a slice of `count` bytes. panics if count > length
            fn take(&self, count: usize) -> Self;
            /// Split the stream at the `count` byte offset. panics if count > length
            fn take_split(&self, count: usize) -> (Self, Self);
        }

        impl<'a> InputIter for &'a [u8]
        {
            type Item = u8;
            type Iter = Enumerate<Self::IterElem>;
            type IterElem = Copied<Iter<'a, u8>>;
            #[inline] fn iter_indices(&self) -> Self::Iter { self.iter_elements().enumerate() }
            #[inline] fn iter_elements(&self) -> Self::IterElem { self.iter().copied() }
            #[inline] fn position<P>(&self, predicate: P) -> Option<usize> where
            P: Fn(Self::Item) -> bool
            { self.iter().position(|b| predicate(*b)) }
            #[inline] fn slice_index(&self, count: usize) -> Result<usize, Needed>
            { if self.len() >= count { Ok(count) } else { Err(Needed::new(count - self.len())) } }
        }

        impl<'a> InputTake for &'a [u8]
        {
            #[inline] fn take(&self, count: usize) -> Self { &self[0..count] }
            #[inline] fn take_split(&self, count: usize) -> (Self, Self)
            {
                let (prefix, suffix) = self.split_at(count);
                (suffix, prefix)
            }
        }

        impl<'a> InputIter for &'a str
        {
            type Item = char;
            type Iter = CharIndices<'a>;
            type IterElem = Chars<'a>;
            #[inline] fn iter_indices(&self) -> Self::Iter { self.char_indices() }
            #[inline] fn iter_elements(&self) -> Self::IterElem { self.chars() }
            fn position<P>(&self, predicate: P) -> Option<usize> where
            P: Fn(Self::Item) -> bool
            {
                for (o, c) in self.char_indices()
                {
                    if predicate(c) { return Some(o); }
                }
                None
            }
            #[inline] fn slice_index(&self, count: usize) -> Result<usize, Needed>
            {
                let mut cnt = 0;
                for (index, _) in self.char_indices()
                {
                    if cnt == count { return Ok(index); }
                    cnt += 1;
                }
                if cnt == count { return Ok(self.len()); }
                Err(Needed::Unknown)
            }
        }

        impl<'a> InputTake for &'a str
        {
            #[inline] fn take(&self, count: usize) -> Self { &self[..count] }
            
            #[inline] fn take_split(&self, count: usize) -> (Self, Self)
            {
                let (prefix, suffix) = self.split_at(count);
                (suffix, prefix)
            }
        }
        /// Dummy trait used for default implementations (currently only used for `InputTakeAtPosition` and `Compare`).
        pub trait UnspecializedInput {}
        /// Methods to take as much input as possible until the provided function returns true for the current element.
        pub trait InputTakeAtPosition: Sized
        {
            /// The current input type is a sequence of that `Item` type.
            type Item;

            /// Looks for the first element of the input type in which the condition returns true, 
            /// and returns the input up to this position.
            fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where 
            P: Fn(Self::Item) -> bool;

            /// Looks for the first element of the input type for which the condition returns true
            /// and returns the input up to this position.
            fn split_at_position1<P, E: ParseError<Self>> ( &self, predicate: P, e: ErrorKind, ) -> IResult<Self, Self, E> 
            where P: Fn(Self::Item) -> bool;

            /// Looks for the first element of the input type for which the condition returns true,
            /// and returns the input up to this position.
            fn split_at_position_complete<P, E: ParseError<Self>>( &self, predicate: P, ) -> IResult<Self, Self, E>
            where P: Fn(Self::Item) -> bool;

            /// Looks for the first element of the input type for which the condition returns true
            /// and returns the input up to this position.
            fn split_at_position1_complete<P, E: ParseError<Self>>( &self, predicate: P, e: ErrorKind, ) 
            -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool;
        }

        impl<Type: InputLength + InputIter + InputTake + Clone + UnspecializedInput> InputTakeAtPosition for Type
        {
            type Item = <Type as InputIter>::Item;

            fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where 
            P: Fn(Self::Item) -> bool
            {
                match self.position(predicate)
                {
                    Some(n) => Ok(self.take_split(n)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position1<P, E: ParseError<Self>>( &self, predicate: P, e: ErrorKind, ) -> IResult<Self, Self, E> 
            where P: Fn(Self::Item) -> bool
            {
                match self.position(predicate)
                {
                    Some(0) => Err(Err::Error(E::from_error_kind(self.clone(), e))),
                    Some(n) => Ok(self.take_split(n)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position_complete<P, E: ParseError<Self>>( &self, predicate: P, ) -> IResult<Self, Self, E> where 
            P: Fn(Self::Item) -> bool
            {
                match self.split_at_position(predicate)
                {
                    Err(Err::Incomplete(_)) => Ok(self.take_split(self.input_len())),
                    res => res,
                }
            }

            fn split_at_position1_complete<P, E: ParseError<Self>>( &self, predicate: P, e: ErrorKind ) -> 
            IResult<Self, Self, E> where 
            P: Fn(Self::Item) -> bool
            {
                match self.split_at_position1(predicate, e)
                {
                    Err(Err::Incomplete(_)) =>
                    {
                        if self.input_len() == 0 { Err(Err::Error(E::from_error_kind(self.clone(), e))) } 
                        else { Ok(self.take_split(self.input_len())) }
                    }
                    res => res,
                }
            }
        }

        impl<'a> InputTakeAtPosition for &'a [u8]
        {
            type Item = u8;

            fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.iter().position(|c| predicate(*c))
                {
                    Some(i) => Ok(self.take_split(i)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position1<P, E: ParseError<Self>>( &self, predicate: P, e: ErrorKind ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.iter().position(|c| predicate(*c))
                {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => Ok(self.take_split(i)),
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position_complete<P, E: ParseError<Self>>( &self, predicate: P ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool,
            {
                match self.iter().position(|c| predicate(*c))
                {
                    Some(i) => Ok(self.take_split(i)),
                    None => Ok(self.take_split(self.input_len())),
                }
            }

            fn split_at_position1_complete<P, E: ParseError<Self>>( &self, predicate: P, e: ErrorKind ) 
            -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool
            {
                match self.iter().position(|c| predicate(*c))
                {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => Ok(self.take_split(i)),
                    None => 
                    {
                        if self.is_empty() { Err(Err::Error(E::from_error_kind(self, e))) } 
                        else { Ok(self.take_split(self.input_len())) }
                    }
                }
            }
        }

        impl<'a> InputTakeAtPosition for &'a str
        {
            type Item = char;
            fn split_at_position<P, E: ParseError<Self>>(&self, predicate: P) -> IResult<Self, Self, E> where 
            P: Fn(Self::Item) -> bool,
            {
                match self.find(predicate)
                {
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position1<P, E: ParseError<Self>>( &self, predicate: P, e: ErrorKind ) -> IResult<Self, Self, E> 
            where P: Fn(Self::Item) -> bool
            {
                match self.find(predicate)
                {
                    Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => Err(Err::Incomplete(Needed::new(1))),
                }
            }

            fn split_at_position_complete<P, E: ParseError<Self>>( &self, predicate: P ) -> IResult<Self, Self, E> where
            P: Fn(Self::Item) -> bool
            {
                match self.find(predicate)
                {
                    Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                    None => unsafe
                    {
                        Ok
                        ((
                            self.get_unchecked(self.len()..),
                            self.get_unchecked(..self.len()),
                        ))
                    }
                }
            }

            fn split_at_position1_complete<P, E: ParseError<Self>>( &self, predicate: P, e: ErrorKind ) -> 
            IResult<Self, Self, E> where 
            P: Fn(Self::Item) -> bool
            {
                unsafe
                {
                    match self.find(predicate)
                    {
                        Some(0) => Err(Err::Error(E::from_error_kind(self, e))),
                        Some(i) => unsafe { Ok((self.get_unchecked(i..), self.get_unchecked(..i))) },
                        None =>
                        {
                            if self.is_empty(){ Err(Err::Error(E::from_error_kind(self, e))) } 
                            else { Ok(( self.get_unchecked(self.len()..), self.get_unchecked(..self.len()) )) }
                        }
                    }
                }
            }
        }
        /// Indicates whether a comparison was successful, an error, or if more data was needed
        #[derive( Debug, PartialEq )]
        pub enum CompareResult
        {
            /// Comparison was successful
            Ok,
            /// We need more data to be sure
            Incomplete,
            /// Comparison failed
            Error
        }
        /// Abstracts comparison operations
        pub trait Compare<T>
        {
            /// Compares self to another value for equality
            fn compare(&self, t: T) -> CompareResult;
            /// Compares self to another value for equality independently of the case.
            fn compare_no_case(&self, t: T) -> CompareResult;
        }

        impl<'a, 'b> Compare<&'b [u8]> for &'a [u8] 
        {
            #[inline(always )] fn compare(&self, t: &'b [u8]) -> CompareResult
            {
                let pos = self.iter().zip(t.iter()).position(|(a, b)| a != b);
                match pos
                {
                    Some(_) => CompareResult::Error,
                    None => { if self.len() >= t.len() { CompareResult::Ok } else { CompareResult::Incomplete } }
                }
            }

            #[inline(always )] fn compare_no_case(&self, t: &'b [u8]) -> CompareResult
            {
                if self.iter().zip(t).any(|(a, b)| lowercase_byte(*a) != lowercase_byte(*b)) { CompareResult::Error } 
                else if self.len() < t.len(){ CompareResult::Incomplete } 
                else { CompareResult::Ok }
            }
        }

        impl
        <
        T: InputLength + InputIter<Item = u8> + InputTake + UnspecializedInput, 
        O: InputLength + InputIter<Item = u8> + InputTake,
        > Compare<O> for T
        {
            #[inline(always )] fn compare(&self, t: O) -> CompareResult
            {
                let pos = self.iter_elements().zip(t.iter_elements()).position(|(a, b)| a != b);
                match pos
                {
                    Some(_) => CompareResult::Error,
                    None =>
                    {
                        if self.input_len() >= t.input_len(){ CompareResult::Ok } else { CompareResult::Incomplete }
                    }
                }
            }

            #[inline(always )] fn compare_no_case(&self, t: O) -> CompareResult
            {
                if self.iter_elements().zip(t.iter_elements()).any(|(a, b)| lowercase_byte(a) != lowercase_byte(b))
                { CompareResult::Error } 
                else if self.input_len() < t.input_len() { CompareResult::Incomplete } 
                else { CompareResult::Ok }
            }
        }

        impl<'a, 'b> Compare<&'b str> for &'a [u8]
        {
            #[inline(always )] fn compare(&self, t: &'b str) -> CompareResult { self.compare(AsBytes::as_bytes(t)) }
            #[inline(always )] fn compare_no_case(&self, t: &'b str) -> CompareResult 
            { self.compare_no_case(AsBytes::as_bytes(t)) }
        }

        impl<'a, 'b> Compare<&'b str> for &'a str
        {
            #[inline(always )]
            fn compare(&self, t: &'b str) -> CompareResult { self.as_bytes().compare(t.as_bytes()) }
            
            #[inline(always )] fn compare_no_case(&self, t: &'b str) -> CompareResult
            {
                let pos = self.chars().zip(t.chars()).position(|(a, b)| a.to_lowercase().ne(b.to_lowercase()));
                match pos
                {
                    Some(_) => CompareResult::Error,
                    None => { if self.len() >= t.len(){ CompareResult::Ok } else { CompareResult::Incomplete } }
                }
            }
        }

        impl<'a, 'b> Compare<&'b [u8]> for &'a str
        {
            #[inline(always )] fn compare(&self, t: &'b [u8]) -> CompareResult { AsBytes::as_bytes( self ).compare(t) }
            #[inline(always )] fn compare_no_case(&self, t: &'b [u8]) -> CompareResult
            { AsBytes::as_bytes( self ).compare_no_case(t) }
        }
        /// Look for a token in self
        pub trait FindToken<T> 
        {
            /// Returns true if self contains the token
            fn find_token(&self, token: T) -> bool;
        }

        impl<'a> FindToken<u8> for &'a [u8]
        { fn find_token(&self, token: u8) -> bool { memchr::memchr(token, self).is_some() } }

        impl<'a> FindToken<u8> for &'a str { fn find_token(&self, token: u8) -> bool { self.as_bytes().find_token(token) } }

        impl<'a, 'b> FindToken<&'a u8> for &'b [u8]{ fn find_token(&self, token: &u8) -> bool { self.find_token(*token) } }

        impl<'a, 'b> FindToken<&'a u8> for &'b str 
        { fn find_token(&self, token: &u8) -> bool { self.as_bytes().find_token(token) } }

        impl<'a> FindToken<char> for &'a [u8] 
        { fn find_token(&self, token: char) -> bool { self.iter().any(|i| *i == token as u8) } }

        impl<'a> FindToken<char> for &'a str
        { fn find_token(&self, token: char) -> bool { self.chars().any(|i| i == token) } }

        impl<'a> FindToken<char> for &'a [char]
        { fn find_token(&self, token: char) -> bool { self.iter().any(|i| *i == token) } }

        impl<'a, 'b> FindToken<&'a char> for &'b [char] 
        { fn find_token(&self, token: &char) -> bool { self.find_token(*token) } }
        /// Look for a substring in self
        pub trait FindSubstring<T>
        {
            /// Returns the byte position of the substring if it is found
            fn find_substring(&self, substr: T) -> Option<usize>;
        }

        impl<'a, 'b> FindSubstring<&'b [u8]> for &'a [u8]
        {
            fn find_substring(&self, substr: &'b [u8]) -> Option<usize>
            {
                if substr.len() > self.len() { return None; }

                let (&substr_first, substr_rest) = match substr.split_first()
                {
                    Some(split) => split,
                    None => return Some(0),
                };
                if substr_rest.is_empty() { return memchr::memchr(substr_first, self); }

                let mut offset = 0;
                let haystack = &self[..self.len() - substr_rest.len( )];
                while let Some(position) = memchr::memchr(substr_first, &haystack[offset..])
                {
                    offset += position;
                    let next_offset = offset + 1;
                    if &self[next_offset..][..substr_rest.len( )] == substr_rest { return Some(offset); }
                    offset = next_offset;
                }

                None
            }
        }

        impl<'a, 'b> FindSubstring<&'b str> for &'a [u8] 
        { fn find_substring(&self, substr: &'b str) -> Option<usize> { self.find_substring(AsBytes::as_bytes(substr)) } }

        impl<'a, 'b> FindSubstring<&'b str> for &'a str 
        { fn find_substring(&self, substr: &'b str) -> Option<usize> { self.find(substr) } }
        /// Used to integrate `str`'s `parse()` method
        pub trait ParseTo<R>
        {
            /// Succeeds if `parse()` succeeded.
            fn parse_to(&self) -> Option<R>;
        }

        impl<'a, R: FromStr> ParseTo<R> for &'a [u8] 
        { fn parse_to(&self) -> Option<R> { from_utf8( self ).ok().and_then(|s| s.parse().ok()) } }

        impl<'a, R: FromStr> ParseTo<R> for &'a str { fn parse_to(&self) -> Option<R> { self.parse().ok() } }
        /// Slicing operations using ranges.
        pub trait Slice<R>
        {
            /// Slices self according to the range argument
            fn slice(&self, range: R) -> Self;
        }

        slice_ranges_impl! {str}
        slice_ranges_impl! {[T]}
        array_impls! { 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 }
        /// Abstracts something which can extend an `Extend`.
        pub trait ExtendInto
        {
            /// The current input type is a sequence of that `Item` type.
            type Item;
            /// The type that will be produced
            type Extender;
            /// Create a new `Extend` of the correct type
            fn new_builder(&self) -> Self::Extender;
            /// Accumulate the input into an accumulator
            fn extend_into(&self, acc: &mut Self::Extender);
        }
        
        impl ExtendInto for [u8]
        {
            type Item = u8;
            type Extender = Vec<u8>;
            #[inline] fn new_builder(&self) -> Vec<u8> { Vec::new() }
            #[inline] fn extend_into(&self, acc: &mut Vec<u8>) { acc.extend(self.iter().cloned()); }
        }
        
        impl ExtendInto for &[u8]
        {
            type Item = u8;
            type Extender = Vec<u8>;
            #[inline] fn new_builder(&self) -> Vec<u8> { Vec::new() }
            #[inline] fn extend_into(&self, acc: &mut Vec<u8>) { acc.extend_from_slice( self ); }
        }
        
        impl ExtendInto for str
        {
            type Item = char;
            type Extender = String;
            #[inline] fn new_builder(&self) -> String { String::new() }
            #[inline] fn extend_into(&self, acc: &mut String) { acc.push_str( self ); }
        }
        
        impl ExtendInto for &str
        {
            type Item = char;
            type Extender = String;
            #[inline] fn new_builder(&self) -> String { String::new() }
            #[inline] fn extend_into(&self, acc: &mut String) { acc.push_str( self ); }
        }
        
        impl ExtendInto for char
        {
            type Item = char;
            type Extender = String;
            #[inline] fn new_builder(&self) -> String { String::new() }
            #[inline] fn extend_into(&self, acc: &mut String) { acc.push(*self); }
        }
        /// Helper trait to convert numbers to usize.
        pub trait ToUsize
        {
            /// converts self to usize
            fn to_usize(&self) -> usize;
        }

        impl ToUsize for u8 { #[inline] fn to_usize(&self) -> usize { *self as usize } }

        impl ToUsize for u16 { #[inline] fn to_usize(&self) -> usize { *self as usize } }

        impl ToUsize for usize { #[inline] fn to_usize(&self) -> usize { *self } }
        
        impl ToUsize for u64 { #[inline] fn to_usize(&self) -> usize { *self as usize } }
        /// Equivalent From implementation to avoid orphan rules in bits parsers
        pub trait ErrorConvert<E>
        {
            /// Transform to another error type
            fn convert( self ) -> E;
        }

        impl<I> ErrorConvert<(I, ErrorKind)> for ((I, usize), ErrorKind)
        { 
            fn convert( self ) -> (I, ErrorKind) { ((self.0).0, self.1) } 
        }

        impl<I> ErrorConvert<((I, usize), ErrorKind)> for (I, ErrorKind)
        { 
            fn convert( self ) -> ((I, usize), ErrorKind) { ((self.0, 0), self.1) }
        }
        
        impl<I> ErrorConvert<error::Error<I>> for error::Error<(I, usize)>
        {
            fn convert( self ) -> error::Error<I>
            {
                error::Error
                {
                    input: self.input.0,
                    code: self.code,
                }
            }
        }

        impl<I> ErrorConvert<error::Error<(I, usize)>> for error::Error<I>
        {
            fn convert( self ) -> error::Error<(I, usize)>
            {
                error::Error
                {
                    input: (self.input, 0),
                    code: self.code,
                }
            }
        }
        
        impl<I> ErrorConvert<error::VerboseError<I>> for error::VerboseError<(I, usize)>
        {
            fn convert( self ) -> error::VerboseError<I>
            {
                error::VerboseError
                {
                    errors: self.errors.into_iter().map(|(i, e)| (i.0, e)).collect(),
                }
            }
        }
        
        impl<I> ErrorConvert<error::VerboseError<(I, usize)>> for error::VerboseError<I>
        {
            fn convert( self ) -> error::VerboseError<(I, usize)>
            {
                error::VerboseError
                {
                    errors: self.errors.into_iter().map(|(i, e)| ((i, 0), e)).collect(),
                }
            }
        }

        impl ErrorConvert<()> for () { fn convert( self ) {} }
        /// Helper trait to show a byte slice as a hex dump
        pub trait HexDisplay
        {
            /// Converts the value of `self` to a hex dump, returning the owned `String`.
            fn to_hex(&self, chunk_size: usize) -> String;
            /// Converts the value of `self` to a hex dump beginning at `from` address, returning the owned `String`.
            fn to_hex_from(&self, chunk_size: usize, from: usize) -> String;
        }
        
        impl HexDisplay for [u8]
        {
            fn to_hex(&self, chunk_size: usize) -> String { self.to_hex_from(chunk_size, 0) }
            fn to_hex_from(&self, chunk_size: usize, from: usize) -> String
            {
                let mut v = Vec::with_capacity(self.len() * 3);
                let mut i = from;
                for chunk in self.chunks(chunk_size)
                {
                    let s = format!("{:08x}", i);
                    for &ch in s.as_bytes().iter()
                    { v.push(ch); }
                    
                    v.push(b'\t');
                    i += chunk_size;
                    for &byte in chunk
                    {
                        v.push(CHARS[(byte >> 4) as usize]);
                        v.push(CHARS[(byte & 0xf) as usize]);
                        v.push(b' ');
                    }
                    
                    if chunk_size > chunk.len()
                    {
                        for j in 0..(chunk_size - chunk.len())
                        {
                            v.push(b' ');
                            v.push(b' ');
                            v.push(b' ');
                        }
                    }                    
                    
                    v.push(b'\t');

                    for &byte in chunk
                    {
                        if (byte >= 32 && byte <= 126) || byte >= 128  { v.push(byte); } else { v.push(b'.'); }
                    }

                    v.push(b'\n');
                }

                String::from_utf8_lossy(&v[..]).into_owned()
            }
        }
        
        impl HexDisplay for str
        {
            fn to_hex(&self, chunk_size: usize) -> String { self.to_hex_from(chunk_size, 0) }
            fn to_hex_from(&self, chunk_size: usize, from: usize) -> String { self.as_bytes().to_hex_from(chunk_size, from) }
        }
        
        fn lowercase_byte(c: u8) -> u8
        {
            match c
            {
                b'A'..=b'Z' => c - b'A' + b'a',
                _ => c,
            }
        }
    }
    /**/
    pub mod bits
    {
        //! Bit level parsers
        use ::
        {
            nom::
            {
                error::{ ErrorKind, ParseError },
                internal::{ Err, IResult, Needed, Parser },
                traits::{ ErrorConvert, Slice },
            },
            ops::{ RangeFrom },
            *,
        };

        pub mod complete
        {
            //! Bit level parsers
            use ::
            {
                nom::
                {
                    error::{ ErrorKind, ParseError },
                    internal::{ Err, IResult },
                    traits::{ InputIter, InputLength, Slice, ToUsize },
                },
                ops::{ AddAssign, Div, RangeFrom, Shl, Shr },
                *,
            };
            /// Generates a parser taking `count` bits.
            pub fn take<I, O, C, E: ParseError<(I, usize)>>( count:C ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E>
            where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            C: ToUsize,
            O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O>
            {
                let count = count.to_usize();
                move |(input, bit_offset): (I, usize)|
                {
                    if count == 0 { Ok(((input, bit_offset), 0u8.into())) } 
                    else
                    {
                        let cnt = (count + bit_offset).div(8);
                        if input.input_len() * 8 < count + bit_offset
                        {
                            Err(Err::Error(E::from_error_kind
                            (
                                (input, bit_offset),
                                ErrorKind::Eof,
                            )))
                        }
                        
                        else
                        {
                            let mut acc: O = 0_u8.into();
                            let mut offset: usize = bit_offset;
                            let mut remaining: usize = count;
                            let mut end_offset: usize = 0;

                            for byte in input.iter_elements().take(cnt + 1)
                            {
                                if remaining == 0 { break; }

                                let val: O = if offset == 0 { byte.into() } 
                                else { ((byte << offset) as u8 >> offset).into() };

                                if remaining < 8 - offset
                                {
                                    acc += val >> (8 - offset - remaining);
                                    end_offset = remaining + offset;
                                    break;
                                }
                                
                                else
                                {
                                    acc += val << (remaining - (8 - offset));
                                    remaining -= 8 - offset;
                                    offset = 0;
                                }
                            }

                            Ok(((input.slice(cnt..), end_offset), acc))
                        }
                    }
                }
            }
            /// Generates a parser taking `count` bits and comparing them to `pattern`
            pub fn tag<I, O, C, E: ParseError<(I, usize)>>( pattern: O, count: C ) -> 
            impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength + Clone,
            C: ToUsize,
            O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O> + PartialEq
            {
                let count = count.to_usize();
                move |input: (I, usize)| {
                    let inp = input.clone();

                    take(count)(input).and_then(|(i, o)| {
                    if pattern == o {
                        Ok((i, o))
                    } else {
                        Err(Err::Error(error_position!(inp, ErrorKind::TagBits)))
                    }
                    })
                }
            }
            /// Parses one specific bit as a bool.
            pub fn bool<I, E: ParseError<(I, usize)>>(input: (I, usize)) -> IResult<(I, usize), bool, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let (res, bit): (_, u32) = take(1usize)(input)?;
                Ok((res, bit != 0))
            }
        }

        pub mod streaming
        {
            //! Bit level parsers
            use ::
            {
                nom::
                {
                    error::{ ErrorKind, ParseError },
                    internal::{ Err, IResult, Needed },
                    traits::{ InputIter, InputLength, Slice, ToUsize },
                },
                ops::{AddAssign, Div, RangeFrom, Shl, Shr},
                *,
            };
            /// Generates a parser taking `count` bits
            pub fn take<I, O, C, E: ParseError<(I, usize)>>( count: C ) -> impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength,
            C: ToUsize,
            O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O>
            {
                let count = count.to_usize();
                move |(input, bit_offset): (I, usize)|
                {
                    if count == 0 { Ok(((input, bit_offset), 0u8.into())) } 
                    else
                    {
                        let cnt = (count + bit_offset).div(8);
                        if input.input_len() * 8 < count + bit_offset { Err(Err::Incomplete(Needed::new(count as usize))) } 
                        else 
                        {
                            let mut acc: O = 0_u8.into();
                            let mut offset: usize = bit_offset;
                            let mut remaining: usize = count;
                            let mut end_offset: usize = 0;

                            for byte in input.iter_elements().take(cnt + 1)
                            {
                                if remaining == 0 { break; }
                                let val: O = if offset == 0  { byte.into() } 
                                else { ((byte << offset) as u8 >> offset).into() };

                                if remaining < 8 - offset 
                                {
                                    acc += val >> (8 - offset - remaining);
                                    end_offset = remaining + offset;
                                    break;
                                } 
                                
                                else 
                                {
                                    acc += val << (remaining - (8 - offset));
                                    remaining -= 8 - offset;
                                    offset = 0;
                                }
                            }

                            Ok(((input.slice(cnt..), end_offset), acc))
                        }
                    }
                }
            }
            /// Generates a parser taking `count` bits and comparing them to `pattern`
            pub fn tag<I, O, C, E: ParseError<(I, usize)>>( pattern: O, count: C ) -> 
            impl Fn((I, usize)) -> IResult<(I, usize), O, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength + Clone,
            C: ToUsize,
            O: From<u8> + AddAssign + Shl<usize, Output = O> + Shr<usize, Output = O> + PartialEq
            {
                let count = count.to_usize();
                move |input: (I, usize)|
                {
                    let inp = input.clone();
                    take(count)(input).and_then(|(i, o)| 
                    {
                        if pattern == o { Ok((i, o)) } 
                        else { Err(Err::Error(error_position!(inp, ErrorKind::TagBits))) }
                    })
                }
            }
            /// Parses one specific bit as a bool.
            pub fn bool<I, E: ParseError<(I, usize)>>(input: (I, usize)) -> IResult<(I, usize), bool, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let (res, bit): (_, u32) = take(1usize)(input)?;
                Ok((res, bit != 0))
            }
        }
        /// Converts a byte-level input to a bit-level input, for consumption by a parser that uses bits.
        pub fn bits<I, O, E1, E2, P>( mut parser:P  ) -> impl FnMut(I) -> IResult<I, O, E2> where
        E1: ParseError<(I, usize)> + ErrorConvert<E2>,
        E2: ParseError<I>,
        I: Slice<RangeFrom<usize>>,
        P: Parser<(I, usize), O, E1>
        {
            move |input: I| match parser.parse((input, 0))
            {
                Ok(((rest, offset), result)) => 
                {
                    let remaining_bytes_index = offset / 8 + if offset % 8 == 0 { 0 } else { 1 };
                    Ok((rest.slice(remaining_bytes_index..), result))
                }
                Err(Err::Incomplete(n)) => Err(Err::Incomplete(n.map(|u| u.get() / 8 + 1))),
                Err(Err::Error(e)) => Err(Err::Error(e.convert())),
                Err(Err::Failure(e)) => Err(Err::Failure(e.convert())),
            }
        }
        /// Counterpart to `bits`, `bytes` transforms its bit stream input into a byte slice for the underlying
        /// parser, allowing byte-slice parsers to work on bit streams.
        pub fn bytes<I, O, E1, E2, P>( mut parser:P  ) -> impl FnMut((I, usize)) -> IResult<(I, usize), O, E2> where
        E1: ParseError<I> + ErrorConvert<E2>,
        E2: ParseError<(I, usize)>,
        I: Slice<RangeFrom<usize>> + Clone,
        P: Parser<I, O, E1>
        {
            move |(input, offset): (I, usize)|
            {
                let inner = if offset % 8 != 0  { input.slice((1 + offset / 8)..) } else { input.slice((offset / 8)..) };
                let i = (input, offset);
                match parser.parse(inner)
                {
                    Ok((rest, res)) => Ok(((rest, 0), res)),
                    Err(Err::Incomplete(Needed::Unknown)) => Err(Err::Incomplete(Needed::Unknown)),
                    Err(Err::Incomplete(Needed::Size(sz))) => Err(match sz.get().checked_mul(8)
                    {
                        Some(v) => Err::Incomplete(Needed::new(v)),
                        None => Err::Failure(E2::from_error_kind(i, ErrorKind::TooLarge)),
                    }),
                    Err(Err::Error(e)) => Err(Err::Error(e.convert())),
                    Err(Err::Failure(e)) => Err(Err::Failure(e.convert())),
                }
            }
        }
    }
    /**/
    pub mod bytes
    {
        //! Parsers recognizing bytes streams
        pub mod complete
        {
            //! Parsers recognizing bytes streams, complete input version
            use ::
            {
                nom::
                {
                    error::{ ErrorKind, ParseError },
                    internal::{ Err, IResult, Parser },
                    traits::
                    { 
                        AsChar, Compare, CompareResult, ExtendInto, FindSubstring, FindToken, InputIter, InputLength, 
                        InputTake, InputTakeAtPosition, Offset, Slice, ToUsize,
                    },
                    *,
                },
                ops::{ RangeFrom },
                result::{ Result::* },
                *,
            };
            /// Recognizes a pattern.
            pub fn tag<T, Input, Error: ParseError<Input>>( tag: T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + Compare<T>,
            T: InputLength + Clone
            {
                move |i: Input|
                {
                    let tag_len = tag.input_len();
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match i.compare(t)
                    {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        _ =>
                        {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                    };
                    res
                }
            }
            /// Recognizes a case insensitive pattern.
            pub fn tag_no_case<T, Input, Error: ParseError<Input>>( tag: T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + Compare<T>,
            T: InputLength + Clone
            {
                move |i: Input|
                {
                    let tag_len = tag.input_len();
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match (i).compare_no_case(t)
                    {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        _ =>
                        {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                    };

                    res
                }
            }
            /// Parse till certain characters are met.
            pub fn is_not<T, Input, Error: ParseError<Input>>( arr: T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            T: FindToken<<Input as InputTakeAtPosition>::Item>
            {
                move |i: Input|
                {
                    let e: ErrorKind = ErrorKind::IsNot;
                    i.split_at_position1_complete(|c| arr.find_token(c), e)
                }
            }
            /// Returns the longest slice of the matches the pattern.
            pub fn is_a<T, Input, Error: ParseError<Input>>( arr: T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            T: FindToken<<Input as InputTakeAtPosition>::Item>
            {
                move |i: Input|
                {
                    let e: ErrorKind = ErrorKind::IsA;
                    i.split_at_position1_complete(|c| !arr.find_token(c), e)
                }
            }
            /// Returns the longest input slice (if any) that matches the predicate.
            pub fn take_while<F, Input, Error: ParseError<Input>>( cond: F ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool
            { move |i: Input| i.split_at_position_complete(|c| !cond(c)) }
            /// Returns the longest (at least 1) input slice that matches the predicate.
            pub fn take_while1<F, Input, Error: ParseError<Input>>( cond: F ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool
            {
                move |i: Input|
                {
                    let e: ErrorKind = ErrorKind::TakeWhile1;
                    i.split_at_position1_complete(|c| !cond(c), e)
                }
            }
            /// Returns the longest (m <= len <= n) input slice  that matches the predicate.
            pub fn take_while_m_n<F, Input, Error: ParseError<Input>>( m: usize, n: usize, cond: F ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputIter + InputLength + Slice<RangeFrom<usize>>,
            F: Fn(<Input as InputIter>::Item) -> bool
            {
                move |i: Input|
                {
                    let input = i;
                    match input.position(|c| !cond(c))
                    {
                        Some(idx) =>
                        {
                            if idx >= m
                            {
                                if idx <= n
                                {
                                    let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(idx) 
                                    { Ok(input.take_split(index)) } 
                                    else
                                    {
                                        Err(Err::Error(Error::from_error_kind
                                        (
                                            input,
                                            ErrorKind::TakeWhileMN,
                                        )))
                                    };

                                    res
                                }
                                
                                else
                                {
                                    let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(n)
                                    { Ok(input.take_split(index)) }
                                    
                                    else
                                    {
                                        Err(Err::Error(Error::from_error_kind
                                        (
                                            input,
                                            ErrorKind::TakeWhileMN,
                                        )))
                                    };

                                    res
                                }
                            }

                            else
                            {
                                let e = ErrorKind::TakeWhileMN;
                                Err(Err::Error(Error::from_error_kind(input, e)))
                            }
                        }

                        None =>
                        {
                            let len = input.input_len();
                            if len >= n
                            {
                                match input.slice_index(n)
                                {
                                    Ok(index) => Ok(input.take_split(index)),
                                    Err(_needed) => Err(Err::Error(Error::from_error_kind
                                    (
                                        input,
                                        ErrorKind::TakeWhileMN,
                                    ))),
                                }
                            }
                            
                            else if len >= m && len <= n
                            {
                                let res: IResult<_, _, Error> = Ok((input.slice(len..), input));
                                res
                            }
                            
                            else
                            {
                                let e = ErrorKind::TakeWhileMN;
                                Err(Err::Error(Error::from_error_kind(input, e)))
                            }
                        }
                    }
                }
            }
            /// Returns the longest input slice (if any) till a predicate is met.
            pub fn take_till<F, Input, Error: ParseError<Input>>( cond: F ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool
            { move |i: Input| i.split_at_position_complete(|c| cond(c)) }
            /// Returns the longest (at least 1) input slice till a predicate is met.
            pub fn take_till1<F, Input, Error: ParseError<Input>>( cond: F ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool
            {
                move |i: Input|
                {
                    let e: ErrorKind = ErrorKind::TakeTill1;
                    i.split_at_position1_complete(|c| cond(c), e)
                }
            }
            /// Returns an input slice containing the first N input elements (Input[..N]).
            pub fn take<C, Input, Error: ParseError<Input>>( count: C ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputIter + InputTake,
            C: ToUsize
            {
                let c = count.to_usize();
                move |i: Input| match i.slice_index(c)
                {
                    Err(_needed) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Eof))),
                    Ok(index) => Ok(i.take_split(index)),
                }
            }
            /// Returns the input slice up to the first occurrence of the pattern.
            pub fn take_until<T, Input, Error: ParseError<Input>>( tag: T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + FindSubstring<T>,
            T: InputLength + Clone
            {
                move |i: Input|
                {
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match i.find_substring(t)
                    {
                        None => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(index) => Ok(i.take_split(index)),
                    };
                    res
                }
            }
            /// Returns the non empty input slice up to the first occurrence of the pattern.
            pub fn take_until1<T, Input, Error: ParseError<Input>>( tag: T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + FindSubstring<T>,
            T: InputLength + Clone,
            {
                move |i: Input|
                {
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match i.find_substring(t)
                    {
                        None => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(0) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(index) => Ok(i.take_split(index)),
                    };

                    res
                }
            }
            /// Matches a byte string with escaped characters.
            pub fn escaped<'a, Input: 'a, Error, F, G, O1, O2>( mut normal: F, control_char: char, mut escapable: G ) -> 
            impl FnMut(Input) -> IResult<Input, Input, Error> where
            Input: Clone
            + Offset
            + InputLength
            + InputTake
            + InputTakeAtPosition
            + Slice<RangeFrom<usize>>
            + InputIter,
            <Input as InputIter>::Item: AsChar,
            F: Parser<Input, O1, Error>,
            G: Parser<Input, O2, Error>,
            Error: ParseError<Input>
            {
                move |input: Input|
                {
                    let mut i = input.clone();
                    while i.input_len() > 0
                    {
                        let current_len = i.input_len();
                        match normal.parse(i.clone())
                        {
                            Ok((i2, _)) =>
                            {
                                if i2.input_len() == 0 { return Ok((input.slice(input.input_len()..), input)); }
                                                                
                                else if i2.input_len() == current_len
                                {
                                    let index = input.offset(&i2);
                                    return Ok(input.take_split(index));
                                }

                                else { i = i2; }
                            }

                            Err(Err::Error(_)) =>
                            {
                                if i.iter_elements().next().unwrap().as_char() == control_char
                                {
                                    let next = control_char.len_utf8();
                                    if next >= i.input_len()
                                    {
                                        return Err(Err::Error(Error::from_error_kind
                                        (
                                            input,
                                            ErrorKind::Escaped,
                                        )));
                                    }
                                    
                                    else
                                    {
                                        match escapable.parse(i.slice(next..))
                                        {
                                            Ok((i2, _)) =>
                                            {
                                                if i2.input_len() == 0 { return Ok((input.slice(input.input_len()..), input)); } 
                                                else { i = i2; }
                                            }

                                            Err(e) => return Err(e),
                                        }
                                    }
                                }
                                
                                else
                                {
                                    let index = input.offset(&i);
                                    if index == 0
                                    {
                                        return Err(Err::Error(Error::from_error_kind
                                        (
                                            input,
                                            ErrorKind::Escaped,
                                        )));
                                    }
                                    return Ok(input.take_split(index));
                                }
                            }

                            Err(e ) => { return Err(e); }
                        }
                    }

                    Ok((input.slice(input.input_len()..), input))
                }
            }
            /// Matches a byte string with escaped characters.
            pub fn escaped_transform<Input, Error, F, G, O1, O2, ExtendItem, Output>
            ( mut normal: F, control_char: char, mut transform: G ) -> impl FnMut(Input) -> IResult<Input, Output, Error> where
            Input: Clone
            + Offset
            + InputLength
            + InputTake
            + InputTakeAtPosition
            + Slice<RangeFrom<usize>>
            + InputIter,
            Input: ExtendInto<Item = ExtendItem, Extender = Output>,
            O1: ExtendInto<Item = ExtendItem, Extender = Output>,
            O2: ExtendInto<Item = ExtendItem, Extender = Output>,
            <Input as InputIter>::Item: AsChar,
            F: Parser<Input, O1, Error>,
            G: Parser<Input, O2, Error>,
            Error: ParseError<Input>
            {
                move |input: Input|
                {
                    let mut index = 0;
                    let mut res = input.new_builder();
                    let i = input.clone();
                    while index < i.input_len()
                    {
                        let current_len = i.input_len();
                        let remainder = i.slice(index..);
                        match normal.parse(remainder.clone())
                        {
                            Ok((i2, o)) =>
                            {
                                o.extend_into(&mut res);

                                if i2.input_len() == 0 { return Ok((i.slice(i.input_len()..), res)); }
                                else if i2.input_len() == current_len { return Ok((remainder, res)); }
                                else { index = input.offset(&i2); }
                            }

                            Err(Err::Error(_)) =>
                            {
                                if remainder.iter_elements().next().unwrap().as_char() == control_char
                                {
                                    let next = index + control_char.len_utf8();
                                    let input_len = input.input_len();

                                    if next >= input_len
                                    {
                                        return Err(Err::Error(Error::from_error_kind
                                        (
                                            remainder,
                                            ErrorKind::EscapedTransform,
                                        )));
                                    }
                                    
                                    else
                                    {
                                        match transform.parse(i.slice(next..))
                                        {
                                            Ok((i2, o)) =>
                                            {
                                                o.extend_into(&mut res);
                                                if i2.input_len() == 0 { return Ok((i.slice(i.input_len()..), res)); }
                                                else { index = input.offset(&i2); }
                                            }

                                            Err(e) => return Err(e),
                                        }
                                    }
                                }

                                else
                                {
                                    if index == 0
                                    {
                                        return Err(Err::Error(Error::from_error_kind
                                        (
                                            remainder,
                                            ErrorKind::EscapedTransform,
                                        )));
                                    }

                                    return Ok((remainder, res));
                                }
                            }

                            Err(e) => return Err(e),
                        }
                    }
                    
                    Ok((input.slice(index..), res))
                }
            }
        }

        pub mod streaming
        {
            //! Parsers recognizing bytes streams, streaming version
            use ::
            {
                nom::
                {
                    error::{ ErrorKind, ParseError },
                    internal::{ Err, IResult, Needed, Parser },
                    traits::
                    {   
                        AsChar, Compare, CompareResult, FindSubstring, FindToken, InputIter, InputLength, InputTake,
                        InputTakeAtPosition, Offset, Slice, ToUsize,
                    },
                    *,
                },
                ops::{ RangeFrom },
                result::{ Result::* },
                *,
            };
            /// Recognizes a pattern.
            pub fn tag<T, Input, Error: ParseError<Input>>( tag: T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputLength + Compare<T>,
            T: InputLength + Clone,
            {
                move |i: Input|
                {
                    let tag_len = tag.input_len();
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match i.compare(t)
                    {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(tag_len - i.input_len()))),
                        CompareResult::Error =>
                        {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                    };
                    res
                }
            }
            /// Recognizes a case insensitive pattern.
            pub fn tag_no_case<T, Input, Error: ParseError<Input>>( tag:T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputLength + Compare<T>,
            T: InputLength + Clone
            {
                move |i: Input|
                {
                    let tag_len = tag.input_len();
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match (i).compare_no_case(t)
                    {
                        CompareResult::Ok => Ok(i.take_split(tag_len)),
                        CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(tag_len - i.input_len()))),
                        CompareResult::Error =>
                        {
                            let e: ErrorKind = ErrorKind::Tag;
                            Err(Err::Error(Error::from_error_kind(i, e)))
                        }
                    };
                    res
                }
            }
            /// Parse till certain characters are met.
            pub fn is_not<T, Input, Error: ParseError<Input>>( arr:T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            T: FindToken<<Input as InputTakeAtPosition>::Item>
            {
                move |i: Input|
                {
                    let e: ErrorKind = ErrorKind::IsNot;
                    i.split_at_position1(|c| arr.find_token(c), e)
                }
            }
            /// Returns the longest slice of the matches the pattern.
            pub fn is_a<T, Input, Error: ParseError<Input>>( arr: T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            T: FindToken<<Input as InputTakeAtPosition>::Item>
            {
                move |i: Input|
                {
                    let e: ErrorKind = ErrorKind::IsA;
                    i.split_at_position1(|c| !arr.find_token(c), e)
                }
            }
            /// Returns the longest input slice (if any) that matches the predicate.
            pub fn take_while<F, Input, Error: ParseError<Input>>( cond:F ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool
            { move |i: Input| i.split_at_position(|c| !cond(c)) }
            /// Returns the longest (at least 1) input slice that matches the predicate.
            pub fn take_while1<F, Input, Error: ParseError<Input>>( cond: F ) -> 
            impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool
            {
                move |i: Input|
                {
                    let e: ErrorKind = ErrorKind::TakeWhile1;
                    i.split_at_position1(|c| !cond(c), e)
                }
            }
            /// Returns the longest (m <= len <= n) input slice  that matches the predicate.
            pub fn take_while_m_n<F, Input, Error: ParseError<Input>>( m: usize, n: usize, cond: F ) -> 
            impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputIter + InputLength,
            F: Fn(<Input as InputIter>::Item) -> bool
            {
                move |i: Input|
                {
                    let input = i;
                    match input.position(|c| !cond(c))
                    {
                        Some(idx) =>
                        {
                            if idx >= m
                            {
                                if idx <= n
                                {
                                    let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(idx) 
                                    { Ok(input.take_split(index)) }
                                    
                                    else
                                    {
                                        Err(Err::Error(Error::from_error_kind
                                        (
                                            input,
                                            ErrorKind::TakeWhileMN,
                                        )))
                                    };
                                    res
                                }
                                
                                else
                                {
                                    let res: IResult<_, _, Error> = if let Ok(index) = input.slice_index(n) {
                                    Ok(input.take_split(index))
                                    } else {
                                    Err(Err::Error(Error::from_error_kind(
                                        input,
                                        ErrorKind::TakeWhileMN,
                                    )))
                                    };
                                    res
                                }
                            }
                            
                            else
                            {
                                let e = ErrorKind::TakeWhileMN;
                                Err(Err::Error(Error::from_error_kind(input, e)))
                            }
                        }

                        None =>
                        {
                            let len = input.input_len();
                            if len >= n
                            {
                                match input.slice_index(n)
                                {
                                    Ok(index) => Ok(input.take_split(index)),
                                    Err(_needed) => Err(Err::Error(Error::from_error_kind
                                    (
                                        input,
                                        ErrorKind::TakeWhileMN,
                                    ))),
                                }
                            }

                            else
                            {
                                let needed = if m > len { m - len } else { 1 };
                                Err(Err::Incomplete(Needed::new(needed)))
                            }
                        }
                    }
                }
            }
            /// Returns the longest input slice (if any) till a predicate is met.
            pub fn take_till<F, Input, Error: ParseError<Input>>( cond: F ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool
            { move |i: Input| i.split_at_position(|c| cond(c)) }
            /// Returns the longest (at least 1) input slice till a predicate is met.
            pub fn take_till1<F, Input, Error: ParseError<Input>>( cond: F ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTakeAtPosition,
            F: Fn(<Input as InputTakeAtPosition>::Item) -> bool
            {
                move |i: Input|
                {
                    let e: ErrorKind = ErrorKind::TakeTill1;
                    i.split_at_position1(|c| cond(c), e)
                }
            }
            /// Returns an input slice containing the first N input elements (Input[..N]).
            pub fn take<C, Input, Error: ParseError<Input>>( count: C ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputIter + InputTake + InputLength,
            C: ToUsize
            {
                let c = count.to_usize();
                move |i: Input| match i.slice_index(c)
                {
                    Err(i) => Err(Err::Incomplete(i)),
                    Ok(index) => Ok(i.take_split(index)),
                }
            }
            /// Returns the input slice up to the first occurrence of the pattern.
            pub fn take_until<T, Input, Error: ParseError<Input>>( tag: T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputLength + FindSubstring<T>,
            T: Clone
            {
                move |i: Input|
                {
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match i.find_substring(t)
                    {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some(index) => Ok(i.take_split(index)),
                    };
                    
                    res
                }
            }
            /// Returns the non empty input slice up to the first occurrence of the pattern.
            pub fn take_until1<T, Input, Error: ParseError<Input>>( tag: T ) -> impl Fn(Input) -> IResult<Input, Input, Error> where
            Input: InputTake + InputLength + FindSubstring<T>,
            T: Clone
            {
                move |i: Input|
                {
                    let t = tag.clone();
                    let res: IResult<_, _, Error> = match i.find_substring(t)
                    {
                        None => Err(Err::Incomplete(Needed::Unknown)),
                        Some(0) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::TakeUntil))),
                        Some(index) => Ok(i.take_split(index)),
                    };
                    res
                }
            }
            /// Matches a byte string with escaped characters.
            pub fn escaped<Input, Error, F, G, O1, O2>( mut normal: F, control_char: char, mut escapable: G ) -> 
            impl FnMut(Input) -> IResult<Input, Input, Error> where
            Input: Clone
            + Offset
            + InputLength
            + InputTake
            + InputTakeAtPosition
            + Slice<RangeFrom<usize>>
            + InputIter,
            <Input as InputIter>::Item: AsChar,
            F: Parser<Input, O1, Error>,
            G: Parser<Input, O2, Error>,
            Error: ParseError<Input>
            {
                move |input: Input|
                {
                    let mut i = input.clone();
                    while i.input_len() > 0
                    {
                        let current_len = i.input_len();
                        match normal.parse(i.clone())
                        {
                            Ok((i2, _)) =>
                            {
                                if i2.input_len() == 0 { return Err(Err::Incomplete(Needed::Unknown)); }
                                else if i2.input_len() == current_len
                                {
                                    let index = input.offset(&i2);
                                    return Ok(input.take_split(index));
                                }
                                
                                else { i = i2; }
                            }

                            Err(Err::Error(_)) =>
                            {
                                if i.iter_elements().next().unwrap().as_char() == control_char
                                {
                                    let next = control_char.len_utf8();
                                    if next >= i.input_len() { return Err(Err::Incomplete(Needed::new(1))); }

                                    else
                                    {
                                        match escapable.parse(i.slice(next..))
                                        {
                                            Ok((i2, _)) =>
                                            {
                                                if i2.input_len() == 0 { return Err(Err::Incomplete(Needed::Unknown)); } 
                                                else { i = i2; }
                                            }
                                            Err(e) => return Err(e),
                                        }
                                    }
                                }
                                
                                else
                                {
                                    let index = input.offset(&i);
                                    return Ok(input.take_split(index));
                                }
                            }

                            Err(e ) => { return Err(e); }
                        }
                    }

                    Err(Err::Incomplete(Needed::Unknown))
                }
            }
            /// Matches a byte string with escaped characters.
            pub fn escaped_transform<Input, Error, F, G, O1, O2, ExtendItem, Output>
            ( mut normal: F, control_char: char, mut transform: G ) -> impl FnMut(Input) -> IResult<Input, Output, Error> where
            Input: Clone
            + Offset
            + InputLength
            + InputTake
            + InputTakeAtPosition
            + Slice<RangeFrom<usize>>
            + InputIter,
            Input: ExtendInto<Item = ExtendItem, Extender = Output>,
            O1: ExtendInto<Item = ExtendItem, Extender = Output>,
            O2: ExtendInto<Item = ExtendItem, Extender = Output>,
            <Input as InputIter>::Item: AsChar,
            F: Parser<Input, O1, Error>,
            G: Parser<Input, O2, Error>,
            Error: ParseError<Input>
            {
                move |input: Input|
                {
                    let mut index = 0;
                    let mut res = input.new_builder();
                    let i = input.clone();

                    while index < i.input_len()
                    {
                        let current_len = i.input_len();
                        let remainder = i.slice(index..);
                        match normal.parse(remainder.clone())
                        {
                            Ok((i2, o)) =>
                            {
                                o.extend_into(&mut res);
                                if i2.input_len() == 0 { return Err(Err::Incomplete(Needed::Unknown)); }
                                else if i2.input_len() == current_len { return Ok((remainder, res)); }
                                else { index = input.offset(&i2); }
                            }

                            Err(Err::Error(_)) =>
                            {
                                if remainder.iter_elements().next().unwrap().as_char() == control_char
                                {
                                    let next = index + control_char.len_utf8();
                                    let input_len = input.input_len();

                                    if next >= input_len { return Err(Err::Incomplete(Needed::Unknown)); }
                                    else
                                    {
                                        match transform.parse(i.slice(next..))
                                        {
                                            Ok((i2, o)) =>
                                            {
                                                o.extend_into(&mut res);
                                                if i2.input_len() == 0 { return Err(Err::Incomplete(Needed::Unknown)); }
                                                else { index = input.offset(&i2); }
                                            }
                                            
                                            Err(e) => return Err(e),
                                        }
                                    }
                                }

                                else { return Ok((remainder, res)); }
                            }

                            Err(e) => return Err(e),
                        }
                    }
                    Err(Err::Incomplete(Needed::Unknown))
                }
            }
        }
    }
    /**/
    pub mod character
    {
        //! Character specific parsers and combinators.
        pub mod complete
        {
            //! Character specific parsers and combinators, complete input version.
            use ::
            {
                nom::
                {
                    branch::{ alt },
                    bytes::complete::{ tag },
                    combinator::{ opt, value },
                    error::{ ErrorKind, ParseError },
                    internal::{ Err, IResult },
                    traits::
                    {
                        AsChar, Compare, CompareResult, FindToken, InputIter, InputLength, InputTake, InputTakeAtPosition, 
                        Slice,
                    }
                },
                ops::{ Range, RangeFrom, RangeTo },
                *,
            };
            /// Recognizes one character.
            pub fn char<I, Error: ParseError<I>>(c: char) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar
            {
                move |i: I| match (i).iter_elements().next().map(|t|
                {
                    let b = t.as_char() == c;
                    (&c, b)
                })
                {
                    Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    _ => Err(Err::Error(Error::from_char(i, c))),
                }
            }
            /// Recognizes one character and checks that it satisfies a predicate.
            pub fn satisfy<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar,
            F: Fn(char) -> bool
            {
                move |i: I| match (i).iter_elements().next().map(|t|
                {
                    let c = t.as_char();
                    let b = cond(c);
                    (c, b)
                })
                {
                    Some((c, true)) => Ok((i.slice(c.len()..), c)),
                    _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Satisfy))),
                }
            }
            /// Recognizes one of the provided characters.
            pub fn one_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar + Copy,
            T: FindToken<<I as InputIter>::Item>
            {
                move |i: I| match (i).iter_elements().next().map(|c| (c, list.find_token(c)))
                {
                    Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::OneOf))),
                }
            }
            /// Recognizes a character that is not in the provided characters.
            pub fn none_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar + Copy,
            T: FindToken<<I as InputIter>::Item>
            {
                move |i: I| match (i).iter_elements().next().map(|c| (c, !list.find_token(c)))
                {
                    Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                    _ => Err(Err::Error(Error::from_error_kind(i, ErrorKind::NoneOf))),
                }
            }
            /// Recognizes the string "\r\n".
            pub fn crlf<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>>,
            T: InputIter,
            T: Compare<&'static str>
            {
                match input.compare("\r\n")
                {
                    CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                    _ =>
                    {
                        let e: ErrorKind = ErrorKind::CrLf;
                        Err(Err::Error(E::from_error_kind(input, e)))
                    }
                }
            }            
            /// Recognizes a string of any char except '\r\n' or '\n'.
            pub fn not_line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E>
            where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: InputIter + InputLength,
            T: Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            <T as InputIter>::Item: AsChar
            {
                match input.position(|item|
                {
                    let c = item.as_char();
                    c == '\r' || c == '\n'
                })
                {
                    None => Ok((input.slice(input.input_len()..), input)),
                    Some(index) =>
                    {
                        let mut it = input.slice(index..).iter_elements();
                        let nth = it.next().unwrap().as_char();
                        if nth == '\r'
                        {
                            let sliced = input.slice(index..);
                            let comp = sliced.compare("\r\n");
                            match comp 
                            {
                                CompareResult::Ok => Ok((input.slice(index..), input.slice(..index))),
                                _ =>
                                {
                                    let e: ErrorKind = ErrorKind::Tag;
                                    Err(Err::Error(E::from_error_kind(input, e)))
                                }
                            }
                        } 
                        else { Ok((input.slice(index..), input.slice(..index))) }
                    }
                }
            }
            /// Recognizes an end of line (both '\n' and '\r\n').
            pub fn line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: InputIter + InputLength,
            T: Compare<&'static str>
            {
                match input.compare("\n")
                {
                    CompareResult::Ok => Ok((input.slice(1..), input.slice(0..1))),
                    CompareResult::Incomplete => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),
                    CompareResult::Error =>
                    {
                        match input.compare("\r\n")
                        {
                            CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                            _ => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),
                        }
                    }
                }
            }
            /// Matches a newline character '\n'.
            pub fn newline<I, Error: ParseError<I>>(input: I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar
            { char('\n')(input) }
            /// Matches a tab character '\t'.
            pub fn tab<I, Error: ParseError<I>>(input: I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar
            { char('\t')(input) }
            /// Matches one byte as a character. Note that the input type will accept a `str`, 
            /// but not a `&[u8]`, unlike many other nom parsers.
            pub fn anychar<T, E: ParseError<T>>(input: T) -> IResult<T, char, E> where
            T: InputIter + InputLength + Slice<RangeFrom<usize>>,
            <T as InputIter>::Item: AsChar
            {
                let mut it = input.iter_indices();
                match it.next()
                {
                    None => Err(Err::Error(E::from_error_kind(input, ErrorKind::Eof))),
                    Some((_, c)) => match it.next()
                    {
                        None => Ok((input.slice(input.input_len()..), c.as_char())),
                        Some((idx, _)) => Ok((input.slice(idx..), c.as_char())),
                    },
                }
            }
            /// Recognizes zero or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
            pub fn alpha0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position_complete(|item| !item.is_alpha()) }
            /// Recognizes one or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
            pub fn alpha1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position1_complete(|item| !item.is_alpha(), ErrorKind::Alpha) }
            /// Recognizes zero or more ASCII numerical characters: 0-9.
            pub fn digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position_complete(|item| !item.is_dec_digit()) }
            /// Recognizes one or more ASCII numerical characters: 0-9.
            pub fn digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position1_complete(|item| !item.is_dec_digit(), ErrorKind::Digit) }
            /// Recognizes zero or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f.
            pub fn hex_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position_complete(|item| !item.is_hex_digit()) }
            /// Recognizes one or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f.
            pub fn hex_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position1_complete(|item| !item.is_hex_digit(), ErrorKind::HexDigit) }
            /// Recognizes zero or more octal characters: 0-7.
            pub fn oct_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position_complete(|item| !item.is_oct_digit()) }
            /// Recognizes one or more octal characters: 0-7.
            pub fn oct_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position1_complete(|item| !item.is_oct_digit(), ErrorKind::OctDigit) }
            /// Recognizes zero or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z.
            pub fn alphanumeric0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position_complete(|item| !item.is_alphanum()) }
            /// Recognizes one or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z.
            pub fn alphanumeric1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position1_complete(|item| !item.is_alphanum(), ErrorKind::AlphaNumeric) }
            /// Recognizes zero or more spaces and tabs.
            pub fn space0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone
            {
                input.split_at_position_complete(|item|
                {
                    let c = item.as_char();
                    !(c == ' ' || c == '\t')
                })
            }
            /// Recognizes one or more spaces and tabs.
            pub fn space1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone
            {
                input.split_at_position1_complete
                (
                    |item|
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t')
                    },
                    ErrorKind::Space,
                )
            }
            /// Recognizes zero or more spaces, tabs, carriage returns and line feeds.
            pub fn multispace0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone
            {
                input.split_at_position_complete(|item|
                {
                    let c = item.as_char();
                    !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                })
            }
            /// Recognizes one or more spaces, tabs, carriage returns and line feeds.
            pub fn multispace1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone
            {
                input.split_at_position1_complete
                (
                    |item|
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                    },
                    ErrorKind::MultiSpace,
                )
            }

            pub(crate) fn sign<T, E: ParseError<T>>(input: T) -> IResult<T, bool, E> where
            T: Clone + InputTake,
            T: for<'a> Compare<&'a [u8]>,
            {
                let (i, opt_sign) = opt
                (
                    alt
                    ((
                        value(false, tag(&b"-"[..])),
                        value(true, tag(&b"+"[..])),
                    ))
                )(input)?;
                    
                let sign = opt_sign.unwrap_or(true);
                Ok((i, sign))
            }

            macro_rules! ints
            {
                ($($t:tt)+) =>
                {
                    $(
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E> where
                        T: InputIter + Slice<RangeFrom<usize>> + InputLength + InputTake + Clone,
                        <T as InputIter>::Item: AsChar,
                        T: for <'a> Compare<&'a[u8]>
                        {
                            let (i, sign) = sign(input.clone())?;

                            if i.input_len() == 0 { return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))); }

                            let mut value: $t = 0;
                            if sign
                            {
                                for (pos, c) in i.iter_indices()
                                {
                                    match c.as_char().to_digit(10)
                                    {
                                        None =>
                                        {
                                            if pos == 0 { return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))); }
                                            else { return Ok((i.slice(pos..), value)); }
                                        },

                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t))
                                        {
                                            None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }

                            }
                            
                            else
                            {
                                for (pos, c) in i.iter_indices()
                                {
                                    match c.as_char().to_digit(10)
                                    {
                                        None =>
                                        {
                                            if pos == 0 { return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))); } 
                                            else { return Ok((i.slice(pos..), value)); }
                                        },

                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t))
                                        {
                                            None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }
                            }

                            Ok((i.slice(i.input_len()..), value))
                        }
                    )+
                }
            }

            ints! { i8 i16 i32 i64 i128 }

            #[doc(hidden )]
            macro_rules! uints
            {
                ($($t:tt)+) =>
                {
                    $(
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E> where
                        T: InputIter + Slice<RangeFrom<usize>> + InputLength,
                        <T as InputIter>::Item: AsChar
                        {
                            let i = input;
                            if i.input_len() == 0 { return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))); }

                            let mut value: $t = 0;
                            for (pos, c) in i.iter_indices()
                            {
                                match c.as_char().to_digit(10)
                                {
                                    None =>
                                    {
                                        if pos == 0 { return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))); } 
                                        else { return Ok((i.slice(pos..), value)); }
                                    },

                                    Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t))
                                    {
                                        None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),
                                        Some(v) => value = v,
                                    }
                                }
                            }

                            Ok((i.slice(i.input_len()..), value))
                        }
                    )+
                }
            }

            uints! { u8 u16 u32 u64 u128 }
        }

        pub mod streaming
        {
            //! Character specific parsers and combinators, streaming version.
            use ::
            {
                nom::
                {
                    branch::{ alt },
                    bytes::streaming::{ tag },
                    combinator::{ opt, value },
                    error::{ ErrorKind, ParseError },
                    internal::{ Err, IResult, Needed },
                    traits::
                    { 
                        AsChar, Compare, CompareResult, FindToken, InputIter, InputLength, InputTake, InputTakeAtPosition,
                        Slice, 
                    }
                },
                ops::{ Range, RangeFrom, RangeTo },
                *,
            };
            
            macro_rules! ints
            {
                ($($t:tt)+) =>
                {
                    $(
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E> where
                        T: InputIter + Slice<RangeFrom<usize>> + InputLength + InputTake + Clone,
                        <T as InputIter>::Item: AsChar,
                        T: for <'a> Compare<&'a[u8]>
                        {
                            let (i, sign) = sign(input.clone())?;
                            if i.input_len() == 0 { return Err(Err::Incomplete(Needed::new(1))); }

                            let mut value: $t = 0;
                            if sign
                            {
                                for (pos, c) in i.iter_indices()
                                {
                                    match c.as_char().to_digit(10)
                                    {
                                        None =>
                                        {
                                            if pos == 0
                                            { return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))); }
                                            
                                            else { return Ok((i.slice(pos..), value)); }
                                        },

                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t))
                                        {
                                            None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }
                            }
                            
                            else
                            {
                                for (pos, c) in i.iter_indices()
                                {
                                    match c.as_char().to_digit(10)
                                    {
                                        None =>
                                        {
                                            if pos == 0 
                                            { return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))); } 
                                            else { return Ok((i.slice(pos..), value)); }
                                        },

                                        Some(d) => match value.checked_mul(10).and_then(|v| v.checked_sub(d as $t))
                                        {
                                            None => return Err(Err::Error(E::from_error_kind(input, ErrorKind::Digit))),
                                            Some(v) => value = v,
                                        }
                                    }
                                }
                            }

                            Err(Err::Incomplete(Needed::new(1)))
                        }
                    )+
                }
            }
            
            macro_rules! uints 
            {
                ($($t:tt)+) =>
                {
                    $(
                        pub fn $t<T, E: ParseError<T>>(input: T) -> IResult<T, $t, E> where
                        T: InputIter + Slice<RangeFrom<usize>> + InputLength,
                        <T as InputIter>::Item: AsChar,
                        {
                            let i = input;
                            if i.input_len() == 0 { return Err(Err::Incomplete(Needed::new(1))); }

                            let mut value: $t = 0;
                            for (pos, c) in i.iter_indices()
                            {
                                match c.as_char().to_digit(10)
                                {
                                    None =>
                                    {
                                        if pos == 0
                                        { return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))); } 
                                        else { return Ok((i.slice(pos..), value)); }
                                    },

                                    Some(d) => match value.checked_mul(10).and_then(|v| v.checked_add(d as $t))
                                    {
                                        None => return Err(Err::Error(E::from_error_kind(i, ErrorKind::Digit))),
                                        Some(v) => value = v,
                                    }
                                }
                            }

                            Err(Err::Incomplete(Needed::new(1)))
                        }
                    )+
                }
            }
            /// Recognizes one character.
            pub fn char<I, Error: ParseError<I>>(c: char) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter + InputLength,
            <I as InputIter>::Item: AsChar
            {
                move |i: I| match (i).iter_elements().next().map(|t|
                {
                    let b = t.as_char() == c;
                    (&c, b)
                })
                {
                    None => Err(Err::Incomplete(Needed::new(c.len() - i.input_len()))),
                    Some((_, false)) => Err(Err::Error(Error::from_char(i, c))),
                    Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                }
            }
            /// Recognizes one character and checks that it satisfies a predicate.
            pub fn satisfy<F, I, Error: ParseError<I>>(cond: F) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar,
            F: Fn(char) -> bool
            {
                move |i: I| match (i).iter_elements().next().map(|t|
                {
                    let c = t.as_char();
                    let b = cond(c);
                    (c, b)
                })
                {
                    None => Err(Err::Incomplete(Needed::Unknown)),
                    Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::Satisfy))),
                    Some((c, true)) => Ok((i.slice(c.len()..), c)),
                }
            }
            /// Recognizes one of the provided characters.
            pub fn one_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar + Copy,
            T: FindToken<<I as InputIter>::Item>
            {
                move |i: I| match (i).iter_elements().next().map(|c| (c, list.find_token(c)))
                {
                    None => Err(Err::Incomplete(Needed::new(1))),
                    Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::OneOf))),
                    Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                }
            }
            /// Recognizes a character that is not in the provided characters.
            pub fn none_of<I, T, Error: ParseError<I>>(list: T) -> impl Fn(I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter,
            <I as InputIter>::Item: AsChar + Copy,
            T: FindToken<<I as InputIter>::Item>
            {
                move |i: I| match (i).iter_elements().next().map(|c| (c, !list.find_token(c)))
                {
                    None => Err(Err::Incomplete(Needed::new(1))),
                    Some((_, false)) => Err(Err::Error(Error::from_error_kind(i, ErrorKind::NoneOf))),
                    Some((c, true)) => Ok((i.slice(c.len()..), c.as_char())),
                }
            }
            /// Recognizes the string "\r\n".
            pub fn crlf<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: InputIter,
            T: Compare<&'static str>
            {
                match input.compare("\r\n")
                {
                    CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                    CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(2))),
                    CompareResult::Error =>
                    {
                        let e: ErrorKind = ErrorKind::CrLf;
                        Err(Err::Error(E::from_error_kind(input, e)))
                    }
                }
            }
            /// Recognizes a string of any char except '\r\n' or '\n'.
            pub fn not_line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: InputIter + InputLength,
            T: Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            <T as InputIter>::Item: AsChar
            {
                match input.position(|item|
                {
                    let c = item.as_char();
                    c == '\r' || c == '\n'
                })
                {
                    None => Err(Err::Incomplete(Needed::Unknown)),
                    Some(index) =>
                    {
                        let mut it = input.slice(index..).iter_elements();
                        let nth = it.next().unwrap().as_char();
                        if nth == '\r'
                        {
                            let sliced = input.slice(index..);
                            let comp = sliced.compare("\r\n");
                            match comp
                            {
                                CompareResult::Incomplete => Err(Err::Incomplete(Needed::Unknown)),
                                
                                CompareResult::Error =>
                                {
                                    let e: ErrorKind = ErrorKind::Tag;
                                    Err(Err::Error(E::from_error_kind(input, e)))
                                }
                                
                                CompareResult::Ok => Ok((input.slice(index..), input.slice(..index))),
                            }
                        }
                        else { Ok((input.slice(index..), input.slice(..index))) }
                    }
                }
            }
            /// Recognizes an end of line (both '\n' and '\r\n').
            pub fn line_ending<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<Range<usize>> + Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: InputIter + InputLength,
            T: Compare<&'static str>
            {
                match input.compare("\n")
                {
                    CompareResult::Ok => Ok((input.slice(1..), input.slice(0..1))),
                    CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(1))),
                    CompareResult::Error =>
                    {
                        match input.compare("\r\n")
                        {
                            CompareResult::Ok => Ok((input.slice(2..), input.slice(0..2))),
                            CompareResult::Incomplete => Err(Err::Incomplete(Needed::new(2))),
                            CompareResult::Error => Err(Err::Error(E::from_error_kind(input, ErrorKind::CrLf))),
                        }
                    }
                }
            }
            /// Matches a newline character '\\n'.
            pub fn newline<I, Error: ParseError<I>>(input: I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter + InputLength,
            <I as InputIter>::Item: AsChar
            { char('\n')(input) }
            /// Matches a tab character '\t'.
            pub fn tab<I, Error: ParseError<I>>(input: I) -> IResult<I, char, Error> where
            I: Slice<RangeFrom<usize>> + InputIter + InputLength,
            <I as InputIter>::Item: AsChar
            { char('\t')(input) }
            /// Matches one byte as a character. Note that the input type will
            /// accept a `str`, but not a `&[u8]`, unlike many other nom parsers.
            pub fn anychar<T, E: ParseError<T>>(input: T) -> IResult<T, char, E> where
            T: InputIter + InputLength + Slice<RangeFrom<usize>>,
            <T as InputIter>::Item: AsChar
            {
                let mut it = input.iter_indices();
                match it.next()
                {
                    None => Err(Err::Incomplete(Needed::new(1))),
                    Some((_, c)) => match it.next()
                    {
                        None => Ok((input.slice(input.input_len()..), c.as_char())),
                        Some((idx, _)) => Ok((input.slice(idx..), c.as_char())),
                    },
                }
            }
            /// Recognizes zero or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
            pub fn alpha0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position(|item| !item.is_alpha()) }
            /// Recognizes one or more lowercase and uppercase ASCII alphabetic characters: a-z, A-Z.
            pub fn alpha1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position1(|item| !item.is_alpha(), ErrorKind::Alpha) }
            /// Recognizes zero or more ASCII numerical characters: 0-9.
            pub fn digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position(|item| !item.is_dec_digit()) }
            /// Recognizes one or more ASCII numerical characters: 0-9.
            pub fn digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position1(|item| !item.is_dec_digit(), ErrorKind::Digit) }
            /// Recognizes zero or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f.
            pub fn hex_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position(|item| !item.is_hex_digit()) }
            /// Recognizes one or more ASCII hexadecimal numerical characters: 0-9, A-F, a-f.
            pub fn hex_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position1(|item| !item.is_hex_digit(), ErrorKind::HexDigit) }
            /// Recognizes zero or more octal characters: 0-7.
            pub fn oct_digit0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position(|item| !item.is_oct_digit()) }
            /// Recognizes one or more octal characters: 0-7.
            pub fn oct_digit1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position1(|item| !item.is_oct_digit(), ErrorKind::OctDigit) }
            /// Recognizes zero or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z.
            pub fn alphanumeric0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position(|item| !item.is_alphanum()) }
            /// Recognizes one or more ASCII numerical and alphabetic characters: 0-9, a-z, A-Z.
            pub fn alphanumeric1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            { input.split_at_position1(|item| !item.is_alphanum(), ErrorKind::AlphaNumeric) }
            /// Recognizes zero or more spaces and tabs.
            pub fn space0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone
            {
                input.split_at_position(|item|
                {
                    let c = item.as_char();
                    !(c == ' ' || c == '\t')
                })
            }
            /// Recognizes one or more spaces and tabs.
            pub fn space1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone
            {
                input.split_at_position1
                (
                    |item| 
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t')
                    },
                    ErrorKind::Space,
                )
            }
            /// Recognizes zero or more spaces, tabs, carriage returns and line feeds.
            pub fn multispace0<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone
            {
                input.split_at_position(|item|
                {
                    let c = item.as_char();
                    !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                })
            }
            /// Recognizes one or more spaces, tabs, carriage returns and line feeds.
            pub fn multispace1<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar + Clone
            {
                input.split_at_position1
                (
                    |item|
                    {
                        let c = item.as_char();
                        !(c == ' ' || c == '\t' || c == '\r' || c == '\n')
                    },
                    ErrorKind::MultiSpace,
                )
            }

            pub(crate) fn sign<T, E: ParseError<T>>(input: T) -> IResult<T, bool, E> where
            T: Clone + InputTake + InputLength,
            T: for<'a> Compare<&'a [u8]>,
            {
                let (i, opt_sign) = opt
                (alt
                ((
                    value(false, tag(&b"-"[..])),
                    value(true, tag(&b"+"[..])),
                )))(input)?;
                let sign = opt_sign.unwrap_or(true);
                Ok((i, sign))
            }

            ints! { i8 i16 i32 i64 i128 }
            uints! { u8 u16 u32 u64 u128 }
        }
    }
    /**/
    pub mod number
    {
        //! Parsers recognizing numbers
        pub mod complete
        {
            //! Parsers recognizing numbers, complete input version
            use ::
            {
                nom::
                {
                    branch::{ alt },
                    bytes::complete::{ is_a, tag, tag_no_case },
                    character::complete::{ self as chars, char, digit1, sign},
                    combinator::{cut, map, opt, recognize},
                    error::{ ErrorKind, make_error, ParseError },
                    internal::{ * },
                    number::{ Endianness },
                    sequence::{ pair, tuple },
                    traits::
                    {
                        AsBytes, AsChar, Compare, InputIter, InputLength, InputTake, InputTakeAtPosition, Offset, 
                        ParseTo, Slice,
                    },
                    Err as err,
                },
                ops::{Range, RangeFrom, RangeTo},
                *,
            };
            /// Recognizes an unsigned 1 byte integer.
            #[inline] pub fn be_u8<I, E: ParseError<I>>( input:I ) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 1;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) }
                else
                {
                    let res = input.iter_elements().next().unwrap();
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 2 bytes integer.
            #[inline] pub fn be_u16<I, E: ParseError<I>>( input:I ) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 2;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) } 
                else 
                {
                    let mut res = 0u16;
                    for byte in input.iter_elements().take(bound)
                    {
                        res = (res << 8) + byte as u16;
                    }

                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 3 byte integer.
            #[inline] pub fn be_u24<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 3;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) }
                else
                {
                    let mut res = 0u32;
                    for byte in input.iter_elements().take(bound)
                    {
                        res = (res << 8) + byte as u32;
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 4 bytes integer.
            #[inline] pub fn be_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 4;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) }
                else
                {
                    let mut res = 0u32;
                    for byte in input.iter_elements().take(bound)
                    {
                        res = (res << 8) + byte as u32;
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 8 bytes integer.
            #[inline] pub fn be_u64<I, E: ParseError<I>>(input: I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 8;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) } 
                else
                {
                    let mut res = 0u64;
                    for byte in input.iter_elements().take(bound)
                    {
                        res = (res << 8) + byte as u64;
                    }

                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 16 bytes integer.
            #[inline] pub fn be_u128<I, E: ParseError<I>>(input: I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 16;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) } 
                else
                {
                    let mut res = 0u128;
                    for byte in input.iter_elements().take(bound)
                    {
                        res = (res << 8) + byte as u128;
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a signed 1 byte integer.
            #[inline] pub fn be_i8<I, E: ParseError<I>>(input: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u8.map(|x| x as i8).parse(input) }
            /// Recognizes a big endian signed 2 bytes integer.
            #[inline] pub fn be_i16<I, E: ParseError<I>>(input: I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u16.map(|x| x as i16).parse(input) }
            /// Recognizes a big endian signed 3 bytes integer.
            #[inline] pub fn be_i24<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                be_u24
                .map(|x|
                {
                    if x & 0x80_00_00 != 0 { (x | 0xff_00_00_00) as i32 } 
                    else { x as i32 }
                })
                .parse(input)
            }
            /// Recognizes a big endian signed 4 bytes integer.
            #[inline] pub fn be_i32<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u32.map(|x| x as i32).parse(input) }
            /// Recognizes a big endian signed 8 bytes integer.
            #[inline] pub fn be_i64<I, E: ParseError<I>>(input: I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u64.map(|x| x as i64).parse(input) }
            /// Recognizes a big endian signed 16 bytes integer.
            #[inline] pub fn be_i128<I, E: ParseError<I>>(input: I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u128.map(|x| x as i128).parse(input) }
            /// Recognizes an unsigned 1 byte integer.
            #[inline] pub fn le_u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 1;
                if input.input_len() < bound  { Err(Err::Error(make_error(input, ErrorKind::Eof))) }
                else
                {
                    let res = input.iter_elements().next().unwrap();
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a little endian unsigned 2 bytes integer.
            #[inline] pub fn le_u16<I, E: ParseError<I>>(input: I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 2;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) }
                else
                {
                    let mut res = 0u16;
                    for (index, byte) in input.iter_indices().take(bound)
                    {
                        res += (byte as u16) << (8 * index);
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a little endian unsigned 3 byte integer.
            #[inline] pub fn le_u24<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 3;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) } 
                else
                {
                    let mut res = 0u32;
                    for (index, byte) in input.iter_indices().take(bound)
                    {
                        res += (byte as u32) << (8 * index);
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a little endian unsigned 4 bytes integer.
            #[inline] pub fn le_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 4;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) } 
                else
                {
                    let mut res = 0u32;
                    for (index, byte) in input.iter_indices().take(bound)
                    {
                        res += (byte as u32) << (8 * index);
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a little endian unsigned 8 bytes integer.
            #[inline] pub fn le_u64<I, E: ParseError<I>>(input: I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 8;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) }
                else
                {
                    let mut res = 0u64;
                    for (index, byte) in input.iter_indices().take(bound)
                    {
                        res += (byte as u64) << (8 * index);
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a little endian unsigned 16 bytes integer.
            #[inline] pub fn le_u128<I, E: ParseError<I>>(input: I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 16;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) }
                else
                {
                    let mut res = 0u128;
                    for (index, byte) in input.iter_indices().take(bound)
                    {
                        res += (byte as u128) << (8 * index);
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a signed 1 byte integer.
            #[inline] pub fn le_i8<I, E: ParseError<I>>(input: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u8.map(|x| x as i8).parse(input) }
            /// Recognizes a little endian signed 2 bytes integer.
            #[inline] pub fn le_i16<I, E: ParseError<I>>(input: I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { le_u16.map(|x| x as i16).parse(input) }
            /// Recognizes a little endian signed 3 bytes integer.
            #[inline] pub fn le_i24<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                le_u24
                .map(|x| 
                {
                    if x & 0x80_00_00 != 0 { (x | 0xff_00_00_00) as i32 } 
                    else { x as i32 }
                })
                .parse(input)
            }
            /// Recognizes a little endian signed 4 bytes integer.
            #[inline] pub fn le_i32<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { le_u32.map(|x| x as i32).parse(input) }
            /// Recognizes a little endian signed 8 bytes integer.
            #[inline] pub fn le_i64<I, E: ParseError<I>>(input: I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { le_u64.map(|x| x as i64).parse(input) }
            /// Recognizes a little endian signed 16 bytes integer.
            #[inline] pub fn le_i128<I, E: ParseError<I>>(input: I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { le_u128.map(|x| x as i128).parse(input) }
            /// Recognizes an unsigned 1 byte integer.
            #[inline] pub fn u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 1;
                if input.input_len() < bound { Err(Err::Error(make_error(input, ErrorKind::Eof))) }
                else
                {
                    let res = input.iter_elements().next().unwrap();
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes an unsigned 2 bytes integer.
            #[inline] pub fn u16<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_u16,
                    Endianness::Little => le_u16,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_u16,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_u16,
                }
            }
            /// Recognizes an unsigned 3 byte integer
            #[inline] pub fn u24<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_u24,
                    Endianness::Little => le_u24,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_u24,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_u24,
                }
            }
            /// Recognizes an unsigned 4 byte integer
            #[inline] pub fn u32<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_u32,
                    Endianness::Little => le_u32,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_u32,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_u32,
                }
            }
            /// Recognizes an unsigned 8 byte integer
            #[inline] pub fn u64<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_u64,
                    Endianness::Little => le_u64,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_u64,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_u64,
                }
            }
            /// Recognizes an unsigned 16 byte integer
            #[inline] pub fn u128<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian 
                {
                    Endianness::Big => be_u128,
                    Endianness::Little => le_u128,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_u128,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_u128,
                }
            }
            /// Recognizes a signed 1 byte integer
            #[inline] pub fn i8<I, E: ParseError<I>>(i: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { u8.map(|x| x as i8).parse(i) }
            /// Recognizes a signed 2 byte integer
            #[inline] pub fn i16<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_i16,
                    Endianness::Little => le_i16,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_i16,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_i16,
                }
            }
            /// Recognizes a signed 3 byte integer
            #[inline] pub fn i24<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_i24,
                    Endianness::Little => le_i24,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_i24,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_i24,
                }
            }
            /// Recognizes a signed 4 byte integer
            #[inline] pub fn i32<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_i32,
                    Endianness::Little => le_i32,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_i32,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_i32,
                }
            }
            /// Recognizes a signed 8 byte integer
            #[inline] pub fn i64<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_i64,
                    Endianness::Little => le_i64,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_i64,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_i64,
                }
            }
            /// Recognizes a signed 16 byte integer
            #[inline] pub fn i128<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_i128,
                    Endianness::Little => le_i128,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_i128,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_i128,
                }
            }
            /// Recognizes a big endian 4 bytes floating point number.
            #[inline] pub fn be_f32<I, E: ParseError<I>>(input: I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match be_u32(input)
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f32::from_bits(o))),
                }
            }
            /// Recognizes a big endian 8 bytes floating point number.
            #[inline] pub fn be_f64<I, E: ParseError<I>>(input: I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match be_u64(input)
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f64::from_bits(o))),
                }
            }
            /// Recognizes a little endian 4 bytes floating point number.
            #[inline] pub fn le_f32<I, E: ParseError<I>>(input: I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match le_u32(input)
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f32::from_bits(o))),
                }
            }
            /// Recognizes a little endian 8 bytes floating point number.
            #[inline] pub fn le_f64<I, E: ParseError<I>>(input: I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match le_u64(input)
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f64::from_bits(o))),
                }
            }
            /// Recognizes a 4 byte floating point number
            #[inline] pub fn f32<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_f32,
                    Endianness::Little => le_f32,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_f32,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_f32,
                }
            }
            /// Recognizes an 8 byte floating point number
            #[inline]
            pub fn f64<I, E: ParseError<I>>( endian:Endianness ) -> fn(I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian 
                {
                    Endianness::Big => be_f64,
                    Endianness::Little => le_f64,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_f64,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_f64,
                }
            }
            /// Recognizes a hex-encoded integer.
            #[inline] pub fn hex_u32<'a, E: ParseError<&'a [u8]>>(input: &'a [u8]) -> IResult<&'a [u8], u32, E>
            {
                let (i, o) = is_a(&b"0123456789abcdefABCDEF"[..])(input)?;
                let (parsed, remaining) = if o.len() <= 8 { (o, i) } 
                else { (&input[..8], &input[8..]) };
                let res = parsed
                .iter()
                .rev()
                .enumerate()
                .map(|(k, &v)|
                {
                    let digit = v as char;
                    digit.to_digit(16).unwrap_or(0) << (k * 4)
                })
                .sum();
                Ok((remaining, res))
            }
            /// Recognizes floating point number in a byte string and returns the corresponding slice.
            pub fn recognize_float<T, E:ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter,
            <T as InputIter>::Item: AsChar,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            {
                recognize
                (
                    tuple
                    ((
                        opt(alt((char('+'), char('-')))),
                        alt
                        ((
                            map(tuple((digit1, opt(pair(char('.'), opt(digit1))))), |_| ()),
                            map(tuple((char('.'), digit1)), |_| ())
                        )),
                        opt
                        (
                            tuple
                            ((
                                alt((char('e'), char('E'))),
                                opt(alt((char('+'), char('-')))),
                                cut(digit1)
                            ))
                        )
                    ))
                )(input)
            }
            
            pub fn recognize_float_or_exceptions<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter + InputTake + Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            {
                alt
                ((
                    |i: T| 
                    {
                        recognize_float::<_, E>(i.clone()).map_err(|e| match e {
                        err::Error(_) => err::Error(E::from_error_kind(i, ErrorKind::Float)),
                        err::Failure(_) => err::Failure(E::from_error_kind(i, ErrorKind::Float)),
                        err::Incomplete(needed) => err::Incomplete(needed),
                    })
                    },

                    |i: T|
                    {
                        tag_no_case::<_, _, E>("nan")(i.clone())
                        .map_err(|_| err::Error(E::from_error_kind(i, ErrorKind::Float)))
                    },

                    |i: T|
                    {
                        tag_no_case::<_, _, E>("inf")(i.clone())
                        .map_err(|_| err::Error(E::from_error_kind(i, ErrorKind::Float)))
                    },
                    
                    |i: T|
                    {
                        tag_no_case::<_, _, E>("infinity")(i.clone())
                        .map_err(|_| err::Error(E::from_error_kind(i, ErrorKind::Float)))
                    },
                ))(input)
            }
            /// Recognizes a floating point number in text format.
            pub fn recognize_float_parts<T, E: ParseError<T>>(input: T) -> IResult<T, (bool, T, T, i32), E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
            T: Clone + Offset,
            T: InputIter + InputTake,
            <T as InputIter>::Item: AsChar + Copy,
            T: InputTakeAtPosition + InputLength,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: for<'a> Compare<&'a [u8]>,
            T: AsBytes
            {
                let (i, sign) = sign(input.clone())?;                
                let (i, zeroes) = match i.as_bytes().iter().position(|c| *c != b'0')
                {
                    Some(index) => i.take_split(index),
                    None => i.take_split(i.input_len()),
                };
                
                let (i, mut integer) = match i
                    .as_bytes()
                    .iter()
                    .position(|c| !(*c >= b'0' && *c <= b'9'))
                {
                    Some(index) => i.take_split(index),
                    None => i.take_split(i.input_len()),
                };

                if integer.input_len() == 0 && zeroes.input_len() > 0 {
                    integer = zeroes.slice(zeroes.input_len() - 1..);
                }

                let (i, opt_dot) = opt(tag(&b"."[..]))(i)?;
                let (i, fraction) = if opt_dot.is_none() {
                    let i2 = i.clone();
                    (i2, i.slice(..0))
                } else {
                    let mut zero_count = 0usize;
                    let mut position = None;
                    for (pos, c) in i.as_bytes().iter().enumerate() {
                    if *c >= b'0' && *c <= b'9' {
                        if *c == b'0' {
                        zero_count += 1;
                        } else {
                        zero_count = 0;
                        }
                    } else {
                        position = Some(pos);
                        break;
                    }
                    }

                    let position = position.unwrap_or(i.input_len());

                    let index = if zero_count == 0 {
                    position
                    } else if zero_count == position {
                    position - zero_count + 1
                    } else {
                    position - zero_count
                    };

                    (i.slice(position..), i.slice(..index))
                };

                if integer.input_len() == 0 && fraction.input_len() == 0 {
                    return Err(Err::Error(E::from_error_kind(input, ErrorKind::Float)));
                }

                let i2 = i.clone();
                let (i, e) = match i.as_bytes().iter().next() {
                    Some(b'e') => (i.slice(1..), true),
                    Some(b'E') => (i.slice(1..), true),
                    _ => (i, false),
                };

                let (i, exp) = if e {
                    cut( chars::i32 )(i)?
                } else {
                    (i2, 0)
                };

                Ok((i, (sign, integer, fraction, exp)))
            }
            /// Recognizes floating point number in text format and returns a f32.
            pub fn float<T, E: ParseError<T>>(input: T) -> IResult<T, f32, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
            T: Clone + Offset + ParseTo<f32> + Compare<&'static str>,
            T: InputIter + InputLength + InputTake,
            <T as InputIter>::Item: AsChar + Copy,
            <T as InputIter>::IterElem: Clone,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: AsBytes,
            T: for<'a> Compare<&'a [u8]>
            {
                let (i, s) = recognize_float_or_exceptions(input)?;
                match s.parse_to()
                {
                    Some(f) => Ok((i, f)),
                    None => Err( err::Error(E::from_error_kind
                    (
                        i,
                        ErrorKind::Float,
                    ))),
                }
            }
            /// Recognizes floating point number in text format and returns a f64.
            pub fn double<T, E: ParseError<T>>(input: T) -> IResult<T, f64, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>> + Slice<Range<usize>>,
            T: Clone + Offset + ParseTo<f64> + Compare<&'static str>,
            T: InputIter + InputLength + InputTake,
            <T as InputIter>::Item: AsChar + Copy,
            <T as InputIter>::IterElem: Clone,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: AsBytes,
            T: for<'a> Compare<&'a [u8]>
            {
                let (i, s) = recognize_float_or_exceptions(input)?;
                match s.parse_to() 
                {
                    Some(f) => Ok((i, f)),
                    None => Err( err::Error(E::from_error_kind
                    (
                        i,
                        ErrorKind::Float,
                    ))),
                }
            }
        }

        pub mod streaming
        {
            //! Parsers recognizing numbers, streaming version
            use ::
            { 
                nom::
                {
                    branch::{ alt },
                    bytes::streaming::{ tag, is_a, tag_no_case },
                    character::streaming::{ self as chars, char, digit1, sign },
                    combinator::{ cut, map, opt, recognize },
                    error::{ ErrorKind, ParseError },
                    internal::{ * },
                    number::{ Endianness },
                    sequence::{ pair, tuple },                    
                    traits::
                    {
                        AsBytes, AsChar, Compare, InputIter, InputLength, InputTake, InputTakeAtPosition, Offset, ParseTo,
                        Slice,
                    },
                    Err as err,
                },
                ops::{ RangeFrom, RangeTo },
                *,
            };
            /// Recognizes an unsigned 1 byte integer.
            #[inline] pub fn be_u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 1;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(1))) }
                else
                {
                    let res = input.iter_elements().next().unwrap();
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 2 bytes integer.
            #[inline] pub fn be_u16<I, E: ParseError<I>>(input: I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 2;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(bound - input.input_len()))) }
                else
                {
                    let mut res = 0u16;
                    for byte in input.iter_elements().take(bound)
                    {
                        res = (res << 8) + byte as u16;
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 3 byte integer.
            #[inline] pub fn be_u24<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 3;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(bound - input.input_len()))) }                
                else
                {
                    let mut res = 0u32;
                    for byte in input.iter_elements().take(bound)
                    {
                        res = (res << 8) + byte as u32;
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 4 bytes integer.
            #[inline] pub fn be_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 4;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(bound - input.input_len()))) }
                else
                {
                    let mut res = 0u32;
                    for byte in input.iter_elements().take(bound)
                    {
                        res = (res << 8) + byte as u32;
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 8 bytes integer.
            #[inline] pub fn be_u64<I, E: ParseError<I>>(input: I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 8;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(bound - input.input_len()))) }
                
                else
                {
                    let mut res = 0u64;
                    for byte in input.iter_elements().take(bound)
                    {
                        res = (res << 8) + byte as u64;
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a big endian unsigned 16 bytes integer.
            #[inline] pub fn be_u128<I, E: ParseError<I>>(input: I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 16;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(bound - input.input_len()))) }
                
                else
                {
                    let mut res = 0u128;
                    for byte in input.iter_elements().take(bound)
                    {
                        res = (res << 8) + byte as u128;
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a signed 1 byte integer.
            #[inline] pub fn be_i8<I, E: ParseError<I>>(input: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u8.map(|x| x as i8).parse(input) }
            /// Recognizes a big endian signed 2 bytes integer.
            #[inline] pub fn be_i16<I, E: ParseError<I>>(input: I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u16.map(|x| x as i16).parse(input) }
            /// Recognizes a big endian signed 3 bytes integer.
            #[inline] pub fn be_i24<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                be_u24
                .map(|x|
                {
                    if x & 0x80_00_00 != 0 { (x | 0xff_00_00_00) as i32 } 
                    else { x as i32 }
                })
                .parse(input)
            }
            /// Recognizes a big endian signed 4 bytes integer.
            #[inline] pub fn be_i32<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u32.map(|x| x as i32).parse(input) }
            /// Recognizes a big endian signed 8 bytes integer.
            #[inline] pub fn be_i64<I, E: ParseError<I>>(input: I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u64.map(|x| x as i64).parse(input) }
            /// Recognizes a big endian signed 16 bytes integer.
            #[inline] pub fn be_i128<I, E: ParseError<I>>(input: I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { be_u128.map(|x| x as i128).parse(input) }
            /// Recognizes an unsigned 1 byte integer.
            #[inline] pub fn le_u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 1;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(1))) }
                else
                {
                    let res = input.iter_elements().next().unwrap();
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a little endian unsigned 2 bytes integer.
            #[inline] pub fn le_u16<I, E: ParseError<I>>(input: I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 2;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(bound - input.input_len()))) }

                else
                {
                    let mut res = 0u16;
                    for (index, byte) in input.iter_indices().take(bound)
                    {
                        res += (byte as u16) << (8 * index);
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a little endian unsigned 3 bytes integer.
            #[inline] pub fn le_u24<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 3;
                if input.input_len() < bound
                {
                    Err(Err::Incomplete(Needed::new(bound - input.input_len())))
                }

                else
                {
                    let mut res = 0u32;
                    for (index, byte) in input.iter_indices().take(bound)
                    {
                        res += (byte as u32) << (8 * index);
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a little endian unsigned 4 bytes integer.
            #[inline] pub fn le_u32<I, E: ParseError<I>>(input: I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 4;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(bound - input.input_len()))) }
                else
                {
                    let mut res = 0u32;
                    for (index, byte) in input.iter_indices().take(bound)
                    {
                        res += (byte as u32) << (8 * index);
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a little endian unsigned 8 bytes integer.
            #[inline] pub fn le_u64<I, E: ParseError<I>>(input: I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 8;
                if input.input_len() < bound
                { Err(Err::Incomplete(Needed::new(bound - input.input_len()))) } 
                else 
                {
                    let mut res = 0u64;
                    for (index, byte) in input.iter_indices().take(bound)
                    {
                        res += (byte as u64) << (8 * index);
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a little endian unsigned 16 bytes integer.
            #[inline] pub fn le_u128<I, E: ParseError<I>>(input: I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 16;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(bound - input.input_len()))) }                
                else
                {
                    let mut res = 0u128;
                    for (index, byte) in input.iter_indices().take(bound)
                    {
                        res += (byte as u128) << (8 * index);
                    }
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes a signed 1 byte integer.
            #[inline] pub fn le_i8<I, E: ParseError<I>>(input: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { le_u8.map(|x| x as i8).parse(input) }
            /// Recognizes a little endian signed 2 bytes integer.
            #[inline] pub fn le_i16<I, E: ParseError<I>>(input: I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { le_u16.map(|x| x as i16).parse(input) }
            /// Recognizes a little endian signed 3 bytes integer.
            #[inline] pub fn le_i24<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                le_u24.map(|x|
                {
                    if x & 0x80_00_00 != 0 { (x | 0xff_00_00_00) as i32 } 
                    else { x as i32 }
                })
                .parse(input)
            }
            /// Recognizes a little endian signed 4 bytes integer.
            #[inline] pub fn le_i32<I, E: ParseError<I>>(input: I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { le_u32.map(|x| x as i32).parse(input) }
            /// Recognizes a little endian signed 8 bytes integer.
            #[inline] pub fn le_i64<I, E: ParseError<I>>(input: I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { le_u64.map(|x| x as i64).parse(input) }
            /// Recognizes a little endian signed 16 bytes integer.
            #[inline] pub fn le_i128<I, E: ParseError<I>>(input: I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { le_u128.map(|x| x as i128).parse(input) }
            /// Recognizes an unsigned 1 byte integer
            #[inline] pub fn u8<I, E: ParseError<I>>(input: I) -> IResult<I, u8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                let bound: usize = 1;
                if input.input_len() < bound { Err(Err::Incomplete(Needed::new(1))) }
                else
                {
                    let res = input.iter_elements().next().unwrap();
                    Ok((input.slice(bound..), res))
                }
            }
            /// Recognizes an unsigned 2 bytes integer
            #[inline] pub fn u16<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, u16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian 
                {
                    Endianness::Big => be_u16,
                    Endianness::Little => le_u16,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_u16,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_u16,
                }
            }
            /// Recognizes an unsigned 3 byte integer
            #[inline] pub fn u24<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian 
                {
                    Endianness::Big => be_u24,
                    Endianness::Little => le_u24,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_u24,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_u24,
                }
            }
            /// Recognizes an unsigned 4 byte integer
            #[inline] pub fn u32<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, u32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_u32,
                    Endianness::Little => le_u32,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_u32,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_u32,
                }
            }
            /// Recognizes an unsigned 8 byte integer
            #[inline] pub fn u64<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, u64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_u64,
                    Endianness::Little => le_u64,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_u64,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_u64,
                }
            }
            /// Recognizes an unsigned 16 byte integer
            #[inline] pub fn u128<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, u128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_u128,
                    Endianness::Little => le_u128,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_u128,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_u128,
                }
            }
            /// Recognizes a signed 1 byte integer
            #[inline] pub fn i8<I, E: ParseError<I>>(i: I) -> IResult<I, i8, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            { u8.map(|x| x as i8).parse(i) }
            /// Recognizes a signed 2 byte integer
            #[inline] pub fn i16<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, i16, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_i16,
                    Endianness::Little => le_i16,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_i16,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_i16,
                }
            }
            /// Recognizes a signed 3 byte integer
            #[inline] pub fn i24<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_i24,
                    Endianness::Little => le_i24,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_i24,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_i24,
                }
            }
            /// Recognizes a signed 4 byte integer
            #[inline] pub fn i32<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, i32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_i32,
                    Endianness::Little => le_i32,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_i32,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_i32,
                }
            }
            /// Recognizes a signed 8 byte integer
            #[inline]
            pub fn i64<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, i64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_i64,
                    Endianness::Little => le_i64,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_i64,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_i64,
                }
            }
            /// Recognizes a signed 16 byte integer
            #[inline] pub fn i128<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, i128, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_i128,
                    Endianness::Little => le_i128,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_i128,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_i128,
                }
            }
            /// Recognizes a big endian 4 bytes floating point number.
            #[inline] pub fn be_f32<I, E: ParseError<I>>(input: I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match be_u32(input)
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f32::from_bits(o))),
                }
            }
            /// Recognizes a big endian 8 bytes floating point number.
            #[inline] pub fn be_f64<I, E: ParseError<I>>(input: I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match be_u64(input)
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f64::from_bits(o))),
                }
            }
            /// Recognizes a little endian 4 bytes floating point number.
            #[inline] pub fn le_f32<I, E: ParseError<I>>(input: I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match le_u32(input)
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f32::from_bits(o))),
                }
            }
            /// Recognizes a little endian 8 bytes floating point number.
            #[inline] pub fn le_f64<I, E: ParseError<I>>(input: I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match le_u64(input)
                {
                    Err(e) => Err(e),
                    Ok((i, o)) => Ok((i, f64::from_bits(o))),
                }
            }
            /// Recognizes a 4 byte floating point number
            #[inline] pub fn f32<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, f32, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_f32,
                    Endianness::Little => le_f32,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_f32,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_f32,
                }
            }
            /// Recognizes an 8 byte floating point number
            #[inline] pub fn f64<I, E: ParseError<I>>(endian:Endianness) -> fn(I) -> IResult<I, f64, E> where
            I: Slice<RangeFrom<usize>> + InputIter<Item = u8> + InputLength
            {
                match endian
                {
                    Endianness::Big => be_f64,
                    Endianness::Little => le_f64,
                    #[cfg(target_endian = "big" )]
                    Endianness::Native => be_f64,
                    #[cfg(target_endian = "little" )]
                    Endianness::Native => le_f64,
                }
            }
            /// Recognizes a hex-encoded integer.
            #[inline] pub fn hex_u32<'a, E: ParseError<&'a [u8]>>(input: &'a [u8]) -> IResult<&'a [u8], u32, E>
            {
                let (i, o) = is_a(&b"0123456789abcdefABCDEF"[..])(input)?;
                let (parsed, remaining) = if o.len() <= 8  { (o, i) } 
                else { (&input[..8], &input[8..]) };

                let res = parsed
                .iter()
                .rev()
                .enumerate()
                .map(|(k, &v)|
                {
                    let digit = v as char;
                    digit.to_digit(16).unwrap_or(0) << (k * 4)
                })
                .sum();

                Ok((remaining, res))
            }
            /// Recognizes a floating point number in text format and returns the corresponding part of the input.
            pub fn recognize_float<T, E:ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter,
            <T as InputIter>::Item: AsChar,
            T: InputTakeAtPosition + InputLength,
            <T as InputTakeAtPosition>::Item: AsChar
            {
                recognize
                (
                    tuple
                    ((
                        opt(alt((char('+'), char('-')))),
                        alt
                        ((
                            map(tuple((digit1, opt(pair(char('.'), opt(digit1))))), |_| ()),
                            map(tuple((char('.'), digit1)), |_| ())
                        )),
                        opt(tuple
                        ((
                            alt((char('e'), char('E'))),
                            opt(alt((char('+'), char('-')))),
                            cut(digit1)
                        )))
                    ))
                )(input)
            }
            
            pub fn recognize_float_or_exceptions<T, E: ParseError<T>>(input: T) -> IResult<T, T, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter + InputTake + InputLength + Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar
            {
                alt
                ((
                    |i: T| 
                    {
                        recognize_float::<_, E>(i.clone()).map_err(|e| match e 
                        {
                            err::Error(_) => err::Error(E::from_error_kind(i, ErrorKind::Float)),
                            err::Failure(_) => err::Failure(E::from_error_kind(i, ErrorKind::Float)),
                            err::Incomplete(needed) => err::Incomplete(needed),
                        })
                    },
                    
                    |i: T|
                    {
                        tag_no_case::<_, _, E>("nan")(i.clone())
                        .map_err(|_| err::Error(E::from_error_kind(i, ErrorKind::Float)))
                    },
                    
                    |i: T|
                    {
                        tag_no_case::<_, _, E>("inf")(i.clone())
                        .map_err(|_| err::Error(E::from_error_kind(i, ErrorKind::Float)))
                    },

                    |i: T|
                    {
                        tag_no_case::<_, _, E>("infinity")(i.clone())
                        .map_err(|_| err::Error(E::from_error_kind(i, ErrorKind::Float)))
                    },
                ))(input)
            }
            /// Recognizes a floating point number in text format
            pub fn recognize_float_parts<T, E: ParseError<T>>(input: T) -> IResult<T, (bool, T, T, i32), E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter + ParseTo<i32>,
            <T as InputIter>::Item: AsChar,
            T: InputTakeAtPosition + InputTake + InputLength,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: for<'a> Compare<&'a [u8]>,
            T: AsBytes
            {
                let (i, sign) = sign(input.clone())?;                
                let (i, zeroes) = match i.as_bytes().iter().position(|c| *c != b'0')
                {
                    Some(index) => i.take_split(index),
                    None => i.take_split(i.input_len()),
                };                
                let (i, mut integer) = match i
                .as_bytes()
                .iter()
                .position(|c| !(*c >= b'0' && *c <= b'9'))
                {
                    Some(index) => i.take_split(index),
                    None => i.take_split(i.input_len()),
                };

                if integer.input_len() == 0 && zeroes.input_len() > 0
                {
                    integer = zeroes.slice(zeroes.input_len() - 1..);
                }

                let (i, opt_dot) = opt(tag(&b"."[..]))(i)?;
                let (i, fraction) = if opt_dot.is_none()
                {
                    let i2 = i.clone();
                    (i2, i.slice(..0))
                }
                
                else
                {
                    let mut zero_count = 0usize;
                    let mut position = None;
                    
                    for (pos, c) in i.as_bytes().iter().enumerate()
                    {
                        if *c >= b'0' && *c <= b'9' 
                        {
                            if *c == b'0' { zero_count += 1; } else { zero_count = 0; }
                        }
                        
                        else 
                        {
                            position = Some(pos);
                            break;
                        }
                    }

                    let position = match position
                    {
                        Some(p) => p,
                        None => return Err(Err::Incomplete(Needed::new(1))),
                    };
                    let index = if zero_count == 0 { position } 
                    else if zero_count == position { position - zero_count + 1 } 
                    else { position - zero_count };
                    (i.slice(position..), i.slice(..index))
                };

                if integer.input_len() == 0 && fraction.input_len() == 0 
                { return Err(Err::Error(E::from_error_kind(input, ErrorKind::Float))); }

                let i2 = i.clone();
                let (i, e) = match i.as_bytes().iter().next()
                {
                    Some(b'e') => (i.slice(1..), true),
                    Some(b'E') => (i.slice(1..), true),
                    _ => (i, false),
                };
                let (i, exp) = if e { cut( chars::i32 )(i)? } else { (i2, 0) };

                Ok((i, (sign, integer, fraction, exp)))
            }
            /// Recognizes floating point number in text format and returns a f32.
            pub fn float<T, E: ParseError<T>>(input: T) -> IResult<T, f32, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter + InputLength + InputTake + ParseTo<f32> + Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            <T as InputIter>::IterElem: Clone,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: AsBytes,
            T: for<'a> Compare<&'a [u8]>
            {
                let (i, s) = recognize_float_or_exceptions(input)?;
                match s.parse_to()
                {
                    Some(f) => Ok((i, f)),
                    None => Err( err::Error(E::from_error_kind
                    ( i, ErrorKind::Float ))),
                }
            }
            /// Recognizes floating point number in text format and returns a f64.
            pub fn double<T, E: ParseError<T>>(input: T) -> IResult<T, f64, E> where
            T: Slice<RangeFrom<usize>> + Slice<RangeTo<usize>>,
            T: Clone + Offset,
            T: InputIter + InputLength + InputTake + ParseTo<f64> + Compare<&'static str>,
            <T as InputIter>::Item: AsChar,
            <T as InputIter>::IterElem: Clone,
            T: InputTakeAtPosition,
            <T as InputTakeAtPosition>::Item: AsChar,
            T: AsBytes,
            T: for<'a> Compare<&'a [u8]>
            {
                let (i, s) = recognize_float_or_exceptions(input)?;
                match s.parse_to()
                {
                    Some(f) => Ok((i, f)),
                    None => Err(err::Error(E::from_error_kind
                    ( i, ErrorKind::Float ))),
                }
            }
        }
        /// Configurable endianness
        #[derive( Debug, PartialEq, Eq, Clone, Copy )]
        pub enum Endianness
        {
            /// Big endian
            Big,
            /// Little endian
            Little,
            /// Will match the host's endianness
            Native,
        }
    }
}
/* aka pub mod execute */
pub mod now
{
    use ::
    {
        collections::{ HashMap },
        error::{ self, Error as Errors, no::{ Errno, errno } },
        ffi::{ CString, NulError, OsStr, OsString },
        io::{ self, Read, Write },
        iter::{ IntoIterator, Iterator },
        os::unix::ffi::{ OsStrExt },
        regex::{ Regex },
        shell::{ self, Shell },
        types::{ CommandLine, CommandResult, Tokens },
        *,
    };
    /// Like `try!`, but it just returns the error directly without wrapping it in `Err`. 
    /// For functions that only return if something goes wrong.
    macro_rules! exec_try
    {
        ( $ expr : expr ) =>
        {
            match $expr
            {
                Ok(val) => val,
                Err(err) => return From::from(err),
            }
        };
    }
    /// Entry point for non-ttys ( e.g. Cmd-N on MacVim )
    pub fn run_procs_for_non_tty( sh:&mut Shell )
    {
        let mut buffer = String::new();
        let stdin = io::stdin();
        let mut handle = stdin.lock();
        match handle.read_to_string( &mut buffer )
        {
            Ok( _ ) => { run_command_line( sh, &buffer, false, false ); /* log!( "run non tty command:{}", &buffer ); */ }
            Err( e ) => { println!( "pls:stdin.read_to_string() failed:{:?}", e ); }
        }
    }

    pub fn run_command_line( sh:&mut Shell, line:&str, tty:bool, capture:bool ) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();
        for token in parsers::line::line_to_cmds( line )
        {
            if token == ";" || token == "&&" || token == "||"
            {
                sep = token.clone();
                continue;
            }
            if sep == "&&" && status != 0 { break; }
            if sep == "||" && status == 0 { break; }
            let cmd = token.clone();
            let cr = run_proc( sh, &cmd, tty, capture );
            status = cr.status;
            sh.previous_status = status;
            cr_list.push( cr );
        }
        cr_list
    }

    fn drain_env_tokens( tokens:&mut Tokens ) -> HashMap<String, String>
    {
        let mut envs:HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let ptn_env_exp = r"^( [a-zA-Z_][a-zA-Z0-9_]* )=( .* )$";
        let re = Regex::new( ptn_env_exp ).unwrap();
        for ( sep, text ) in tokens.iter()
        {
            if !sep.is_empty() || !regex::re_contains( text, ptn_env_exp ) { break; }

            for cap in re.captures_iter( text )
            {
                let name = cap[1].to_string();
                let value = parsers::line::unquote( &cap[2] );
                envs.insert( name, value );
            }

            n += 1;
        }

        if n > 0 { tokens.drain( 0..n ); }
        envs
    }

    fn line_to_tokens( sh:&mut Shell, line:&str ) -> ( Tokens, HashMap<String, String> )
    {
        let linfo = parsers::line::parse_line( line );
        let mut tokens = linfo.tokens;
        shell::do_expansion( sh, &mut tokens );
        let envs = drain_env_tokens( &mut tokens );
        ( tokens, envs )
    }

    fn set_shell_vars( sh:&mut Shell, envs:&HashMap<String, String> )
    {
        for ( name, value ) in envs.iter() { sh.set_env( name, value ); }
    }
    /// Run simple command or pipeline without using `&&`, `||`, `;`.
    fn run_proc( sh:&mut Shell, line:&str, tty:bool, capture:bool ) -> CommandResult
    {
        unsafe
        {        
            let log_cmd = !sh.cmd.starts_with( ' ' );
            match CommandLine::from_line( line, sh )
            {
                Ok( cl ) =>
                {
                    if cl.is_empty()
                    {
                        if !cl.envs.is_empty() { set_shell_vars( sh, &cl.envs ); }
                        return CommandResult::new();
                    }

                    let ( term_given, cr ) = shell::run_pipeline( sh, &cl, tty, capture, log_cmd );
                    if term_given
                    {
                        let gid = libc::getpgid( 0 );
                        shell::give_terminal_to( gid );
                    }

                    cr
                }
                Err( e ) =>
                {
                    println_stderr!( "pls:{}", e );
                    CommandResult::from_status( 0, 1 )
                }
            }
        }
    }

    fn run_with_shell( sh:&mut Shell, line:&str ) -> CommandResult
    {
        unsafe
        {
            let ( tokens, envs ) = line_to_tokens( sh, line );
            if tokens.is_empty()
            {
                set_shell_vars( sh, &envs );
                return CommandResult::new();
            }

            match CommandLine::from_line( line, sh )
            {
                Ok( c ) =>
                {
                    let ( term_given, cr ) = shell::run_pipeline( sh, &c, false, true, false );
                    if term_given
                    {
                        let gid = libc::getpgid( 0 );
                        shell::give_terminal_to( gid );    
                    }

                    cr
                }
                Err( e ) =>
                {
                    println_stderr!( "pls:{}", e );
                    CommandResult::from_status( 0, 1 )
                }
            }
        }
    }

    pub fn run( line:&str ) -> CommandResult
    {
        let mut sh = Shell::new();
        run_with_shell( &mut sh, line )
    }
    // A simple wrapper around the C library's `execvp` function.
    /// Represents an error calling `exec`.
    #[derive(Debug)]
    #[must_use]
    pub enum Error 
    {
        /// One of the strings passed to `execv` contained an internal null byte and can't be passed correctly to C.
        BadArgument(NulError),
        /// An error was returned by the system.
        Errno(Errno),
    }

    impl error::Error for Error
    {
        fn description(&self) -> &str
        {
            match self
            {
                &Error::BadArgument(_) => "bad argument to exec",
                &Error::Errno(_) => "couldn't exec process",
            }
        }

        fn cause(&self) -> Option<&error::Error>
        {
            match self
            {
                &Error::BadArgument(ref err) => Some(err),
                &Error::Errno(_) => None,
            }
        }
    }

    impl fmt::Display for Error
    {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
        {
            match self
            {
                &Error::BadArgument(ref err) => write!(f, "{}: {}", self.description(), err),
                &Error::Errno(err) => write!(f, "{}: {}", self.description(), err),
            }
        }
    }

    impl From<NulError> for Error
    {
        /// Convert a `NulError` into an `ExecError`.
        fn from(err: NulError) -> Error { Error::BadArgument(err) }
    }
    /// Run `program` with `args`, completely replacing the currently running program.
    pub fn execvp<S, I>(program: S, args: I) -> Error where 
    S: AsRef<OsStr>, I: IntoIterator, I::Item: AsRef<OsStr>
    {
        // Add null terminations to our strings and our argument array,
        // converting them into a C-compatible format.
        let program_cstring =
            exec_try!(CString::new(program.as_ref().as_bytes()));
        let arg_cstrings = exec_try!(args.into_iter().map(|arg| {
            CString::new(arg.as_ref().as_bytes())
        }).collect::<Result<Vec<_>, _>>());
        let mut arg_charptrs: Vec<_> = arg_cstrings.iter().map(|arg| {
            arg.as_bytes_with_nul().as_ptr() as *const i8
        }).collect();
        arg_charptrs.push(ptr::null());

        // Use an `unsafe` block so that we can call directly into C.
        let res = unsafe {
            libc::execvp(program_cstring.as_bytes_with_nul().as_ptr() as *const i8,
                        arg_charptrs.as_ptr())
        };

        // Handle our error result.
        if res < 0 {
            Error::Errno(errno())
        } else {
            // Should never happen.
            panic!("execvp returned unexpectedly")
        }
    }
    /// Build a command to execute.  This has an API which is deliberately similar to `std::process::Command`.
    pub struct Command
    {
        /// The program name and arguments, in typical C `argv` style.
        argv: Vec<OsString>,
    }

    impl Command
    {
        /// Create a new command builder, specifying the program to run.
        pub fn new<S: AsRef<OsStr>>(program: S) -> Command
        {
            Command
            {
                argv: vec!(program.as_ref().to_owned()),
            }
        }
        /// Add an argument to the command builder.  This can be chained.
        pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command
        {
            self.argv.push(arg.as_ref().to_owned());
            self
        }
        /// Add multiple arguments to the command builder.  This can be chained.
        pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command
        {
            for arg in args
            {
                self.arg(arg.as_ref());
            }
            self
        }
        /// Execute the command we built.  If this function succeeds, it will never return.
        pub fn exec(&mut self) -> Error { execvp(&self.argv[0], &self.argv) }
    }
}
pub mod num { pub use std::num::{ * }; }
pub mod ops { pub use std::ops::{ * }; }
pub mod option
{
    pub use std::option::{ * };
    pub use self::Option::{ * };
    /*
    option-ext v0.0.0*/
    pub mod implementation
    {
        use super::OptionExt;

        impl<T> OptionExt<T> for Option<T>
        {
            fn contains<U>( &self, x:&U ) -> bool where
            U:PartialEq<T> 
            {
                match *self
                {
                    Some( ref y ) => x == y,
                    None => false,
                }
            }

            #[inline] fn map_or2<U, F:FnOnce( T ) -> U>( self, f:F, default:U ) -> U 
            { self.map_or( default, f ) }

            #[inline] fn map_or_else2<U, F:FnOnce( T ) -> U, D:FnOnce() -> U>( self, f:F, default:D ) -> U 
            { self.map_or_else( default, f ) }
        }
    }

    /// Extension trait providing additional methods for `Option`.
    pub trait OptionExt<T>
    {
        /// Returns `true` if the option is a [`Some`] value containing the given value.
        #[must_use] fn contains<U>( &self, x:&U ) -> bool where U:PartialEq<T>;

        /// Returns the result from applying the function `f` to the contained value if the option is [`Some`], 
        /// or returns provided `default` value if the option is [`None`].
        #[must_use] fn map_or2<U, F:FnOnce( T ) -> U>( self, f:F, default:U ) -> U;

        /// Returns the result from applying the function `f` to the contained value if the option is [`Some`],
        /// or returns the result from evaluating the provided function `default` if the option is [`None`].
        #[must_use] fn map_or_else2<U, F:FnOnce( T ) -> U, D:FnOnce() -> U>( self, f:F, default:D ) -> U;
    }
}
pub mod os { pub use std::os::{ * }; }
pub mod panic { pub use std::panic::{ * }; }
pub mod parsers
{
    pub mod line
    {
        use ::
        {
            regex::{ Regex },
            types::{LineInfo, Redirection, Tokens},
            *,
        };

        pub fn line_to_plain_tokens( line:&str ) -> Vec<String>
        {
            let mut result = Vec::new();
            let linfo = parse_line( line );
            for ( _, r ) in linfo.tokens {
                result.push( r.clone() );
            }
            result
        }

        pub fn tokens_to_args( tokens:&Tokens ) -> Vec<String>
        {
            let mut result = Vec::new();
            for s in tokens {
                result.push( s.1.clone() );
            }
            result
        }

        pub fn tokens_to_line( tokens:&Tokens ) -> String
        {
            let mut result = String::new();
            for t in tokens {
                if t.0.is_empty() {
                    result.push_str( &t.1 );
                } else {
                    let s = str::wrap_sep_string( &t.0, &t.1 );
                    result.push_str( &s );
                }
                result.push( ' ' );
            }
            if result.ends_with( ' ' ) {
                let len = result.len();
                result.truncate( len - 1 );
            }
            result
        }
        /// Parse command line for multiple commands.
        pub fn line_to_cmds( line:&str ) -> Vec<String>
        {
            let mut result = Vec::new();
            let mut sep = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let len = line.chars().count();
            for ( i, c ) in line.chars().enumerate() {
                if has_backslash {
                    token.push( '\\' );
                    token.push( c );
                    has_backslash = false;
                    continue;
                }

                if c == '\\' && sep != "'" {
                    has_backslash = true;
                    continue;
                }

                if c == '#' {
                    if sep.is_empty() {
                        break;
                    } else {
                        token.push( c );
                        continue;
                    }
                }
                if c == '\'' || c == '"' || c == '`' {
                    if sep.is_empty() {
                        sep.push( c );
                        token.push( c );
                        continue;
                    } else if sep == c.to_string() {
                        token.push( c );
                        sep = String::new();
                        continue;
                    } else {
                        token.push( c );
                        continue;
                    }
                }
                if c == '&' || c == '|' {
                    if sep.is_empty() {
                        if i + 1 == len {
                            token.push( c );
                            continue;
                        } else {
                            let c_next = match line.chars().nth( i + 1 ) {
                                Some( x ) => x,
                                None => {
                                    println!( "chars nth error - should never happen" );
                                    continue;
                                }
                            };

                            if c_next != c {
                                token.push( c );
                                continue;
                            }
                        }
                    }

                    if sep.is_empty() {
                        sep.push( c );
                        continue;
                    } else if c.to_string() == sep {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push( _token );
                        }
                        token = String::new();
                        result.push( format!( "{}{}", sep, sep ) );
                        sep = String::new();
                        continue;
                    } else {
                        token.push( c );
                        continue;
                    }
                }
                if c == ';' {
                    if sep.is_empty() {
                        let _token = token.trim().to_string();
                        if !_token.is_empty() {
                            result.push( _token );
                        }
                        result.push( String::from( ";" ) );
                        token = String::new();
                        continue;
                    } else {
                        token.push( c );
                        continue;
                    }
                }
                token.push( c );
            }
            if !token.is_empty() {
                result.push( token.trim().to_string() );
            }
            result
        }
        /// Parse command line to tokens.
        pub fn parse_line( line:&str ) -> LineInfo
        {
            let mut result = Vec::new();
            if is::arithmetic( line ) {
                for x in line.split( ' ' ) {
                    result.push( ( String::from( "" ), x.to_string() ) );
                }
                return LineInfo::new( result );
            }

            let mut sep = String::new();
            let mut sep_second = String::new();
            let mut token = String::new();
            let mut has_backslash = false;
            let mut met_parenthesis = false;
            let mut new_round = true;
            let mut skip_next = false;
            let mut has_dollar = false;
            let mut parens_left_ignored = false;
            let mut sep_made = String::new();
            let mut semi_ok = false;
            let count_chars = line.chars().count();
            for ( i, c ) in line.chars().enumerate() {
                if skip_next {
                    skip_next = false;
                    continue;
                }

                if has_backslash && sep.is_empty() && ( c == '>' || c == '<' ) {
                    sep_made = String::from( "'" );
                    token.push( c );
                    has_backslash = false;
                    continue;
                }

                if has_backslash && sep == "\"" && c != '\"' {
                    token.push( '\\' );
                    token.push( c );
                    has_backslash = false;
                    continue;
                }

                if has_backslash {
                    if new_round && sep.is_empty() && ( c == '|' || c == '$' ) && token.is_empty() {
                        sep = String::from( "\\" );
                        token = format!( "{}", c );
                    } else {
                        token.push( c );
                    }
                    new_round = false;
                    has_backslash = false;
                    continue;
                }

                if c == '$' {
                    has_dollar = true;
                }
                
                if c == '(' && sep.is_empty() {
                    if !has_dollar && token.is_empty() {
                        parens_left_ignored = true;
                        continue;
                    }
                    met_parenthesis = true;
                }
                if c == ')' {
                    if parens_left_ignored && !has_dollar {
                        if i == count_chars - 1 ||
                                ( i + 1 < count_chars &&
                                 line.chars().nth( i + 1 ).unwrap() == ' ' ) {
                            continue;
                        }
                    }
                    if sep.is_empty() {
                        met_parenthesis = false;
                    }
                }

                if c == '\\' {
                    if sep == "'" || !sep_second.is_empty() {
                        token.push( c )
                    } else {
                        has_backslash = true;
                    }
                    continue;
                }

                if new_round {
                    if c == ' ' {
                        continue;
                    } else if c == '"' || c == '\'' || c == '`' {
                        sep = c.to_string();
                        new_round = false;
                        continue;
                    }

                    sep = String::new();

                    if c == '#' {
                        break;
                    }

                    if c == '|' {
                        if i + 1 < count_chars && line.chars().nth( i + 1 ).unwrap() == '|' {
                            result.push( ( String::from( "" ), "||".to_string() ) );
                            skip_next = true;
                        } else {
                            result.push( ( String::from( "" ), "|".to_string() ) );
                        }
                        new_round = true;
                        continue;
                    }

                    token.push( c );
                    new_round = false;
                    continue;
                }

                if c == '|' && !has_backslash {
                    if semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push( ( sep_made.to_string(), token ) );
                            sep_made = String::new();
                        } else {
                            result.push( ( sep.to_string(), token ) );
                        }
                        result.push( ( String::from( "" ), "|".to_string() ) );
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    } else if !met_parenthesis && sep_second.is_empty() && sep.is_empty() {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push( ( sep_made.to_string(), token ) );
                            sep_made = String::new();
                        } else {
                            result.push( ( String::from( "" ), token ) );
                        }
                        result.push( ( String::from( "" ), "|".to_string() ) );
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        continue;
                    }
                }

                if c == ' ' {
                    if semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push( ( sep_made.to_string(), token ) );
                            sep_made = String::new();
                        } else {
                            result.push( ( sep.to_string(), token ) );
                        }
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                        continue;
                    }

                    if has_backslash {
                        has_backslash = false;
                        token.push( c );
                        continue;
                    }

                    if met_parenthesis {
                        token.push( c );
                        continue;
                    }

                    if sep == "\\" {
                        result.push( ( String::from( "\\" ), token ) );
                        token = String::new();
                        new_round = true;
                        continue;
                    }

                    if sep.is_empty() {
                        if sep_second.is_empty() {
                            if sep.is_empty() && !sep_made.is_empty() {
                                result.push( ( sep_made.clone(), token ) );
                                sep_made = String::new();
                            } else {
                                result.push( ( String::from( "" ), token ) );
                            }
                            token = String::new();
                            new_round = true;
                            continue;
                        } else {
                            token.push( c );
                            continue;
                        }
                    } else {
                        token.push( c );
                        continue;
                    }
                }

                if c == '\'' || c == '"' || c == '`' {
                    if has_backslash {
                        has_backslash = false;
                        token.push( c );
                        continue;
                    }

                    if sep != c.to_string() && semi_ok {
                        if sep.is_empty() && !sep_made.is_empty() {
                            result.push( ( sep_made.to_string(), token ) );
                            sep_made = String::new();
                        } else {
                            result.push( ( sep.to_string(), token ) );
                        }
                        sep = String::new();
                        sep_second = String::new();
                        token = String::new();
                        new_round = true;
                        semi_ok = false;
                    }

                    if sep != c.to_string() && met_parenthesis {
                        token.push( c );
                        continue;
                    }
                    if sep.is_empty() && !sep_second.is_empty() && sep_second != c.to_string() {
                        token.push( c );
                        continue;
                    }

                    if sep.is_empty() {
                        let is_an_env = regex::re_contains( &token, r"^[a-zA-Z0-9_]+=.*$" );
                        if !is_an_env && ( c == '\'' || c == '"' ) {
                            sep = c.to_string();
                            continue;
                        }

                        token.push( c );
                        if sep_second.is_empty() {
                            sep_second = c.to_string();
                        } else if sep_second == c.to_string() {
                            sep_second = String::new();
                        }
                        continue;
                    } else if sep == c.to_string() {
                        semi_ok = true;
                        continue;
                    } else {
                        token.push( c );
                    }
                } else {
                    if has_backslash {
                        has_backslash = false;
                        if sep == "\"" || sep == "'" {
                            token.push( '\\' );
                        }
                    }
                    token.push( c );
                }
            }
            if !token.is_empty() || semi_ok {
                if sep.is_empty() && !sep_made.is_empty() {
                    result.push( ( sep_made.clone(), token ) );
                } else {
                    result.push( ( sep.clone(), token ) );
                }
            }

            let mut is_line_complete = true;
            if !result.is_empty() {
                let token_last = result[result.len() - 1].clone();
                if token_last.0.is_empty() && token_last.1 == "|" {
                    is_line_complete = false;
                }
            }

            if !sep.is_empty() {
                is_line_complete = semi_ok;
            }
            if has_backslash {
                is_line_complete = false;
            }

            LineInfo { tokens:result, is_complete:is_line_complete }
        }

        pub fn tokens_to_redirections( tokens:&Tokens ) -> Result<( Tokens, Vec<Redirection> ), String>
        {
            let mut tokens_new = Vec::new();
            let mut redirects = Vec::new();
            let mut to_be_continued = false;
            let mut to_be_continued_s1 = String::new();
            let mut to_be_continued_s2 = String::new();

            for token in tokens {
                let sep = &token.0;
                if !sep.is_empty() && !to_be_continued {
                    tokens_new.push( token.clone() );
                    continue;
                }
                let word = &token.1;

                if to_be_continued {
                    if sep.is_empty() && word.starts_with( '&' ) {
                        return Err( String::from( "bad redirection syntax near &" ) );
                    }

                    let s3 = word.to_string();
                    if regex::re_contains( &to_be_continued_s1, r"^\d+$" ) {
                        if to_be_continued_s1 != "1" && to_be_continued_s1 != "2" {
                            return Err( String::from( "Bad file descriptor #3" ) );
                        }
                        let s1 = to_be_continued_s1.clone();
                        let s2 = to_be_continued_s2.clone();
                        redirects.push( ( s1, s2, s3 ) );
                    } else {
                        if !to_be_continued_s1.is_empty() {
                            tokens_new.push( ( sep.clone(), to_be_continued_s1.to_string() ) );
                        }
                        redirects.push( ( "1".to_string(), to_be_continued_s2.clone(), s3 ) );
                    }

                    to_be_continued = false;
                    continue;
                }

                let ptn1 = r"^( [^>]* )( >>? )( [^>]+ )$";
                let ptn2 = r"^( [^>]* )( >>? )$";
                if !regex::re_contains( word, r">" ) {
                    tokens_new.push( token.clone() );
                } else if regex::re_contains( word, ptn1 ) {
                    let re;
                    if let Ok( x ) = Regex::new( ptn1 ) {
                        re = x;
                    } else {
                        return Err( String::from( "Failed to build Regex" ) );
                    }

                    if let Some( caps ) = re.captures( word ) {
                        let s1 = caps.get( 1 ).unwrap().as_str();
                        let s2 = caps.get( 2 ).unwrap().as_str();
                        let s3 = caps.get( 3 ).unwrap().as_str();
                        if s3.starts_with( '&' ) && s3 != "&1" && s3 != "&2" {
                            return Err( String::from( "Bad file descriptor #1" ) );
                        }

                        if regex::re_contains( s1, r"^\d+$" ) {
                            if s1 != "1" && s1 != "2" {
                                return Err( String::from( "Bad file descriptor #2" ) );
                            }
                            redirects.push( ( s1.to_string(), s2.to_string(), s3.to_string() ) );
                        } else {
                            if !s1.is_empty() {
                                tokens_new.push( ( sep.clone(), s1.to_string() ) );
                            }
                            redirects.push( ( String::from( "1" ), s2.to_string(), s3.to_string() ) );
                        }
                    }
                } else if regex::re_contains( word, ptn2 ) {
                    let re;
                    if let Ok( x ) = Regex::new( ptn2 ) {
                        re = x;
                    } else {
                        return Err( String::from( "Failed to build Regex" ) );
                    }

                    if let Some( caps ) = re.captures( word ) {
                        let s1 = caps.get( 1 ).unwrap().as_str();
                        let s2 = caps.get( 2 ).unwrap().as_str();

                        to_be_continued = true;
                        to_be_continued_s1 = s1.to_string();
                        to_be_continued_s2 = s2.to_string();
                    }
                }
            }

            if to_be_continued {
                return Err( String::from( "redirection syntax error" ) );
            }

            Ok( ( tokens_new, redirects ) )
        }

        pub fn unquote( text:&str ) -> String
        {
            let mut new_str = String::from( text );
            for &c in ['"', '\''].iter() {
                if text.starts_with( c ) && text.ends_with( c ) {
                    new_str.remove( 0 );
                    new_str.pop();
                    break;
                }
            }
            new_str
        }
    }

    pub mod locust
    {
        /*
        use pest::Parser;
        use pest::iterators::Pairs;
        use pest::error::Error;

        #[derive( Parser )]
        #[grammar = "parsers/grammar.pest"]
        struct Locust;

        pub fn parse_lines( lines:&str ) -> 
        Result<Pairs<crate::parsers::locust::Rule>, Error<crate::parsers::locust::Rule>> {
            Locust::parse( Rule::EXP, lines )
        }
        */
        pub struct Pairs();
        /**/
        pub fn parse_lines( lines:&str ) -> Result<Pairs<crate::parsers::locust::Rule>, Error<crate::parsers::locust::Rule>>
        {
            //Locust::parse( Rule::EXP, lines )
            Ok( Pairs() )
        }


        #[derive( Debug )]
        pub enum Rule
        {
            If,
            IfElse,
        }
    }
    /*
    Fast, minimal float-parsing algorithm.*/
    pub mod float
    {

        #[macro_use] pub mod upper
        {
            use super::
            {
                bigint::{ nonzero, rview },
                limb::{ Limb, LIMB_BITS },
            };
            /// Extract the hi bits from the buffer.
           #[macro_export] macro_rules! upper
            {
                ( @1 $self:ident, $rview:ident, $t:ident, $fn:ident ) =>
                {{
                    $fn( $rview[0] as $t )
                }};
                
                ( @2 $self:ident, $rview:ident, $t:ident, $fn:ident ) =>
                {{
                    let r0 = $rview[0] as $t;
                    let r1 = $rview[1] as $t;
                    $fn( r0, r1 )
                }};
                
                ( @nonzero2 $self:ident, $rview:ident, $t:ident, $fn:ident ) =>
                {{
                    let ( v, n ) = upper!( @2 $self, $rview, $t, $fn );
                    ( v, n || nonzero( $self, 2 ) )
                }};
                
                ( @3 $self:ident, $rview:ident, $t:ident, $fn:ident ) =>
                {{
                    let r0 = $rview[0] as $t;
                    let r1 = $rview[1] as $t;
                    let r2 = $rview[2] as $t;
                    $fn( r0, r1, r2 )
                }};
                
                ( @nonzero3 $self:ident, $rview:ident, $t:ident, $fn:ident ) =>
                {{
                    let ( v, n ) = upper!( @3 $self, $rview, $t, $fn );
                    ( v, n || nonzero( $self, 3 ) )
                }};
            }
            /// Shift 64-bit integer to high 64-bits.
            #[inline] pub fn u64_to_hi64_1( r0:u64 ) -> ( u64, bool )
            {
                let ls = r0.leading_zeros();
                ( r0 << ls, false )
            }
            /// Shift 2 64-bit integers to high 64-bits.
            #[inline] pub fn u64_to_hi64_2( r0:u64, r1:u64 ) -> ( u64, bool )
            {
                let ls = r0.leading_zeros();
                let rs = 64 - ls;
                let v = match ls
                {
                    0 => r0,
                    _ => ( r0 << ls ) | ( r1 >> rs ),
                };
                let n = r1 << ls != 0;
                ( v, n )
            }            
            /// Shift 32-bit integer to high 64-bits.
            #[inline] pub fn u32_to_hi64_1( r0:u32 ) -> ( u64, bool ) 
            { u64_to_hi64_1( r0 as u64 ) }
            /// Shift 2 32-bit integers to high 64-bits.
            #[inline] pub fn u32_to_hi64_2( r0:u32, r1:u32 ) -> ( u64, bool )
            {
                let r0 = ( r0 as u64 ) << 32;
                let r1 = r1 as u64;
                u64_to_hi64_1( r0 | r1 )
            }
            /// Shift 3 32-bit integers to high 64-bits.
            #[inline] pub fn u32_to_hi64_3( r0:u32, r1:u32, r2:u32 ) -> ( u64, bool )
            {
                let r0 = r0 as u64;
                let r1 = ( r1 as u64 ) << 32;
                let r2 = r2 as u64;
                u64_to_hi64_2( r0, r1 | r2 )
            }

            /// Get the high 64 bits from the vector.
            #[inline( always )] pub fn upper( x:&[Limb] ) -> ( u64, bool ) 
            {
                let rslc = rview( x );
                match x.len()
                {
                    0 => ( 0, false ),
                    1 if LIMB_BITS == 32 => upper!( @1 x, rslc, u32, u32_to_hi64_1 ),
                    1 => upper!( @1 x, rslc, u64, u64_to_hi64_1 ),
                    2 if LIMB_BITS == 32 => upper!( @2 x, rslc, u32, u32_to_hi64_2 ),
                    2 => upper!( @2 x, rslc, u64, u64_to_hi64_2 ),
                    _ if LIMB_BITS == 32 => upper!( @nonzero3 x, rslc, u32, u32_to_hi64_3 ),
                    _ => upper!( @nonzero2 x, rslc, u64, u64_to_hi64_2 ),
                }
            }
        }

        pub mod bellerophon
        {
            
            //! An implementation of Clinger's Bellerophon algorithm.
            use super::extended::ExtendedFloat;
            use super::mask::{lower_n_halfway, lower_n_mask};
            use super::num::Float;
            use super::number::Number;
            use super::rounding::{round, round_nearest_tie_even};
            use super::table::BASE10_POWERS;
            
            /// Core implementation of the Bellerophon algorithm.
            pub fn bellerophon<F:Float>( num:&Number ) -> ExtendedFloat
            {
                let fp_zero = ExtendedFloat
                {
                    mant:0,
                    exp:0,
                };
                
                let fp_inf = ExtendedFloat
                {
                    mant:0,
                    exp:F::INFINITE_POWER,
                };

                if num.mantissa == 0 || num.exponent <= -0x1000 { return fp_zero; } 
                else if num.exponent >= 0x1000 { return fp_inf; }

                let exponent = num.exponent as i32 + BASE10_POWERS.bias;
                let small_index = exponent % BASE10_POWERS.step;
                let large_index = exponent / BASE10_POWERS.step;
                if exponent < 0 { return fp_zero; }
                if large_index as usize >= BASE10_POWERS.large.len() { return fp_inf; }
                
                let mut errors:u32 = 0;
                if num.many_digits { errors += error_halfscale(); }

                let mut fp = ExtendedFloat
                {
                    mant:num.mantissa,
                    exp:0,
                };
                match fp.mant.overflowing_mul( BASE10_POWERS.get_small_int( small_index as usize ) )
                {
                    ( _, true ) =>
                    {
                        normalize( &mut fp );
                        fp = mul( &fp, &BASE10_POWERS.get_small( small_index as usize ) );
                        errors += error_halfscale();
                    },
                    
                    ( mant, false ) =>
                    {
                        fp.mant = mant;
                        normalize( &mut fp );
                    },
                }
                
                fp = mul( &fp, &BASE10_POWERS.get_large( large_index as usize ) );
                if errors > 0
                {
                    errors += 1;
                }

                errors += error_halfscale();                
                let shift = normalize( &mut fp );
                errors <<= shift;
                fp.exp += F::EXPONENT_BIAS;                
                if -fp.exp + 1 > 65 { return fp_zero; }                
                if !error_is_accurate::<F>( errors, &fp )
                {
                    fp.exp += F::INVALID_FP;
                    return fp;
                }
                
                if -fp.exp + 1 == 65 { return fp_zero; }
                round::<F, _>( &mut fp, |f, s| 
                {
                    round_nearest_tie_even( f, s, |is_odd, is_halfway, is_above|
                    {
                        is_above || ( is_odd && is_halfway )
                    } );
                } );
                fp
            }
            /// Get the full error scale.
            #[inline( always )] const fn error_scale() -> u32 { 8 }
            /// Get the half error scale.
            #[inline( always )] const fn error_halfscale() -> u32 { error_scale() / 2 }
            /// Determine if the number of errors is tolerable for float precision.
            fn error_is_accurate<F:Float>( errors:u32, fp:&ExtendedFloat ) -> bool
            {
                debug_assert!( fp.exp >= -64 );
                let mantissa_shift = 64 - F::MANTISSA_SIZE - 1;
                let extrabits = match fp.exp <= -mantissa_shift 
                {
                    true => 1 - fp.exp,
                    false => 64 - F::MANTISSA_SIZE - 1,
                };
                let maskbits = extrabits as u64;
                let errors = errors as u64;
                if extrabits > 64 { !fp.mant.overflowing_add( errors ).1 } 
                else
                {
                    let mask = lower_n_mask( maskbits );
                    let extra = fp.mant & mask;
                    let halfway = lower_n_halfway( maskbits );
                    let cmp1 = halfway.wrapping_sub( errors ) < extra;
                    let cmp2 = extra < halfway.wrapping_add( errors );
                    !( cmp1 && cmp2 )
                }
            }
            /// Normalize float-point number.
            pub fn normalize( fp:&mut ExtendedFloat ) -> i32
            {
                if fp.mant != 0
                {
                    let shift = fp.mant.leading_zeros() as i32;
                    fp.mant <<= shift;
                    fp.exp -= shift;
                    shift
                } 
                else { 0 }
            }
            /// Multiply two normalized extended-precision floats, as if by `a*b`.
            pub fn mul( x:&ExtendedFloat, y:&ExtendedFloat ) -> ExtendedFloat
            {
                debug_assert!( x.mant >> 32 != 0 );
                debug_assert!( y.mant >> 32 != 0 );

                const LOMASK:u64 = 0xffff_ffff;
                let x1 = x.mant >> 32;
                let x0 = x.mant & LOMASK;
                let y1 = y.mant >> 32;
                let y0 = y.mant & LOMASK;
                let x1_y0 = x1 * y0;
                let x0_y1 = x0 * y1;
                let x0_y0 = x0 * y0;
                let x1_y1 = x1 * y1;
                let mut tmp = ( x1_y0 & LOMASK ) + ( x0_y1 & LOMASK ) + ( x0_y0 >> 32 );
                tmp += 1 << ( 32 - 1 );
                ExtendedFloat
                {
                    mant:x1_y1 + ( x1_y0 >> 32 ) + ( x0_y1 >> 32 ) + ( tmp >> 32 ),
                    exp:x.exp + y.exp + 64,
                }
            }
            /// Precalculated powers of base N for the Bellerophon algorithm.
            pub struct BellerophonPowers
            {
                pub small:&'static [u64],
                pub large:&'static [u64],
                pub small_int:&'static [u64],
                pub step:i32,
                pub bias:i32,
                /// ceil( log2( radix ) ) scaled as a multiplier.
                pub log2:i64,
                /// Bitshift for the log2 multiplier.
                pub log2_shift:i32,
            }

            /// Allow indexing of values without bounds checking
            impl BellerophonPowers
            {
                #[inline] pub fn get_small( &self, index:usize ) -> ExtendedFloat
                {
                    let mant = self.small[index];
                    let exp = ( 1 - 64 ) + ( ( self.log2 * index as i64 ) >> self.log2_shift );
                    ExtendedFloat
                    {
                        mant,
                        exp:exp as i32,
                    }
                }

                #[inline] pub fn get_large( &self, index:usize ) -> ExtendedFloat
                {
                    let mant = self.large[index];
                    let biased_e = index as i64 * self.step as i64 - self.bias as i64;
                    let exp = ( 1 - 64 ) + ( ( self.log2 * biased_e ) >> self.log2_shift );
                    ExtendedFloat
                    {
                        mant,
                        exp:exp as i32,
                    }
                }

                #[inline] pub fn get_small_int( &self, index:usize ) -> u64 { self.small_int[index] }
            }
        }

        pub mod bigint
        {
            //! A simple big-integer type for slow path algorithms.
            use super::
            {
                heapvec::{ HeapVec },
                num::{ int_pow_fast_path, FastPathRadix },
            };

            use ::
            {
                *,
            };
            /// Number of bits in a Bigint.
            pub const BIGINT_BITS:usize = 4000;

            /// The number of limbs for the bigint.
            pub const BIGINT_LIMBS:usize = BIGINT_BITS / LIMB_BITS;

            pub type VecType = HeapVec;

            /// Storage for a big integer type.
            #[derive( Clone, PartialEq, Eq )]
            pub struct Bigint
            {
                /// Significant digits for the float, stored in a big integer in LE order.
                pub data:VecType,
            }
            
            impl Bigint
            {
                /// Construct a bigint representing 0.
                #[inline( always )]
                pub fn new() -> Self
                {
                    Self { data:VecType::new(), }
                }

                /// Construct a bigint from an integer.
                #[inline( always )] pub fn from_u64( value:u64 ) -> Self
                {
                    Self
                    {
                        data:VecType::from_u64( value ),
                    }
                }

                #[inline( always )] pub fn hi64( &self ) -> ( u64, bool )
                {
                    self.data.hi64()
                }

                /// Multiply and assign as if by exponentiation by a power.
                #[inline]
                pub fn pow( &mut self, base:u32, exp:u32 ) -> Option<()> {
                    debug_assert!( base == 2 || base == 5 || base == 10 );
                    if base % 5 == 0 {
                        pow( &mut self.data, exp )?;
                    }
                    if base % 2 == 0 {
                        shl( &mut self.data, exp as usize )?;
                    }
                    Some( () )
                }

                /// Calculate the bit-length of the big-integer.
                #[inline]
                pub fn bit_length( &self ) -> u32 {
                    bit_length( &self.data )
                }
            }

            impl ops::MulAssign<&Bigint> for Bigint {
                fn mul_assign( &mut self, rhs:&Bigint ) {
                    self.data *= &rhs.data;
                }
            }

            /// REVERSE VIEW

            /// Reverse, immutable view of a sequence.
            pub struct ReverseView<'a, T:'a> {
                inner:&'a [T],
            }

            impl<'a, T> ops::Index<usize> for ReverseView<'a, T> {
                type Output = T;

                #[inline]
                fn index( &self, index:usize ) -> &T {
                    let len = self.inner.len();
                    &( *self.inner )[len - index - 1]
                }
            }

            /// Create a reverse view of the vector for indexing.
            #[inline]
            pub fn rview( x:&[Limb] ) -> ReverseView<Limb> {
                ReverseView {
                    inner:x,
                }
            }

            /// Compare `x` to `y`, in little-endian order.
            #[inline]
            pub fn compare( x:&[Limb], y:&[Limb] ) -> cmp::Ordering {
                match x.len().cmp( &y.len() ) {
                    cmp::Ordering::Equal => {
                        let iter = x.iter().rev().zip( y.iter().rev() );
                        for ( &xi, yi ) in iter {
                            match xi.cmp( yi ) {
                                cmp::Ordering::Equal => (),
                                ord => return ord,
                            }
                        }
                        
                        cmp::Ordering::Equal
                    },
                    ord => ord,
                }
            }

            /// Normalize the integer, so any leading zero values are removed.
            #[inline]
            pub fn normalize( x:&mut VecType ) {
                while let Some( &value ) = x.get( x.len().wrapping_sub( 1 ) ) {
                    if value == 0 {
                        unsafe { x.set_len( x.len() - 1 ) };
                    } else {
                        break;
                    }
                }
            }

            /// Get if the big integer is normalized.
            #[inline]
            #[allow( clippy::match_like_matches_macro )]
            pub fn is_normalized( x:&[Limb] ) -> bool {
                match x.get( x.len().wrapping_sub( 1 ) ) {
                    Some( &0 ) => false,
                    _ => true,
                }
            }

            /// Create StackVec from u64 value.
            #[inline( always )]
            #[allow( clippy::branches_sharing_code )]
            pub fn from_u64( x:u64 ) -> VecType {
                let mut vec = VecType::new();
                debug_assert!( vec.capacity() >= 2 );
                if LIMB_BITS == 32 {
                    vec.try_push( x as Limb ).unwrap();
                    vec.try_push( ( x >> 32 ) as Limb ).unwrap();
                } else {
                    vec.try_push( x as Limb ).unwrap();
                }
                vec.normalize();
                vec
            }
            /// Check if any of the remaining bits are non-zero.
            #[inline]
            pub fn nonzero( x:&[Limb], rindex:usize ) -> bool {
                debug_assert!( rindex <= x.len() );

                let len = x.len();
                let slc = &x[..len - rindex];
                slc.iter().rev().any( |&x| x != 0 )
            }

            /// Shift 32-bit integer to high 64-bits.
            #[inline]
            pub fn u32_to_hi64_1( r0:u32 ) -> ( u64, bool ) {
                u64_to_hi64_1( r0 as u64 )
            }

            /// Shift 2 32-bit integers to high 64-bits.
            #[inline]
            pub fn u32_to_hi64_2( r0:u32, r1:u32 ) -> ( u64, bool ) {
                let r0 = ( r0 as u64 ) << 32;
                let r1 = r1 as u64;
                u64_to_hi64_1( r0 | r1 )
            }

            /// Shift 3 32-bit integers to high 64-bits.
            #[inline]
            pub fn u32_to_hi64_3( r0:u32, r1:u32, r2:u32 ) -> ( u64, bool ) {
                let r0 = r0 as u64;
                let r1 = ( r1 as u64 ) << 32;
                let r2 = r2 as u64;
                u64_to_hi64_2( r0, r1 | r2 )
            }

            /// Shift 64-bit integer to high 64-bits.
            #[inline]
            pub fn u64_to_hi64_1( r0:u64 ) -> ( u64, bool ) {
                let ls = r0.leading_zeros();
                ( r0 << ls, false )
            }

            /// Shift 2 64-bit integers to high 64-bits.
            #[inline]
            pub fn u64_to_hi64_2( r0:u64, r1:u64 ) -> ( u64, bool ) {
                let ls = r0.leading_zeros();
                let rs = 64 - ls;
                let v = match ls {
                    0 => r0,
                    _ => ( r0 << ls ) | ( r1 >> rs ),
                };
                let n = r1 << ls != 0;
                ( v, n )
            }

            /// Extract the hi bits from the buffer.
            macro_rules! hi {
                ( @1 $self:ident, $rview:ident, $t:ident, $fn:ident ) => {{
                    $fn( $rview[0] as $t )
                }};
                
                ( @2 $self:ident, $rview:ident, $t:ident, $fn:ident ) => {{
                    let r0 = $rview[0] as $t;
                    let r1 = $rview[1] as $t;
                    $fn( r0, r1 )
                }};
                
                ( @nonzero2 $self:ident, $rview:ident, $t:ident, $fn:ident ) => {{
                    let ( v, n ) = hi!( @2 $self, $rview, $t, $fn );
                    ( v, n || nonzero( $self, 2 ) )
                }};
                
                ( @3 $self:ident, $rview:ident, $t:ident, $fn:ident ) => {{
                    let r0 = $rview[0] as $t;
                    let r1 = $rview[1] as $t;
                    let r2 = $rview[2] as $t;
                    $fn( r0, r1, r2 )
                }};
                
                ( @nonzero3 $self:ident, $rview:ident, $t:ident, $fn:ident ) => {{
                    let ( v, n ) = hi!( @3 $self, $rview, $t, $fn );
                    ( v, n || nonzero( $self, 3 ) )
                }};
            }

            /// Get the high 64 bits from the vector.
            #[inline( always )]
            pub fn hi64( x:&[Limb] ) -> ( u64, bool ) {
                let rslc = rview( x );
                match x.len() {
                    0 => ( 0, false ),
                    1 if LIMB_BITS == 32 => hi!( @1 x, rslc, u32, u32_to_hi64_1 ),
                    1 => hi!( @1 x, rslc, u64, u64_to_hi64_1 ),
                    2 if LIMB_BITS == 32 => hi!( @2 x, rslc, u32, u32_to_hi64_2 ),
                    2 => hi!( @2 x, rslc, u64, u64_to_hi64_2 ),
                    _ if LIMB_BITS == 32 => hi!( @nonzero3 x, rslc, u32, u32_to_hi64_3 ),
                    _ => hi!( @nonzero2 x, rslc, u64, u64_to_hi64_2 ),
                }
            }

            /// MulAssign by a power of 5.
            pub fn pow( x:&mut VecType, mut exp:u32 ) -> Option<()>
            {
                let small_step = if LIMB_BITS == 32 {
                    13
                } else {
                    27
                };
                let max_native = ( 5 as Limb ).pow( small_step );
                while exp >= small_step {
                    small_mul( x, max_native )?;
                    exp -= small_step;
                }
                if exp != 0 {
                    let small_power = unsafe { int_pow_fast_path( exp as usize, FastPathRadix::Five ) };
                    small_mul( x, small_power as Limb )?;
                }
                Some( () )
            }

            /// Add two small integers and return the resulting value and if overflow happens.
            #[inline( always )]
            pub fn scalar_add( x:Limb, y:Limb ) -> ( Limb, bool ) {
                x.overflowing_add( y )
            }

            /// Multiply two small integers ( with carry ) ( and return the overflow contribution ).
            #[inline( always )]
            pub fn scalar_mul( x:Limb, y:Limb, carry:Limb ) -> ( Limb, Limb ) {
                let z:Wide = ( x as Wide ) * ( y as Wide ) + ( carry as Wide );
                ( z as Limb, ( z >> LIMB_BITS ) as Limb )
            }

            /// Add small integer to bigint starting from offset.
            #[inline]
            pub fn small_add_from( x:&mut VecType, y:Limb, start:usize ) -> Option<()> {
                let mut index = start;
                let mut carry = y;
                while carry != 0 && index < x.len() {
                    let result = scalar_add( x[index], carry );
                    x[index] = result.0;
                    carry = result.1 as Limb;
                    index += 1;
                }
                
                if carry != 0 {
                    x.try_push( carry )?;
                }
                Some( () )
            }

            /// Add small integer to bigint.
            #[inline( always )]
            pub fn small_add( x:&mut VecType, y:Limb ) -> Option<()> {
                small_add_from( x, y, 0 )
            }

            /// Multiply bigint by small integer.
            #[inline]
            pub fn small_mul( x:&mut VecType, y:Limb ) -> Option<()> {
                let mut carry = 0;
                for xi in x.iter_mut() {
                    let result = scalar_mul( *xi, y, carry );
                    *xi = result.0;
                    carry = result.1;
                }
                
                if carry != 0 {
                    x.try_push( carry )?;
                }
                Some( () )
            }

            /// Add bigint to bigint starting from offset.
            pub fn large_add_from( x:&mut VecType, y:&[Limb], start:usize ) -> Option<()> {
                if y.len() > x.len().saturating_sub( start ) {
                    x.try_resize( y.len() + start, 0 )?;
                }
                
                let mut carry = false;
                for ( index, &yi ) in y.iter().enumerate() {
                    let xi = x.get_mut( start + index ).unwrap();                    
                    let result = scalar_add( *xi, yi );
                    *xi = result.0;
                    let mut tmp = result.1;
                    if carry {
                        let result = scalar_add( *xi, 1 );
                        *xi = result.0;
                        tmp |= result.1;
                    }
                    carry = tmp;
                }
                
                if carry {
                    small_add_from( x, 1, y.len() + start )?;
                }
                Some( () )
            }

            /// Add bigint to bigint.
            #[inline( always )]
            pub fn large_add( x:&mut VecType, y:&[Limb] ) -> Option<()> {
                large_add_from( x, y, 0 )
            }

            /// Grade-school multiplication algorithm.
            /// In short, Karatsuba multiplication is never worthwhile for out use-case.
            pub fn long_mul( x:&[Limb], y:&[Limb] ) -> Option<VecType>
            {
                let mut z = VecType::try_from( x )?;
                if !y.is_empty() {
                    let y0 = y[0];
                    small_mul( &mut z, y0 )?;

                    for ( index, &yi ) in y.iter().enumerate().skip( 1 ) {
                        if yi != 0 {
                            let mut zi = VecType::try_from( x )?;
                            small_mul( &mut zi, yi )?;
                            large_add_from( &mut z, &zi, index )?;
                        }
                    }
                }

                z.normalize();
                Some( z )
            }

            /// Multiply bigint by bigint using grade-school multiplication algorithm.
            #[inline( always )]
            pub fn large_mul( x:&mut VecType, y:&[Limb] ) -> Option<()> {
                if y.len() == 1 {
                    small_mul( x, y[0] )?;
                } else {
                    *x = long_mul( y, x )?;
                }
                Some( () )
            }
            
            /// Shift-left `n` bits inside a buffer.
            #[inline]
            pub fn shl_bits( x:&mut VecType, n:usize ) -> Option<()>
            {
                debug_assert!( n != 0 );
                debug_assert!( n < LIMB_BITS );
                let rshift = LIMB_BITS - n;
                let lshift = n;
                let mut prev:Limb = 0;
                for xi in x.iter_mut() {
                    let tmp = *xi;
                    *xi <<= lshift;
                    *xi |= prev >> rshift;
                    prev = tmp;
                }

                // Always push the carry, even if it creates a non-normal result.
                let carry = prev >> rshift;
                if carry != 0 {
                    x.try_push( carry )?;
                }

                Some( () )
            }

            /// Shift-left `n` limbs inside a buffer.
            #[inline]
            pub fn shl_limbs( x:&mut VecType, n:usize ) -> Option<()> {
                debug_assert!( n != 0 );
                if n + x.len() > x.capacity() {
                    None
                } else if !x.is_empty() {
                    let len = n + x.len();
                    unsafe {
                        let src = x.as_ptr();
                        let dst = x.as_mut_ptr().add( n );
                        ptr::copy( src, dst, x.len() );
                        ptr::write_bytes( x.as_mut_ptr(), 0, n );
                        x.set_len( len );
                    }
                    Some( () )
                } else {
                    Some( () )
                }
            }

            /// Shift-left buffer by n bits.
            #[inline]
            pub fn shl( x:&mut VecType, n:usize ) -> Option<()> {
                let rem = n % LIMB_BITS;
                let div = n / LIMB_BITS;
                if rem != 0 {
                    shl_bits( x, rem )?;
                }
                if div != 0 {
                    shl_limbs( x, div )?;
                }
                Some( () )
            }

            /// Get number of leading zero bits in the storage.
            #[inline]
            pub fn leading_zeros( x:&[Limb] ) -> u32 {
                let length = x.len();
                if let Some( &value ) = x.get( length.wrapping_sub( 1 ) ) {
                    value.leading_zeros()
                } else {
                    0
                }
            }

            /// Calculate the bit-length of the big-integer.
            #[inline]
            pub fn bit_length( x:&[Limb] ) -> u32 {
                let nlz = leading_zeros( x );
                LIMB_BITS as u32 * x.len() as u32 - nlz
            }

            ///  Type for a single limb of the big integer.
            #[cfg( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) )]
            pub type Limb = u64;
            #[cfg( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) )]
            pub type Wide = u128;
            #[cfg( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) )]
            pub const LIMB_BITS:usize = 64;

            #[cfg( not( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) ) )]
            pub type Limb = u32;
            #[cfg( not( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) ) )]
            pub type Wide = u64;
            #[cfg( not( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) ) )]
            pub const LIMB_BITS:usize = 32;
        }

        pub mod extended
        {
            use super::num::Float;

            /// Extended precision floating-point type.
            #[derive( Clone, Copy, Debug, PartialEq, Eq )]
            pub struct ExtendedFloat 
            {
                /// Mantissa for the extended-precision float.
                pub mant:u64,
                /// Binary exponent for the extended-precision float.
                pub exp:i32,
            }

            /// Converts an `ExtendedFloat` to the closest machine float type.
            #[inline( always )] pub fn extended_to_float<F:Float>( x:ExtendedFloat ) -> F
            {
                let mut word = x.mant;
                word |= ( x.exp as u64 ) << F::MANTISSA_SIZE;
                F::from_bits( word )
            }
        }

        pub mod fpu
        {
            //! Platform-specific, assembly instructions to avoid rounding on architectures with FPUs.
            mod fpu_precision
            {
                pub fn set_precision<T>(){}
            }
        }

        pub mod heapvec
        {
            use ::
            {
                cmp::{ Ord, Ordering, PartialOrd },
                ops::{ Deref, DerefMut, MulAssign },
                parsers::float::
                {
                    bigint::{ long_mul },
                    limb::{ self, BIGINT_LIMBS, Limb, LIMB_BITS, Wide },
                    upper::{ self },
                },
                *
            };
            /// Simple heap vector implementation.
            #[derive( Clone )] pub struct HeapVec
            {
                /// The heap-allocated buffer for the elements.
                data:Vec<Limb>,
            }
            
            impl HeapVec
            {
                /// Construct an empty vector.
                pub const fn new() -> Self
                {
                    Self
                    {
                        data:Vec::with_capacity( limb::BIGINT_LIMBS ),
                    }
                }

                /// Construct a vector from an existing slice.
                #[inline] pub fn try_from( x:&[Limb] ) -> Option<Self>
                {
                    let mut vec = Self::new();
                    vec.try_extend( x )?;
                    Some( vec )
                }

                /// Sets the length of a vector.
                #[inline] pub unsafe fn set_len( &mut self, len:usize )
                {
                    unsafe
                    {
                        debug_assert!( len <= BIGINT_LIMBS );
                        self.data.set_len( len )
                    };
                }

                /// The number of elements stored in the vector.
                #[inline] pub fn len( &self ) -> usize
                { self.data.len() }

                /// If the vector is empty.
                #[inline] pub fn is_empty( &self ) -> bool
                { self.len() == 0 }

                /// The number of items the vector can hold.
                #[inline] pub fn capacity( &self ) -> usize
                { self.data.capacity() }

                /// Append an item to the vector.
                #[inline] pub fn try_push( &mut self, value:Limb ) -> Option<()>
                {
                    self.data.push( value );
                    Some( () )
                }

                /// Remove an item from the end of the vector and return it, or None if empty.
                #[inline] pub fn pop( &mut self ) -> Option<Limb>
                { self.data.pop() }

                /// Copy elements from a slice and append them to the vector.
                #[inline] pub fn try_extend( &mut self, slc:&[Limb] ) -> Option<()>
                {
                    self.data.extend_from_slice( slc );
                    Some( () )
                }

                /// Try to resize the buffer.
                #[inline] pub fn try_resize( &mut self, len:usize, value:Limb ) -> Option<()>
                {
                    self.data.resize( len, value );
                    Some( () )
                }

                /// Get the high 64 bits from the vector.
                #[inline( always )] pub fn hi64( &self ) -> ( u64, bool )
                { upper::upper( &self.data ) }
                
                /// Create StackVec from u64 value.
                #[inline( always )] pub fn from_u64( x:u64 ) -> Self
                { from_u64( x ) }
                
                /// Normalize the integer, so any leading zero values are removed.
                #[inline] pub fn normalize( &mut self )
                { normalize( self ) }
                /// Get if the big integer is normalized.
                #[inline] pub fn is_normalized( &self ) -> bool
                { is_normalized( self ) }
                /// AddAssign small integer.
                #[inline] pub fn add_small( &mut self, y:Limb ) -> Option<()>
                { small_add( self, y ) }
                /// MulAssign small integer.
                #[inline]
                pub fn mul_small( &mut self, y:Limb ) -> Option<()>
                { small_mul( self, y ) }
            }

            impl Eq for HeapVec {}
            
            impl PartialEq for HeapVec
            {
                #[inline] fn eq( &self, other:&Self ) -> bool
                {
                    self.len() == other.len() && self.deref() == other.deref()
                }
            }

            impl PartialOrd for HeapVec
            {
                #[inline] fn partial_cmp( &self, other:&Self ) -> Option<cmp::Ordering>
                { Some( compare( self, other ) ) }
            }

            impl Ord for HeapVec
            {
                #[inline] fn cmp( &self, other:&Self ) -> cmp::Ordering
                { compare( self, other ) }
            }

            impl Deref for HeapVec
            {
                type Target = [ Limb ];
                #[inline] fn deref( &self ) -> &[ Limb ]
                { &self.data }
            }

            impl DerefMut for HeapVec
            {
                #[inline] fn deref_mut( &mut self ) -> &mut [ Limb ]
                { &mut self.data }
            }

            impl MulAssign<&[ Limb ]> for HeapVec
            {
                #[inline] fn mul_assign( &mut self, rhs:&[ Limb ] )
                { large_mul( self, rhs ).unwrap(); }
            }
            /// Compare `x` to `y`, in little-endian order.
            #[inline] pub fn compare( x:&[Limb], y:&[Limb] ) -> cmp::Ordering
            {
                match x.len().cmp( &y.len() )
                {
                    Ordering::Equal =>
                    {
                        let iter = x.iter().rev().zip( y.iter().rev() );
                        for ( &xi, yi ) in iter
                        {
                            match xi.cmp( yi )
                            {
                                Ordering::Equal => (),
                                ord => return ord,
                            }
                        }
                        
                        Ordering::Equal
                    },
                    ord => ord,
                }
            }
            /// Create StackVec from u64 value.
            #[inline( always )] pub fn from_u64( x:u64 ) -> HeapVec
            {
                let mut vec = HeapVec::new();
                debug_assert!( vec.capacity() >= 2 );
                if LIMB_BITS == 32
                {
                    vec.try_push( x as Limb ).unwrap();
                    vec.try_push( ( x >> 32 ) as Limb ).unwrap();
                } 
                else { vec.try_push( x as Limb ).unwrap(); }
                vec.normalize();
                vec
            }
            /// Normalize the integer, so any leading zero values are removed.
            #[inline] pub fn normalize( x:&mut HeapVec )
            {
                unsafe
                {
                    while let Some( &value ) = x.get( x.len().wrapping_sub( 1 ) )
                    {
                        if value == 0 { x.set_len( x.len() - 1 ); } 
                        else { break; }
                    }
                }
            }
            /// Get if the big integer is normalized.
            #[inline] pub fn is_normalized( x:&[Limb] ) -> bool
            {
                match x.get( x.len().wrapping_sub( 1 ) )
                {
                    Some( &0 ) => false,
                    _ => true,
                }
            }
            /// Add small integer to bigint starting from offset.
            #[inline] pub fn small_add_from( x:&mut HeapVec, y:Limb, start:usize ) -> Option<()>
            {
                let mut index = start;
                let mut carry = y;
                while carry != 0 && index < x.len()
                {
                    let result = scalar_add( x[index], carry );
                    x[index] = result.0;
                    carry = result.1 as Limb;
                    index += 1;
                }
                if carry != 0 { x.try_push( carry )?; }
                Some( () )
            }
            /// Add small integer to bigint.
            #[inline( always )] pub fn small_add( x:&mut HeapVec, y:Limb ) -> Option<()>
            { small_add_from( x, y, 0 ) }
            /// Multiply bigint by small integer.
            #[inline] pub fn small_mul( x:&mut HeapVec, y:Limb ) -> Option<()>
            {
                let mut carry = 0;
                for xi in x.iter_mut()
                {
                    let result = scalar_mul( *xi, y, carry );
                    *xi = result.0;
                    carry = result.1;
                }                
                if carry != 0 { x.try_push( carry )?; }
                Some( () )
            }
            /// Multiply bigint by bigint using grade-school multiplication algorithm.
            #[inline( always )] pub fn large_mul( x:&mut HeapVec, y:&[Limb] ) -> Option<()>
            {
                if y.len() == 1 { small_mul( x, y[0] )?; }
                else
                { *x = long_mul( y, x )?; }
                Some( () )
            }
            /// Add two small integers and return the resulting value and if overflow happens.
            #[inline( always )] pub fn scalar_add( x:Limb, y:Limb ) -> ( Limb, bool )
            { x.overflowing_add( y ) }

            /// Multiply two small integers ( with carry ) ( and return the overflow contribution ).
            #[inline( always )] pub fn scalar_mul( x:Limb, y:Limb, carry:Limb ) -> ( Limb, Limb )
            {
                let z:Wide = ( x as Wide ) * ( y as Wide ) + ( carry as Wide );
                ( z as Limb, ( z >> LIMB_BITS ) as Limb )
            }            
        }

        pub mod libm
        {
            //! A small number of math routines for floats and doubles.
            macro_rules! i 
            {
                ( $array:ident, $index:expr ) => 
                {
                    unsafe { *$array.get_unchecked( $index ) }
                };
            }

            pub fn powf( x:f32, y:f32 ) -> f32 
            {
                const BP:[f32; 2] = [1.0, 1.5];
                const DP_H:[f32; 2] = [0.0, 5.84960938e-01];
                const DP_L:[f32; 2] = [0.0, 1.56322085e-06];
                const TWO24:f32 = 16777216.0;
                const HUGE:f32 = 1.0e30;
                const TINY:f32 = 1.0e-30;
                const L1:f32 = 6.0000002384e-01;
                const L2:f32 = 4.2857143283e-01;
                const L3:f32 = 3.3333334327e-01;
                const L4:f32 = 2.7272811532e-01;
                const L5:f32 = 2.3066075146e-01;
                const L6:f32 = 2.0697501302e-01;
                const P1:f32 = 1.6666667163e-01;
                const P2:f32 = -2.7777778450e-03;
                const P3:f32 = 6.6137559770e-05;
                const P4:f32 = -1.6533901999e-06;
                const P5:f32 = 4.1381369442e-08;
                const LG2:f32 = 6.9314718246e-01;
                const LG2_H:f32 = 6.93145752e-01;
                const LG2_L:f32 = 1.42860654e-06;
                const OVT:f32 = 4.2995665694e-08;
                const CP:f32 = 9.6179670095e-01;
                const CP_H:f32 = 9.6191406250e-01;
                const CP_L:f32 = -1.1736857402e-04;
                const IVLN2:f32 = 1.4426950216e+00;
                const IVLN2_H:f32 = 1.4426879883e+00;
                const IVLN2_L:f32 = 7.0526075433e-06;

                let mut z:f32;
                let mut ax:f32;
                let z_h:f32;
                let z_l:f32;
                let mut p_h:f32;
                let mut p_l:f32;
                let y1:f32;
                let mut t1:f32;
                let t2:f32;
                let mut r:f32;
                let s:f32;
                let mut sn:f32;
                let mut t:f32;
                let mut u:f32;
                let mut v:f32;
                let mut w:f32;
                let i:i32;
                let mut j:i32;
                let mut k:i32;
                let mut yisint:i32;
                let mut n:i32;
                let hx:i32;
                let hy:i32;
                let mut ix:i32;
                let iy:i32;
                let mut is:i32;

                hx = x.to_bits() as i32;
                hy = y.to_bits() as i32;
                ix = hx & 0x7fffffff;
                iy = hy & 0x7fffffff;
                
                if iy == 0 {
                    return 1.0;
                }
                
                if hx == 0x3f800000 {
                    return 1.0;
                }
                
                if ix > 0x7f800000 || iy > 0x7f800000 {
                    return x + y;
                }
                
                yisint = 0;
                if hx < 0 {
                    if iy >= 0x4b800000 {
                        yisint = 2;
                    } else if iy >= 0x3f800000 {
                        k = ( iy >> 23 ) - 0x7f;
                        j = iy >> ( 23 - k );
                        if ( j << ( 23 - k ) ) == iy {
                            yisint = 2 - ( j & 1 );
                        }
                    }
                }

                if iy == 0x7f800000 {
                    if ix == 0x3f800000 {
                        return 1.0;
                    } else if ix > 0x3f800000 {
                        return if hy >= 0 {
                            y
                        } else {
                            0.0
                        };
                    } else {
                        return if hy >= 0 {
                            0.0
                        } else {
                            -y
                        };
                    }
                }

                if iy == 0x3f800000
                {
                    return if hy >= 0 { x } 
                    else { 1.0 / x };
                }

                if hy == 0x40000000 { return x * x; }

                if hy == 0x3f000000 && hx >= 0 { return sqrtf( x ); }

                ax = fabsf( x );
                if ix == 0x7f800000 || ix == 0 || ix == 0x3f800000
                {
                    z = ax;
                    if hy < 0 { z = 1.0 / z; }
                    if hx < 0
                    {
                        if ( ( ix - 0x3f800000 ) | yisint ) == 0 { z = ( z - z ) / ( z - z ); }
                        else if yisint == 1 { z = -z; }
                    }
                    return z;
                }

                sn = 1.0;
                if hx < 0 {
                    if yisint == 0 {
                        return ( x - x ) / ( x - x );
                    }

                    if yisint == 1 {
                        sn = -1.0;
                    }
                }                

                if iy > 0x4d000000 {
                    if ix < 0x3f7ffff8 {
                        return if hy < 0 {
                            sn * HUGE * HUGE
                        } else {
                            sn * TINY * TINY
                        };
                    }

                    if ix > 0x3f800007
                    {
                        return if hy > 0
                        { sn * HUGE * HUGE } 
                        else 
                        { sn * TINY * TINY };
                    }
                    
                    t = ax - 1.;
                    w = ( t * t ) * ( 0.5 - t * ( 0.333333333333 - t * 0.25 ) );
                    u = IVLN2_H * t;
                    v = t * IVLN2_L - w * IVLN2;
                    t1 = u + v;
                    is = t1.to_bits() as i32;
                    t1 = f32::from_bits( is as u32 & 0xfffff000 );
                    t2 = v - ( t1 - u );
                } else {
                    let mut s2:f32;
                    let mut s_h:f32;
                    let s_l:f32;
                    let mut t_h:f32;
                    let mut t_l:f32;
                    n = 0;
                    if ix < 0x00800000 {
                        ax *= TWO24;
                        n -= 24;
                        ix = ax.to_bits() as i32;
                    }
                    n += ( ( ix ) >> 23 ) - 0x7f;
                    j = ix & 0x007fffff;
                    ix = j | 0x3f800000;
                    if j <= 0x1cc471 {
                        k = 0;
                    } else if j < 0x5db3d7 {
                        k = 1;
                    } else {
                        k = 0;
                        n += 1;
                        ix -= 0x00800000;
                    }
                    ax = f32::from_bits( ix as u32 );
                    u = ax - i!( BP, k as usize );
                    v = 1.0 / ( ax + i!( BP, k as usize ) );
                    s = u * v;
                    s_h = s;
                    is = s_h.to_bits() as i32;
                    s_h = f32::from_bits( is as u32 & 0xfffff000 );
                    is = ( ( ( ix as u32 >> 1 ) & 0xfffff000 ) | 0x20000000 ) as i32;
                    t_h = f32::from_bits( is as u32 + 0x00400000 + ( ( k as u32 ) << 21 ) );
                    t_l = ax - ( t_h - i!( BP, k as usize ) );
                    s_l = v * ( ( u - s_h * t_h ) - s_h * t_l );
                    s2 = s * s;
                    r = s2 * s2 * ( L1 + s2 * ( L2 + s2 * ( L3 + s2 * ( L4 + s2 * ( L5 + s2 * L6 ) ) ) ) );
                    r += s_l * ( s_h + s );
                    s2 = s_h * s_h;
                    t_h = 3.0 + s2 + r;
                    is = t_h.to_bits() as i32;
                    t_h = f32::from_bits( is as u32 & 0xfffff000 );
                    t_l = r - ( ( t_h - 3.0 ) - s2 );
                    u = s_h * t_h;
                    v = s_l * t_h + t_l * s;
                    p_h = u + v;
                    is = p_h.to_bits() as i32;
                    p_h = f32::from_bits( is as u32 & 0xfffff000 );
                    p_l = v - ( p_h - u );
                    z_h = CP_H * p_h;
                    z_l = CP_L * p_h + p_l * CP + i!( DP_L, k as usize );
                    t = n as f32;
                    t1 = ( ( z_h + z_l ) + i!( DP_H, k as usize ) ) + t;
                    is = t1.to_bits() as i32;
                    t1 = f32::from_bits( is as u32 & 0xfffff000 );
                    t2 = z_l - ( ( ( t1 - t ) - i!( DP_H, k as usize ) ) - z_h );
                };

                is = y.to_bits() as i32;
                y1 = f32::from_bits( is as u32 & 0xfffff000 );
                p_l = ( y - y1 ) * t1 + y * t2;
                p_h = y1 * t1;
                z = p_l + p_h;
                j = z.to_bits() as i32;
                if j > 0x43000000 {
                    return sn * HUGE * HUGE;
                } else if j == 0x43000000 {
                    if p_l + OVT > z - p_h {
                        return sn * HUGE * HUGE;
                    }
                } else if ( j & 0x7fffffff ) > 0x43160000 {
                    return sn * TINY * TINY; 
                } else if j as u32 == 0xc3160000
                        && p_l <= z - p_h
                {
                    return sn * TINY * TINY;
                }
                
                i = j & 0x7fffffff;
                k = ( i >> 23 ) - 0x7f;
                n = 0;
                if i > 0x3f000000 {
                    n = j + ( 0x00800000 >> ( k + 1 ) );
                    k = ( ( n & 0x7fffffff ) >> 23 ) - 0x7f;
                    t = f32::from_bits( n as u32 & !( 0x007fffff >> k ) );
                    n = ( ( n & 0x007fffff ) | 0x00800000 ) >> ( 23 - k );
                    if j < 0 {
                        n = -n;
                    }
                    p_h -= t;
                }
                t = p_l + p_h;
                is = t.to_bits() as i32;
                t = f32::from_bits( is as u32 & 0xffff8000 );
                u = t * LG2_H;
                v = ( p_l - ( t - p_h ) ) * LG2 + t * LG2_L;
                z = u + v;
                w = v - ( z - u );
                t = z * z;
                t1 = z - t * ( P1 + t * ( P2 + t * ( P3 + t * ( P4 + t * P5 ) ) ) );
                r = ( z * t1 ) / ( t1 - 2.0 ) - ( w + z * w );
                z = 1.0 - ( r - z );
                j = z.to_bits() as i32;
                j += n << 23;
                if ( j >> 23 ) <= 0 {
                    z = scalbnf( z, n );
                } else {
                    z = f32::from_bits( j as u32 );
                }
                sn * z
            }
            
            pub fn sqrtf( x:f32 ) -> f32
            {
                unsafe
                {
                    use ::arch::x86_64::*;
                    let m = _mm_set_ss( x );
                    let m_sqrt = _mm_sqrt_ss( m );
                    _mm_cvtss_f32( m_sqrt )
                }
            }
            
            pub fn fabsf( x:f32 ) -> f32 
            { f32::from_bits( x.to_bits() & 0x7fffffff ) }

            pub fn scalbnf( mut x:f32, mut n:i32 ) -> f32
            {
                let x1p127 = f32::from_bits( 0x7f000000 );
                let x1p_126 = f32::from_bits( 0x800000 );
                let x1p24 = f32::from_bits( 0x4b800000 );

                if n > 127
                {
                    x *= x1p127;
                    n -= 127;
                    if n > 127 {
                        x *= x1p127;
                        n -= 127;
                        if n > 127 {
                            n = 127;
                        }
                    }
                }
                else if n < -126
                {
                    x *= x1p_126 * x1p24;
                    n += 126 - 24;
                    if n < -126 {
                        x *= x1p_126 * x1p24;
                        n += 126 - 24;
                        if n < -126 {
                            n = -126;
                        }
                    }
                }
                x * f32::from_bits( ( ( 0x7f + n ) as u32 ) << 23 )
            }

            pub fn powd( x:f64, y:f64 ) -> f64 
            {
                const BP:[f64; 2] = [1.0, 1.5];
                const DP_H:[f64; 2] = [0.0, 5.84962487220764160156e-01];
                const DP_L:[f64; 2] = [0.0, 1.35003920212974897128e-08];
                const TWO53:f64 = 9007199254740992.0;
                const HUGE:f64 = 1.0e300;
                const TINY:f64 = 1.0e-300;
                
                const L1:f64 = 5.99999999999994648725e-01;
                const L2:f64 = 4.28571428578550184252e-01;
                const L3:f64 = 3.33333329818377432918e-01;
                const L4:f64 = 2.72728123808534006489e-01;
                const L5:f64 = 2.30660745775561754067e-01;
                const L6:f64 = 2.06975017800338417784e-01;
                const P1:f64 = 1.66666666666666019037e-01;
                const P2:f64 = -2.77777777770155933842e-03;
                const P3:f64 = 6.61375632143793436117e-05;
                const P4:f64 = -1.65339022054652515390e-06;
                const P5:f64 = 4.13813679705723846039e-08;
                const LG2:f64 = 6.93147180559945286227e-01;
                const LG2_H:f64 = 6.93147182464599609375e-01;
                const LG2_L:f64 = -1.90465429995776804525e-09;
                const OVT:f64 = 8.0085662595372944372e-017;
                const CP:f64 = 9.61796693925975554329e-01;
                const CP_H:f64 = 9.61796700954437255859e-01;
                const CP_L:f64 = -7.02846165095275826516e-09;
                const IVLN2:f64 = 1.44269504088896338700e+00;
                const IVLN2_H:f64 = 1.44269502162933349609e+00;
                const IVLN2_L:f64 = 1.92596299112661746887e-08;

                let t1:f64;
                let t2:f64;
                let ( hx, lx ):( i32, u32 ) = ( ( x.to_bits() >> 32 ) as i32, x.to_bits() as u32 );
                let ( hy, ly ):( i32, u32 ) = ( ( y.to_bits() >> 32 ) as i32, y.to_bits() as u32 );
                let mut ix:i32 = ( hx & 0x7fffffff ) as i32;
                let iy:i32 = ( hy & 0x7fffffff ) as i32;
                if ( ( iy as u32 ) | ly ) == 0 { return 1.0; }
                if hx == 0x3ff00000 && lx == 0 { return 1.0; }
                if ix > 0x7ff00000
                || ( ix == 0x7ff00000 && lx != 0 )
                || iy > 0x7ff00000
                || ( iy == 0x7ff00000 && ly != 0 )
                { return x + y; }
                
                let mut yisint:i32 = 0;
                let mut k:i32;
                let mut j:i32;
                if hx < 0
                {
                    if iy >= 0x43400000 { yisint = 2; } 
                    else if iy >= 0x3ff00000 
                    {
                        k = ( iy >> 20 ) - 0x3ff;
                        if k > 20
                        {
                            j = ( ly >> ( 52 - k ) ) as i32;

                            if ( j << ( 52 - k ) ) == ( ly as i32 ) {
                                yisint = 2 - ( j & 1 );
                            }
                        }
                        
                        else if ly == 0
                        {
                            j = iy >> ( 20 - k );

                            if ( j << ( 20 - k ) ) == iy {
                                yisint = 2 - ( j & 1 );
                            }
                        }
                    }
                }

                if ly == 0
                {
                    if iy == 0x7ff00000
                    {
                        return if ( ( ix - 0x3ff00000 ) | ( lx as i32 ) ) == 0 { 1.0 } 
                        else if ix >= 0x3ff00000
                        {
                            if hy >= 0 { y }  else { 0.0 }
                        } 
                        else
                        {
                            if hy >= 0 { 0.0 } else { -y }
                        };
                    }

                    if iy == 0x3ff00000
                    {
                        return if hy >= 0 { x } else { 1.0 / x };
                    }

                    if hy == 0x40000000 
                    { return x * x; }

                    if hy == 0x3fe00000
                    {
                        if hx >= 0 { return sqrtd( x ); }
                    }
                }

                let mut ax:f64 = fabsd( x );
                if lx == 0
                {
                    if ix == 0x7ff00000 || ix == 0 || ix == 0x3ff00000 
                    {
                        let mut z:f64 = ax;
                        if hy < 0 { z = 1.0 / z; }
                        if hx < 0 
                        {
                            if ( ( ix - 0x3ff00000 ) | yisint ) == 0 { z = ( z - z ) / ( z - z ); } else if yisint == 1 { z = -z; }
                        }
                        return z;
                    }
                }

                let mut s:f64 = 1.0;
                if hx < 0 
                {
                    if yisint == 0  { return ( x - x ) / ( x - x ); }
                    if yisint == 1 { s = -1.0; }
                }
                
                if iy > 0x41e00000
                {
                    
                    if iy > 0x43f00000 
                    {
                        if ix <= 0x3fefffff
                        { return if hy < 0 { HUGE * HUGE } else { TINY * TINY }; }

                        if ix >= 0x3ff00000
                        { return if hy > 0 { HUGE * HUGE } else { TINY * TINY }; }
                    }
                    
                    if ix < 0x3fefffff
                    { return if hy < 0 { s * HUGE * HUGE } else { s * TINY * TINY }; }

                    if ix > 0x3ff00000
                    { return if hy > 0 { s * HUGE * HUGE } else { s * TINY * TINY }; }
                    
                    let t:f64 = ax - 1.0;
                    let w:f64 = ( t * t ) * ( 0.5 - t * ( 0.3333333333333333333333 - t * 0.25 ) );
                    let u:f64 = IVLN2_H * t;
                    let v:f64 = t * IVLN2_L - w * IVLN2;
                    t1 = with_set_low_word( u + v, 0 );
                    t2 = v - ( t1 - u );
                }
                
                else
                {
                    let mut n:i32 = 0;

                    if ix < 0x00100000 {
                        ax *= TWO53;
                        n -= 53;
                        ix = get_high_word( ax ) as i32;
                    }

                    n += ( ix >> 20 ) - 0x3ff;
                    j = ix & 0x000fffff;
                    
                    let k:i32;
                    ix = j | 0x3ff00000;
                    if j <= 0x3988E {
                        k = 0;
                    } else if j < 0xBB67A {
                        k = 1;
                    } else {
                        k = 0;
                        n += 1;
                        ix -= 0x00100000;
                    }

                    ax = with_set_high_word( ax, ix as u32 );                    
                    let u:f64 = ax - i!( BP, k as usize );
                    let v:f64 = 1.0 / ( ax + i!( BP, k as usize ) );
                    let ss:f64 = u * v;
                    let s_h = with_set_low_word( ss, 0 );                    
                    let t_h:f64 = with_set_high_word( 0.0, ( ( ix as u32 >> 1 ) | 0x20000000 ) + 0x00080000 + ( ( k as u32 ) << 18 ), );
                    let t_l:f64 = ax - ( t_h - i!( BP, k as usize ) );
                    let s_l:f64 = v * ( ( u - s_h * t_h ) - s_h * t_l );                    
                    let s2:f64 = ss * ss;
                    let mut r:f64 = s2 * s2 * ( L1 + s2 * ( L2 + s2 * ( L3 + s2 * ( L4 + s2 * ( L5 + s2 * L6 ) ) ) ) );
                    r += s_l * ( s_h + ss );
                    let s2:f64 = s_h * s_h;
                    let t_h:f64 = with_set_low_word( 3.0 + s2 + r, 0 );
                    let t_l:f64 = r - ( ( t_h - 3.0 ) - s2 );                    
                    let u:f64 = s_h * t_h;
                    let v:f64 = s_l * t_h + t_l * ss;                    
                    let p_h:f64 = with_set_low_word( u + v, 0 );
                    let p_l = v - ( p_h - u );
                    let z_h:f64 = CP_H * p_h;
                    let z_l:f64 = CP_L * p_h + p_l * CP + i!( DP_L, k as usize );                    
                    let t:f64 = n as f64;
                    t1 = with_set_low_word( ( ( z_h + z_l ) + i!( DP_H, k as usize ) ) + t, 0 );
                    t2 = z_l - ( ( ( t1 - t ) - i!( DP_H, k as usize ) ) - z_h );
                }
                
                let y1:f64 = with_set_low_word( y, 0 );
                let p_l:f64 = ( y - y1 ) * t1 + y * t2;
                let mut p_h:f64 = y1 * t1;
                let z:f64 = p_l + p_h;
                let mut j:i32 = ( z.to_bits() >> 32 ) as i32;
                let i:i32 = z.to_bits() as i32;

                if j >= 0x40900000
                {
                    if ( j - 0x40900000 ) | i != 0 { return s * HUGE * HUGE; }
                    if p_l + OVT > z - p_h { return s * HUGE * HUGE; }
                }
                
                else if ( j & 0x7fffffff ) >= 0x4090cc00
                {
                    if ( ( ( j as u32 ) - 0xc090cc00 ) | ( i as u32 ) ) != 0 { return s * TINY * TINY; }
                    if p_l <= z - p_h { return s * TINY * TINY; }
                }
                
                let i:i32 = j & ( 0x7fffffff as i32 );
                k = ( i >> 20 ) - 0x3ff;
                let mut n:i32 = 0;

                if i > 0x3fe00000
                {
                    n = j + ( 0x00100000 >> ( k + 1 ) );
                    k = ( ( n & 0x7fffffff ) >> 20 ) - 0x3ff;
                    let t:f64 = with_set_high_word( 0.0, ( n & !( 0x000fffff >> k ) ) as u32 );
                    n = ( ( n & 0x000fffff ) | 0x00100000 ) >> ( 20 - k );
                    if j < 0 { n = -n; }
                    p_h -= t;
                }

                let t:f64 = with_set_low_word( p_l + p_h, 0 );
                let u:f64 = t * LG2_H;
                let v:f64 = ( p_l - ( t - p_h ) ) * LG2 + t * LG2_L;
                let mut z:f64 = u + v;
                let w:f64 = v - ( z - u );
                let t:f64 = z * z;
                let t1:f64 = z - t * ( P1 + t * ( P2 + t * ( P3 + t * ( P4 + t * P5 ) ) ) );
                let r:f64 = ( z * t1 ) / ( t1 - 2.0 ) - ( w + z * w );
                z = 1.0 - ( r - z );
                j = get_high_word( z ) as i32;
                j += n << 20;

                if ( j >> 20 ) <= 0 { z = scalbnd( z, n ); } 
                else { z = with_set_high_word( z, j as u32 ); }
                s * z
            }

            /// Absolute value ( magnitude ) ( f64 )
            pub fn fabsd( x:f64 ) -> f64 
            { f64::from_bits( x.to_bits() & ( u64::MAX / 2 ) ) }

            pub fn scalbnd( x:f64, mut n:i32 ) -> f64
            {
                let x1p1023 = f64::from_bits( 0x7fe0000000000000 );
                let x1p53 = f64::from_bits( 0x4340000000000000 );
                let x1p_1022 = f64::from_bits( 0x0010000000000000 );
                let mut y = x;

                if n > 1023
                {
                    y *= x1p1023;
                    n -= 1023;
                    if n > 1023
                    {
                        y *= x1p1023;
                        n -= 1023;
                        if n > 1023 { n = 1023; }
                    }
                }
                else if n < -1022
                {
                    y *= x1p_1022 * x1p53;
                    n += 1022 - 53;
                    if n < -1022
                    {
                        y *= x1p_1022 * x1p53;
                        n += 1022 - 53;
                        if n < -1022 { n = -1022; }
                    }
                }
                y * f64::from_bits( ( ( 0x3ff + n ) as u64 ) << 52 )
            }

            pub fn sqrtd( x:f64 ) -> f64 
            {
                unsafe 
                {
                    use ::arch::x86_64::*;
                    let m = _mm_set_sd( x );
                    let m_sqrt = _mm_sqrt_pd( m );
                    _mm_cvtsd_f64( m_sqrt )
                }
            }

            #[inline] fn get_high_word( x:f64 ) -> u32
            { ( x.to_bits() >> 32 ) as u32 }

            #[inline] fn with_set_high_word( f:f64, hi:u32 ) -> f64
            {
                let mut tmp = f.to_bits();
                tmp &= 0x00000000_ffffffff;
                tmp |= ( hi as u64 ) << 32;
                f64::from_bits( tmp )
            }

            #[inline] fn with_set_low_word( f:f64, lo:u32 ) -> f64
            {
                let mut tmp = f.to_bits();
                tmp &= 0xffffffff_00000000;
                tmp |= lo as u64;
                f64::from_bits( tmp )
            }
        }

        pub mod limb
        {
            /// Number of bits in a Bigint.
            pub const BIGINT_BITS:usize = 4000;

            /// The number of limbs for the bigint.
            pub const BIGINT_LIMBS:usize = BIGINT_BITS / LIMB_BITS;

            #[cfg( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) )]
            pub type Limb = u64;
            #[cfg( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) )]
            pub type Wide = u128;
            #[cfg( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) )]
            pub const LIMB_BITS:usize = 64;

            #[cfg( not( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) ) )]
            pub type Limb = u32;
            #[cfg( not( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) ) )]
            pub type Wide = u64;
            #[cfg( not( all( target_pointer_width = "64", not( target_arch = "sparc" ) ) ) )]
            pub const LIMB_BITS:usize = 32;
        }
        
        pub mod mask
        {
            //! Utilities to generate bitmasks.

            /// Generate a bitwise mask for the lower `n` bits.
            #[inline] pub fn lower_n_mask( n:u64 ) -> u64
            {
                debug_assert!( n <= 64, "lower_n_mask() overflow in shl." );
                match n == 64
                {
                    true => 0xffff_ffff_ffff_ffff,
                    false => ( 1 << n ) - 1,
                }
            }

            /// Calculate the halfway point for the lower `n` bits.
            #[inline] pub fn lower_n_halfway( n:u64 ) -> u64
            {
                debug_assert!( n <= 64, "lower_n_halfway() overflow in shl." );
                match n == 0
                {
                    true => 0,
                    false => nth_bit( n - 1 ),
                }
            }

            /// Calculate a scalar factor of 2 above the halfway point.
            #[inline] pub fn nth_bit( n:u64 ) -> u64
            {
                debug_assert!( n < 64, "nth_bit() overflow in shl." );
                1 << n
            }
        }

        pub mod num
        {
            use ::
            {
                *,
            };

            /// Generic floating-point type, to be used in generic code for parsing.
            pub trait Float:
            Sized
            + Copy
            + PartialEq
            + PartialOrd
            + Send
            + Sync
            + ops::Add<Output = Self>
            + ops::AddAssign
            + ops::Div<Output = Self>
            + ops::DivAssign
            + ops::Mul<Output = Self>
            + ops::MulAssign
            + ops::Rem<Output = Self>
            + ops::RemAssign
            + ops::Sub<Output = Self>
            + ops::SubAssign
            + ops::Neg<Output = Self>
            {
                /// Maximum number of digits that can contribute in the mantissa.
                const MAX_DIGITS:usize;
                /// Bitmask for the sign bit.
                const SIGN_MASK:u64;
                /// Bitmask for the exponent, including the hidden bit.
                const EXPONENT_MASK:u64;
                /// Bitmask for the hidden bit in exponent, which is an implicit 1 in the fraction.
                const HIDDEN_BIT_MASK:u64;
                /// Bitmask for the mantissa ( fraction ), excluding the hidden bit.
                const MANTISSA_MASK:u64;
                /// Size of the significand ( mantissa ) without hidden bit.
                const MANTISSA_SIZE:i32;
                /// Bias of the exponet
                const EXPONENT_BIAS:i32;
                /// Exponent portion of a denormal float.
                const DENORMAL_EXPONENT:i32;
                /// Maximum exponent value in float.
                const MAX_EXPONENT:i32;
                /// Mask to determine if a full-carry occurred ( 1 in bit above hidden bit ).
                const CARRY_MASK:u64;
                /// Bias for marking an invalid extended float.
                const INVALID_FP:i32 = -0x8000;
                // Maximum mantissa for the fast-path ( `1 << 53` for f64 ).
                const MAX_MANTISSA_FAST_PATH:u64 = 2_u64 << Self::MANTISSA_SIZE;
                // Largest exponent value `( 1 << EXP_BITS ) - 1`.
                const INFINITE_POWER:i32 = Self::MAX_EXPONENT + Self::EXPONENT_BIAS;
                const MIN_EXPONENT_ROUND_TO_EVEN:i32;
                const MAX_EXPONENT_ROUND_TO_EVEN:i32;
                /// Minimum normal exponent value `-( 1 << ( EXPONENT_SIZE - 1 ) ) + 1`.
                const MINIMUM_EXPONENT:i32;
                /// Smallest decimal exponent for a non-zero value.
                const SMALLEST_POWER_OF_TEN:i32;
                /// Largest decimal exponent for a non-infinite value.
                const LARGEST_POWER_OF_TEN:i32;
                /// Minimum exponent that for a fast path case, or `-⌊( MANTISSA_SIZE+1 )/log2( 10 )⌋`
                const MIN_EXPONENT_FAST_PATH:i32;
                /// Maximum exponent that for a fast path case, or `⌊( MANTISSA_SIZE+1 )/log2( 5 )⌋`
                const MAX_EXPONENT_FAST_PATH:i32;
                /// Maximum exponent that can be represented for a disguised-fast path case.
                const MAX_EXPONENT_DISGUISED_FAST_PATH:i32;
                /// Convert 64-bit integer to float.
                fn from_u64( u:u64 ) -> Self;
                fn from_bits( u:u64 ) -> Self;
                fn to_bits( self ) -> u64;

                /// Get a small power-of-radix for fast-path multiplication.
                unsafe fn pow_fast_path( exponent:usize ) -> Self;

                /// Returns true if the float is a denormal.
                #[inline] fn is_denormal( self ) -> bool { self.to_bits() & Self::EXPONENT_MASK == 0 }

                /// Get exponent component from the float.
                #[inline] fn exponent( self ) -> i32
                {
                    if self.is_denormal() { return Self::DENORMAL_EXPONENT; }
                    let bits = self.to_bits();
                    let biased_e:i32 = ( ( bits & Self::EXPONENT_MASK ) >> Self::MANTISSA_SIZE ) as i32;
                    biased_e - Self::EXPONENT_BIAS
                }

                /// Get mantissa ( significand ) component from float.
                #[inline] fn mantissa( self ) -> u64
                {
                    let bits = self.to_bits();
                    let s = bits & Self::MANTISSA_MASK;
                    if !self.is_denormal(){ s + Self::HIDDEN_BIT_MASK } 
                    else { s }
                }
            }

            impl Float for f32
            {
                const MAX_DIGITS:usize = 114;
                const SIGN_MASK:u64 = 0x80000000;
                const EXPONENT_MASK:u64 = 0x7F800000;
                const HIDDEN_BIT_MASK:u64 = 0x00800000;
                const MANTISSA_MASK:u64 = 0x007FFFFF;
                const MANTISSA_SIZE:i32 = 23;
                const EXPONENT_BIAS:i32 = 127 + Self::MANTISSA_SIZE;
                const DENORMAL_EXPONENT:i32 = 1 - Self::EXPONENT_BIAS;
                const MAX_EXPONENT:i32 = 0xFF - Self::EXPONENT_BIAS;
                const CARRY_MASK:u64 = 0x1000000;
                const MIN_EXPONENT_ROUND_TO_EVEN:i32 = -17;
                const MAX_EXPONENT_ROUND_TO_EVEN:i32 = 10;
                const MINIMUM_EXPONENT:i32 = -127;
                const SMALLEST_POWER_OF_TEN:i32 = -65;
                const LARGEST_POWER_OF_TEN:i32 = 38;
                const MIN_EXPONENT_FAST_PATH:i32 = -10;
                const MAX_EXPONENT_FAST_PATH:i32 = 10;
                const MAX_EXPONENT_DISGUISED_FAST_PATH:i32 = 17;

                #[inline( always )] unsafe fn pow_fast_path( exponent:usize ) -> Self
                { return powf( 10.0f32, exponent as f32 ); }

                #[inline] fn from_u64( u:u64 ) -> f32 { u as _ }

                #[inline] fn from_bits( u:u64 ) -> f32
                {
                    debug_assert!( u <= 0xffff_ffff );
                    f32::from_bits( u as u32 )
                }

                #[inline] fn to_bits( self ) -> u64 { f32::to_bits( self ) as u64 }
            }

            impl Float for f64
            {
                const MAX_DIGITS:usize = 769;
                const SIGN_MASK:u64 = 0x8000000000000000;
                const EXPONENT_MASK:u64 = 0x7FF0000000000000;
                const HIDDEN_BIT_MASK:u64 = 0x0010000000000000;
                const MANTISSA_MASK:u64 = 0x000FFFFFFFFFFFFF;
                const MANTISSA_SIZE:i32 = 52;
                const EXPONENT_BIAS:i32 = 1023 + Self::MANTISSA_SIZE;
                const DENORMAL_EXPONENT:i32 = 1 - Self::EXPONENT_BIAS;
                const MAX_EXPONENT:i32 = 0x7FF - Self::EXPONENT_BIAS;
                const CARRY_MASK:u64 = 0x20000000000000;
                const MIN_EXPONENT_ROUND_TO_EVEN:i32 = -4;
                const MAX_EXPONENT_ROUND_TO_EVEN:i32 = 23;
                const MINIMUM_EXPONENT:i32 = -1023;
                const SMALLEST_POWER_OF_TEN:i32 = -342;
                const LARGEST_POWER_OF_TEN:i32 = 308;
                const MIN_EXPONENT_FAST_PATH:i32 = -22;
                const MAX_EXPONENT_FAST_PATH:i32 = 22;
                const MAX_EXPONENT_DISGUISED_FAST_PATH:i32 = 37;

                #[inline( always )] unsafe fn pow_fast_path( exponent:usize ) -> Self  { return powd( 10.0f64, exponent as f64 ); }
                #[inline] fn from_u64( u:u64 ) -> f64 { u as _ }
                #[inline] fn from_bits( u:u64 ) -> f64 { f64::from_bits( u ) }
                #[inline] fn to_bits( self ) -> u64 { f64::to_bits( self ) }
            }

            #[inline( always )] pub fn powf( x:f32, y:f32 ) -> f32 { x.powf( y ) }

            #[inline( always )] pub fn powd( x:f64, y:f64 ) -> f64 { x.powf( y ) }

            pub( crate ) enum FastPathRadix
            {
                Five,
                Ten,
            }

            impl From<FastPathRadix> for u64
            {
                fn from( radix:FastPathRadix ) -> u64
                {
                    match radix
                    {
                        FastPathRadix::Five => 5,
                        FastPathRadix::Ten => 10,
                    }
                }
            }
            /// Get a small, integral power-of-radix for fast-path multiplication.
            #[inline( always )]
            pub( crate ) unsafe fn int_pow_fast_path( exponent:usize, radix:FastPathRadix ) -> u64
            {
                return u64::from( radix ).pow( exponent as u32 );
            }
        }

        pub mod number
        {
            //! Representation of a float as the significant digits and exponent.
            /*
            #![doc( hidden )]

            #[cfg( feature = "nightly" )]
            use crate::fpu::set_precision;
            */
            use ::
            {
                *,
            };
            use super::num::{int_pow_fast_path, FastPathRadix, Float};

            /// Representation of a number as the significant digits and exponent.
            #[derive( Clone, Copy, Debug, Default, PartialEq, Eq )]
            pub struct Number 
            {
                /// The exponent of the float, scaled to the mantissa.
                pub exponent:i32,
                /// The significant digits of the float.
                pub mantissa:u64,
                /// If the significant digits were truncated.
                pub many_digits:bool,
            }

            impl Number 
            {
                /// Detect if the float can be accurately reconstructed from native floats.
                #[inline]
                pub fn is_fast_path<F:Float>( &self ) -> bool 
                {
                    F::MIN_EXPONENT_FAST_PATH <= self.exponent
                    && self.exponent <= F::MAX_EXPONENT_DISGUISED_FAST_PATH
                    && self.mantissa <= F::MAX_MANTISSA_FAST_PATH
                    && !self.many_digits
                }

                /// The fast path algorithmn using machine-sized integers and floats.
                pub fn try_fast_path<F:Float>( &self ) -> Option<F>
                {
                    /*
                    // The fast path crucially depends on arithmetic being rounded to the correct number of bits
                    // without any intermediate rounding. On x86 ( without SSE or SSE2 ) this requires the precision
                    // of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.
                    // The `set_precision` function takes care of setting the precision on architectures which
                    // require setting it by changing the global state ( like the control word of the x87 FPU ).
                    #[cfg( feature = "nightly" )]
                    let _cw = set_precision::<F>();
                    */
                    if self.is_fast_path::<F>() 
                    {
                        let max_exponent = F::MAX_EXPONENT_FAST_PATH;
                        Some( if self.exponent <= max_exponent 
                        {
                            let value = F::from_u64( self.mantissa );
                            if self.exponent < 0 { value / unsafe { F::pow_fast_path( ( -self.exponent ) as _ ) } }
                            else { value * unsafe { F::pow_fast_path( self.exponent as _ ) } }
                        }
                        else
                        {
                            let shift = self.exponent - max_exponent;
                            let int_power = unsafe { int_pow_fast_path( shift as usize, FastPathRadix::Ten ) };
                            let mantissa = self.mantissa.checked_mul( int_power )?;
                            if mantissa > F::MAX_MANTISSA_FAST_PATH { return None; }
                            F::from_u64( mantissa ) * unsafe { F::pow_fast_path( max_exponent as _ ) }
                        } )
                    }
                    
                    else { None }
                }
            }
        }

        pub mod parse
        {
            //! Parse byte iterators to float.
            use super::bellerophon::bellerophon;
            use super::extended::{extended_to_float, ExtendedFloat};
            use super::num::Float;
            use super::number::Number;
            use super::slow::slow;
            /// Try to parse the significant digits quickly.
            #[inline] fn parse_number_fast<'a, Iter1, Iter2>
            ( 
                integer:Iter1,
                fraction:Iter2,
                exponent:i32,
            ) -> Option<Number> where
            Iter1:Iterator<Item = &'a u8>,
            Iter2:Iterator<Item = &'a u8>,
            {
                let mut num = Number::default();
                let mut integer_count:usize = 0;
                let mut fraction_count:usize = 0;
                for &c in integer 
                {
                    integer_count += 1;
                    let digit = c - b'0';
                    num.mantissa = num.mantissa.wrapping_mul( 10 ).wrapping_add( digit as u64 );
                }

                for &c in fraction
                {
                    fraction_count += 1;
                    let digit = c - b'0';
                    num.mantissa = num.mantissa.wrapping_mul( 10 ).wrapping_add( digit as u64 );
                }

                if integer_count + fraction_count <= 19 
                {
                    num.exponent = exponent.saturating_sub( fraction_count as i32 );
                    Some( num )
                } 
                else { None }
            }
            /// Parse the significant digits of the float and adjust the exponent.
            #[inline] fn parse_number<'a, I1, I2>( mut integer:I1, mut fraction:I2, exponent:i32 ) -> Number where 
            I1:Iterator<Item = &'a u8> + Clone, I2:Iterator<Item = &'a u8> + Clone,
            {
                if let Some( num ) = parse_number_fast( integer.clone(), fraction.clone(), exponent ){ return num; }
                let mut num = Number::default();
                let mut count = 0;
                while let Some( &c ) = integer.next()
                {
                    count += 1;
                    if count == 20
                    {
                        num.many_digits = true;
                        num.exponent = exponent.saturating_add( into_i32( 1 + integer.count() ) );
                        return num;
                    } 
                    else
                    {
                        let digit = c - b'0';
                        num.mantissa = num.mantissa * 10 + digit as u64;
                    }
                }
                
                let mut fraction_count:usize = 0;
                if count == 0 
                {
                    for &c in &mut fraction 
                    {
                        fraction_count += 1;
                        if c != b'0'
                        {
                            count += 1;
                            let digit = c - b'0';
                            num.mantissa = num.mantissa * 10 + digit as u64;
                            break;
                        }
                    }
                }

                for c in fraction
                {
                    fraction_count += 1;
                    count += 1;
                    if count == 20
                    {
                        num.many_digits = true;
                        num.exponent = exponent.saturating_sub( fraction_count as i32 - 1 );
                        return num;
                    } 
                    else
                    {
                        let digit = c - b'0';
                        num.mantissa = num.mantissa * 10 + digit as u64;
                    }
                }

                num.exponent = exponent.saturating_sub( fraction_count as i32 );
                num
            }
            /// Parse float from extracted float components.
            pub fn parse_float<'a, F, Iter1, Iter2>( integer:Iter1, fraction:Iter2, exponent:i32 ) -> F where
            F:Float,
            Iter1:Iterator<Item = &'a u8> + Clone,
            Iter2:Iterator<Item = &'a u8> + Clone,
            {
                let num = parse_number( integer.clone(), fraction.clone(), exponent );
                if let Some( value ) = num.try_fast_path() { return value; }

                let mut fp = moderate_path::<F>( &num );
                if fp.exp < 0
                {
                    fp.exp -= F::INVALID_FP;
                    fp = slow::<F, _, _>( num, fp, integer, fraction );
                }
                
                extended_to_float::<F>( fp )
            }
            /// Wrapper for different moderate-path algorithms..
            #[inline] pub fn moderate_path<F:Float>( num:&Number ) -> ExtendedFloat 
            { return bellerophon::<F>( num ); }
            /// Convert usize into i32 without overflow.
            #[inline] fn into_i32( value:usize ) -> i32
            {
                if value > i32::max_value() as usize { i32::max_value() }
                else { value as i32 }
            }
            // Add digit to mantissa.
            #[inline] pub fn add_digit( value:u64, digit:u8 ) -> Option<u64>
            { value.checked_mul( 10 )?.checked_add( digit as u64 ) }
        }

        pub mod rounding
        {
            //! Defines rounding schemes for floating-point numbers.
            use super::extended::ExtendedFloat;
            use super::mask::{lower_n_halfway, lower_n_mask};
            use super::num::Float;
            
            /// Round an extended-precision float to the nearest machine float.
            #[inline] pub fn round<F, Cb>( fp:&mut ExtendedFloat, cb:Cb ) where
            F:Float,
            Cb:Fn( &mut ExtendedFloat, i32 ),
            {
                let fp_inf = ExtendedFloat
                {
                    mant:0,
                    exp:F::INFINITE_POWER,
                };
                
                let mantissa_shift = 64 - F::MANTISSA_SIZE - 1;
                if -fp.exp >= mantissa_shift 
                {
                    let shift = -fp.exp + 1;
                    debug_assert!( shift <= 65 );
                    cb( fp, shift.min( 64 ) );
                    fp.exp = ( fp.mant >= F::HIDDEN_BIT_MASK ) as i32;
                    return;
                }
                cb( fp, mantissa_shift );
                let carry_mask = F::CARRY_MASK;
                if fp.mant & carry_mask == carry_mask 
                {
                    fp.mant >>= 1;
                    fp.exp += 1;
                }

                if fp.exp >= F::INFINITE_POWER 
                {
                    *fp = fp_inf;
                    return;
                }

                fp.mant &= F::MANTISSA_MASK;
            }

            /// Shift right N-bytes and round towards a direction.
            pub fn round_nearest_tie_even<Cb>( fp:&mut ExtendedFloat, shift:i32, cb:Cb ) where
            Cb:Fn( bool, bool, bool ) -> bool,
            {
                debug_assert!( shift <= 64 );
                let mask = lower_n_mask( shift as u64 );
                let halfway = lower_n_halfway( shift as u64 );
                let truncated_bits = fp.mant & mask;
                let is_above = truncated_bits > halfway;
                let is_halfway = truncated_bits == halfway;
                fp.mant = match shift == 64 
                {
                    true => 0,
                    false => fp.mant >> shift,
                };
                fp.exp += shift;
                let is_odd = fp.mant & 1 == 1;
                fp.mant += cb( is_odd, is_halfway, is_above ) as u64;
            }
            
            pub fn round_down( fp:&mut ExtendedFloat, shift:i32 ) 
            {
                fp.mant = match shift == 64 
                {
                    true => 0,
                    false => fp.mant >> shift,
                };
                fp.exp += shift;
            }
        }

        pub mod slow
        {
            //! Slow, fallback cases where we cannot unambiguously round a float.
            use super::bigint::{Bigint, Limb, LIMB_BITS};
            use super::extended::{extended_to_float, ExtendedFloat};
            use super::num::{int_pow_fast_path, FastPathRadix, Float};
            use super::number::Number;
            use super::rounding::{round, round_down, round_nearest_tie_even};
            use ::
            {
                *,
            };

            /// Add a digit to the temporary value.
            macro_rules! add_digit
            {
                ( $c:ident, $value:ident, $counter:ident, $count:ident ) =>
                {{
                    let digit = $c - b'0';
                    $value *= 10 as Limb;
                    $value += digit as Limb;
                    $counter += 1;
                    $count += 1;
                }};
            }

            /// Add a temporary value to our mantissa.
            macro_rules! add_temporary
            {
                ( @mul $result:ident, $power:expr, $value:expr ) =>
                {
                    $result.data.mul_small( $power ).unwrap();
                    $result.data.add_small( $value ).unwrap();
                };
                
                ( $format:ident, $result:ident, $counter:ident, $value:ident ) =>
                {
                    if $counter != 0
                    {
                        let small_power = unsafe { int_pow_fast_path( $counter, FastPathRadix::Ten ) };
                        add_temporary!( @mul $result, small_power as Limb, $value );
                        $counter = 0;
                        $value = 0;
                    }
                };

                // Add a temporary where we won't read the counter results internally.
                ( @end $format:ident, $result:ident, $counter:ident, $value:ident ) =>
                {
                    if $counter != 0
                    {
                        let small_power = unsafe { int_pow_fast_path( $counter, FastPathRadix::Ten ) };
                        add_temporary!( @mul $result, small_power as Limb, $value );
                    }
                };

                // Add the maximum native value.
                ( @max $format:ident, $result:ident, $counter:ident, $value:ident, $max:ident ) =>
                {
                    add_temporary!( @mul $result, $max, $value );
                    $counter = 0;
                    $value = 0;
                };
            }

            /// Round-up a truncated value.
            macro_rules! round_up_truncated
            {
                ( $format:ident, $result:ident, $count:ident ) =>
                {{
                    add_temporary!( @mul $result, 10, 1 );
                    $count += 1;
                }};
            }

            /// Check and round-up the fraction if any non-zero digits exist.
            macro_rules! round_up_nonzero
            {
                ( $format:ident, $iter:expr, $result:ident, $count:ident ) => 
                {{
                    for &digit in $iter 
                    {
                        if digit != b'0' 
                        {
                            round_up_truncated!( $format, $result, $count );
                            return ( $result, $count );
                        }
                    }
                }};
            }

            /// Parse the significant digits and biased, binary exponent of a float.
            #[inline] pub fn slow<'a, F, Iter1, Iter2>
            ( 
                num:Number,
                fp:ExtendedFloat,
                integer:Iter1,
                fraction:Iter2,
            ) -> ExtendedFloat where
            F:Float,
            Iter1:Iterator<Item = &'a u8> + Clone,
            Iter2:Iterator<Item = &'a u8> + Clone,
            {
                debug_assert!( fp.mant & ( 1 << 63 ) != 0 );
                let sci_exp = scientific_exponent( &num );
                let ( bigmant, digits ) = parse_mantissa( integer, fraction, F::MAX_DIGITS );
                let exponent = sci_exp + 1 - digits as i32;
                if exponent >= 0 { positive_digit_comp::<F>( bigmant, exponent ) }
                else { negative_digit_comp::<F>( bigmant, fp, exponent ) }
            }

            /// Generate the significant digits with a positive exponent relative to mantissa.
            pub fn positive_digit_comp<F:Float>( mut bigmant:Bigint, exponent:i32 ) -> ExtendedFloat
            {
                bigmant.pow( 10, exponent as u32 ).unwrap();
                let ( mant, is_truncated ) = bigmant.hi64();
                let exp = bigmant.bit_length() as i32 - 64 + F::EXPONENT_BIAS;
                let mut fp = ExtendedFloat
                {
                    mant,
                    exp,
                };

                // Shift the digits into position and determine if we need to round-up.
                round::<F, _>( &mut fp, |f, s|
                {
                    round_nearest_tie_even( f, s, |is_odd, is_halfway, is_above|
                    {
                        is_above || ( is_halfway && is_truncated ) || ( is_odd && is_halfway )
                    } );
                } );
                fp
            }

            /// Generate the significant digits with a negative exponent relative to mantissa.
            pub fn negative_digit_comp<F:Float>
            ( 
                bigmant:Bigint,
                mut fp:ExtendedFloat,
                exponent:i32,
            ) -> ExtendedFloat
            {
                debug_assert!( fp.mant & ( 1 << 63 ) != 0 );
                let mut real_digits = bigmant;
                let real_exp = exponent;
                debug_assert!( real_exp < 0 );
                let mut b = fp;
                round::<F, _>( &mut b, round_down );
                let b = extended_to_float::<F>( b );
                let theor = bh( b );
                let mut theor_digits = Bigint::from_u64( theor.mant );
                let theor_exp = theor.exp;
                let binary_exp = theor_exp - real_exp;
                let halfradix_exp = -real_exp;
                if halfradix_exp != 0 { theor_digits.pow( 5, halfradix_exp as u32 ).unwrap(); }
                
                if binary_exp > 0 { theor_digits.pow( 2, binary_exp as u32 ).unwrap(); }
                else if binary_exp < 0 { real_digits.pow( 2, ( -binary_exp ) as u32 ).unwrap(); }
                
                let ord = real_digits.data.cmp( &theor_digits.data );
                round::<F, _>( &mut fp, |f, s|
                {
                    round_nearest_tie_even( f, s, |is_odd, _, _|
                    {
                        match ord
                        {
                            cmp::Ordering::Greater => true,
                            cmp::Ordering::Less => false,
                            cmp::Ordering::Equal if is_odd => true,
                            cmp::Ordering::Equal => false,
                        }
                    } );
                } );

                fp
            }

            /// Parse the full mantissa into a big integer.
            pub fn parse_mantissa<'a, Iter1, Iter2>
            ( 
                mut integer:Iter1,
                mut fraction:Iter2,
                max_digits:usize,
            ) -> ( Bigint, usize ) where
            Iter1:Iterator<Item = &'a u8> + Clone,
            Iter2:Iterator<Item = &'a u8> + Clone,
            {
                let mut counter:usize = 0;
                let mut count:usize = 0;
                let mut value:Limb = 0;
                let mut result = Bigint::new();                
                let step:usize = if LIMB_BITS == 32 { 9 } else { 19 };
                let max_native = ( 10 as Limb ).pow( step as u32 );                
                'integer:loop 
                {
                    while counter < step && count < max_digits 
                    {
                        if let Some( &c ) = integer.next(){ add_digit!( c, value, counter, count ); } else { break 'integer; }
                    }

                    // Check if we've exhausted our max digits.
                    if count == max_digits 
                    {
                        add_temporary!( @end format, result, counter, value );
                        round_up_nonzero!( format, integer, result, count );
                        round_up_nonzero!( format, fraction, result, count );
                        return ( result, count );
                    }
                    else 
                    { add_temporary!( @max format, result, counter, value, max_native ); }
                }
                
                if count == 0 
                {
                    for &c in &mut fraction 
                    {
                        if c != b'0' 
                        {
                            add_digit!( c, value, counter, count );
                            break;
                        }
                    }
                }
                
                'fraction:loop 
                {
                    while counter < step && count < max_digits 
                    {
                        if let Some( &c ) = fraction.next(){ add_digit!( c, value, counter, count ); } else { break 'fraction; }
                    }
                    
                    if count == max_digits 
                    {
                        add_temporary!( @end format, result, counter, value );
                        round_up_nonzero!( format, fraction, result, count );
                        return ( result, count );
                    } 
                    else { add_temporary!( @max format, result, counter, value, max_native ); }
                }
                
                add_temporary!( @end format, result, counter, value );
                ( result, count )
            }
            /// Calculate the scientific exponent from a `Number` value.
            #[inline] pub fn scientific_exponent( num:&Number ) -> i32
            {
                let mut mantissa = num.mantissa;
                let mut exponent = num.exponent;
                while mantissa >= 10000
                {
                    mantissa /= 10000;
                    exponent += 4;
                }
                while mantissa >= 100
                {
                    mantissa /= 100;
                    exponent += 2;
                }
                while mantissa >= 10
                {
                    mantissa /= 10;
                    exponent += 1;
                }
                exponent as i32
            }

            /// Calculate `b` from a a representation of `b` as a float.
            #[inline] pub fn b<F:Float>( float:F ) -> ExtendedFloat 
            {
                ExtendedFloat
                {
                    mant:float.mantissa(),
                    exp:float.exponent(),
                }
            }

            /// Calculate `b+h` from a a representation of `b` as a float.
            #[inline] pub fn bh<F:Float>( float:F ) -> ExtendedFloat
            {
                let fp = b( float );
                ExtendedFloat
                {
                    mant:( fp.mant << 1 ) + 1,
                    exp:fp.exp - 1,
                }
            }
        }
        
        pub mod table
        {
            use super::{ bellerophon::BellerophonPowers };
            
            pub const BASE10_POWERS:BellerophonPowers = BellerophonPowers
            {
                small:&BASE10_SMALL_MANTISSA,
                large:&BASE10_LARGE_MANTISSA,
                small_int:&BASE10_SMALL_INT_POWERS,
                step:BASE10_STEP,
                bias:BASE10_BIAS,
                log2:BASE10_LOG2_MULT,
                log2_shift:BASE10_LOG2_SHIFT,
            };
            
            const BASE10_SMALL_MANTISSA:[u64; 10] =
            [
                9223372036854775808, 
                11529215046068469760,
                14411518807585587200,
                18014398509481984000,
                11258999068426240000,
                14073748835532800000,
                17592186044416000000,
                10995116277760000000,
                13743895347200000000,
                17179869184000000000,
            ];

            const BASE10_LARGE_MANTISSA:[u64; 66] = 
            [
                11555125961253852697, 
                13451937075301367670, 
                15660115838168849784, 
                18230774251475056848, 
                10611707258198326947, 
                12353653155963782858, 
                14381545078898527261, 
                16742321987285426889, 
                9745314011399999080,  
                11345038669416679861, 
                13207363278391631158, 
                15375394465392026070, 
                17899314949046850752, 
                10418772551374772303, 
                12129047596099288555, 
                14120069793541087484, 
                16437924692338667210, 
                9568131466127621947,  
                11138771039116687545, 
                12967236152753102995, 
                15095849699286165408, 
                17573882009934360870, 
                10229345649675443343, 
                11908525658859223294, 
                13863348470604074297, 
                16139061738043178685, 
                9394170331095332911,  
                10936253623915059621, 
                12731474852090538039, 
                14821387422376473014, 
                17254365866976409468, 
                10043362776618689222, 
                11692013098647223345, 
                13611294676837538538, 
                15845632502852867518, 
                9223372036854775808,  
                10737418240000000000, 
                12500000000000000000, 
                14551915228366851806, 
                16940658945086006781, 
                9860761315262647567,  
                11479437019748901445, 
                13363823550460978230, 
                15557538194652854267, 
                18111358157653424735, 
                10542197943230523224, 
                12272733663244316382, 
                14287342391028437277, 
                16632655625031838749, 
                9681479787123295682,  
                11270725851789228247, 
                13120851772591970218, 
                15274681817498023410, 
                17782069995880619867, 
                10350527006597618960, 
                12049599325514420588, 
                14027579833653779454, 
                16330252207878254650, 
                9505457831475799117,  
                11065809325636130661, 
                12882297539194266616, 
                14996968138956309548, 
                17458768723248864463, 
                10162340898095201970, 
                11830521861667747109, 
                13772540099066387756, 
            ];
            const BASE10_SMALL_INT_POWERS:[u64; 10] = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];
            const BASE10_STEP:i32 = 10;
            const BASE10_BIAS:i32 = 350;
            const BASE10_LOG2_MULT:i64 = 217706;
            const BASE10_LOG2_SHIFT:i32 = 16;
        }
        
        pub use self::num::Float;
        pub use self::parse::parse_float;
    }
}
pub mod path
{
    pub use std::path::{ * };
    use ::
    {
        borrow::{ Cow },        
        fs::{ read_dir },
        io::{ ErrorKind, Write },
        os::unix::fs::{ PermissionsExt },
        regex::{ re_contains, Regex },
        *,
    };
    /*
    dirs     v0.0.0
    dirs-sys v0.0.0*/
    pub mod sys
    {
        use ::
        {
            ffi::{ OsString },
            path::{ PathBuf },
            *
        };
        pub fn cache_dir() -> Option<PathBuf> { env::var_os( "XDG_CACHE_HOME" ) .and_then( is_absolute_path ).or_else( || home_dir().map( |h| h.join( ".cache" ) ) ) }
        pub fn config_dir() -> Option<PathBuf> { env::var_os( "XDG_CONFIG_HOME" ).and_then( is_absolute_path ).or_else( || home_dir().map( |h| h.join( ".config" ) ) ) }
        pub fn config_local_dir() -> Option<PathBuf> { config_dir() }
        pub fn data_dir() -> Option<PathBuf> { env::var_os( "XDG_DATA_HOME" )  .and_then( is_absolute_path ).or_else( || home_dir().map( |h| h.join( ".local/share" ) ) ) }
        pub fn data_local_dir() -> Option<PathBuf> { data_dir() }
        pub fn preference_dir() -> Option<PathBuf> { config_dir() }
        pub fn runtime_dir() -> Option<PathBuf> { env::var_os( "XDG_RUNTIME_DIR" ).and_then( is_absolute_path ) }
        pub fn state_dir() -> Option<PathBuf> { env::var_os( "XDG_STATE_HOME" ) .and_then( is_absolute_path ).or_else( || home_dir().map( |h| h.join( ".local/state" ) ) ) }
        pub fn executable_dir() -> Option<PathBuf> { env::var_os( "XDG_BIN_HOME" ).and_then( is_absolute_path ).or_else( || home_dir().map( |h| h.join( ".local/bin" ) ) ) }
        pub fn audio_dir() -> Option<PathBuf> { user_dir( "MUSIC" ) }
        pub fn desktop_dir() -> Option<PathBuf> { user_dir( "DESKTOP" ) }
        pub fn document_dir() -> Option<PathBuf> { user_dir( "DOCUMENTS" ) }
        pub fn download_dir() -> Option<PathBuf> { user_dir( "DOWNLOAD" ) }
        pub fn font_dir() -> Option<PathBuf> { data_dir().map( |d| d.join( "fonts" ) ) }
        pub fn picture_dir() -> Option<PathBuf> { user_dir( "PICTURES" ) }
        pub fn public_dir() -> Option<PathBuf> { user_dir( "PUBLICSHARE" ) }
        pub fn template_dir() -> Option<PathBuf> { user_dir( "TEMPLATES" ) }
        pub fn video_dir() -> Option<PathBuf> { user_dir( "VIDEOS" ) }
        
        pub fn is_absolute_path( path:OsString ) -> Option<PathBuf>
        {
            let path = PathBuf::from( path );
            if path.is_absolute() { Some( path ) } 
            else { None }
        }

        #[cfg( all( unix, not( target_os = "redox" ) ) )]
        mod target_unix_not_redox
        {
            use ::
            {
                ffi::{ CStr, OsString },
                os::unix::ffi::{ OsStringExt },
                path::{ PathBuf },
                *,
            };
            
            // https://github.com/rust-lang/rust/blob/2682b88c526d493edeb2d3f2df358f44db69b73f/library/std/src/sys/unix/os.rs#L595
            pub fn home_dir() -> Option<PathBuf>
            {
                return env::var_os( "HOME" )
                .and_then( |h| if h.is_empty() { None } else { Some( h ) } )
                .or_else( || unsafe { fallback() } )
                .map( PathBuf::from );
                
                #[cfg( any( target_os = "android", target_os = "ios", target_os = "emscripten" ) )]
                unsafe fn fallback() -> Option<OsString> { None }

                #[cfg( not( any( target_os = "android", target_os = "ios", target_os = "emscripten" ) ) )]
                unsafe fn fallback() -> Option<OsString>
                {
                    let amt = match libc::sysconf( libc::_SC_GETPW_R_SIZE_MAX )
                    {
                        n if n < 0 => 512 as usize,
                        n => n as usize,
                    };

                    let mut buf = Vec::with_capacity( amt );
                    let mut passwd:libc::passwd = mem::zeroed();
                    let mut result = ptr::null_mut();
                    match libc::getpwuid_r
                    ( 
                        libc::getuid(),
                        &mut passwd,
                        buf.as_mut_ptr(),
                        buf.capacity(),
                        &mut result,
                    )
                    {
                        0 if !result.is_null() =>
                        {
                            let ptr = passwd.pw_dir as *const _;
                            let bytes = CStr::from_ptr( ptr ).to_bytes();
                            if bytes.is_empty() { None }
                            else { Some( OsStringExt::from_vec( bytes.to_vec() ) ) }
                        }
                        _ => None,
                    }
                }
            }

        }

        #[cfg( all( unix, not( target_os = "redox" ) ) )]
        pub use self::target_unix_not_redox::home_dir;

        #[cfg( target_os = "redox" )]
        extern crate redox_users;

        #[cfg( target_os = "redox" )]
        mod target_redox
        {
            use ::
            {
                path::{ PathBuf },
                *,
            };
            use super::redox_users::{All, AllUsers, Config};

            pub fn home_dir() -> Option<PathBuf>
            {
                let current_uid = redox_users::get_uid().ok()?;
                let users = AllUsers::basic( Config::default() ).ok()?;
                let user = users.get_by_id( current_uid )?;
                Some( PathBuf::from( user.home.clone() ) )
            }
        }

        #[cfg( target_os = "redox" )]
        pub use self::target_redox::home_dir;

        #[cfg( all( unix, not( any( target_os = "macos", target_os = "ios" ) ) ) )]
        mod xdg_user_dirs
        {
            use ::
            {
                collections::{ HashMap },
                ffi::{ OsString },
                io::{ self, Read },
                option::{ OptionExt },
                os::unix::ffi::{ OsStringExt },
                path::{ Path, PathBuf },
                *
            };

            /// Returns all XDG user directories obtained from $( XDG_CONFIG_HOME )/user-dirs.dirs.
            pub fn all( home_dir_path:&Path, user_dir_file_path:&Path ) -> HashMap<String, PathBuf>
            {
                let bytes = read_all( user_dir_file_path ).unwrap_or( Vec::new() );
                parse_user_dirs( home_dir_path, None, &bytes )
            }

            /// Returns a single XDG user directory obtained from $( XDG_CONFIG_HOME )/user-dirs.dirs.
            pub fn single( home_dir_path:&Path, user_dir_file_path:&Path, user_dir_name:&str ) -> HashMap<String, PathBuf>
            {
                let bytes = read_all( user_dir_file_path ).unwrap_or( Vec::new() );
                parse_user_dirs( home_dir_path, Some( user_dir_name ), &bytes )
            }

            fn parse_user_dirs( home_dir:&Path, user_dir:Option<&str>, bytes:&[u8] ) -> HashMap<String, PathBuf>
            {
                let mut user_dirs = HashMap::new();
                for line in bytes.split( |b| *b == b'\n' )
                {
                    let mut single_dir_found = false;
                    let ( key, value ) = 
                    match split_once( line, b'=' )
                    {
                        Some( kv ) => kv,
                        None => continue,
                    };

                    let key = trim_blank( key );
                    let key = if key.starts_with( b"XDG_" ) && key.ends_with( b"_DIR" )
                    {
                        match str::from_utf8( &key[4..key.len()-4] )
                        {
                            Ok( key ) =>
                            {
                                if user_dir.contains( &key )
                                {
                                    single_dir_found = true;
                                    key
                                } 
                                else if user_dir.is_none() { key } 
                                else { continue }
                            }                               
                            Err( _ )  => continue,
                        }
                    } 
                    else { continue };
                    
                    let value = trim_blank( value );
                    let mut value = if value.starts_with( b"\"" ) && value.ends_with( b"\"" )
                    { &value[1..value.len()-1] } 
                    else { continue };
                    
                    let is_relative = if value == b"$HOME/" { continue } 
                    else if value.starts_with( b"$HOME/" )
                    {
                        value = &value[b"$HOME/".len()..];
                        true
                    }
                    else if value.starts_with( b"/" ){ false }
                    else { continue };

                    let value = OsString::from_vec( shell_unescape( value ) );
                    let path = if is_relative
                    {
                        let mut path = PathBuf::from( &home_dir );
                        path.push( value );
                        path
                    }
                    else { PathBuf::from( value ) };

                    user_dirs.insert( key.to_owned(), path );
                    if single_dir_found
                    { break; }
                }
                user_dirs
            }

            /// Reads the entire contents of a file into a byte vector.
            fn read_all( path:&Path ) -> io::Result<Vec<u8>>
            {
                let mut file = fs::File::open( path )?;
                let mut bytes = Vec::with_capacity( 1024 );
                file.read_to_end( &mut bytes )?;
                Ok( bytes )
            }

            /// Returns bytes before and after first occurrence of separator.
            fn split_once( bytes:&[u8], separator:u8 ) -> Option<( &[u8], &[u8] )>
            {
                bytes.iter()
                .position( |b| *b == separator )
                .map( |i| 
                {
                    ( &bytes[..i], &bytes[i+1..] )
                } )
            }

            /// Returns a slice with leading and trailing <blank> characters removed.
            fn trim_blank( bytes:&[u8] ) -> &[u8]
            {
                let i = bytes.iter().cloned().take_while( |b| *b == b' ' || *b == b'\t' ).count();
                let bytes = &bytes[i..];
                let i = bytes.iter().cloned().rev().take_while( |b| *b == b' ' || *b == b'\t' ).count();
                &bytes[..bytes.len()-i]
            }

            /// Unescape bytes escaped with POSIX shell double-quotes rules ( as used by xdg-user-dirs-update ).
            fn shell_unescape( escaped:&[u8] ) -> Vec<u8>
            {
                let mut unescaped:Vec<u8> = Vec::with_capacity( escaped.len() );
                let mut i = escaped.iter().cloned();
                while let Some( b ) = i.next()
                {
                    if b == b'\\' { if let Some( b ) = i.next() { unescaped.push( b ); } }
                    else { unescaped.push( b ); }
                }

                unescaped
            }
        }

        #[cfg( all( unix, not( any( target_os = "macos", target_os = "ios" ) ) ) )]
        mod target_unix_not_mac
        {
            use ::
            {
                collections::{ HashMap },
                path::{ Path, PathBuf },
                *
            };

            use super::{home_dir, is_absolute_path};
            use super::xdg_user_dirs;

            fn user_dir_file( home_dir:&Path ) -> PathBuf
            {
                env::var_os( "XDG_CONFIG_HOME" )
                .and_then( is_absolute_path )
                .unwrap_or_else( || home_dir.join( ".config" ) )
                .join( "user-dirs.dirs" )
            }
            
            pub fn user_dir( user_dir_name:&str ) -> Option<PathBuf>
            {
                if let Some( home_dir ) = home_dir()
                { xdg_user_dirs::single( &home_dir, &user_dir_file( &home_dir ), user_dir_name ).remove( user_dir_name ) }
                else { None }
            }

            pub fn user_dirs( home_dir_path:&Path ) -> HashMap<String, PathBuf>
            { xdg_user_dirs::all( home_dir_path, &user_dir_file( home_dir_path ) ) }
        }

        #[cfg( all( unix, not( any( target_os = "macos", target_os = "ios" ) ) ) )]
        pub use self::target_unix_not_mac::{user_dir, user_dirs};

        #[cfg( target_os = "windows" )]
        extern crate windows_sys as windows;

        #[cfg( target_os = "windows" )]
        mod target_windows
        {
            use ::
            {
                ffi::{ c_void, OsString },
                os::windows::ffi::OsStringExt,
                path::{ PathBuf },
                *
            };

            use super::windows::Win32::UI::Shell;

            pub fn known_folder( folder_id:windows::core::GUID ) -> Option<PathBuf>
            {
                unsafe
                {
                    let mut path_ptr:windows::core::PWSTR = ptr::null_mut();
                    let result = Shell::SHGetKnownFolderPath
                    ( 
                        &folder_id,
                        0,
                        std::ptr::null_mut(),
                        &mut path_ptr
                    );

                    if result == 0
                    {
                        let len = windows::Win32::Globalization::lstrlenW( path_ptr ) as usize;
                        let path = slice::from_raw_parts( path_ptr, len );
                        let ostr:OsString = OsStringExt::from_wide( path );
                        windows::Win32::System::Com::CoTaskMemFree( path_ptr as *const c_void );
                        Some( PathBuf::from( ostr ) )
                    }
                    
                    else
                    {
                        windows::Win32::System::Com::CoTaskMemFree( path_ptr as *const c_void );
                        None
                    }
                }
            }

            pub fn known_folder_profile() -> Option<PathBuf> { known_folder( Shell::FOLDERID_Profile ) }
            pub fn known_folder_roaming_app_data() -> Option<PathBuf> { known_folder( Shell::FOLDERID_RoamingAppData ) }
            pub fn known_folder_local_app_data() -> Option<PathBuf> { known_folder( Shell::FOLDERID_LocalAppData ) }
            pub fn known_folder_music() -> Option<PathBuf> { known_folder( Shell::FOLDERID_Music ) }
            pub fn known_folder_desktop() -> Option<PathBuf> { known_folder( Shell::FOLDERID_Desktop ) }
            pub fn known_folder_documents() -> Option<PathBuf> { known_folder( Shell::FOLDERID_Documents ) }
            pub fn known_folder_downloads() -> Option<PathBuf> { known_folder( Shell::FOLDERID_Downloads ) }
            pub fn known_folder_pictures() -> Option<PathBuf> { known_folder( Shell::FOLDERID_Pictures ) }
            pub fn known_folder_public() -> Option<PathBuf> { known_folder( Shell::FOLDERID_Public ) }
            pub fn known_folder_templates() -> Option<PathBuf> { known_folder( Shell::FOLDERID_Templates ) }           
            pub fn known_folder_videos() -> Option<PathBuf> { known_folder( Shell::FOLDERID_Videos ) }
        }

        #[cfg( target_os = "windows" )] pub use self::target_windows::
        {
            known_folder, known_folder_profile, known_folder_roaming_app_data, known_folder_local_app_data, 
            known_folder_music, known_folder_desktop, known_folder_documents, known_folder_downloads,
            known_folder_pictures, known_folder_public, known_folder_templates, known_folder_videos
        };
    }
    /*
    dir v0.0.0*/
    /// Returns the path to the user's home directory.
    pub fn home_dir() -> Option<PathBuf> { sys::home_dir() }
    /// Returns the path to the user's cache directory.
    pub fn cache_dir() -> Option<PathBuf> { sys::cache_dir() }
    /// Returns the path to the user's config directory.
    pub fn config_dir() -> Option<PathBuf> { sys::config_dir() }
    /// Returns the path to the user's local config directory.
    pub fn config_local_dir() -> Option<PathBuf> { sys::config_local_dir() }
    /// Returns the path to the user's data directory.
    pub fn data_dir() -> Option<PathBuf> { sys::data_dir() }
    /// Returns the path to the user's local data directory.
    pub fn data_local_dir() -> Option<PathBuf> { sys::data_local_dir() }
    /// Returns the path to the user's executable directory.
    pub fn executable_dir() -> Option<PathBuf> { sys::executable_dir() }
    /// Returns the path to the user's preference directory.
    pub fn preference_dir() -> Option<PathBuf> { sys::preference_dir() }
    /// Returns the path to the user's runtime directory.
    pub fn runtime_dir() -> Option<PathBuf> { sys::runtime_dir() }
    /// Returns the path to the user's state directory.
    pub fn state_dir() -> Option<PathBuf> { sys::state_dir() }
    /// Returns the path to the user's audio directory.
    pub fn audio_dir() -> Option<PathBuf> { sys::audio_dir() }
    /// Returns the path to the user's desktop directory.
    pub fn desktop_dir() -> Option<PathBuf> { sys::desktop_dir() }
    /// Returns the path to the user's document directory.
    pub fn document_dir() -> Option<PathBuf> { sys::document_dir() }
    /// Returns the path to the user's download directory.
    pub fn download_dir() -> Option<PathBuf> { sys::download_dir() }
    /// Returns the path to the user's font directory.
    pub fn font_dir() -> Option<PathBuf> { sys::font_dir() }
    /// Returns the path to the user's picture directory.
    pub fn picture_dir() -> Option<PathBuf> { sys::picture_dir() }
    /// Returns the path to the user's public directory.
    pub fn public_dir() -> Option<PathBuf> { sys::public_dir() }
    /// Returns the path to the user's template directory.
    pub fn template_dir() -> Option<PathBuf> { sys::template_dir() }
    /// Returns the path to the user's video directory.
    pub fn video_dir() -> Option<PathBuf> { sys::video_dir() }

    pub fn escape_path( path:&str ) -> String
    {
        let re = Regex::new( r##"( ?P<c>[!\( \ )<>,\?\]\[\{\} \\'"`*\^#|$&;] )"## ).unwrap();
        return re.replace_all( path, "\\$c" ).to_string();
    }
    
    pub fn extend_bangbang( sh:&shell::Shell, line:&mut String )
    {
        if !re_contains( line, r"!!" ) { return; }
        if sh.previous_cmd.is_empty() { return; }

        let re = Regex::new( r"!!" ).unwrap();
        let mut replaced = false;
        let mut new_line = String::new();
        let linfo = parsers::line::parse_line( line );

        for ( sep, token ) in linfo.tokens
        {
            if !sep.is_empty() { new_line.push_str( &sep ); }

            if re_contains( &token, r"!!" ) && sep != "'"
            {
                let line2 = token.clone();
                let result = re.replace_all( &line2, sh.previous_cmd.as_str() );
                new_line.push_str( &result );
                replaced = true;
            }

            else { new_line.push_str( &token ); }

            if !sep.is_empty() { new_line.push_str( &sep ); }

            new_line.push( ' ' );
        }

        *line = new_line.trim_end().to_string();
        if replaced {
            println!( "{}", line );
        }
    }
    
    pub fn basename( path:&str ) -> Cow<'_, str>
    {
        let mut pieces = path.rsplit( '/' );
        match pieces.next()
        {
            Some( p ) => p.into(),
            None => path.into(),
        }
    }
    
    pub fn find_file_in_path( filename:&str, exec:bool ) -> String
    {
        let env_path = match env::var( "PATH" )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println_stderr!( "pls:error with env PATH:{:?}", e );
                return String::new();
            }
        };
        
        let vec_path:Vec<&str> = env_path.split( ':' ).collect();

        for p in &vec_path
        {
            match read_dir( p )
            {
                Ok( list ) =>
                {
                    for entry in list.flatten()
                    {
                        if let Ok( name ) = entry.file_name().into_string()
                        {
                            if name != filename { continue; }

                            if exec
                            {
                                let _mode = match entry.metadata()
                                {
                                    Ok( x ) => x,
                                    Err( e ) =>
                                    {
                                        println_stderr!( "pls:metadata error:{:?}", e );
                                        continue;
                                    }
                                };

                                let mode = _mode.permissions().mode();
                                if mode & 0o111 == 0 { continue; }
                            }

                            return entry.path().to_string_lossy().to_string();
                        }
                    }
                }

                Err( e ) => 
                {
                    if e.kind() == ErrorKind::NotFound { continue; } 
                    /* log!( "pls:fs read_dir error:{}:{}", p, e ); */
                }
            }
        }

        String::new()
    }
    
    pub fn current_dir() -> String
    {
        let _current_dir = match env::current_dir()
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                /*log!( "pls:PROMPT:env current_dir error:{}", e );*/
                return String::new();
            }
        };

        let current_dir = match _current_dir.to_str()
        {
            Some( x ) => x,
            None =>
            {
                /*log!( "pls:PROMPT:to_str error" );*/
                return String::new();
            }
        };

        current_dir.to_string()
    }
}
/*
pest v0.0.0*/
pub mod pest
{
    /*
    pest-derive v0.0.0*/
    pub mod derive
    {

    }
}
pub mod pin { pub use std::pin::{ * }; }
pub mod print
{
    use ::
    {
        error::no::{ errno }, //use errno::errno;
        fs::{ File },
        io::{ Write },
        os::unix::io::{ FromRawFd, RawFd },
        types::{ Command, CommandLine, CommandResult, Redirection },
        *,
    };
    
    pub fn print_stdout( info:&str, cmd:&Command, cl:&CommandLine )
    {
        unsafe 
        {
            let fd = get::dupped_stdout_fd( cmd, cl );
            if fd == -1 { return; }
            let mut f = File::from_raw_fd( fd );
            let info = info.trim_end_matches( '\n' );
            match f.write_all( info.as_bytes() )
            {
                Ok( _ ) => {},
                Err( e ) => { println_stderr!( "write_all:error:{}", e ); }
            }
            
            if !info.is_empty()
            {
                match f.write_all( b"\n" )
                {
                    Ok( _ ) => {},
                    Err( e ) => { println_stderr!( "write_all:error:{}", e ); }
                }
            }
        }
    }
    
    pub fn print_stderr( info:&str, cmd:&Command, cl:&CommandLine )
    {
        unsafe
        {
            let fd = get::dupped_stderr_fd( cmd, cl );
            if fd == -1 { return; }

            let mut f = File::from_raw_fd( fd );
            let info = info.trim_end_matches( '\n' );
            match f.write_all( info.as_bytes() )
            {
                Ok( _ ) => (),
                Err( e ) =>
                {
                    println_stderr!( "write_all:error:{}", e );
                }
            }

            if !info.is_empty()
            {
                match f.write_all( b"\n" )
                {
                    Ok( _ ) => (),
                    Err( e ) =>
                    {
                        println_stderr!( "write_all:error:{}", e );
                    }
                }
            }
        }
    }

    pub fn print_stderr_with_capture( info:&str, cr:&mut CommandResult, cl:&CommandLine, cmd:&Command, capture:bool )
    {
        cr.status = 1;
        if capture { cr.stderr = info.to_string(); }
        else { print_stderr( info, cmd, cl ); }
    }

    pub fn print_stdout_with_capture( info:&str, cr:&mut CommandResult, cl:&CommandLine, cmd:&Command, capture:bool )
    {
        cr.status = 0;
        if capture { cr.stdout = info.to_string(); }
        else { print_stdout( info, cmd, cl ); }
    }
}
pub mod process
{
    pub use std::process::{ * };
    use ::
    {
        libc::{ c_int },
        nix::
        {
            unistd::{ fork as nix_fork, ForkResult },
            Error, Result
        },
        os::fd::{RawFd},
        *,
    };
    
    pub fn fork() -> Result<ForkResult> { unsafe{ nix_fork() } }
    
    pub fn pipe() -> ::result::Result<( RawFd, RawFd ), Error>
    {
        let mut fds = mem::MaybeUninit::<[c_int; 2]>::uninit();
        let res = unsafe { libc::pipe( fds.as_mut_ptr() as *mut c_int ) };
        Error::result( res )?;
        unsafe { Ok( ( fds.assume_init()[0], fds.assume_init()[1] ) ) }
    }
}
pub mod prompt
{
    use ::
    {
        shell::{ self },
        *
    };

    use self::main::render_prompt;
    pub use self::multilines::EnterFunction;
    /*
    linefeed v0.6.0 */
    pub mod lines
    {
        //! Provides a configurable, concurrent, extensible, interactive input reader for Unix terminals & Windows console.
        pub mod chars
        {
            //! Provides utilities for manipulating character values
            /// Character value indicating end-of-file
            pub const EOF: char = '\x04';
            /// Character value generated by the Escape key
            pub const ESCAPE: char = '\x1b';
            /// Character value generated by the Backspace key
            pub const DELETE: char = RUBOUT;
            /// Character value generated by the Backspace key on some systems
            pub const RUBOUT: char = '\x7f';
            pub const CTRL_BIT: u8 = 0x40;
            pub const CTRL_MASK: u8 = 0x1f;
            pub const CTRL_MAX: u32 = 0x1f;

            /// Returns a character name as a key sequence, e.g. `Control-x` or `Meta-x`.
            pub fn parse_char_name(name: &str) -> Option<String>
            {
                let name_lc = name.to_lowercase();
                let is_ctrl = contains_any(&name_lc, &["c-", "ctrl-", "control-"]);
                let is_meta = contains_any(&name_lc, &["m-", "meta-"]);
                let name = match name_lc.rfind('-') 
                {
                    Some(pos) => &name_lc[pos + 1..],
                    None => &name_lc[..]
                };

                let ch = match name 
                {
                    "del" | "rubout"  => DELETE,
                    "esc" | "escape"  => ESCAPE,
                    "lfd" | "newline" => '\n',
                    "ret" | "return"  => '\r',
                    "spc" | "space"   => ' ',
                    "tab"             => '\t',
                    s if !s.is_empty() => s.chars().next().unwrap(),
                    _ => return None
                };

                let ch = match (is_ctrl, is_meta) 
                {
                    (true,  true)  => meta(ctrl(ch)),
                    (true,  false) => ctrl(ch).to_string(),
                    (false, true)  => meta(ch),
                    (false, false) => ch.to_string(),
                };

                Some(ch)
            }
            /// Returns a character sequence escaped for user-facing display.
            pub fn escape_sequence(s: &str) -> String
            {
                let mut res = String::with_capacity(s.len());
                for ch in s.chars()
                {
                    match ch
                    {
                        ESCAPE => res.push_str(r"\e"),
                        RUBOUT => res.push_str(r"\C-?"),
                        '\\' => res.push_str(r"\\"),
                        '\'' => res.push_str(r"\'"),
                        '"' => res.push_str(r#"\""#),
                        ch if is_ctrl(ch) =>
                        {
                            res.push_str(r"\C-");
                            res.push(unctrl_lower(ch));
                        }
                        ch => res.push(ch)
                    }
                }

                res
            }
            /// Returns a meta sequence for the given character.
            pub fn meta(ch: char) -> String
            {
                let mut s = String::with_capacity(ch.len_utf8() + 1);
                s.push(ESCAPE);
                s.push(ch);
                s
            }

            fn contains_any(s: &str, strs: &[&str]) -> bool { strs.iter().any(|a| s.contains(a)) }
            /// Returns whether the character is printable.
            pub fn is_printable(c: char) -> bool { c == '\t' || c == '\n' || !(c == '\0' || is_ctrl(c)) }
            /// Returns whether the given character is a control character.
            pub fn is_ctrl(c: char) -> bool { c != '\0' && c as u32 <= CTRL_MAX }
            /// Returns a control character for the given character.
            pub fn ctrl(c: char) -> char { ((c as u8) & CTRL_MASK) as char }
            /// Returns the printable character corresponding to the given control character.
            pub fn unctrl(c: char) -> char { ((c as u8) | CTRL_BIT) as char }
            /// Returns the lowercase character corresponding to the given control character.
            pub fn unctrl_lower(c: char) -> char { unctrl(c).to_ascii_lowercase() }
        }

        pub mod command
        {
            //! Defines the set of line editing commands
            use ::
            {
                borrow::Cow::{self, Borrowed, Owned},
                prompt::lines::
                {
                    chars::{ escape_sequence },
                },
                *,
            };

            macro_rules! define_commands
            {
                ( $( #[$meta:meta] $name:ident => $str:expr , )+ ) =>
                {
                    /// Represents a command to modify `Reader` state
                    #[derive(Clone, Debug, Eq, PartialEq)]
                    pub enum Command
                    {
                        $( #[$meta] $name , )+
                        /// Custom application-defined command
                        Custom(Cow<'static, str>),
                        /// Execute a given key sequence
                        Macro(Cow<'static, str>),
                    }
                    /// List of all command names
                    pub static COMMANDS: &[&str] = &[ $( $str ),+ ];

                    impl fmt::Display for Command
                    {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                        {
                            match *self
                            {
                                $( Command::$name => f.write_str($str) , )+
                                Command::Custom( ref s) => f.write_str(s),
                                Command::Macro( ref s) => write!(f, "\"{}\"", escape_sequence(s))
                            }
                        }
                    }

                    impl Command
                    {
                        /// Constructs a command from a `'static str` reference.
                        pub fn from_str(name: &'static str) -> Command
                        { Command::opt_from_str(name).unwrap_or_else(|| Command::Custom(Borrowed(name))) }
                        /// Constructs a command from a non-`'static` string-like type.
                        pub fn from_string<T>(name: T) -> Command where
                        T: AsRef<str> + Into<String>
                        {
                            Command::opt_from_str(name.as_ref())
                            .unwrap_or_else(|| Command::Custom(Owned(name.into())))
                        }

                        fn opt_from_str(s: &str) -> Option<Command>
                        {
                            match s
                            {
                                $( $str => Some(Command::$name), )+
                                _ => None
                            }
                        }
                    }
                }
            }

            define_commands!
            {
                /// Abort history search
                Abort => "abort",
                /// Accepts the current input line
                AcceptLine => "accept-line",
                /// Perform completion
                Complete => "complete",
                /// Insert all completions into the input buffer
                InsertCompletions => "insert-completions",
                /// Show possible completions
                PossibleCompletions => "possible-completions",
                /// Insert the next possible completion
                MenuComplete => "menu-complete",
                /// Insert the previous possible completion
                MenuCompleteBackward => "menu-complete-backward",
                /// Begin numeric argument input
                DigitArgument => "digit-argument",
                /// Insert character or sequence at the cursor
                SelfInsert => "self-insert",
                /// Inserts a tab character
                TabInsert => "tab-insert",
                /// Toggles insert/overwrite mode
                OverwriteMode => "overwrite-mode",
                /// Insert a comment and accept input
                InsertComment => "insert-comment",
                /// Move the cursor backward one character
                BackwardChar => "backward-char",
                /// Move the cursor forward one character
                ForwardChar => "forward-char",
                /// Search for a given character
                CharacterSearch => "character-search",
                /// Search backward for a given character
                CharacterSearchBackward => "character-search-backward",
                /// Move the cursor backward one word
                BackwardWord => "backward-word",
                /// Move the cursor forward one word
                ForwardWord => "forward-word",
                /// Kill all characters before the cursor
                BackwardKillLine => "backward-kill-line",
                /// Kill all characters after the cursor
                KillLine => "kill-line",
                /// Kill a word before the cursor
                BackwardKillWord => "backward-kill-word",
                /// Kill a word after the cursor
                KillWord => "kill-word",
                /// Kill a word before the cursor, delimited by whitespace
                UnixWordRubout => "unix-word-rubout",
                /// Clear the screen
                ClearScreen => "clear-screen",
                /// Move the cursor to the beginning of the line
                BeginningOfLine => "beginning-of-line",
                /// Move the cursor to the end of the line
                EndOfLine => "end-of-line",
                /// Delete one character before the cursor
                BackwardDeleteChar => "backward-delete-char",
                /// Delete one character after the cursor
                DeleteChar => "delete-char",
                /// Drag the character before the cursor forward
                TransposeChars => "transpose-chars",
                /// Drag the word before the cursor forward
                TransposeWords => "transpose-words",
                /// Move to the first line of history
                BeginningOfHistory => "beginning-of-history",
                /// Move to the last line of history
                EndOfHistory => "end-of-history",
                /// Select next line in history
                NextHistory => "next-history",
                /// Select previous line in history
                PreviousHistory => "previous-history",
                /// Incremental search in history
                ForwardSearchHistory => "forward-search-history",
                /// Incremental reverse search in history
                ReverseSearchHistory => "reverse-search-history",
                /// Non-incremental forward history search using input up to the cursor
                HistorySearchForward => "history-search-forward",
                /// Non-incremental backward history search using input up to the cursor
                HistorySearchBackward => "history-search-backward",
                /// Insert literal character
                QuotedInsert => "quoted-insert",
                /// Insert text into buffer from the kill ring
                Yank => "yank",
                /// Rotate the kill ring and yank the new top
                YankPop => "yank-pop",
            }
            /// Describes the category of a command.
            #[derive(Copy, Clone, Debug, Eq, PartialEq)]
            pub enum Category
            {
                /// Completion command
                Complete,
                /// Kill command
                Kill,
                /// Non-incremental search command
                Search,
                /// Incremental search command
                IncrementalSearch,
                /// Yank command
                Yank,
                /// Digit argument command
                Digit,
                /// Other command
                Other,
            }

            impl Command
            {
                /// Returns the category of the command
                pub fn category(&self) -> Category
                {
                    use self::Command::*;
                    match *self
                    {
                        DigitArgument => Category::Digit,
                        Complete | InsertCompletions | PossibleCompletions | MenuComplete | MenuCompleteBackward => 
                        Category::Complete,
                        BackwardKillLine | KillLine | BackwardKillWord | KillWord | UnixWordRubout => Category::Kill,
                        ForwardSearchHistory | ReverseSearchHistory => Category::IncrementalSearch,
                        HistorySearchForward | HistorySearchBackward => Category::Search,
                        Yank | YankPop => Category::Yank,
                        _ => Category::Other
                    }
                }
            }
        }
        pub use self::command::Command;
        pub mod complete
        {
            //! Provides utilities for implementing word completion
            use ::
            {
                borrow::Cow::{ self, Borrowed, Owned },
                fs::{ read_dir },
                path::{ is_separator, MAIN_SEPARATOR },
                prompt::lines::
                {
                    prompter::Prompter,
                    terminal::Terminal,
                },
                *,
            };
            /// Represents a single possible completion
            #[derive(Clone, Debug)]
            pub struct Completion
            {
                /// Whole completion text
                pub completion: String,
                /// Listing display string; `None` if matches completion
                pub display: Option<String>,
                /// Completion suffix; replaces append character
                pub suffix: Suffix,
            }
            /// Specifies an optional suffix to override the default value
            #[derive(Copy, Clone, Debug, Eq, PartialEq)]
            pub enum Suffix
            {
                /// Use the default suffix
                Default,
                /// Use no suffix
                None,
                /// Use the given suffix
                Some(char),
            }

            impl Completion
            {
                /// Returns a simple `Completion` value, 
                /// with display string matching completion and using the default completion suffix.
                pub fn simple(s: String) -> Completion
                {
                    Completion
                    {
                        completion: s,
                        display: None,
                        suffix: Suffix::default(),
                    }
                }
                /// Returns the full completion string, including suffix, 
                /// using the given default suffix if one is not assigned to this completion.
                pub fn completion(&self, def_suffix: Option<char>) -> Cow<str>
                {
                    let mut s = Borrowed(&self.completion[..]);
                    if let Some(suffix) = self.suffix.with_default(def_suffix) { s.to_mut().push(suffix); }
                    s
                }
                /// Returns the display string, including suffix
                pub fn display(&self) -> Cow<str>
                {
                    let mut s = Borrowed(self.display_str());
                    if let Suffix::Some(suffix) = self.suffix { s.to_mut().push(suffix); }
                    s
                }
                /// Returns the number of characters displayed
                pub fn display_chars(&self) -> usize
                {
                    let n = self.display_str().chars().count();
                    n + if self.suffix.is_some() { 1 } else { 0 }
                }

                fn display_str(&self) -> &str
                {
                    match self.display
                    {
                        Some( ref dis) => dis,
                        None => &self.completion
                    }
                }
            }

            impl Suffix
            {
                /// Returns whether the `Suffix` value is the `Default` variant.
                pub fn is_default(&self) -> bool
                {
                    match *self
                    {
                        Suffix::Default => true,
                        _ => false
                    }
                }
                /// Returns whether the `Suffix` value is the `Some(_)` variant.
                pub fn is_some(&self) -> bool
                {
                    match *self
                    {
                        Suffix::Some(_) => true,
                        _ => false
                    }
                }
                /// Returns whether the `Suffix` value is the `None` variant.
                pub fn is_none(&self) -> bool
                {
                    match *self
                    {
                        Suffix::None => true,
                        _ => false
                    }
                }
                /// Returns an `Option<char>`, using the given value in place of `Default`.
                pub fn with_default(self, default: Option<char>) -> Option<char>
                {
                    match self
                    {
                        Suffix::None => None,
                        Suffix::Some(ch) => Some(ch),
                        Suffix::Default => default
                    }
                }
            }

            impl Default for Suffix
            {
                fn default() -> Suffix { Suffix::Default }
            }
            /// Performs completion for `Prompter` when triggered by a user input sequence
            pub trait Completer<Term: Terminal>: Send + Sync
            {
                /// Returns the set of possible completions for the prefix `word`.
                fn complete(&self, word: &str, prompter: &Prompter<Term>, start: usize, end: usize) -> 
                Option<Vec<Completion>>;

                /// Returns the starting position of the word under the cursor.
                fn word_start(&self, line: &str, end: usize, prompter: &Prompter<Term>) -> usize
                { word_break_start(&line[..end], prompter.word_break_chars()) }

                /// Quotes a possible completion for insertion into input.
                fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }

                /// Unquotes a piece of user input before searching for completions.
                fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> { Borrowed(word) }
            }

            /// `Completer` type that performs no completion
            pub struct DummyCompleter;
            impl<Term: Terminal> Completer<Term> for DummyCompleter
            {
                fn complete(&self, _word: &str, _reader: &Prompter<Term>, _start: usize, _end: usize) -> 
                Option<Vec<Completion>>
                { None }
            }

            /// Performs completion by searching for filenames matching the word prefix.
            pub struct PathCompleter;
            impl<Term: Terminal> Completer<Term> for PathCompleter
            {
                fn complete(&self, word: &str, _reader: &Prompter<Term>, _start: usize, _end: usize) -> 
                Option<Vec<Completion>>
                { Some(complete_path(word)) }

                fn word_start(&self, line: &str, end: usize, _reader: &Prompter<Term>) -> usize 
                { escaped_word_start(&line[..end]) }

                fn quote<'a>(&self, word: &'a str) -> Cow<'a, str> { escape(word) }
                fn unquote<'a>(&self, word: &'a str) -> Cow<'a, str> { unescape(word) }
            }

            /// Returns a sorted list of paths whose prefix matches the given path.
            pub fn complete_path(path: &str) -> Vec<Completion>
            {
                let (base_dir, fname) = split_path(path);
                let mut res = Vec::new();
                let lookup_dir = base_dir.unwrap_or(".");

                if let Ok(list) = read_dir(lookup_dir)
                {
                    for ent in list
                    {
                        if let Ok(ent) = ent
                        {
                            let ent_name = ent.file_name();
                            
                            if let Ok(path) = ent_name.into_string()
                            {
                                if path.starts_with(fname)
                                {
                                    let (name, display) = if let Some(dir) = base_dir
                                    {
                                        (format!("{}{}{}", dir, MAIN_SEPARATOR, path),
                                            Some(path))
                                    }
                                    else { (path, None) };

                                    let is_dir = ent.metadata().ok().map_or(false, |m| m.is_dir());

                                    let suffix = if is_dir { Suffix::Some(MAIN_SEPARATOR) } 
                                    else { Suffix::Default };

                                    res.push(Completion
                                    {
                                        completion: name,
                                        display: display,
                                        suffix: suffix,
                                    });
                                }
                            }
                        }
                    }
                }

                res.sort_by(|a, b| a.display_str().cmp(b.display_str()));
                res
            }
            /// Returns the start position of the word that ends at the end of the string.
            pub fn word_break_start(s: &str, word_break: &str) -> usize
            {
                let mut start = s.len();
                
                for (idx, ch) in s.char_indices().rev()
                {
                    if word_break.contains(ch) { break; }
                    start = idx;
                }

                start
            }
            /// Returns the start position of a word with non-word characters escaped by backslash (`\\`).
            pub fn escaped_word_start(s: &str) -> usize
            {
                let mut chars = s.char_indices().rev();
                let mut start = s.len();

                while let Some((idx, ch)) = chars.next()
                {
                    if needs_escape(ch)
                    {
                        let n =
                        {
                            let mut n = 0;

                            loop
                            {
                                let mut clone = chars.clone();
                                let ch = match clone.next()
                                {
                                    Some((_, ch)) => ch,
                                    None => break
                                };

                                if ch == '\\'
                                {
                                    chars = clone;
                                    n += 1;
                                } 
                                else { break; }
                            }
                            n
                        };

                        if n % 2 == 0 { break; }
                    }

                    start = idx;
                }

                start
            }
            /// Escapes a word by prefixing a backslash (`\\`) to non-word characters.
            pub fn escape(s: &str) -> Cow<str>
            {
                let n = s.chars().filter(|&ch| needs_escape(ch)).count();
                if n == 0 { Borrowed(s) } 
                else
                {
                    let mut res = String::with_capacity(s.len() + n);

                    for ch in s.chars()
                    {
                        if needs_escape(ch) { res.push('\\'); }
                        res.push(ch);
                    }

                    Owned(res)
                }
            }
            /// Unescapes a word by removing the backslash (`\\`) from escaped characters.
            pub fn unescape(s: &str) -> Cow<str>
            {
                if s.contains('\\')
                {
                    let mut res = String::with_capacity(s.len());
                    let mut chars = s.chars();

                    while let Some(ch) = chars.next()
                    {
                        if ch == '\\'
                        {
                            if let Some(ch) = chars.next() { res.push(ch); }
                        } 
                        else { res.push(ch); }
                    }

                    Owned(res)
                } else {
                    Borrowed(s)
                }
            }

            fn needs_escape(ch: char) -> bool
            {
                match ch
                {
                    ' ' | '\t' | '\n' | '\\' => true,
                    _ => false
                }
            }

            fn split_path(path: &str) -> (Option<&str>, &str)
            {
                match path.rfind(is_separator)
                {
                    Some(pos) => (Some(&path[..pos]), &path[pos + 1..]),
                    None => (None, path)
                }
            }
        }
        pub use self::complete::{Completer, Completion, Suffix};
        pub mod function
        {
            //! Provides the `Function` trait for implementing custom `Prompter` commands
            use ::
            {
                prompt::lines::
                {
                    command::Category,
                    prompter::Prompter,
                    terminal::Terminal,
                },
                *,
            };
            /// Implements custom functionality for a `Prompter` command
            pub trait Function<Term: Terminal>: Send + Sync
            {
                /// Executes the function.
                fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()>;
                /// Returns the command category.
                fn category(&self) -> Category { Category::Other }
            }

            impl<F, Term: Terminal> Function<Term> for F where
            F: Send + Sync,
            F: Fn(&mut Prompter<Term>, i32, char) -> io::Result<()> 
            {
                fn execute(&self, prompter: &mut Prompter<Term>, count: i32, ch: char) -> io::Result<()> 
                { self(prompter, count, ch) }
            }
        }
        pub use self::function::Function;
        pub mod inputrc
        {
            //! Parses configuration files in the format of GNU Readline `inputrc`
            use ::
            {
                char::{ from_u32 },
                fs::{ File },
                io::{ stderr, Read, Write },
                path::{ Path },
                prompt::lines::
                {
                    chars::{ ctrl, meta, parse_char_name },
                    command::{ Command },
                },
                str::{ Chars, Lines },
                *,
            };
            /// Parsed configuration directive
            #[derive(Clone, Debug)]
            pub enum Directive
            {
                /// Bind construct; `"input-sequence": command-or-macro`
                Bind(String, Command),
                /// Conditional construct;
                Conditional
                {
                    /// Value name; if `None`, value refers to application name
                    name: Option<String>,
                    /// Value to compare
                    value: String,
                    /// Group of directives evaluated when condition is true
                    then_group: Vec<Directive>,
                    /// Group of directives evaluated when condition is false
                    else_group: Vec<Directive>,
                },
                /// Set variable; `set name value`
                SetVariable(String, String),
            }
            /// Parses the named file and returns contained directives.
            pub fn parse_file<P: ?Sized>(filename: &P) -> Option<Vec<Directive>> where 
            P: AsRef<Path> 
            {
                let filename = filename.as_ref();
                let mut f = match File::open(filename)
                {
                    Ok(f) => f,
                    Err(e) =>
                    {
                        let _ = writeln!(stderr(), "linefeed: {}: {}", filename.display(), e);
                        return None;
                    }
                };

                let mut buf = String::new();
                if let Err(e) = f.read_to_string(&mut buf)
                {
                    let _ = writeln!(stderr(), "{}: {}", filename.display(), e);
                    return None;
                }

                Some(parse_text(filename, &buf))
            }
            /// Parses some text and returns contained directives.
            pub fn parse_text<P: ?Sized>(name: &P, line: &str) -> Vec<Directive> where 
            P: AsRef<Path>
            {
                let mut p = Parser::new(name.as_ref(), line);
                p.parse()
            }

            struct Parser<'a>
            {
                lines: Lines<'a>,
                filename: &'a Path,
                line_num: usize,
            }

            enum Token<'a>
            {
                /// Colon; `:`
                Colon,
                /// Equal; `=`
                Equal,
                /// Conditional or other special directive; `$word`
                SpecialWord(&'a str),
                /// Double-quoted string; `"foo"`
                String(String),
                /// Bare word; `foo`
                Word(&'a str),
                /// Invalid token
                Invalid,
            }

            impl<'a> Parser<'a>
            {
                pub fn new(filename: &'a Path, text: &'a str) -> Parser<'a>
                {
                    Parser
                    {
                        lines: text.lines(),
                        filename: filename,
                        line_num: 0,
                    }
                }

                fn next_line(&mut self) -> Option<&'a str>
                {
                    self.lines.next().map(|line|
                    {
                        self.line_num += 1;
                        line.trim()
                    })
                }

                fn parse(&mut self) -> Vec<Directive>
                {
                    let mut dirs = Vec::new();

                    while let Some(line) = self.next_line()
                    {
                        if line.starts_with('#') { continue; }

                        let mut tokens = Tokens::new(line);
                        if let Some(Token::SpecialWord("include")) = tokens.next()
                        {
                            let path = tokens.line;

                            if let Some(d) = parse_file(Path::new(path)) { dirs.extend(d); }

                            continue;
                        }

                        if let Some(dir) = self.parse_line(line) { dirs.push(dir); }
                    }

                    dirs
                }

                fn parse_conditional(&mut self) -> (Vec<Directive>, Vec<Directive>)
                {
                    let mut then_group = Vec::new();
                    let mut else_group = Vec::new();
                    let mut parse_else = false;

                    loop
                    {
                        let line = match self.next_line()
                        {
                            Some(line) => line,
                            None =>
                            {
                                self.error("missing $endif directive");
                                break;
                            }
                        };

                        if line.starts_with('#') { continue; }

                        let mut tokens = Tokens::new(line);
                        let start = match tokens.next()
                        {
                            Some(tok) => tok,
                            None => continue
                        };

                        match start
                        {
                            Token::SpecialWord("else") =>
                            {
                                if parse_else { self.error("duplicate $else directive"); } 
                                else { parse_else = true; }
                            }

                            Token::SpecialWord("endif" ) => { break; }

                            _ =>
                            {
                                if let Some(dir) = self.parse_line(line)
                                {
                                    if parse_else { else_group.push(dir); } 
                                    else { then_group.push(dir); }
                                }
                            }
                        }
                    }

                    (then_group, else_group)
                }

                fn parse_line(&mut self, line: &str) -> Option<Directive>
                {
                    let mut tokens = Tokens::new(line);
                    let start = tokens.next()?;
                    let dir = match start
                    {
                        Token::SpecialWord("if") =>
                        {
                            let name = match tokens.next()
                            {
                                Some(Token::Word(w)) => w,
                                _ =>
                                {
                                    self.invalid();
                                    return None;
                                }
                            };

                            let (name, value) = match tokens.next()
                            {
                                Some(Token::Equal) =>
                                {
                                    let value = match tokens.next()
                                    {
                                        Some(Token::Word(w)) => w,
                                        None => "",
                                        _ =>
                                        {
                                            self.invalid();
                                            return None;
                                        }
                                    };

                                    (Some(name), value)
                                }

                                None => (None, name),
                                _ =>
                                {
                                    self.invalid();
                                    return None;
                                }
                            };

                            let (then_group, else_group) = self.parse_conditional();

                            Directive::Conditional{
                                name: name.map(|s| s.to_owned()),
                                value: value.to_owned(),
                                then_group: then_group,
                                else_group: else_group,
                            }
                        }
                        Token::SpecialWord("else") => {
                            self.error("$else without matching $if directive");
                            return None;
                        }
                        Token::SpecialWord("endif") => {
                            self.error("$endif without matching $if directive");
                            return None;
                        }
                        Token::String(seq) => {
                            match tokens.next() {
                                Some(Token::Colon) => (),
                                _ => {
                                    self.invalid();
                                    return None;
                                }
                            }

                            match tokens.next() {
                                Some(Token::Word(value)) =>
                                    Directive::Bind(seq, Command::from_string(value)),
                                Some(Token::String(out)) =>
                                    Directive::Bind(seq, Command::Macro(out.to_owned().into())),
                                _ => {
                                    self.invalid();
                                    return None;
                                }
                            }
                        }
                        Token::Word("set") => {
                            let name = match tokens.next() {
                                Some(Token::Word(w)) => w,
                                _ => {
                                    self.invalid();
                                    return None;
                                }
                            };

                            let rest = tokens.line;

                            let value = match tokens.next() {
                                Some(Token::String(s)) => s,
                                Some(Token::Word(_)) => rest.to_owned(),
                                _ => {
                                    self.invalid();
                                    return None;
                                }
                            };

                            Directive::SetVariable(name.to_owned(), value)
                        }
                        Token::Word(name) => {
                            match tokens.next() {
                                Some(Token::Colon) => (),
                                _ => {
                                    self.invalid();
                                    return None;
                                }
                            }

                            let seq = match parse_char_name(name) {
                                Some(seq) => seq,
                                None => {
                                    self.invalid();
                                    return None;
                                }
                            };

                            match tokens.next() {
                                Some(Token::Word(value)) =>
                                    Directive::Bind(seq, Command::from_string(value)),
                                Some(Token::String(macro_seq)) =>
                                    Directive::Bind(seq, Command::Macro(macro_seq.to_owned().into())),
                                _ => {
                                    self.invalid();
                                    return None;
                                }
                            }
                        }
                        _ => {
                            self.invalid();
                            return None;
                        }
                    };

                    Some(dir)
                }

                fn error(&self, msg: &str)
                {
                    let _ = writeln!(stderr(), "linefeed: {} line {}: {}", self.filename.display(), self.line_num, msg);
                }

                fn invalid(&self)
                {
                    self.error("invalid directive");
                }
            }

            struct Tokens<'a>
            {
                line: &'a str,
            }

            impl<'a> Tokens<'a>
            {
                fn new(line: &str) -> Tokens
                {
                    Tokens
                    {
                        line: line,
                    }
                }
            }

            impl<'a> Iterator for Tokens<'a>
            {
                type Item = Token<'a>;

                fn next(&mut self) -> Option<Token<'a>>
                {
                    let ch = self.line.chars().next()?;
                    let tok = match ch
                    {
                        ':' =>
                        {
                            self.line = self.line[1..].trim_start();
                            Token::Colon
                        }
                        
                        '=' =>
                        {
                            self.line = self.line[1..].trim_start();
                            Token::Equal
                        }
                        
                        '$' =>
                        {
                            let (word, rest) = parse_word(&self.line[1..]);
                            self.line = rest.trim_start();
                            Token::SpecialWord(word)
                        }
                        
                        '"' =>
                        {
                            let (tok, rest) = parse_string(self.line);
                            self.line = rest.trim_start();
                            tok
                        }
                        
                        _ =>
                        {
                            let (word, rest) = parse_word(self.line);
                            self.line = rest.trim_start();
                            Token::Word(word)
                        }
                    };

                    Some(tok)
                }
            }

            fn parse_escape(chars: &mut Chars) -> Option<String>
            {
                let ch = chars.next()?;
                let esc = match ch
                {
                    'C'  =>
                    {
                        match chars.next()
                        {
                            Some('-') => (),
                            _ => return None
                        }
                        ctrl(chars.next()?)
                    }
                    
                    'M'  =>
                    {
                        match chars.next()
                        {
                            Some('-') => (),
                            _ => return None
                        }
                        return Some(meta(chars.next()?));
                    }
                    
                    'e'  => '\x1b',
                    '\\' => '\\',
                    '"'  => '"',
                    '\'' => '\'',
                    'a'  => '\x07',
                    'b'  => '\x08',
                    'd'  => '\x7f',
                    'f'  => '\x0c',
                    'n'  => '\n',
                    'r'  => '\r',
                    't'  => '\t',
                    'u'  =>
                    {
                        match chars.next()
                        {
                            Some('{') => (),
                            _ => return None
                        }

                        let mut n = 0;

                        for _ in 0..6
                        {
                            match chars.clone().next().and_then(|ch| ch.to_digit(16))
                            {
                                Some(digit) =>
                                {
                                    chars.next();
                                    n *= 16;
                                    n += digit;
                                }
                                None => break
                            }
                        }

                        match chars.next()
                        {
                            Some('}') => (),
                            _ => return None
                        }

                        from_u32(n)?
                    }
                    'v'  => '\x0b',
                    'x'  =>
                    {
                        let mut n = 0;

                        for _ in 0..2
                        {
                            let digit = chars.clone().next()?.to_digit(16)? as u8;
                            chars.next();
                            n <<= 4;
                            n |= digit;
                        }

                        n as char
                    }
                    
                    '0' ..= '3' => 
                    {
                        let mut n = ch as u8 - b'0';

                        for _ in 0..2 
                        {
                            let digit = chars.clone().next()?.to_digit(8)? as u8;
                            chars.next();
                            n <<= 3;
                            n |= digit;
                        }

                        n as char
                    }
                    _ => return None
                };

                Some(esc.to_string())
            }

            fn parse_string(s: &str) -> (Token, &str)
            {
                let mut chars = s.chars();
                let mut res = String::new();
                chars.next();

                while let Some(ch) = chars.next()
                {
                    match ch
                    {
                        '"' => return (Token::String(res), chars.as_str()),
                        '\\' =>
                        {
                            match parse_escape(&mut chars)
                            {
                                Some(esc ) => { res.push_str(&esc); }
                                None => break
                            }
                        }
                        ch => res.push(ch)
                    }
                }

                (Token::Invalid, "")
            }

            fn parse_word(s: &str) -> (&str, &str)
            {
                let mut chars = s.char_indices();

                loop
                {
                    let mut clone = chars.clone();
                    match clone.next()
                    {
                        Some((ind, ch)) if ch == ':' || ch == '"' || ch == '=' || ch.is_whitespace() =>
                        { return (&s[..ind], &s[ind..]); }
                        None => { return (s, ""); }
                        _ => ()
                    }

                    chars = clone;
                }
            }
        }
        pub mod interface
        {
            //! Provides the main interface to interactive input reader
            use ::
            {
                borrow::{ Cow },
                fs::{ File, OpenOptions },
                io::{ self, BufRead, BufReader, BufWriter, Read as _, Seek, SeekFrom, Write as _, },
                path::{ Path },
                prompt::lines::
                {
                    command::Command::{ self, * },
                    complete::{Completer},
                    function::Function,
                    inputrc::Directive,
                    reader::{Read, Reader, ReadLock, ReadResult},
                    terminal::{DefaultTerminal, Signal, Terminal},
                    variables::Variable,
                    writer::{Write, Writer, WriteLock},
                },
                sync::{ Arc, Mutex, MutexGuard },
                time::{ Duration },
                *,
            };
            /// The main interface to input reading and other terminal operations.
            pub struct Interface<Term: Terminal>
            {
                term: Term,
                write: Mutex<Write>,
                read: Mutex<Read<Term>>,
            }

            impl Interface<DefaultTerminal>
            {
                /// Creates a new `Interface` with the given application name.
                pub fn new<T>(application: T) -> io::Result<Interface<DefaultTerminal>> where 
                T: Into<Cow<'static, str>>
                {
                    let term = DefaultTerminal::new()?;
                    Interface::with_term(application, term)
                }
            }

            impl<Term: Terminal> Interface<Term>
            {
                /// Creates a new `Interface` instance with a particular terminal implementation.
                pub fn with_term<T>(application: T, term: Term) -> io::Result<Interface<Term>> where 
                T: Into<Cow<'static, str>>
                {
                    let size = term.lock_write().size()?;
                    let read = Read::new(&term, application.into());
                    Ok(Interface
                    {
                        term: term,
                        write: Mutex::new(Write::new(size)),
                        read: Mutex::new(read),
                    })
                }
                /// Acquires the read lock and returns a `Reader` instance.
                pub fn lock_reader(&self) -> Reader<Term> { Reader::new(self, self.lock_read()) }
                /// Acquires the write lock and returns a `Writer` instance.
                pub fn lock_writer_append(&self) -> io::Result<Writer<Term>> { Writer::with_lock(self.lock_write(), false) }
                /// Acquires the write lock and returns a `Writer` instance.
                pub fn lock_writer_erase(&self) -> io::Result<Writer<Term>> { Writer::with_lock(self.lock_write(), true) }

                fn lock_read(&self) -> ReadLock<Term>
                {
                    ReadLock::new
                    (
                        self.term.lock_read(),
                        self.read.lock().expect("Interface::lock_read")
                    )
                }

                pub(crate) fn lock_write(&self) -> WriteLock<Term>
                {
                    WriteLock::new
                    (
                        self.term.lock_write(),
                        self.write.lock().expect("Interface::lock_write")
                    )
                }

                pub(crate) fn lock_write_data(&self) -> MutexGuard<Write>
                {
                    self.write.lock().expect("Interface::lock_write_data")
                }
            }
            /// ## Locking
            /// The following methods internally acquire the read lock.
            /// The lock is released before the method returns.
            impl<Term: Terminal> Interface<Term>
            {
                /// Interactively reads a line from the terminal device.
                pub fn read_line(&self) -> io::Result<ReadResult> { self.lock_reader().read_line() }
                /// Performs one step of the interactive `read_line` loop.
                pub fn read_line_step(&self, timeout: Option<Duration>) -> io::Result<Option<ReadResult>> 
                { self.lock_reader().read_line_step(timeout) }
                /// Cancels an in-progress `read_line` operation.
                pub fn cancel_read_line(&self) -> io::Result<()> { self.lock_reader().cancel_read_line() }
                /// Returns a clone of the current completer instance.
                pub fn completer(&self) -> Arc<dyn Completer<Term>> { self.lock_reader().completer().clone() }
                /// Replaces the current completer, returning the previous instance.
                pub fn set_completer(&self, completer: Arc<dyn Completer<Term>>) -> Arc<dyn Completer<Term>>
                { self.lock_reader().set_completer(completer) }
                /// Returns the value of the named variable or `None` if no such variable exists.
                pub fn get_variable(&self, name: &str) -> Option<Variable> { self.lock_reader().get_variable(name) }
                /// Sets the value of the named variable and returns the previous value.
                pub fn set_variable(&self, name: &str, value: &str) -> Option<Variable> 
                { self.lock_reader().set_variable(name, value) }
                /// Returns whether the given `Signal` is ignored.
                pub fn ignore_signal(&self, signal: Signal) -> bool { self.lock_reader().ignore_signal(signal) }
                /// Sets whether the given `Signal` will be ignored.
                pub fn set_ignore_signal(&self, signal: Signal, set: bool) 
                { self.lock_reader().set_ignore_signal(signal, set) }
                /// Returns whether the given `Signal` is reported.
                pub fn report_signal(&self, signal: Signal) -> bool { self.lock_reader().report_signal(signal) }
                /// Sets whether the given `Signal` is reported.
                pub fn set_report_signal(&self, signal: Signal, set: bool) 
                { self.lock_reader().set_report_signal(signal, set) }
                /// Binds a sequence to a command.
                pub fn bind_sequence<T>(&self, seq: T, cmd: Command) -> Option<Command> where 
                T: Into<Cow<'static, str>> 
                {
                    self.lock_reader().bind_sequence(seq, cmd)
                }
                /// Binds a sequence to a command, if and only if the given sequence is not already bound to a command.
                pub fn bind_sequence_if_unbound<T>(&self, seq: T, cmd: Command) -> bool where 
                T: Into<Cow<'static, str>> 
                { self.lock_reader().bind_sequence_if_unbound(seq, cmd) }

                /// Removes a binding for the given sequence.
                pub fn unbind_sequence(&self, seq: &str) -> Option<Command>
                { self.lock_reader().unbind_sequence(seq) }

                /// Defines a named function to which sequences may be bound.
                pub fn define_function<T>(&self, name: T, cmd: Arc<dyn Function<Term>>) -> 
                Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>>
                { self.lock_reader().define_function(name, cmd) }
                /// Removes a function defined with the given name.
                pub fn remove_function(&self, name: &str) -> Option<Arc<dyn Function<Term>>> 
                { self.lock_reader().remove_function(name) }
                /// Evaluates a series of configuration directives.
                pub fn evaluate_directives(&self, dirs: Vec<Directive>) 
                { self.lock_reader().evaluate_directives(&self.term, dirs) }
                /// Evaluates a single configuration directive.
                pub fn evaluate_directive(&self, dir: Directive) { self.lock_reader().evaluate_directive(&self.term, dir) }
            }
            /// ## Locking
            /// The following methods internally acquire the write lock.
            /// The lock is released before the method returns.
            impl<Term: Terminal> Interface<Term>
            {
                /// Returns the current input buffer.
                pub fn buffer(&self) -> String { self.lock_write().buffer.to_owned() }
                /// Returns the current number of history entries.
                pub fn history_len(&self) -> usize { self.lock_write().history_len() }
                /// Returns the maximum number of history entries.
                pub fn history_size(&self) -> usize { self.lock_write().history_size() }
                /// Save history entries to the specified file.
                pub fn save_history<P: AsRef<Path>>(&self, path: P) -> io::Result<()>
                {
                    let path = path.as_ref();
                    let mut w = self.lock_write();
                    if !path.exists() || w.history_size() == !0 { self.append_history(path, &w)?; } 
                    else { self.rewrite_history(path, &w)?; }
                    w.reset_new_history();
                    Ok(())
                }

                fn append_history<P: AsRef<Path>>(&self, path: P, w: &WriteLock<Term>) -> io::Result<()>
                {
                    let file = OpenOptions::new()
                    .append(true)
                    .create(true)
                    .open(path.as_ref())?;
                    self.append_history_to(&file, w)
                }

                fn append_history_to(&self, file: &File, w: &WriteLock<Term>) -> io::Result<()>
                {
                    let mut wtr = BufWriter::new(file);

                    for entry in w.new_history()
                    {
                        wtr.write_all(entry.as_bytes())?;
                        wtr.write_all(b"\n")?;
                    }

                    wtr.flush()
                }

                fn rewrite_history<P: AsRef<Path>>(&self, path: P, w: &WriteLock<Term>) -> io::Result<()>
                {
                    fn nth_line(s: &str, n: usize) -> Option<usize>
                    {
                        let start = s.as_ptr() as usize;
                        s.lines().nth(n).map(|s| s.as_ptr() as usize - start)
                    }

                    let mut file = OpenOptions::new()
                    .create(true)
                    .read(true)
                    .write(true)
                    .open(path.as_ref())?;

                    let mut hist = String::new();
                    file.read_to_string(&mut hist)?;
                    let n_lines = hist.lines().count();
                    let n = n_lines.saturating_sub( w.history_size() - w.new_history_entries());

                    if n != 0 
                    {
                        if let Some(pos) = nth_line(&hist, n)
                        {
                            file.seek(SeekFrom::Start(0))?;
                            file.write_all(hist[pos..].as_bytes())?;
                            let n = file.seek(SeekFrom::Current(0))?;
                            file.set_len(n)?;
                        }
                    }

                    self.append_history_to(&file, w)
                }
                /// Load history entries from the specified file.
                pub fn load_history<P: AsRef<Path>>(&self, path: P) -> io::Result<()>
                {
                    let mut writer = self.lock_write();
                    let file = File::open(&path)?;
                    let rdr = BufReader::new(file);
                    for line in rdr.lines()
                    {
                        writer.add_history(line?);
                    }
                    writer.reset_new_history();
                    Ok(())
                }
                /// Writes formatted text to the terminal display.
                pub fn write_fmt(&self, args: fmt::Arguments) -> io::Result<()>
                {
                    let s = args.to_string();
                    self.write_str(&s)
                }

                fn write_str(&self, line: &str) -> io::Result<()> { self.lock_writer_erase()?.write_str(line) }
            }
            /// ## Locking
            /// The following methods internally acquire both the read and write locks.
            /// The locks are released before the method returns.
            impl<Term: Terminal> Interface<Term>
            {
                /// Sets the prompt that will be displayed when `read_line` is called.
                pub fn set_prompt(&self, prompt: &str) -> io::Result<()> { self.lock_reader().set_prompt(prompt) }

                /// Sets the input buffer to the given string.
                pub fn set_buffer(&self, buf: &str) -> io::Result<()> { self.lock_reader().set_buffer(buf) }
                /// Sets the cursor position in the input buffer.
                pub fn set_cursor(&self, pos: usize) -> io::Result<()> { self.lock_reader().set_cursor(pos) }
                /// Adds a line to history.
                pub fn add_history(&self, line: String) { self.lock_reader().add_history(line); }
                /// Adds a line to history, unless it is identical to the most recent entry.
                pub fn add_history_unique(&self, line: String) { self.lock_reader().add_history_unique(line); }
                /// Removes all history entries.
                pub fn clear_history(&self) { self.lock_reader().clear_history(); }
                /// Removes the history entry at the given index.
                pub fn remove_history(&self, idx: usize) { self.lock_reader().remove_history(idx); }
                /// Sets the maximum number of history entries.
                pub fn set_history_size(&self, n: usize) { self.lock_reader().set_history_size(n); }
                /// Truncates history to the only the most recent `n` entries.
                pub fn truncate_history(&self, n: usize) { self.lock_reader().truncate_history(n); }
            }
        }
        pub use self::interface::Interface;
        pub mod memory
        {
            //! Implements an in-memory `Terminal` interface.
            use ::
            {
                cmp::{ min },
                iter::{ repeat },
                prompt::lines::terminal::{ CursorMode, RawRead, SignalSet, Size, Terminal, TerminalReader, TerminalWriter },
                sync::{ Arc, Mutex, MutexGuard },
                time::{ Duration },
                *,
            };
            /// Default size of a `MemoryTerminal` buffer
            pub const DEFAULT_SIZE: Size = Size
            {
                columns: 80,
                lines: 24,
            };
            /// Implements an in-memory `Terminal` interface.
            #[derive(Clone, Debug)]
            pub struct MemoryTerminal
            {
                write: Arc<Mutex<Writer>>,
                read: Arc<Mutex<Reader>>,
            }

            #[derive(Debug)]
            struct Writer
            {
                memory: Vec<char>,
                input: Vec<u8>,
                col: usize,
                line: usize,
                cursor_mode: CursorMode,
                size: Size,
            }

            #[derive(Debug)]
            struct Reader
            {
                input: Vec<u8>,
                resize: Option<Size>,
            }
            /// Holds the lock on read operations of a `MemoryTerminal`.
            pub struct MemoryReadGuard<'a>(MutexGuard<'a, Reader>);
            /// Holds the lock on write operations of a `MemoryTerminal`.
            pub struct MemoryWriteGuard<'a>(MutexGuard<'a, Writer>);

            impl MemoryTerminal 
            {
                /// Returns a new `MemoryTerminal` with the default buffer size.
                pub fn new() -> MemoryTerminal { MemoryTerminal::default() }
                /// Returns a new `MemoryTerminal` with the given buffer size.
                pub fn with_size(size: Size) -> MemoryTerminal
                {
                    MemoryTerminal
                    {
                        read: Arc::new(Mutex::new(Reader::new())),
                        write: Arc::new(Mutex::new(Writer::new(size))),
                    }
                }
                /// Clears the terminal buffer and places the cursor at `(0, 0)`.
                pub fn clear_all(&self) { self.lock_writer().clear_all(); }
                /// Clears all characters beginning at the cursor and ending at buffer end.
                pub fn clear_to_end(&self) { self.lock_writer().clear_to_end(); }
                /// Clears the input buffer.
                pub fn clear_input(&self) { self.lock_reader().clear_input(); }
                /// Returns whether any input remains to be read.
                pub fn has_input(&self) -> bool { self.lock_reader().has_input() }
                /// Returns an iterator over lines in the buffer.
                pub fn lines(&self) -> Lines
                {
                    Lines
                    {
                        writer: self.lock_writer(),
                        line: 0,
                    }
                }
                /// Moves the cursor up `n` cells.
                pub fn move_up(&self, n: usize) { self.lock_writer().move_up(n); }
                /// Moves the cursor down `n` cells.
                pub fn move_down(&self, n: usize) { self.lock_writer().move_down(n); }
                /// Moves the cursor left `n` cells.
                pub fn move_left(&self, n: usize) { self.lock_writer().move_left(n); }
                /// Moves the cursor right `n` cells.
                pub fn move_right(&self, n: usize) { self.lock_writer().move_right(n); }
                /// Moves the cursor to the first column of the current line.
                pub fn move_to_first_column(&self) { self.lock_writer().move_to_first_column() }
                /// Pushes a character sequence to the back of the input queue.
                pub fn push_input(&self, s: &str) { self.lock_reader().push_input(s.as_bytes()); }
                /// Reads some input from the input buffer.
                pub fn read_input(&self, buf: &mut [u8]) -> usize { self.lock_reader().read_input(buf) }
                /// Changes the size of the terminal buffer.
                pub fn resize(&self, new_size: Size)
                {
                    self.lock_writer().resize(new_size);
                    self.lock_reader().resize(new_size);
                }
                /// Moves the contents of the buffer up `n` lines.
                pub fn scroll_up(&self, n: usize) { self.lock_writer().scroll_up(n); }
                /// Returns the `(line, column)` position of the cursor.
                pub fn cursor(&self) -> (usize, usize)
                {
                    let r = self.lock_writer();
                    (r.line, r.col)
                }
                /// Sets the cursor mode.
                pub fn set_cursor_mode(&self, mode: CursorMode) { self.lock_writer().set_cursor_mode(mode); }
                /// Returns the cursor mode.
                pub fn cursor_mode(&self) -> CursorMode { self.lock_writer().cursor_mode() }
                /// Returns the size of the terminal buffer.
                pub fn size(&self) -> Size { self.lock_writer().size }
                /// Writes some text into the buffer.
                pub fn write(&self, s: &str) { self.lock_writer().write(s); }

                fn lock_reader(&self) -> MutexGuard<Reader> { self.read.lock().unwrap() }

                fn lock_writer(&self) -> MutexGuard<Writer> { self.write.lock().unwrap() }
            }

            impl Default for MemoryTerminal
            {
                fn default() -> MemoryTerminal { MemoryTerminal::with_size(DEFAULT_SIZE) }
            }

            impl Reader
            {
                fn new() -> Reader
                {
                    Reader
                    {
                        input: Vec::new(),
                        resize: None,
                    }
                }

                fn has_input(&mut self) -> bool { self.resize.is_some() || !self.input.is_empty() }

                fn clear_input(&mut self) { self.input.clear(); }

                fn push_input(&mut self, bytes: &[u8]) { self.input.extend(bytes); }

                fn read_input(&mut self, buf: &mut [u8]) -> usize
                {
                    let n = min(buf.len(), self.input.len());
                    buf[..n].copy_from_slice(&self.input[..n]);
                    let _ = self.input.drain(..n);
                    n
                }

                fn resize(&mut self, size: Size) { self.resize = Some(size); }
            }

            impl Writer 
            {
                fn new(size: Size) -> Writer
                {
                    assert!(size.lines != 0 && size.columns != 0, "zero-area terminal buffer: {:?}", size);
                    let n_chars = size.lines * size.columns;

                    Writer
                    {
                        memory: vec![' '; n_chars],
                        input: Vec::new(),
                        col: 0,
                        line: 0,
                        cursor_mode: CursorMode::Normal,
                        size: size,
                    }
                }

                fn clear_all(&mut self) 
                {
                    for ch in &mut self.memory
                    {
                        *ch = ' ';
                    }
                    self.col = 0;
                    self.line = 0;
                }

                fn clear_to_end(&mut self)
                {
                    let idx = self.index();
                    for ch in &mut self.memory[idx..]
                    {
                        *ch = ' ';
                    }
                }

                fn move_up(&mut self, n: usize) { self.line = self.line.saturating_sub(n); }

                fn move_down(&mut self, n: usize) { self.line = min(self.size.lines - 1, self.line + n); }

                fn move_left(&mut self, n: usize) { self.col = self.col.saturating_sub(n); }

                fn move_right(&mut self, n: usize) { self.col = min(self.size.columns - 1, self.col + n); }

                fn move_to_first_column(&mut self) { self.col = 0; }

                fn resize(&mut self, new_size: Size)
                {
                    if self.size != new_size
                    {
                        let n_chars = new_size.lines
                        .checked_mul(new_size.columns)
                        .unwrap_or_else(|| panic!("terminal size too large: {:?}", new_size));

                        assert!(n_chars != 0, "zero-area terminal buffer: {:?}", new_size);

                        let mut new_buf = Vec::with_capacity(n_chars);

                        let (n_copy, n_extra) = if new_size.columns > self.size.columns 
                        { (self.size.columns, new_size.columns - self.size.columns) }
                        else { (new_size.columns, 0) };

                        for line in self.memory.chunks(self.size.columns).take(new_size.lines)
                        {
                            new_buf.extend(&line[..n_copy]);
                            new_buf.extend(repeat(' ').take(n_extra));
                        }

                        if new_size.lines > self.size.lines
                        {
                            let n_lines = new_size.lines - self.size.lines;
                            new_buf.extend(repeat(' ').take(n_lines * new_size.columns));
                        }

                        debug_assert_eq!(new_buf.len(), n_chars);

                        self.col = min(self.col, new_size.columns);
                        self.line = min(self.line, new_size.lines);
                        self.size = new_size;
                        self.memory = new_buf;
                    }
                }

                fn scroll_up(&mut self, n: usize)
                {
                    let chars = min(self.memory.len(), self.size.columns * n);
                    self.memory.drain(..chars);
                    self.memory.extend(repeat(' ').take(chars));
                    self.line = self.line.saturating_sub(n);
                }

                fn set_cursor_mode(&mut self, mode: CursorMode) { self.cursor_mode = mode; }

                fn cursor_mode(&self) -> CursorMode { self.cursor_mode }

                fn write(&mut self, s: &str)
                {
                    for ch in s.chars()
                    {
                        if ch == '\n' { self.advance_line(); } 
                        else if ch == '\r' { self.col = 0; } 
                        else { self.write_char(ch); }
                    }
                }

                fn advance_line(&mut self)
                {
                    self.line += 1;
                    self.col = 0;
                    if self.line == self.size.lines { self.scroll_up(1); }
                }

                fn write_char(&mut self, ch: char)
                {
                    if self.col >= self.size.columns { self.advance_line(); }

                    let idx = self.index();
                    self.memory[idx] = ch;
                    self.col += 1;
                }

                fn index(&self) -> usize { self.line * self.size.columns + self.col }
            }

            /// Iterator over lines in a `MemoryTerminal` buffer.
            pub struct Lines<'a>
            {
                writer: MutexGuard<'a, Writer>,
                line: usize,
            }

            impl<'a> Lines<'a>
            {
                /// Returns the next line in the buffer.
                pub fn next(&mut self) -> Option<&[char]>
                {
                    if self.line >= self.writer.size.lines { None } 
                    else
                    {
                        let start = self.writer.size.columns * self.line;
                        self.line += 1;
                        let end = self.writer.size.columns * self.line;
                        Some(&self.writer.memory[start..end])
                    }
                }
                /// Returns the number of lines remaining in the iterator.
                pub fn lines_remaining(&self) -> usize { self.writer.size.lines - self.line }
            }

            impl Terminal for MemoryTerminal
            {
                // No preparation needed for in-memory terminal
                type PrepareState = ();
                //type Reader = MemoryReadGuard;
                //type Writer = MemoryWriteGuard;

                fn name(&self) -> &str { "memory-terminal" }

                fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a>
                { Box::new(MemoryReadGuard(self.lock_reader())) }

                fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a>
                { Box::new(MemoryWriteGuard(self.lock_writer())) }
            }

            impl<'a> TerminalReader<MemoryTerminal> for MemoryReadGuard<'a>
            {
                fn wait_for_input(&mut self, _timeout: Option<Duration>) -> io::Result<bool>
                { Ok(!self.0.input.is_empty()) }

                fn prepare(&mut self, _block_signals: bool, _report_signals: SignalSet) -> io::Result<()> { Ok(()) }

                unsafe fn prepare_with_lock
                ( 
                    &mut self, 
                    _lock: &mut dyn TerminalWriter<MemoryTerminal>, 
                    _block_signals: bool, 
                    _report_signals: SignalSet
                ) -> io::Result<()>
                { Ok(()) }

                fn restore(&mut self, _state: ()) -> io::Result<()> { Ok(()) }

                unsafe fn restore_with_lock(&mut self, _lock: &mut dyn TerminalWriter<MemoryTerminal>, _state: ()) 
                -> io::Result<()>
                { Ok(()) }

                fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead>
                {
                    unsafe
                    {
                        if let Some(size) = self.0.resize.take() { return Ok(RawRead::Resize(size)); }
                        buf.reserve(16);
                        let cap = buf.capacity();
                        let len = buf.len();
                        let n;
                        buf.set_len(cap);
                        n = self.0.read_input(&mut buf[len..]);
                        buf.set_len(len + n);
                        Ok(RawRead::Bytes(n))
                    }
                }
            }

            impl<'a> TerminalWriter<MemoryTerminal> for MemoryWriteGuard<'a>
            {
                fn size(&self) -> io::Result<Size> { Ok(self.0.size) }

                fn clear_screen(&mut self) -> io::Result<()>
                {
                    self.0.clear_all();
                    Ok(())
                }

                fn clear_to_screen_end(&mut self) -> io::Result<()>
                {
                    self.0.clear_to_end();
                    Ok(())
                }

                fn move_up(&mut self, n: usize) -> io::Result<()>
                {
                    self.0.move_up(n);
                    Ok(())
                }

                fn move_down(&mut self, n: usize) -> io::Result<()>
                {
                    self.0.move_down(n);
                    Ok(())
                }

                fn move_left(&mut self, n: usize) -> io::Result<()>
                {
                    self.0.move_left(n);
                    Ok(())
                }

                fn move_right(&mut self, n: usize) -> io::Result<()>
                {
                    self.0.move_right(n);
                    Ok(())
                }

                fn move_to_first_column(&mut self) -> io::Result<()>
                {
                    self.0.move_to_first_column();
                    Ok(())
                }

                fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>
                {
                    self.0.set_cursor_mode(mode);
                    Ok(())
                }

                fn write(&mut self, s: &str) -> io::Result<()>
                {
                    self.0.write(s);
                    Ok(())
                }

                fn flush(&mut self) -> io::Result<()> { Ok(()) }
            }
 
        }
        pub mod prompter
        {
            //! Provides access to prompt input state
            use ::
            {
                mem::{ replace },
                mortal::
                {
                    FindResult,
                },
                ops::{ Range },
                prompt::lines::
                {
                    chars::{is_ctrl, is_printable, DELETE, EOF},
                    command::{Category, Command},
                    complete::{ Completion },
                    function::{ Function },
                    reader::{BindingIter, InputState, ReadLock, ReadResult},
                    table::{format_columns, Line, Table},
                    terminal::{CursorMode, Signal, Size, Terminal},
                    util::
                    { 
                        get_open_paren, find_matching_paren, first_word, longest_common_prefix, repeat_char, back_n_words, 
                        forward_n_words, backward_char, forward_char, backward_word, forward_word, word_start, word_end, 
                        RangeArgument, 
                    },
                    variables::{ VariableIter },
                    writer::{ BLINK_DURATION, display_str, Digit, Display, HistoryIter, PromptType, Writer, WriteLock },
                },
                sync::{ Arc },
                time::{ Instant },
                *,
            };
            /// Provides access to the current state of input while a `read_line` call is in progress.
            pub struct Prompter<'a, 'b: 'a, Term: 'b + Terminal>
            {
                pub(crate) read: &'a mut ReadLock<'b, Term>,
                write: WriteLock<'b, Term>,
            }

            impl<'a, 'b: 'a, Term: 'b + Terminal> Prompter<'a, 'b, Term>
            {
                pub(crate) fn new(read: &'a mut ReadLock<'b, Term>, write: WriteLock<'b, Term>) -> Prompter<'a, 'b, Term>
                {
                    Prompter{read, write}
                }
                /// Returns a `Writer` instance using the currently held write lock.
                pub fn writer_append<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>>
                {
                    Writer::with_ref(&mut self.write, false)
                }
                /// Returns a `Writer` instance using the currently held write lock.
                pub fn writer_erase<'c>(&'c mut self) -> io::Result<Writer<'c, 'b, Term>>
                {
                    Writer::with_ref(&mut self.write, true)
                }
                /// Resets input state at the start of `read_line`
                fn reset_input(&mut self)
                {
                    self.read.reset_data();
                    self.write.reset_data();
                }

                pub(crate) fn start_read_line(&mut self) -> io::Result<()> 
                {
                    self.read.state = InputState::NewSequence;
                    self.write.is_prompt_drawn = true;
                    self.write.update_size()?;
                    self.write.draw_prompt()
                }

                pub(crate) fn end_read_line(&mut self) -> io::Result<()>
                {
                    self.write.expire_blink()?;
                    if self.read.overwrite_mode { self.write.set_cursor_mode(CursorMode::Normal)?; }                
                    if self.write.is_prompt_drawn 
                    {
                        self.write.move_to_end()?;
                        self.write.write_str("\n")?;
                        self.write.is_prompt_drawn = false;
                    }
                    self.reset_input();
                    self.read.state = InputState::Inactive;
                    Ok(())
                }

                pub(crate) fn handle_input(&mut self, ch: char) -> io::Result<Option<ReadResult>>
                {
                    self.write.expire_blink()?;
                    
                    match self.read.state 
                    {
                        InputState::Inactive => panic!("input received in inactive state"),
                        InputState::NewSequence =>
                        {
                            if ch == EOF && self.write.buffer.is_empty()
                            {
                                self.write.write_str("\n")?;
                                self.write.is_prompt_drawn = false;
                                return Ok(Some(ReadResult::Eof));
                            }
                            else 
                            {
                                self.read.sequence.push(ch);
                                self.execute_sequence()?;
                                if self.read.input_accepted
                                {
                                    let s = replace(&mut self.write.buffer, String::new());
                                    return Ok(Some(ReadResult::Input(s)));
                                }
                            }
                        }
                        
                        InputState::ContinueSequence{expiry: _} => 
                        {
                            self.read.sequence.push(ch);
                            self.execute_sequence()?;
                            if self.read.input_accepted
                            {
                                let s = replace(&mut self.write.buffer, String::new());
                                return Ok(Some(ReadResult::Input(s)));
                            }
                        }
                        
                        InputState::Number =>
                        {
                            if let Some(digit) = ch.to_digit(10)
                            {
                                self.write.input_arg.input(digit as i32);

                                if self.write.input_arg.is_out_of_bounds()
                                {
                                    self.read.state = InputState::NewSequence;
                                    self.write.input_arg = Digit::None;
                                    self.write.explicit_arg = false;
                                    self.write.redraw_prompt(PromptType::Normal)?;
                                }
                                else { self.write.redraw_prompt(PromptType::Number)?; }
                            }
                            else
                            {
                                self.read.state = InputState::NewSequence;
                                self.write.redraw_prompt(PromptType::Normal)?;
                                self.read.macro_buffer.insert(0, ch);
                            }
                        }
                        
                        InputState::CharSearch{n, backward} => 
                        {
                            if n != 0
                            {
                                if backward { self.write.backward_search_char(n, ch)?; }
                                else { self.write.forward_search_char(n, ch)?; }
                            }
                            self.read.state = InputState::NewSequence;
                        }

                        InputState::TextSearch => 
                        {
                            if ch == DELETE
                            {
                                {
                                    let write = &mut *self.write;
                                    write.search_buffer.pop();
                                    write.last_search.clone_from(&write.search_buffer);
                                }
                                self.write.search_history_update()?;
                            }

                            else if self.is_abort(ch) { self.abort_search_history()?; }

                            else if is_ctrl(ch)
                            {
                                self.end_search_history()?;
                                self.read.macro_buffer.insert(0, ch);
                            }
                            
                            else
                            {
                                {
                                    let write = &mut *self.write;
                                    write.search_buffer.push(ch);
                                    write.last_search.clone_from(&write.search_buffer);
                                }
                                self.write.search_history_update()?;
                            }
                        }

                        InputState::CompleteIntro => 
                        {
                            match ch
                            {
                                'y' | 'Y' | ' ' =>
                                {
                                    self.write.write_str("\n")?;
                                    self.show_completions_page(0)?;
                                }
                                '\r' | '\n' =>
                                {
                                    self.write.write_str("\n")?;
                                    self.show_completions_line(0)?;
                                }
                                'q' | 'Q' | 'n' | 'N' | DELETE =>
                                {
                                    self.write.write_str("\n")?;
                                    self.end_page_completions()?;
                                }
                                _ => ()
                            }
                        }

                        InputState::CompleteMore(offset) => 
                        {
                            match ch
                            {
                                'y' | 'Y' | ' ' =>
                                {
                                    self.write.clear_prompt()?;
                                    self.show_completions_page(offset)?;
                                }
                                '\r' | '\n' =>
                                {
                                    self.write.clear_prompt()?;
                                    self.show_completions_line(offset)?;
                                }
                                'q' | 'Q' | 'n' | 'N' | DELETE =>
                                {
                                    self.write.clear_prompt()?;
                                    self.end_page_completions()?;
                                }
                                _ => ()
                            }
                        }

                        InputState::QuotedInsert(n) => 
                        {
                            if n != 0 { self.insert(n, ch)?; }
                            self.read.state = InputState::NewSequence;
                        }
                    }

                    Ok(None)
                }

                /// Returns the current buffer.
                pub fn buffer(&self) -> &str { &self.write.buffer }
                /// Returns the "backup" buffer.
                pub fn backup_buffer(&self) -> &str { &self.write.backup_buffer }
                /// Returns the command `Category` of the most recently executed command.
                pub fn last_command_category(&self) -> Category { self.read.last_cmd }
                /// Returns the set of characters that indicate a word break.
                pub fn word_break_chars(&self) -> &str { &self.read.word_break }
                /// Sets the buffer to the given value.
                pub fn set_buffer(&mut self, buf: &str) -> io::Result<()> { self.write.set_buffer(buf) }
                /// Returns the current position of the cursor.
                pub fn cursor(&self) -> usize { self.write.cursor }
                /// Sets the cursor to the given position within the buffer.
                pub fn set_cursor(&mut self, pos: usize) -> io::Result<()> { self.write.set_cursor(pos) }
                /// Sets the prompt that will be displayed when `read_line` is called.
                pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> { self.write.set_prompt(prompt) }
                /// Returns the size of the terminal at the last draw operation.
                pub fn screen_size(&self) -> Size { self.write.screen_size }
                /// Returns whether a numerical argument was explicitly supplied by the user.
                pub fn explicit_arg(&self) -> bool { self.write.explicit_arg }
                /// Returns the current input sequence.
                pub fn sequence(&self) -> &str { &self.read.sequence }
                /// Returns an iterator over bound sequences
                pub fn bindings(&self) -> BindingIter { self.read.bindings() }
                /// Returns an iterator over variable values.
                pub fn variables(&self) -> VariableIter { self.read.variables() }
                /// Returns an iterator over history entries
                pub fn history(&self) -> HistoryIter { self.write.history() }
                /// Returns the index into history currently being edited.
                pub fn history_index(&self) -> Option<usize> { self.write.history_index }
                /// Returns the current number of history entries.
                pub fn history_len(&self) -> usize { self.write.history.len() }

                fn next_history(&mut self, n: usize) -> io::Result<()> { self.write.next_history(n) }
                
                fn prev_history(&mut self, n: usize) -> io::Result<()> { self.write.prev_history(n) }

                /// Selects the history entry currently being edited by the user.
                pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()>
                { self.write.select_history_entry(new) }
                /// Returns the current set of completions.
                pub fn completions(&self) -> Option<&[Completion]>
                { self.read.completions.as_ref().map(|v| &v[..]) }
                /// Sets the current set of completions.
                pub fn set_completions(&mut self, completions: Option<Vec<Completion>>)
                { self.read.completions = completions; }
                /// Attempts to execute the current sequence.
                fn execute_sequence(&mut self) -> io::Result<()>
                {
                    match self.find_binding(&self.read.sequence)
                    {
                        FindResult::Found(cmd) =>
                        {
                            let ch = self.read.sequence.chars().last().unwrap();
                            let n = self.write.input_arg.to_i32();
                            self.read.state = InputState::NewSequence;
                            self.execute_command(cmd, n, ch)?;
                            self.read.sequence.clear();
                        }

                        FindResult::NotFound =>
                        {
                            self.read.state = InputState::NewSequence;
                            self.insert_first_char()?;
                        }
                        
                        FindResult::Incomplete =>
                        {
                            let expiry = None;
                            self.read.state = InputState::ContinueSequence{expiry};
                        }
                        
                        FindResult::Undecided(_) =>
                        {
                            let expiry = self.keyseq_expiry();
                            self.read.state = InputState::ContinueSequence{expiry};
                        }
                    }

                    Ok(())
                }

                fn force_execute_sequence(&mut self) -> io::Result<()>
                {
                    self.read.state = InputState::NewSequence;
                    match self.find_binding(&self.read.sequence)
                    {
                        FindResult::Found(cmd) |
                        FindResult::Undecided(cmd) =>
                        {
                            let ch = self.read.sequence.chars().last().unwrap();
                            let n = self.write.input_arg.to_i32();
                            self.execute_command(cmd, n, ch)?;
                            self.read.sequence.clear();
                        }
                        FindResult::NotFound => { self.insert_first_char()?; }
                        FindResult::Incomplete => unreachable!(),
                    }

                    Ok(())
                }
                /// Execute the command `SelfInsert` on the first character in the input sequence, if it is printable.
                fn insert_first_char(&mut self) -> io::Result<()>
                {
                    let (first, rest) =
                    {
                        let mut chars = self.read.sequence.chars();
                        (chars.next().unwrap(), chars.as_str().to_owned())
                    };

                    self.read.sequence.clear();

                    if is_printable(first)
                    {
                        let n = self.write.input_arg.to_i32();
                        self.execute_command(Command::SelfInsert, n, first)?;
                    }

                    if !rest.is_empty() { self.read.queue_input(&rest); }

                    Ok(())
                }

                fn find_binding(&self, seq: &str) -> FindResult<Command> { self.read.bindings.find(seq).cloned() }

                fn get_function(&self, name: &str) -> Option<&Arc<dyn Function<Term>>> { self.read.functions.get(name) }

                fn is_abort(&self, ch: char) -> bool
                {
                    let mut buf = [0; 4];
                    let s = ch.encode_utf8(&mut buf);
                    self.find_binding(&s) == FindResult::Found(Command::Abort)
                }

                fn execute_command(&mut self, cmd: Command, n: i32, ch: char) -> io::Result<()>
                {
                    let mut category = cmd.category();
                    if self.read.overwrite_mode
                    {
                        match cmd
                        {
                            Command::DigitArgument | Command::SelfInsert => (),
                            BackwardDeleteChar if n >= 0 => (),
                            _ => self.read.overwritten_chars.clear()
                        }
                    }

                    match cmd
                    {
                        Abort => (),
                        AcceptLine => { self.accept_input()?; }
                        Complete =>
                        {
                            if !self.read.disable_completion {
                                self.complete_word()?;
                            } else if is_printable(ch) {
                                self.execute_command(SelfInsert, n, ch)?;
                            }
                        }
                        InsertCompletions =>
                        {
                            if self.read.completions.is_none() {
                                self.build_completions();
                            }

                            if let Some(completions) = self.read.completions.take() {
                                self.insert_completions(&completions)?;
                                self.read.completions = Some(completions);
                            }
                        }
                        PossibleCompletions =>
                        {
                            if self.read.completions.is_none() {
                                self.build_completions();
                            }

                            if let Some(completions) = self.read.completions.take() {
                                self.show_completions(&completions)?;
                                self.read.completions = Some(completions);
                            }
                        }
                        MenuComplete =>
                        {
                            if self.read.completions.is_none() {
                                self.build_completions();
                            }

                            if n > 0 {
                                self.next_completion(n as usize)?;
                            } else {
                                self.prev_completion((-n) as usize)?;
                            }
                        }
                        MenuCompleteBackward =>
                        {
                            if self.read.completions.is_none() {
                                self.build_completions();
                            }

                            if n > 0 {
                                self.prev_completion(n as usize)?;
                            } else {
                                self.next_completion((-n) as usize)?;
                            }
                        }
                        DigitArgument =>
                        {
                            self.read.state = InputState::Number;
                            self.write.set_digit_from_char(ch);
                            self.write.redraw_prompt(PromptType::Number)?;
                        }
                        SelfInsert =>
                        {
                            if n > 0
                            {
                                let n = n as usize;
                                
                                if self.read.overwrite_mode { self.overwrite(n, ch)?; }
                                else { self.insert(n, ch)?; }

                                if self.read.blink_matching_paren
                                {
                                    if let Some(open) = get_open_paren(ch)
                                    {
                                        if let Some(pos) = find_matching_paren
                                        (
                                            &self.write.buffer[..self.write.cursor],
                                            &self.read.string_chars, open, ch
                                        )
                                        { self.blink(pos)?; }
                                    }
                                }
                            }
                        }
                        TabInsert =>
                        {
                            if n > 0 { self.insert(n as usize, '\t')?; }
                        }
                        InsertComment =>
                        {
                            if self.explicit_arg() && self.write.buffer.starts_with(&self.read.comment_begin[..])
                            {
                                self.write.move_to(0)?;
                                let n = self.read.comment_begin.len();
                                self.delete_range(..n)?;
                                self.accept_input()?;
                            }
                            
                            else
                            {
                                self.write.move_to(0)?;
                                let s = self.read.comment_begin.clone();
                                self.insert_str(&s)?;
                                self.accept_input()?;
                            }
                        }
                        BackwardChar =>
                        {
                            if n > 0 { self.write.backward_char(n as usize)?; }
                            else if n < 0 { self.write.forward_char((-n) as usize)?; }
                        }
                        ForwardChar =>
                        {
                            if n > 0 { self.write.forward_char(n as usize)?; } 
                            else if n < 0 { self.write.backward_char((-n) as usize)?; }
                        }
                        CharacterSearch =>
                        {
                            if n >= 0
                            {
                                self.read.state = InputState::CharSearch
                                {
                                    n: n as usize,
                                    backward: false,
                                }
                            }
                            else
                            {
                                self.read.state = InputState::CharSearch
                                {
                                    n: (-n) as usize,
                                    backward: true,
                                };
                            }
                        }
                        CharacterSearchBackward =>
                        {
                            if n >= 0
                            {
                                self.read.state = InputState::CharSearch
                                {
                                    n: n as usize,
                                    backward: true,
                                }
                            }
                            else
                            {
                                self.read.state = InputState::CharSearch
                                {
                                    n: (-n) as usize,
                                    backward: false,
                                };
                            }
                        }
                        BackwardWord =>
                        {
                            if n > 0 { self.backward_word(n as usize)?; }
                            else if n < 0 { self.forward_word((-n) as usize)?; }
                        }
                        ForwardWord =>
                        {
                            if n > 0
                            {
                                let pos = forward_word(n as usize,
                                    &self.write.buffer, self.write.cursor, &self.read.word_break);
                                self.write.move_to(pos)?;
                            }
                            else if n < 0
                            {
                                let pos = forward_word
                                (
                                    (-n) as usize, 
                                    &self.write.buffer, 
                                    self.write.cursor, 
                                    &self.read.word_break
                                );
                                self.write.move_to(pos)?;
                            }
                        }
                        BackwardKillLine =>
                        {
                            let r = ..self.write.cursor;
                            self.kill_range(r)?;
                        }
                        KillLine =>
                        {
                            let r = self.write.cursor..;
                            self.kill_range(r)?;
                        }
                        BackwardKillWord =>
                        {
                            if n > 0
                            {
                                let pos = backward_word
                                (
                                    n as usize,
                                    &self.write.buffer,
                                    self.write.cursor,
                                    &self.read.word_break
                                );
                                let r = pos..self.write.cursor;
                                self.kill_range(r)?;
                            }
                            else if n < 0
                            {
                                let pos = forward_word
                                (
                                    (-n) as usize,
                                    &self.write.buffer,
                                    self.write.cursor,
                                    &self.read.word_break
                                );
                                let r = self.write.cursor..pos;
                                self.kill_range(r)?;
                            }
                        }
                        KillWord =>
                        {
                            if n > 0
                            {
                                let pos = forward_word(n as usize, &self.write.buffer, self.write.cursor, &self.read.word_break);
                                let r = self.write.cursor..pos;
                                self.kill_range(r)?;
                            }
                            else if n < 0
                            {
                                let pos = backward_word((-n) as usize, &self.write.buffer, self.write.cursor, &self.read.word_break);
                                let r = pos..self.write.cursor;
                                self.kill_range(r)?;
                            }
                        }
                        UnixWordRubout =>
                        {
                            if n > 0
                            {
                                let pos = backward_word(n as usize, &self.write.buffer, self.write.cursor, " \t\n");
                                let r = pos..self.write.cursor;
                                self.kill_range(r)?;
                            }
                            else if n < 0
                            {
                                let pos = forward_word((-n) as usize, &self.write.buffer, self.write.cursor, " \t\n");
                                let r = self.write.cursor..pos;
                                self.kill_range(r)?;
                            }
                        }
                        ClearScreen => { self.write.clear_screen()?; }
                        BeginningOfLine => self.write.move_to(0)?,
                        EndOfLine => self.write.move_to_end()?,
                        BackwardDeleteChar =>
                        {
                            if n > 0
                            {
                                if self.read.overwrite_mode
                                {
                                    self.overwrite_back(n as usize)?;
                                }
                                else
                                {
                                    let pos = backward_char(n as usize, &self.write.buffer, self.write.cursor);
                                    let r = pos..self.write.cursor;
                                    self.delete_range(r)?;
                                }
                            } else if n < 0 {
                                let pos = forward_char((-n) as usize,
                                    &self.write.buffer, self.write.cursor);
                                let r = self.write.cursor..pos;
                                self.delete_range(r)?;
                            }
                        }
                        DeleteChar =>
                        {
                            if n > 0
                            {
                                let pos = forward_char(n as usize, &self.write.buffer, self.write.cursor);
                                let r = self.write.cursor..pos;
                                self.delete_range(r)?;
                            }

                            else if n < 0
                            {
                                let pos = backward_char(n as usize, &self.write.buffer, self.write.cursor);
                                let r = pos..self.write.cursor;
                                self.delete_range(r)?;
                            }
                        }
                        TransposeChars =>
                        {
                            if n != 0 && self.write.cursor != 0
                            {
                                let (src, dest);

                                if !self.explicit_arg() && self.write.cursor == self.write.buffer.len()
                                {
                                    let end = backward_char(1, &self.write.buffer, self.write.cursor);
                                    let start = backward_char(1, &self.write.buffer, end);
                                    src = start..end;
                                    dest = end..self.write.cursor;
                                }
                                else
                                {
                                    let start = backward_char(1, &self.write.buffer, self.write.cursor);
                                    let end = self.write.cursor;
                                    src = start..end;

                                    dest = if n < 0
                                    {
                                        let back = backward_char((-n) as usize, &self.write.buffer, start);
                                        back..start
                                    }
                                    else
                                    {
                                        let fwd = forward_char(n as usize + 1, &self.write.buffer, start);
                                        end..fwd
                                    };
                                }

                                self.transpose_range(src, dest)?;
                            }
                        }
                        TransposeWords =>
                        {
                            if n != 0 {
                                if let Some(first) = first_word
                                (
                                    &self.write.buffer[..self.write.cursor],
                                    &self.read.word_break
                                )
                                {
                                    let start = word_start(&self.write.buffer, self.write.cursor, &self.read.word_break);

                                    if first != start
                                    {
                                        let (src, dest);

                                        if !self.explicit_arg() && start == self.write.buffer.len()
                                        {
                                            let dest_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                            let dest_end = word_end(&self.write.buffer, dest_start, &self.read.word_break);

                                            let src_start = backward_word(1, &self.write.buffer, dest_start, &self.read.word_break);
                                            let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);

                                            src = src_start..src_end;
                                            dest = dest_start..dest_end;
                                        }
                                        else
                                        {
                                            let src_start = backward_word(1, &self.write.buffer, start, &self.read.word_break);
                                            let src_end = word_end(&self.write.buffer, src_start, &self.read.word_break);
                                            src = src_start..src_end;

                                            dest = if n < 0 
                                            {
                                                back_n_words
                                                (
                                                    (-n) as usize, 
                                                    &self.write.buffer, 
                                                    src_start, 
                                                    &self.read.word_break
                                                )
                                            }
                                            else 
                                            {
                                                forward_n_words
                                                (
                                                    n as usize, 
                                                    &self.write.buffer, 
                                                    src_start, 
                                                    &self.read.word_break
                                                )
                                            };
                                        }

                                        self.transpose_range(src, dest)?;
                                    }
                                }
                            }
                        }
                        BeginningOfHistory => { self.select_history_entry(Some(0))?; }
                        EndOfHistory => { self.select_history_entry(None)?; }
                        NextHistory =>
                        {
                            if n > 0 { self.next_history(n as usize)?; } 
                            else if n < 0 { self.prev_history((-n) as usize)?; }
                        }
                        PreviousHistory =>
                        {
                            if n > 0 { self.prev_history(n as usize)?; }
                            else if n < 0 { self.next_history((-n) as usize)?; }
                        }
                        ForwardSearchHistory =>
                        {
                            self.read.state = InputState::TextSearch;
                            if self.read.last_cmd == Category::IncrementalSearch { self.write.continue_search_history(false)?; }
                            else { self.write.start_search_history(false)?; }
                        }
                        ReverseSearchHistory =>
                        {
                            self.read.state = InputState::TextSearch;
                            if self.read.last_cmd == Category::IncrementalSearch { self.write.continue_search_history(true)?; } 
                            else { self.write.start_search_history(true)?; }
                        }
                        HistorySearchForward =>
                        {
                            if self.read.last_cmd == Category::Search { self.write.continue_history_search(false)?; } 
                            else { self.write.start_history_search(false)?; }
                        }
                        HistorySearchBackward =>
                        {
                            if self.read.last_cmd == Category::Search { self.write.continue_history_search(true)?; } 
                            else { self.write.start_history_search(true)?; }
                        }
                        QuotedInsert => { self.read.state = InputState::QuotedInsert( if n >= 0 { n as usize } else {0} ); }
                        OverwriteMode =>
                        {
                            self.read.overwrite_mode = !self.read.overwrite_mode;

                            if !self.read.overwrite_mode
                            {
                                self.read.overwritten_append = 0;
                                self.read.overwritten_chars.clear();
                            }

                            let mode = if self.read.overwrite_mode { CursorMode::Overwrite } 
                            else { CursorMode::Normal };

                            self.write.set_cursor_mode(mode)?;
                        }
                        Yank =>
                        { self.yank()?; }
                        YankPop => { self.yank_pop()?; }
                        Custom( ref name) =>
                        {
                            if let Some(fun) = self.get_function(name).cloned()
                            {
                                fun.execute(self, n, ch)?;
                                category = fun.category();
                            }
                        }
                        Macro( ref seq ) => { self.read.queue_input(seq); }
                    }

                    if category != Category::Digit
                    {
                        self.write.input_arg = Digit::None;
                        self.write.explicit_arg = false;
                        self.read.last_cmd = category;

                        if category != Category::Complete { self.read.completions = None; }

                        if category != Category::Yank { self.read.last_yank = None; }
                    }

                    Ok(())
                }
                /// Accepts the current input buffer as user input.
                pub fn accept_input(&mut self) -> io::Result<()>
                {
                    self.write.move_to_end()?;
                    self.write.write_str("\n")?;
                    self.read.input_accepted = true;
                    self.write.is_prompt_drawn = false;
                    Ok(())
                }
                /// Moves the cursor to the given position, waits for 500 milliseconds 
                /// (or until next user input), then restores the original cursor position.
                pub fn blink(&mut self, pos: usize) -> io::Result<()>
                {
                    self.write.blink(pos)?;
                    self.read.max_wait_duration = Some(BLINK_DURATION);
                    Ok(())
                }

                fn check_expire_blink(&mut self, now: Instant) -> io::Result<()>
                {
                    if self.write.check_expire_blink(now)? { self.read.max_wait_duration = None; }
                    Ok(())
                }

                fn check_expire_sequence(&mut self, now: Instant) -> io::Result<()>
                {
                    if let InputState::ContinueSequence{expiry: Some(expiry)} = self.read.state
                    {
                        if now >= expiry
                        {
                            self.read.max_wait_duration = None;
                            self.force_execute_sequence()?;
                        }
                    }

                    Ok(())
                }

                fn keyseq_expiry(&mut self) -> Option<Instant>
                {
                    if let Some(t) = self.read.keyseq_timeout
                    {
                        self.read.max_wait_duration = Some(t);
                        Some(Instant::now() + t)
                    }
                    else { None }
                }

                pub(crate) fn check_expire_timeout(&mut self) -> io::Result<()>
                {
                    let now = Instant::now();
                    self.check_expire_blink(now)?;
                    self.check_expire_sequence(now)
                }

                fn expire_blink(&mut self) -> io::Result<()>
                {
                    self.read.max_wait_duration = None;
                    self.write.expire_blink()
                }

                fn build_completions(&mut self)
                {
                    let compl = self.read.completer.clone();
                    let end = self.write.cursor;
                    let start = compl.word_start(&self.write.buffer, end, self);

                    if start > end
                    {
                        panic!( r#"Completer::word_start returned invalid index;
                        start > end ({} > {})"#, start, end);
                    }

                    let unquoted = compl.unquote(&self.write.buffer[start..end]).into_owned();
                    let completions = compl.complete(&unquoted, self, start, end);
                    let n_completions = completions.as_ref().map_or(0, |c| c.len());
                    self.read.completions = completions;
                    self.read.completion_index = n_completions;
                    self.read.completion_start = start;
                    self.read.completion_prefix = end;
                }

                fn complete_word(&mut self) -> io::Result<()>
                {
                    if let Some(completions) = self.read.completions.take()
                    {
                        if completions.len() == 1 { self.substitute_completion(&completions[0])?; }
                        else
                        {
                            self.show_completions(&completions)?;
                            self.read.completions = Some(completions);
                        }
                    }
                    
                    else 
                    {
                        self.build_completions();
                        let completions = self.read.completions.take().unwrap_or_default();

                        if completions.len() == 1 { self.substitute_completion(&completions[0])?; }
                        else if !completions.is_empty()
                        {
                            let start = self.read.completion_start;
                            let end = self.write.cursor;
                            {
                                let pfx = longest_common_prefix(completions.iter()
                                .map(|compl| &compl.completion[..]))
                                .unwrap_or_default();
                                self.replace_str_forward(start..end, &pfx)?;
                            }

                            self.read.completions = Some(completions);
                        }
                    }

                    Ok(())
                }

                fn substitute_completion(&mut self, compl: &Completion) -> io::Result<()>
                {
                    let mut s = self.read.completer.quote(&compl.completion);

                    if let Some(suffix) = compl.suffix.with_default(self.read.completion_append_character)
                    { s.to_mut().push(suffix); }

                    let start = self.read.completion_start;
                    let end = self.write.cursor;
                    self.replace_str_forward(start..end, &s)
                }

                fn insert_completions(&mut self, completions: &[Completion]) -> io::Result<()>
                {
                    let mut words = String::new();

                    for compl in completions
                    {
                        words.push_str(&self.read.completer.unquote(&compl.completion));
                        words.push(' ');
                    }

                    let start = self.read.completion_start;
                    let end = self.write.cursor;

                    self.replace_str_forward(start..end, &words)
                }

                fn show_completions(&mut self, completions: &[Completion]) -> io::Result<()>
                {
                    if completions.is_empty() { return Ok(()); }

                    let eff_width = self.write.screen_size.columns.min(self.read.completion_display_width);

                    let completions = completions.iter()
                    .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                    .collect::<Vec<_>>();

                    let cols = format_columns(&completions, eff_width, self.read.print_completions_horizontally);
                    let table = Table::new
                    (
                        &completions, 
                        cols.as_ref()
                        .map(|c| &c[..]),
                        self.read.print_completions_horizontally,
                    );

                    self.write.write_str("\n")?;
                    let n_completions = completions.len();

                    if self.read.page_completions && n_completions >= self.read.completion_query_items
                    { self.start_page_completions(n_completions) } 
                    else
                    {
                        self.show_list_completions(table)?;
                        self.write.draw_prompt()
                    }
                }

                fn start_page_completions(&mut self, n_completions: usize) -> io::Result<()>
                {
                    self.read.state = InputState::CompleteIntro;
                    self.write.redraw_prompt(PromptType::CompleteIntro(n_completions))
                }

                fn end_page_completions(&mut self) -> io::Result<()>
                {
                    self.read.state = InputState::NewSequence;
                    self.write.prompt_type = PromptType::Normal;
                    self.write.draw_prompt()
                }

                fn is_paging_completions(&self) -> bool
                {
                    match self.read.state
                    {
                        InputState::CompleteMore(_) => true,
                        _ => false
                    }
                }

                fn show_completions_page(&mut self, offset: usize) -> io::Result<()>
                {
                    if let Some(compl) = self.read.completions.take()
                    {
                        let width = self.write.screen_size.columns.min(self.read.completion_display_width);
                        let n_lines = self.write.screen_size.lines - 1;
                        let completions = compl.iter()
                        .map(|compl| display_str(&compl.display(), Display::default()).into_owned())
                        .collect::<Vec<_>>();
                        let cols = format_columns(&completions, width, self.read.print_completions_horizontally);
                        let mut table = Table::new
                        (
                            &completions, 
                            cols.as_ref()
                            .map(|c| &c[..]),
                            self.read.print_completions_horizontally,
                        );

                        for row in table.by_ref().skip(offset).take(n_lines)
                        {
                            self.show_completion_line(row)?;
                        }

                        if table.has_more()
                        {
                            self.read.completions = Some(compl);
                            self.read.state = InputState::CompleteMore(offset + n_lines);
                            self.write.prompt_type = PromptType::CompleteMore;
                            self.write.draw_prompt()?;
                        }
                        else { self.end_page_completions()?; }
                    }

                    Ok(())
                }

                fn show_completions_line(&mut self, offset: usize) -> io::Result<()>
                {
                    if let Some(compl) = self.read.completions.take()
                    {
                        let width = self.write.screen_size.columns.min(self.read.completion_display_width);
                        let completions = compl
                        .iter()
                        .map
                        ( | compl | display_str(&compl.display(), Display::default()).into_owned() )
                        .collect::<Vec<_>>();

                        let cols = format_columns(&completions, width, self.read.print_completions_horizontally);
                        let mut table = Table::new
                        (
                            &completions,
                            cols.as_ref()
                            .map(|c| &c[..]),
                            self.read.print_completions_horizontally,
                        );

                        if let Some(row) = table.by_ref().skip(offset).next() { self.show_completion_line(row)?; }

                        if table.has_more()
                        {
                            self.read.completions = Some(compl);
                            self.read.state = InputState::CompleteMore(offset + 1);
                            self.write.prompt_type = PromptType::CompleteMore;
                            self.write.draw_prompt()?;
                        }
                        else { self.end_page_completions()?; }
                    }

                    Ok(())
                }

                fn show_completion_line<S: AsRef<str>>(&mut self, line: Line<S>) -> io::Result<()>
                {
                    let mut space = 0;

                    for (width, name) in line
                    {
                        self.write.move_right(space)?;
                        self.write.write_str(name)?;
                        space = width - name.chars().count();
                    }

                    self.write.write_str("\n")
                }

                fn show_list_completions<S: AsRef<str>>(&mut self, table: Table<S>) -> io::Result<()>
                {
                    for line in table
                    {
                        let mut space = 0;
                        for (width, name) in line
                        {
                            self.write.move_right(space)?;
                            self.write.write_str(name)?;
                            space = width - name.chars().count();
                        }
                        
                        self.write.write_str("\n")?;
                    }

                    Ok(())
                }

                fn next_completion(&mut self, n: usize) -> io::Result<()>
                {
                    let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                    let max = len + 1;
                    let old = self.read.completion_index;
                    let new = (old + n) % max;

                    if old != new { self.set_completion(new)?; }

                    Ok(())
                }

                fn prev_completion(&mut self, n: usize) -> io::Result<()>
                {
                    let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                    let max = len + 1;
                    let old = self.read.completion_index;

                    let new = if n <= old { max - old - n }
                    else { old - n };

                    self.set_completion(new)
                }

                fn set_completion(&mut self, new: usize) -> io::Result<()>
                {
                    let len = self.read.completions.as_ref().map_or(0, |c| c.len());
                    let old = self.read.completion_index;

                    if old != new
                    {
                        self.read.completion_index = new;

                        if new == len
                        {
                            let start = self.read.completion_prefix;
                            let end = self.write.cursor;
                            self.delete_range(start..end)?;
                        }
                        
                        else 
                        {
                            let start = self.read.completion_start;
                            let end = self.write.cursor;
                            let s = self.read.completions.as_ref()
                            .unwrap()[ new ].completion( self.read.completion_append_character )
                            .into_owned();
                            self.replace_str_forward( start..end, &s )?;
                        }
                    }

                    Ok(())
                }

                fn abort_search_history(&mut self) -> io::Result<()>
                {
                    self.read.state = InputState::NewSequence;
                    self.read.last_cmd = Category::Other;
                    self.write.abort_search_history()
                }

                fn end_search_history(&mut self) -> io::Result<()>
                {
                    self.read.state = InputState::NewSequence;
                    self.write.end_search_history()
                }

                pub(crate) fn handle_resize(&mut self, size: Size) -> io::Result<()>
                {
                    self.expire_blink()?;

                    if self.is_paging_completions() { self.end_page_completions()?; }

                    self.write.screen_size = size;
                    let p = self.write.prompt_type;
                    self.write.redraw_prompt(p)
                }

                pub(crate) fn handle_signal(&mut self, signal: Signal) -> io::Result<()>
                {
                    self.expire_blink()?;

                    match signal
                    {
                        Signal::Continue => { self.write.draw_prompt()?; }
                        Signal::Interrupt =>
                        {
                            self.read.macro_buffer.clear();
                            self.write.move_to_end()?;

                            if self.read.echo_control_characters {
                                self.write.write_str("^C")?;
                            }

                            self.write.write_str("\n")?;
                            self.reset_input();
                            self.write.draw_prompt()?;
                        }
                        _ => ()
                    }

                    Ok(())
                }

                fn backward_word(&mut self, n: usize) -> io::Result<()>
                {
                    let pos = backward_word(n, &self.write.buffer, self.write.cursor, &self.read.word_break);
                    self.write.move_to(pos)
                }

                fn forward_word(&mut self, n: usize) -> io::Result<()>
                {
                    let pos = forward_word(n, &self.write.buffer, self.write.cursor, &self.read.word_break);
                    self.write.move_to(pos)
                }
                /// Deletes a range of text from the input buffer.
                pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()>
                { self.write.delete_range(range) }
                /// Deletes a range from the buffer and adds the removed text to the kill ring.
                pub fn kill_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()>
                {
                    let start = range.start().cloned().unwrap_or(0);
                    let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
                    let len = end - start;

                    if len != 0
                    {
                        let buf = self.write.buffer[start..end].to_owned();
                        
                        if self.read.last_cmd != Category::Kill { self.push_kill_ring(buf); } 
                        else if end == self.write.cursor { self.prepend_kill_ring(buf); }
                        else { self.append_kill_ring(buf); }

                        self.delete_range(start..end)?;
                    }

                    Ok(())
                }

                fn push_kill_ring(&mut self, s: String)
                {
                    if self.read.kill_ring.len() == self.read.kill_ring.capacity() {  self.read.kill_ring.pop_back(); }
                    self.read.kill_ring.push_front(s);
                }

                fn rotate_kill_ring(&mut self)
                {
                    if let Some(kill) = self.read.kill_ring.pop_front() { self.read.kill_ring.push_back(kill); }
                }

                fn append_kill_ring(&mut self, s: String)
                {
                    if let Some(kill) = self.read.kill_ring.front_mut()
                    {
                        kill.push_str(&s);
                        return;
                    }
                    self.push_kill_ring(s);
                }

                fn prepend_kill_ring(&mut self, s: String)
                {
                    if let Some(kill) = self.read.kill_ring.front_mut()
                    {
                        kill.insert_str(0, &s);
                        return;
                    }
                    self.push_kill_ring(s);
                }
                /// Transposes two regions of the buffer, `src` and `dest`.
                pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>) -> io::Result<()>
                { self.write.transpose_range(src, dest) }
                /// Insert text from the front of the kill ring at the current cursor position.
                pub fn yank(&mut self) -> io::Result<()>
                {
                    if let Some(kill) = self.read.kill_ring.front().cloned()
                    {
                        let start = self.write.cursor;
                        self.read.last_yank = Some((start, start + kill.len()));
                        self.insert_str(&kill)?;
                    }

                    Ok(())
                }
                /// Rotates the kill ring and replaces yanked text with the new front.
                pub fn yank_pop(&mut self) -> io::Result<()>
                {
                    if let Some((start, end)) = self.read.last_yank
                    {
                        self.rotate_kill_ring();
                        if let Some(kill) = self.read.kill_ring.front().cloned()
                        {
                            self.read.last_yank = Some((start, start + kill.len()));
                            self.write.move_to(start)?;
                            self.replace_str_forward(start..end, &kill)?;
                        }
                    }

                    Ok(())
                }
                /// Overwrite `n` characters; assumes `n >= 1`
                fn overwrite(&mut self, n: usize, ch: char) -> io::Result<()>
                {
                    let start = self.write.cursor;
                    let end = forward_char(n, &self.write.buffer, start);
                    {
                        let over = &self.write.buffer[start..end];
                        let n_chars = over.chars().count();
                        if n > n_chars { self.read.overwritten_append += n - n_chars; }
                        if !over.is_empty() { self.read.overwritten_chars.push_str(&over); }
                    }
                    let s = repeat_char(ch, n);
                    self.replace_str_forward(start..end, &s)
                }

                fn overwrite_back(&mut self, mut n: usize) -> io::Result<()>
                {
                    if self.read.overwritten_append != 0
                    {
                        let n_del = n.min(self.read.overwritten_append);
                        let pos = backward_char(n_del, &self.write.buffer, self.write.cursor);
                        let r = pos..self.write.cursor;
                        self.delete_range(r)?;
                        self.read.overwritten_append -= n_del;
                        n -= n_del;
                    }

                    if n != 0 && !self.read.overwritten_chars.is_empty()
                    {
                        let n_repl = n.min(self.read.overwritten_chars.chars().count());
                        let pos = backward_char(n_repl, &self.write.buffer, self.write.cursor);
                        let over_pos = backward_char
                        (n_repl, &self.read.overwritten_chars, self.read.overwritten_chars.len());
                        let over = self.read.overwritten_chars.drain(over_pos..).collect::<String>();
                        let r = pos..self.write.cursor;
                        self.replace_str_backward(r, &over)?;

                        n -= n_repl;
                    }

                    if n != 0 { self.write.backward_char(n)?; }

                    Ok(())
                }
                /// Insert a given character at the current cursor position `n` times.
                pub fn insert(&mut self, n: usize, ch: char) -> io::Result<()>
                {
                    if n != 0
                    {
                        let s = repeat_char(ch, n);
                        self.insert_str(&s)?;
                    }
                    Ok(())
                }
                /// Insert a string at the current cursor position.
                pub fn insert_str(&mut self, s: &str) -> io::Result<()> { self.write.insert_str(s) }
                /// Replaces a range in the buffer and redraws.
                pub fn replace_str_backward<R: RangeArgument<usize>>
                ( &mut self, range: R, s: &str ) -> io::Result<()>
                {
                    self.replace_str_impl(range, s)?;
                    let len = self.write.buffer.len();
                    self.write.move_from(len)
                }
                /// Replaces a range in the buffer and redraws.
                pub fn replace_str_forward<R: RangeArgument<usize>>
                ( &mut self, range: R, s: &str ) -> io::Result<()>
                {
                    self.replace_str_impl(range, s)?;
                    self.write.cursor += s.len();
                    let len = self.write.buffer.len();
                    self.write.move_from(len)
                }
                /// Replaces a range in the buffer and redraws.
                fn replace_str_impl<R: RangeArgument<usize>>
                (
                    &mut self, 
                    range:R, 
                    s:&str
                ) -> io::Result<()>
                {
                    let start = range.start().cloned().unwrap_or(0);
                    let end = range.end().cloned().unwrap_or_else(|| self.write.buffer.len());
                    self.write.move_to(start)?;
                    let _ = self.write.buffer.drain(start..end);
                    let cursor = self.write.cursor;
                    self.write.buffer.insert_str(cursor, s);
                    self.write.draw_buffer(cursor)?;
                    self.write.clear_to_screen_end()
                }
            } 
        }
        pub use self::prompter::Prompter;
        pub mod reader
        {
            //! Provides access to terminal read operations
            use ::
            {
                borrow::{ Cow },
                collections::{ HashMap, VecDeque },
                mem::{ replace },
                mortal::
                { 
                    sequence::{ Entry },
                    SequenceMap 
                },
                ops::{ Deref, DerefMut },
                path::{ Path, PathBuf },
                prompt::lines::
                {
                    command::{ Category, Command::{ self, * }, },
                    complete::{ Completer, Completion, DummyCompleter},
                    function::{ Function },
                    inputrc::{ parse_file, Directive },
                    interface::{ Interface },
                    prompter::{ Prompter },
                    sys::path::{ env_init_file, system_init_file, user_init_file },
                    terminal::{ RawRead, Signal, SignalSet, Size, Terminal, TerminalReader, },
                    util::{ first_char, match_name },
                    variables::{ Variable, Variables, VariableIter },
                },
                sync::{ Arc, MutexGuard },
                time::{ Duration, Instant },
                *,
            };
            /// Default set of string characters
            pub const STRING_CHARS: &str = "\"'";
            /// Default set of word break characters
            pub const WORD_BREAK_CHARS: &str = " \t\n\"\\'`@$><=;|&{(";
            /// Indicates the start of a series of invisible characters in the prompt
            pub const START_INVISIBLE: char = '\x01';
            /// Indicates the end of a series of invisible characters in the prompt
            pub const END_INVISIBLE: char = '\x02';
            /// Maximum size of kill ring
            const MAX_KILLS: usize = 10;
            /// Provides access to data related to reading and processing user input.
            pub struct Reader<'a, Term: 'a + Terminal>
            {
                iface: &'a Interface<Term>,
                lock: ReadLock<'a, Term>,
            }

            pub(crate) struct Read<Term: Terminal>
            {
                /// Application name
                pub application: Cow<'static, str>,
                /// Pending input
                pub input_buffer: Vec<u8>,
                /// Pending macro sequence
                pub macro_buffer: String,
                pub bindings: SequenceMap<Cow<'static, str>, Command>,
                pub functions: HashMap<Cow<'static, str>, Arc<dyn Function<Term>>>,
                /// Current input sequence
                pub sequence: String,
                /// Whether newline has been received
                pub input_accepted: bool,
                /// Whether overwrite mode is currently active
                pub overwrite_mode: bool,
                /// Characters appended while in overwrite mode
                pub overwritten_append: usize,
                /// Characters overwritten in overwrite mode
                pub overwritten_chars: String,
                /// Configured completer
                pub completer: Arc<dyn Completer<Term>>,
                /// Character appended to completions
                pub completion_append_character: Option<char>,
                /// Current set of possible completions
                pub completions: Option<Vec<Completion>>,
                /// Current "menu-complete" entry being viewed:
                pub completion_index: usize,
                /// Start of the completed word
                pub completion_start: usize,
                /// Start of the inserted prefix of a completed word
                pub completion_prefix: usize,
                pub string_chars: Cow<'static, str>,
                pub word_break: Cow<'static, str>,
                pub last_cmd: Category,
                pub last_yank: Option<(usize, usize)>,
                pub kill_ring: VecDeque<String>,
                pub catch_signals: bool,
                pub ignore_signals: SignalSet,
                pub report_signals: SignalSet,
                pub last_resize: Option<Size>,
                pub last_signal: Option<Signal>,
                variables: Variables,
                pub state: InputState,
                pub max_wait_duration: Option<Duration>,
            }

            pub(crate) struct ReadLock<'a, Term: 'a + Terminal>
            {
                term: Box<dyn TerminalReader<Term> + 'a>,
                data: MutexGuard<'a, Read<Term>>,
            }

            /// Returned from [`read_line`] to indicate user input.
            #[derive(Debug)] pub enum ReadResult
            {
                /// User issued end-of-file
                Eof,
                /// User input received
                Input(String),
                /// Reported signal was received
                Signal(Signal),
            }

            #[derive(Copy, Clone, Debug)]
            pub(crate) enum InputState
            {
                Inactive,
                NewSequence,
                ContinueSequence
                {
                    expiry: Option<Instant>,
                },
                Number,
                CharSearch
                {
                    n: usize,
                    backward: bool,
                },
                TextSearch,
                CompleteIntro,
                CompleteMore(usize),
                QuotedInsert(usize),
            }

            impl<'a, Term: 'a + Terminal> Reader<'a, Term>
            {
                pub(crate) fn new(iface: &'a Interface<Term>, lock: ReadLock<'a, Term>) -> Reader<'a, Term>
                {
                    Reader{iface, lock}
                }
                /// Interactively reads a line from the terminal device.
                pub fn read_line(&mut self) -> io::Result<ReadResult>
                {
                    loop
                    {
                        if let Some(res) = self.read_line_step(None)? { return Ok(res); }
                    }
                }
                /// Performs one step of the interactive `read_line` loop.
                pub fn read_line_step(&mut self, timeout: Option<Duration>) -> io::Result<Option<ReadResult>>
                {
                    self.initialize_read_line()?;
                    let state = self.prepare_term()?;
                    let res = self.read_line_step_impl(timeout);
                    self.lock.term.restore(state)?;
                    res
                }
                /// Cancels an in-progress `read_line` operation.
                pub fn cancel_read_line(&mut self) -> io::Result<()> { self.end_read_line() }

                fn initialize_read_line(&mut self) -> io::Result<()>
                {
                    if !self.lock.is_active() { self.prompter().start_read_line()?; }
                    Ok(())
                }

                fn read_line_step_impl(&mut self, timeout: Option<Duration>) -> io::Result<Option<ReadResult>>
                {
                    let do_read = if self.lock.is_input_available() 
                    { self.lock.term.wait_for_input(Some(Duration::from_secs(0)))? }

                    else
                    {
                        let timeout = limit_duration(timeout, self.lock.max_wait_duration);
                        self.lock.term.wait_for_input(timeout)?
                    };

                    if do_read { self.lock.read_input()?; }

                    if let Some(size) = self.lock.take_resize() { self.handle_resize(size)?; }

                    if let Some(sig) = self.lock.take_signal()
                    {
                        if self.lock.report_signals.contains(sig) { return Ok(Some(ReadResult::Signal(sig))); }

                        if !self.lock.ignore_signals.contains(sig) { self.handle_signal(sig)?; }
                    }
                    
                    {
                        let mut prompter = self.prompter();
                        prompter.check_expire_timeout()?;
                        
                        let mut macro_len = prompter.read.data.macro_buffer.len();

                        while prompter.read.is_input_available()
                        {
                            if let Some(ch) = prompter.read.read_char()?
                            {
                                if let Some(r) = prompter.handle_input(ch)?
                                {
                                    prompter.end_read_line()?;
                                    return Ok(Some(r));
                                }
                            }

                            let new_macro_len = prompter.read.data.macro_buffer.len();

                            if new_macro_len != 0 && new_macro_len >= macro_len { break; }

                            macro_len = new_macro_len;
                        }
                    }

                    Ok(None)
                }

                fn end_read_line(&mut self) -> io::Result<()>
                {
                    if self.lock.is_active() { self.prompter().end_read_line()?; }
                    Ok(())
                }

                fn prepare_term(&mut self) -> io::Result<Term::PrepareState>
                {
                    if self.read_next_raw() { self.lock.term.prepare(true, SignalSet::new()) }
                    
                    else
                    {
                        let mut signals = self.lock.report_signals.union(self.lock.ignore_signals);

                        if self.lock.catch_signals  { signals.insert(Signal::Interrupt); }

                        let block_signals = !self.lock.catch_signals;
                        self.lock.term.prepare(block_signals, signals)
                    }
                }

                fn read_next_raw(&self) -> bool
                {
                    match self.lock.state
                    {
                        InputState::QuotedInsert(_) => true,
                        _ => false
                    }
                }
                /// Sets the input buffer to the given string.
                pub fn set_buffer(&mut self, buf: &str) -> io::Result<()>
                {
                    if self.lock.is_active() { self.prompter().set_buffer(buf) }
                    else
                    {
                        self.iface.lock_write_data().set_buffer(buf);
                        Ok(())
                    }
                }
                /// Sets the cursor position in the input buffer.
                pub fn set_cursor(&mut self, pos: usize) -> io::Result<()>
                {
                    if self.lock.is_active() { self.prompter().set_cursor(pos) } 
                    else
                    {
                        self.iface.lock_write_data().set_cursor(pos);
                        Ok(())
                    }
                }
                /// Sets the prompt that will be displayed when `read_line` is called.
                pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()> { self.prompter().set_prompt(prompt) }
                /// Adds a line to history.
                pub fn add_history(&self, line: String) 
                { if !self.lock.is_active() { self.iface.lock_write().add_history(line); } }
                /// Adds a line to history, unless it is identical to the most recent entry.
                pub fn add_history_unique(&self, line: String)
                {
                    if !self.lock.is_active() { self.iface.lock_write().add_history_unique(line); }
                }
                /// Removes all history entries.
                pub fn clear_history(&self)
                {
                    if !self.lock.is_active() { self.iface.lock_write().clear_history(); }
                }
                /// Removes the history entry at the given index.
                pub fn remove_history(&self, idx: usize)
                {
                    if !self.lock.is_active() { self.iface.lock_write().remove_history(idx); }
                }
                /// Sets the maximum number of history entries.
                pub fn set_history_size(&self, n: usize)
                {
                    if !self.lock.is_active()
                    {
                        self.iface.lock_write().set_history_size(n);
                    }
                }
                /// Truncates history to the only the most recent `n` entries.
                pub fn truncate_history(&self, n: usize)
                {
                    if !self.lock.is_active() { self.iface.lock_write().truncate_history(n); }
                }
                /// Returns the application name
                pub fn application(&self) -> &str { &self.lock.application }
                /// Sets the application name
                pub fn set_application<T>(&mut self, application: T) where 
                T: Into<Cow<'static, str>> 
                { self.lock.application = application.into(); }
                /// Returns a reference to the current completer instance.
                pub fn completer(&self) -> &Arc<dyn Completer<Term>> { &self.lock.completer }
                /// Replaces the current completer, returning the previous instance.
                pub fn set_completer(&mut self, completer: Arc<dyn Completer<Term>>) -> Arc<dyn Completer<Term>> 
                { replace(&mut self.lock.completer, completer) }
                /// Returns the value of the named variable or `None` if no such variable exists.
                pub fn get_variable(&self, name: &str) -> Option<Variable> { self.lock.get_variable(name) }
                /// Sets the value of the named variable and returns the previous value.
                pub fn set_variable(&mut self, name: &str, value: &str) -> Option<Variable> 
                { self.lock.set_variable(name, value) }
                /// Returns an iterator over stored variables.
                pub fn variables(&self) -> VariableIter { self.lock.variables.iter() }
                /// Returns whether to "blink" matching opening parenthesis character 
                /// when a closing parenthesis character is entered.
                pub fn blink_matching_paren(&self) -> bool { self.lock.blink_matching_paren }
                /// Sets the `blink-matching-paren` variable.
                pub fn set_blink_matching_paren(&mut self, set: bool) { self.lock.blink_matching_paren = set; }
                /// Returns whether `linefeed` will catch certain signals.
                pub fn catch_signals(&self) -> bool { self.lock.catch_signals }
                /// Sets whether `linefeed` will catch certain signals.
                pub fn set_catch_signals(&mut self, enabled: bool) { self.lock.catch_signals = enabled; }
                /// Returns whether the given `Signal` is ignored.
                pub fn ignore_signal(&self, signal: Signal) -> bool { self.lock.ignore_signals.contains(signal) }
                /// Sets whether the given `Signal` will be ignored.
                pub fn set_ignore_signal(&mut self, signal: Signal, set: bool)
                {
                    if set
                    {
                        self.lock.ignore_signals.insert(signal);
                        self.lock.report_signals.remove(signal);
                    }
                    else { self.lock.ignore_signals.remove(signal); }
                }
                /// Returns whether the given `Signal` is to be reported.
                pub fn report_signal(&self, signal: Signal) -> bool { self.lock.report_signals.contains(signal) }
                /// Sets whether to report the given `Signal`.
                pub fn set_report_signal(&mut self, signal: Signal, set: bool)
                {
                    if set
                    {
                        self.lock.report_signals.insert(signal);
                        self.lock.ignore_signals.remove(signal);
                    }
                    else { self.lock.report_signals.remove(signal); }
                }
                /// Returns whether Tab completion is disabled.
                pub fn disable_completion(&self) -> bool { self.lock.disable_completion }
                /// Sets the `disable-completion` variable.
                pub fn set_disable_completion(&mut self, disable: bool) { self.lock.disable_completion = disable; }
                /// When certain control characters are pressed, a character sequence equivalent to this character 
                /// will be echoed.
                pub fn echo_control_characters(&self) -> bool { self.lock.echo_control_characters }
                /// Sets the `echo-control-characters` variable.
                pub fn set_echo_control_characters(&mut self, echo: bool) 
                { self.lock.echo_control_characters = echo; }
                /// Returns the character, if any, that is appended to a successful completion.
                pub fn completion_append_character(&self) -> Option<char> { self.lock.completion_append_character }
                /// Sets the character, if any, that is appended to a successful completion.
                pub fn set_completion_append_character(&mut self, ch: Option<char>) 
                { self.lock.completion_append_character = ch; }
                /// Returns the width of completion listing display.
                pub fn completion_display_width(&self) -> usize { self.lock.completion_display_width }
                /// Sets the `completion-display-width` variable.
                pub fn set_completion_display_width(&mut self, n: usize) { self.lock.completion_display_width = n; }
                /// Returns the minimum number of completion items that require user confirmation before listing.
                pub fn completion_query_items(&self) -> usize { self.lock.completion_query_items }
                /// Sets the `completion-query-items` variable.
                pub fn set_completion_query_items(&mut self, n: usize) { self.lock.completion_query_items = n; }
                /// Returns the timeout to wait for further user input when an ambiguous sequence has been entered.
                pub fn keyseq_timeout(&self) -> Option<Duration> { self.lock.keyseq_timeout }
                /// Sets the `keyseq-timeout` variable.
                pub fn set_keyseq_timeout(&mut self, timeout: Option<Duration>) { self.lock.keyseq_timeout = timeout; }
                /// Returns whether to list possible completions one page at a time.
                pub fn page_completions(&self) -> bool { self.lock.page_completions }
                /// Sets the `page-completions` variable.
                pub fn set_page_completions(&mut self, set: bool) { self.lock.page_completions = set; }
                /// Returns whether to list completions horizontally, rather than down the screen.
                pub fn print_completions_horizontally(&self) -> bool { self.lock.print_completions_horizontally }
                /// Sets the `print-completions-horizontally` variable.
                pub fn set_print_completions_horizontally(&mut self, set: bool) { self.lock.print_completions_horizontally = set; }
                /// Returns the set of characters that delimit strings.
                pub fn string_chars(&self) -> &str { &self.lock.string_chars }
                /// Sets the set of characters that delimit strings.
                pub fn set_string_chars<T>(&mut self, chars: T) where
                T: Into<Cow<'static, str>> 
                { self.lock.string_chars = chars.into(); }
                /// Returns the set of characters that indicate a word break.
                pub fn word_break_chars(&self) -> &str { &self.lock.word_break }
                /// Sets the set of characters that indicate a word break.
                pub fn set_word_break_chars<T>(&mut self, chars: T) where
                T: Into<Cow<'static, str>> { self.lock.word_break = chars.into(); }
                /// Returns an iterator over bound sequences
                pub fn bindings(&self) -> BindingIter { self.lock.bindings() }
                /// Binds a sequence to a command.
                pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command> where 
                T: Into<Cow<'static, str>> 
                { self.lock.bind_sequence(seq, cmd) }
                /// Binds a sequence to a command, if and only if the given sequence
                /// is not already bound to a command.
                pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool where 
                T: Into<Cow<'static, str>> { self.lock.bind_sequence_if_unbound(seq, cmd) }
                /// Removes a binding for the given sequence.
                pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command> { self.lock.unbind_sequence(seq) }
                /// Defines a named function to which sequences may be bound.
                pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>) -> 
                Option<Arc<dyn Function<Term>>> where 
                T: Into<Cow<'static, str>>
                { self.lock.define_function(name, cmd) }
                /// Removes a function defined with the given name.
                pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>>
                { self.lock.remove_function(name) }

                pub(crate) fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>)
                { self.lock.data.evaluate_directives(term, dirs) }

                pub(crate) fn evaluate_directive(&mut self, term: &Term, dir: Directive)
                { self.lock.data.evaluate_directive(term, dir) }

                fn prompter<'b>(&'b mut self) -> Prompter<'b, 'a, Term>
                { Prompter::new( &mut self.lock, self.iface.lock_write() ) }

                fn handle_resize(&mut self, size: Size) -> io::Result<()> { self.prompter().handle_resize(size) }

                fn handle_signal(&mut self, sig: Signal) -> io::Result<()> { self.prompter().handle_signal(sig) }
            }

            impl<'a, Term: 'a + Terminal> ReadLock<'a, Term>
            {
                pub fn new(term: Box<dyn TerminalReader<Term> + 'a>, data: MutexGuard<'a, Read<Term>>) 
                -> ReadLock<'a, Term>
                { ReadLock{term, data} }
                /// Reads the next character of input.
                pub fn read_char(&mut self) -> io::Result<Option<char>>
                {
                    if let Some(ch) = self.macro_pop() { Ok(Some(ch)) }
                     else if let Some(ch) = self.decode_input()? { Ok(Some(ch)) } 
                    else { Ok(None) }
                }

                fn read_input(&mut self) -> io::Result<()>
                 {
                    match self.term.read(&mut self.data.input_buffer)?
                    {
                        RawRead::Bytes(_) => (),
                        RawRead::Resize(new_size) => { self.last_resize = Some(new_size); }
                        RawRead::Signal(sig) => { self.last_signal = Some(sig); }
                    }

                    Ok(())
                }

                fn is_input_available(&self) -> bool
                {
                    !self.data.macro_buffer.is_empty() || match self.peek_input()
                    {
                        Ok(Some(_)) | Err(_) => true,
                        Ok(None) => false
                    }
                }

                fn macro_pop(&mut self) -> Option<char>
                {
                    if self.data.macro_buffer.is_empty() { None }
                    else { Some(self.data.macro_buffer.remove(0)) }
                }

                fn decode_input(&mut self) -> io::Result<Option<char>>
                {
                    let res = self.peek_input();
                
                    if let Ok(Some(ch)) = res { self.data.input_buffer.drain(..ch.len_utf8()); }

                    res
                }

                fn peek_input(&self) -> io::Result<Option<char>>
                {
                    if self.data.input_buffer.is_empty() { Ok(None) }
                    else { first_char(&self.data.input_buffer) }
                }

                pub fn reset_data(&mut self) { self.data.reset_data(); }
            }

            impl<'a, Term: 'a + Terminal> Deref for ReadLock<'a, Term>
            {
                type Target = Read<Term>;
                fn deref(&self) -> &Read<Term> 
                { &self.data }
            }

            impl<'a, Term: 'a + Terminal> DerefMut for ReadLock<'a, Term>
            {
                fn deref_mut(&mut self) -> &mut Read<Term>
                { &mut self.data }
            }

            impl<Term: Terminal> Deref for Read<Term>
            {
                type Target = Variables;
                fn deref(&self) -> &Variables { &self.variables }
            }

            impl<Term: Terminal> DerefMut for Read<Term>
            {
                fn deref_mut(&mut self) -> &mut Variables { &mut self.variables }
            }

            impl<Term: Terminal> Read<Term>
            {
                pub fn new(term: &Term, application: Cow<'static, str>) -> Read<Term>
                {
                    let mut r = Read
                    {
                        application,
                        bindings: default_bindings(),
                        functions: HashMap::new(),
                        input_buffer: Vec::new(),
                        macro_buffer: String::new(),
                        sequence: String::new(),
                        input_accepted: false,
                        overwrite_mode: false,
                        overwritten_append: 0,
                        overwritten_chars: String::new(),
                        completer: Arc::new(DummyCompleter),
                        completion_append_character: Some(' '),
                        completions: None,
                        completion_index: 0,
                        completion_start: 0,
                        completion_prefix: 0,
                        string_chars: STRING_CHARS.into(),
                        word_break: WORD_BREAK_CHARS.into(),
                        last_cmd: Category::Other,
                        last_yank: None,
                        kill_ring: VecDeque::with_capacity(MAX_KILLS),
                        catch_signals: true,
                        ignore_signals: SignalSet::new(),
                        report_signals: SignalSet::new(),
                        last_resize: None,
                        last_signal: None,
                        variables: Variables::default(),
                        state: InputState::Inactive,
                        max_wait_duration: None,
                    };

                    r.read_init(term);
                    r
                }

                pub fn bindings(&self) -> BindingIter { BindingIter(self.bindings.sequences().iter()) }

                pub fn variables(&self) -> VariableIter { self.variables.iter() }

                fn take_resize(&mut self) -> Option<Size> { self.last_resize.take() }

                fn take_signal(&mut self) -> Option<Signal> { self.last_signal.take() }

                pub fn queue_input(&mut self, seq: &str) { self.macro_buffer.insert_str(0, seq); }

                pub fn is_active(&self) -> bool
                {
                    match self.state
                    {
                        InputState::Inactive => false,
                        _ => true
                    }
                }

                pub fn reset_data(&mut self)
                {
                    self.state = InputState::NewSequence;
                    self.input_accepted = false;
                    self.overwrite_mode = false;
                    self.overwritten_append = 0;
                    self.overwritten_chars.clear();
                    self.sequence.clear();
                    self.completions = None;
                    self.last_cmd = Category::Other;
                    self.last_yank = None;
                    self.last_resize = None;
                    self.last_signal = None;
                }

                pub fn bind_sequence<T>(&mut self, seq: T, cmd: Command) -> Option<Command> where
                T: Into<Cow<'static, str>>
                { self.bindings.insert(seq.into(), cmd) }

                pub fn bind_sequence_if_unbound<T>(&mut self, seq: T, cmd: Command) -> bool where 
                T: Into<Cow<'static, str>>
                {
                    match self.bindings.entry(seq.into())
                    {
                        Entry::Occupied(_) => false,
                        Entry::Vacant(ent) =>
                        {
                            ent.insert(cmd);
                            true
                        }
                    }
                }

                pub fn unbind_sequence(&mut self, seq: &str) -> Option<Command>
                { self.bindings.remove(seq).map(|(_, cmd)| cmd) }

                pub fn define_function<T>(&mut self, name: T, cmd: Arc<dyn Function<Term>>) -> 
                Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>>
                { self.functions.insert(name.into(), cmd) }

                pub fn remove_function(&mut self, name: &str) -> Option<Arc<dyn Function<Term>>>
                { self.functions.remove(name) }

                fn read_init(&mut self, term: &Term)
                {
                    if let Some(path) = env_init_file()
                    { self.read_init_file_if_exists(term, Some(path)); }
                    
                    else
                    {
                        if !self.read_init_file_if_exists(term, user_init_file())
                        { self.read_init_file_if_exists(term, system_init_file()); }
                    }
                }

                fn read_init_file_if_exists(&mut self, term: &Term, path: Option<PathBuf>) -> bool
                {
                    match path
                    {
                        Some(ref path) if path.exists() =>
                        {
                            self.read_init_file(term, path);
                            true
                        }
                        _ => false
                    }
                }

                fn read_init_file(&mut self, term: &Term, path: &Path)
                {
                    if let Some(dirs) = parse_file(path) { self.evaluate_directives(term, dirs); }
                }
                /// Evaluates a series of configuration directives.
                pub(crate) fn evaluate_directives(&mut self, term: &Term, dirs: Vec<Directive>)
                {
                    for dir in dirs
                    {
                        self.evaluate_directive(term, dir);
                    }
                }
                /// Evaluates a single configuration directive.
                pub(crate) fn evaluate_directive(&mut self, term: &Term, dir: Directive)
                {
                    match dir
                    {
                        Directive::Bind(seq, cmd) => { self.bind_sequence(seq, cmd); }
                        Directive::Conditional{name, value, then_group, else_group} =>
                        {
                            let name = name.as_ref().map(|s| &s[..]);

                            if self.eval_condition(term, name, &value) { self.evaluate_directives(term, then_group); }
                            else { self.evaluate_directives(term, else_group); }
                        }
                        Directive::SetVariable(name, value) => { self.set_variable(&name, &value); }
                    }
                }

                fn eval_condition(&self, term: &Term, name: Option<&str>, value: &str) -> bool
                {
                    match name
                    {
                        None => self.application == value,
                        Some("lib") => value == "linefeed",
                        Some("mode") => value == "emacs",
                        Some("term") => self.term_matches(term, value),
                        _ => false
                    }
                }

                fn term_matches(&self, term: &Term, value: &str) -> bool { match_name(term.name(), value) }
            }
            /// Iterator over `Reader` bindings
            pub struct BindingIter<'a>(slice::Iter<'a, (Cow<'static, str>, Command)>);

            impl<'a> ExactSizeIterator for BindingIter<'a> {}

            impl<'a> Iterator for BindingIter<'a>
            {
                type Item = (&'a str, &'a Command);
                #[inline] fn next(&mut self) -> Option<Self::Item> { self.0.next().map(|&(ref s, ref cmd)| (&s[..], cmd)) }
                #[inline] fn nth(&mut self, n: usize) -> Option<Self::Item> { self.0.nth(n).map(|&(ref s, ref cmd)| (&s[..], cmd)) }
                #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }
            }

            impl<'a> DoubleEndedIterator for BindingIter<'a>
            {
                #[inline] fn next_back(&mut self) -> Option<Self::Item>
                { self.0.next_back().map(|&(ref s, ref cmd)| (&s[..], cmd)) }
            }

            fn default_bindings() -> SequenceMap<Cow<'static, str>, Command>
            {
                SequenceMap::from(vec!
                [
                    ("\r".into(), AcceptLine),
                    ("\n".into(), AcceptLine),
                    ("\x1b[A".into(), PreviousHistory),
                    ("\x1b[B".into(), NextHistory),
                    ("\x1b[C".into(), ForwardChar),
                    ("\x1b[D".into(), BackwardChar),
                    ("\x1b[H".into(), BeginningOfLine),
                    ("\x1b[F".into(), EndOfLine),
                    ("\x1bOA".into(), PreviousHistory),
                    ("\x1bOB".into(), NextHistory),
                    ("\x1bOC".into(), ForwardChar),
                    ("\x1bOD".into(), BackwardChar),
                    ("\x1bOH".into(), BeginningOfLine),
                    ("\x1bOF".into(), EndOfLine),
                    ("\x1b[2~".into(), OverwriteMode),
                    ("\x1b[3~".into(), DeleteChar),
                    ("\x01".into(), BeginningOfLine),           
                    ("\x02".into(), BackwardChar),              
                    ("\x04".into(), DeleteChar),                
                    ("\x05".into(), EndOfLine),                 
                    ("\x06".into(), ForwardChar),               
                    ("\x07".into(), Abort),                     
                    ("\x08".into(), BackwardDeleteChar),        
                    ("\x0b".into(), KillLine),                  
                    ("\x0c".into(), ClearScreen),               
                    ("\x0e".into(), NextHistory),               
                    ("\x10".into(), PreviousHistory),           
                    ("\x12".into(), ReverseSearchHistory),      
                    ("\x14".into(), TransposeChars),            
                    ("\x15".into(), BackwardKillLine),          
                    ("\x16".into(), QuotedInsert),              
                    ("\x17".into(), UnixWordRubout),            
                    ("\x19".into(), Yank),                      
                    ("\x1d".into(), CharacterSearch),           
                    ("\x7f".into(), BackwardDeleteChar),        
                    ("\x1b\x08".into(), BackwardKillWord),          
                    ("\x1b\x1d".into(), CharacterSearchBackward),   
                    ("\x1b\x7f".into(), BackwardKillWord),          
                    ("\x1bb".into(), BackwardWord),              
                    ("\x1bd".into(), KillWord),                  
                    ("\x1bf".into(), ForwardWord),               
                    ("\x1bt".into(), TransposeWords),            
                    ("\x1by".into(), YankPop),                   
                    ("\x1b#".into(), InsertComment),             
                    ("\x1b<".into(), BeginningOfHistory),        
                    ("\x1b>".into(), EndOfHistory),              
                    ("\t".into(), Complete),
                    ("\x1b?".into(), PossibleCompletions),
                    ("\x1b*".into(), InsertCompletions),
                    ("\x1b-".into(), DigitArgument),
                    ("\x1b0".into(), DigitArgument),
                    ("\x1b1".into(), DigitArgument),
                    ("\x1b2".into(), DigitArgument),
                    ("\x1b3".into(), DigitArgument),
                    ("\x1b4".into(), DigitArgument),
                    ("\x1b5".into(), DigitArgument),
                    ("\x1b6".into(), DigitArgument),
                    ("\x1b7".into(), DigitArgument),
                    ("\x1b8".into(), DigitArgument),
                    ("\x1b9".into(), DigitArgument),
                ])
            }

            fn limit_duration(dur: Option<Duration>, max: Option<Duration>) -> Option<Duration>
            {
                match (dur, max)
                {
                    (dur, None) | (None, dur) => dur,
                    (Some(dur), Some(max)) => Some(dur.min(max)),
                }
            }
        }
        pub use self::reader::{Reader, ReadResult};
        pub mod table
        {
            //! Provides utilities for formatting strings in a table
            use ::cmp::min;

            const COL_SPACE: usize = 2;
            /// Represents a table of strings, formatted into rows and columns
            pub struct Table<'a, S: 'a> 
            {
                strings: &'a [S],
                sizes: Option<&'a [usize]>,
                offset: usize,
                per_col: usize,
                rows: usize,
                horizontal: bool,
            }

            impl<'a, S: 'a + AsRef<str>> Table<'a, S> 
            {
                /// Constructs a new table from the given set of strings, using the given column sizes.
                pub fn new(strs: &'a [S], mut sizes: Option<&'a [usize]>, horizontal: bool) -> Table<'a, S>  
                {
                    if let Some(sz) = sizes
                    {
                        if sz.is_empty() { sizes = None; }
                    }

                    let n_strs = strs.len();
                    let n_cols = sizes.map_or(1, |sz| sz.len());
                    let rows = n_strs / n_cols + (n_strs % n_cols != 0) as usize;

                    Table
                    {
                        strings: strs,
                        sizes: sizes,
                        offset: 0,
                        per_col: (strs.len() + (n_cols - 1)) / n_cols,
                        rows: rows,
                        horizontal: horizontal,
                    }
                }

                /// Returns whether more lines are present in the table.
                pub fn has_more(&self) -> bool { self.offset < self.rows }
                fn num_cols(&self) -> usize { self.sizes.map_or(1, |sz| sz.len()) }
            }

            impl<'a, S: 'a + AsRef<str>> Iterator for Table<'a, S>
            {
                type Item = Line<'a, S>;
                fn next(&mut self) -> Option<Line<'a, S>>
                {
                    if self.offset == self.rows { return None; }

                    let n = self.num_cols();
                    let (start, end, stride) = if self.horizontal
                    {
                        let start = self.offset * n;
                        let end = min(self.strings.len(), start + n);
                        (start, end, 1)
                    }
                    
                    else
                    {
                        let start = self.offset;
                        let end = min(self.strings.len(), start + self.per_col * n);
                        (start, end, self.per_col)
                    };

                    self.offset += 1;
                    Some(Line
                    {
                        strings: &self.strings[start..end],
                        sizes: self.sizes,
                        stride: stride,
                        offset: 0,
                    })
                }
            }
            /// Represents a single line of the table.
            pub struct Line<'a, S: 'a>
            {
                strings: &'a [S],
                sizes: Option<&'a [usize]>,
                stride: usize,
                offset: usize,
            }

            impl<'a, S: 'a + AsRef<str>> Iterator for Line<'a, S>
            {
                type Item = (usize, &'a str);
                fn next(&mut self) -> Option<(usize, &'a str)>
                {
                    let s = self.strings.get(self.offset * self.stride)?.as_ref();
                    let width = self.sizes.and_then(|sz| sz.get(self.offset).cloned()).unwrap_or_else(|| s.chars().count());
                    self.offset += 1;
                    Some((width, s))
                }
            }
            /// Formats a series of strings into columns, fitting within a given screen width.
            pub fn format_columns<S: AsRef<str>>(strs: &[S], screen_width: usize, horizontal: bool) -> Option<Vec<usize>>
            {
                if strs.is_empty() { return None; }

                let n_strs = strs.len();
                let (mut min_len, mut max_len) = min_max(strs.iter().map(|s| s.as_ref().chars().count()));

                if min_len == 0 { min_len = 1; }
                if max_len == 0 { max_len = 1; }

                let mut min_cols = min(n_strs, screen_width / max_len);
                let max_cols = min(n_strs, screen_width / min_len);

                if min_cols <= 1 { min_cols = 2; }

                if max_cols <= 1 { return None; }

                let mut col_sizes = if min_cols == max_cols { vec![vec![0; max_cols]] } 
                else { (min_cols..max_cols + 1).map(|n| vec![0; n]).collect::<Vec<_>>() };

                for (i, s) in strs.iter().enumerate()
                {
                    let len = s.as_ref().chars().count();

                    for cols in &mut col_sizes
                    {
                        let n_cols = cols.len();
                        let col = if horizontal { i % n_cols } 
                        else
                        {
                            let per_col = (n_strs + (n_cols - 1)) / n_cols;
                            i / per_col
                        };

                        let real_len = if col == n_cols - 1 { len } else { len + COL_SPACE };

                        if real_len > cols[col] { cols[col] = real_len; }
                    }
                }

                for cols in col_sizes.into_iter().rev()
                {
                    if cols.iter().fold(0, |a, b| a + b) <= screen_width { return Some(cols); }
                }

                None
            }

            fn min_max<I>(iter: I) -> (usize, usize) where I: Iterator<Item=usize>
            {
                let mut min = usize::max_value();
                let mut max = 0;

                for n in iter
                {
                    if n < min { min = n; }
                    if n + COL_SPACE > max { max = n + COL_SPACE; }
                }

                (min, max)
            }
        }
        pub mod terminal
        {
            //! Provides a low-level terminal interface
            use ::
            {
                mortal::
                { 
                    self, CursorMode, PrepareConfig, PrepareState, TerminalReadGuard, Signal, SignalSet, Size, TerminalWriteGuard
                },
                prompt::lines::{ sys },
                time::{ Duration },
                *,
            };
            /// Default `Terminal` interface
            pub struct DefaultTerminal(mortal::Terminal);
            /// Represents the result of a `Terminal` read operation
            pub enum RawRead
            {
                /// `n` bytes were read from the device
                Bytes(usize),
                /// The terminal window was resized
                Resize(Size),
                /// A signal was received while waiting for input
                Signal(Signal),
            }
            /// Defines a low-level interface to the terminal
            pub trait Terminal: Sized + Send + Sync
            {
                /// Returned by `prepare`; passed to `restore` to restore state.
                type PrepareState;
                /*
                /// Holds an exclusive read lock and provides read operations
                type Reader: TerminalReader;
                /// Holds an exclusive write lock and provides write operations
                type Writer: TerminalWriter;
                */
                /// Returns the name of the terminal.
                fn name(&self) -> &str;
                /// Acquires a lock on terminal read operations and returns a value holding
                /// that lock and granting access to such operations.
                fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a>;

                /// Acquires a lock on terminal write operations and returns a value holding
                /// that lock and granting access to such operations.
                fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a>;
            }
            /// Holds a lock on `Terminal` read operations
            pub trait TerminalReader<Term: Terminal>
            {
                /// Prepares the terminal for line reading and editing operations.
                fn prepare(&mut self, block_signals: bool, report_signals: SignalSet) -> io::Result<Term::PrepareState>;
                /// Like `prepare`, but called when the write lock is already held.ongs.
                unsafe fn prepare_with_lock
                (&mut self, lock: &mut dyn TerminalWriter<Term>, block_signals: bool, report_signals: SignalSet)
                -> io::Result<Term::PrepareState>;
                /// Restores the terminal state using the given state data.
                fn restore(&mut self, state: Term::PrepareState) -> io::Result<()>;
                /// Like `restore`, but called when the write lock is already held.
                unsafe fn restore_with_lock
                (&mut self, lock: &mut dyn TerminalWriter<Term>, state: Term::PrepareState) -> io::Result<()>;
                /// Reads some input from the terminal and appends it to the given buffer.
                fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead>;
                /// Waits `timeout` for user input. If `timeout` is `None`, waits indefinitely.
                fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool>;
            }
            /// Holds a lock on `Terminal` write operations
            pub trait TerminalWriter<Term: Terminal>
            {
                /// Returns the size of the terminal window
                fn size(&self) -> io::Result<Size>;
                /// Presents a clear terminal screen, with cursor at first row, first column.
                fn clear_screen(&mut self) -> io::Result<()>;
                /// Clears characters on the line occupied by the cursor, beginning with the
                /// cursor and ending at the end of the line.
                fn clear_to_screen_end(&mut self) -> io::Result<()>;
                /// Moves the cursor up `n` cells; `n` may be zero.
                fn move_up(&mut self, n: usize) -> io::Result<()>;
                /// Moves the cursor down `n` cells; `n` may be zero.
                fn move_down(&mut self, n: usize) -> io::Result<()>;
                /// Moves the cursor left `n` cells; `n` may be zero.
                fn move_left(&mut self, n: usize) -> io::Result<()>;
                /// Moves the cursor right `n` cells; `n` may be zero.
                fn move_right(&mut self, n: usize) -> io::Result<()>;
                /// Moves the cursor to the first column of the current line
                fn move_to_first_column(&mut self) -> io::Result<()>;
                /// Set the current cursor mode
                fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()>;
                /// Writes output to the terminal.
                fn write(&mut self, s: &str) -> io::Result<()>;
                /// Flushes any currently buffered output data.
                fn flush(&mut self) -> io::Result<()>;
            }

            impl DefaultTerminal 
            {
                /// Opens access to the terminal device associated with standard output.
                pub fn new() -> io::Result<DefaultTerminal> { mortal::Terminal::new().map(DefaultTerminal) }
                /// Opens access to the terminal device associated with standard error.
                pub fn stderr() -> io::Result<DefaultTerminal> { mortal::Terminal::stderr().map(DefaultTerminal) }

                unsafe fn cast_writer<'a>(writer: &'a mut dyn TerminalWriter<Self>) -> 
                &'a mut TerminalWriteGuard<'a> { &mut *(writer as *mut _ as *mut TerminalWriteGuard) }
            }

            impl Terminal for DefaultTerminal
            {
                type PrepareState = PrepareState;

                fn name(&self) -> &str { self.0.name() }

                fn lock_read<'a>(&'a self) -> Box<dyn TerminalReader<Self> + 'a> { Box::new(self.0.lock_read().unwrap()) }

                fn lock_write<'a>(&'a self) -> Box<dyn TerminalWriter<Self> + 'a> { Box::new(self.0.lock_write().unwrap()) }
            }

            impl<'a> TerminalReader<DefaultTerminal> for TerminalReadGuard<'a>
            {
                fn prepare(&mut self, block_signals: bool, report_signals: SignalSet) -> io::Result<PrepareState>
                {
                    self.prepare(PrepareConfig
                    {
                        block_signals,
                        enable_control_flow: !block_signals,
                        enable_keypad: false,
                        report_signals,
                        .. PrepareConfig::default()
                    })
                }

                unsafe fn prepare_with_lock
                (
                    &mut self,
                    lock: &mut dyn TerminalWriter<DefaultTerminal>,
                    block_signals: bool, 
                    report_signals: SignalSet,
                ) -> io::Result<PrepareState>
                {
                    let lock = DefaultTerminal::cast_writer(lock);
                    self.prepare_with_lock(lock, PrepareConfig
                    {
                        block_signals,
                        enable_control_flow: !block_signals,
                        enable_keypad: false,
                        report_signals,
                        .. PrepareConfig::default()
                    })
                }

                fn restore(&mut self, state: PrepareState) -> io::Result<()> { self.restore(state) }

                unsafe fn restore_with_lock
                (
                    &mut self,
                    lock: &mut dyn TerminalWriter<DefaultTerminal>, 
                    state: PrepareState,
                ) -> io::Result<()> 
                {
                    let lock = DefaultTerminal::cast_writer(lock);
                    self.restore_with_lock(lock, state)
                }
                fn read(&mut self, buf: &mut Vec<u8>) -> io::Result<RawRead> { sys::terminal_read(self, buf) }
                fn wait_for_input(&mut self, timeout: Option<Duration>) -> io::Result<bool> { self.wait_event(timeout) }

            }

            impl<'a> TerminalWriter<DefaultTerminal> for TerminalWriteGuard<'a>
            {
                fn size(&self) -> io::Result<Size> { self.size() }
                fn clear_screen(&mut self) -> io::Result<()> { self.clear_screen() }
                fn clear_to_screen_end(&mut self) -> io::Result<()> { self.clear_to_screen_end() }
                fn move_up(&mut self, n: usize) -> io::Result<()> { self.move_up(n) }
                fn move_down(&mut self, n: usize) -> io::Result<()> { self.move_down(n) }
                fn move_left(&mut self, n: usize) -> io::Result<()> { self.move_left(n) }
                fn move_right(&mut self, n: usize) -> io::Result<()> { self.move_right(n) }
                fn move_to_first_column(&mut self) -> io::Result<()> { self.move_to_first_column() }
                fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> { self.set_cursor_mode(mode) }
                fn write(&mut self, s: &str) -> io::Result<()> { self.write_str(s) }
                fn flush(&mut self) -> io::Result<()> { self.flush() }
            }
        }
        pub use self::terminal::{DefaultTerminal, Signal, Terminal, Size};
        pub mod util
        {
            //! Provides miscellaneous utilities
            use ::
            {
                borrow::{ Cow },
                ops::{ Range, RangeFrom, RangeFull, RangeTo },
                prompt::lines::
                {
                    reader::{START_INVISIBLE, END_INVISIBLE},
                },
                str::{ from_utf8, from_utf8_unchecked },
                *,
            };
            
            pub fn filter_visible(s: &str) -> Cow<str>
            {
                if !s.contains(START_INVISIBLE) { return Cow::Borrowed(s); }

                let mut virt = String::new();
                let mut ignore = false;

                for ch in s.chars()
                {
                    if ch == START_INVISIBLE { ignore = true; }
                    else if ch == END_INVISIBLE { ignore = false; }
                    else if !ignore { virt.push(ch); }
                }

                Cow::Owned(virt)
            }
            /// Returns the longest common prefix of a set of strings.
            pub fn longest_common_prefix<'a, I, S>(iter: I) -> Option<&'a str> where
            I: IntoIterator<Item=&'a S>,
            S: 'a + ?Sized + AsRef<str>,
            {
                let mut iter = iter.into_iter();
                let mut pfx = iter.next()?.as_ref();

                for s in iter
                {
                    let s = s.as_ref();
                    let n = pfx.chars().zip(s.chars())
                    .take_while(|&(a, b)| a == b)
                    .map(|(ch, _)| ch.len_utf8()).sum();

                    if n == 0 { return None; } 
                    else { pfx = &pfx[..n]; }
                }

                Some(pfx)
            }
            /// Returns a string consisting of a `char`, repeated `n` times.
            pub fn repeat_char(ch: char, n: usize) -> String
            {
                let mut buf = [0; 4];
                let s = ch.encode_utf8(&mut buf);
                s.repeat(n)
            }
            /// Implemented for built-in range types.
            pub trait RangeArgument<T>
            {
                /// Returns the start of range, if present.
                fn start(&self) -> Option<&T> { None }
                /// Returns the end of range, if present.
                fn end(&self) -> Option<&T> { None }
            }

            impl<T> RangeArgument<T> for Range<T>
            {
                fn start(&self) -> Option<&T> { Some(&self.start) }
                fn end(&self) -> Option<&T> { Some(&self.end) }
            }

            impl<T> RangeArgument<T> for RangeFrom<T>
            {
                fn start(&self) -> Option<&T> { Some(&self.start) }
            }

            impl<T> RangeArgument<T> for RangeTo<T> 
            {
                fn end(&self) -> Option<&T> { Some(&self.end) }
            }

            impl<T> RangeArgument<T> for RangeFull {}

            pub fn backward_char(n: usize, s: &str, cur: usize) -> usize
            {
                let mut chars = s[..cur].char_indices().filter(|&(_, ch)| !is_combining_mark(ch));
                let mut res = cur;

                for _ in 0..n
                {
                    match chars.next_back()
                    {
                        Some((idx, _)) => res = idx,
                        None => return 0
                    }
                }

                res
            }

            pub fn forward_char(n: usize, s: &str, cur: usize) -> usize
            {
                let mut chars = s[cur..].char_indices().filter(|&(_, ch)| !is_combining_mark(ch));

                for _ in 0..n
                {
                    match chars.next()
                    {
                        Some(_) => (),
                        None => return s.len()
                    }
                }

                match chars.next()
                {
                    Some((idx, _)) => cur + idx,
                    None => s.len()
                }
            }

            pub fn backward_search_char(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize>
            {
                let mut pos = None;

                for _ in 0..n
                {
                    match buf[..cur].rfind(ch)
                    {
                        Some(p) =>
                        {
                            cur = p;
                            pos = Some(cur);
                        }
                        None => break
                    }
                }

                pos
            }

            pub fn forward_search_char(n: usize, buf: &str, mut cur: usize, ch: char) -> Option<usize>
            {
                let mut pos = None;

                for _ in 0..n
                {
                    let off = match buf[cur..].chars().next()
                    {
                        Some(ch) => ch.len_utf8(),
                        None => break
                    };

                    match buf[cur + off..].find(ch)
                    {
                        Some(p) =>
                        {
                            cur += off + p;
                            pos = Some(cur);
                        }
                        None => break
                    }
                }

                pos
            }

            pub fn backward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
            {
                let mut chars = buf[..cur].char_indices().rev();

                for _ in 0..n
                {
                    drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                    if chars.clone().next().is_none() { break; }
                    drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                    if chars.clone().next().is_none() { break; }
                }

                match chars.next()
                {
                    Some((ind, ch)) => ind + ch.len_utf8(),
                    None => 0
                }
            }

            pub fn forward_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
            {
                let mut chars = buf[cur..].char_indices();

                for _ in 0..n
                {
                    drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                    if chars.clone().next().is_none() { break; }
                    drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                    if chars.clone().next().is_none() { break; }
                }

                match chars.next()
                {
                    Some((ind, _)) => cur + ind,
                    None => buf.len()
                }
            }

            pub fn back_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize>
            {
                let prev = backward_word(1, buf, cur, word_break);
                let end = word_end(&buf, prev, word_break);

                if n > 1
                {
                    let start = backward_word(n - 1, buf, prev, word_break);
                    start..end
                }

                else { prev..end }
            }

            pub fn forward_n_words(n: usize, buf: &str, cur: usize, word_break: &str) -> Range<usize>
            {
                let start = next_word(1, buf, cur, word_break);

                if n > 1
                {
                    let last = next_word(n - 1, buf, start, word_break);
                    let end = word_end(buf, last, word_break);
                    start..end
                }
                
                else
                {
                    let end = word_end(buf, start, word_break);
                    start..end
                }
            }
            /// Returns the first character in the buffer, if it contains any valid characters.
            pub fn first_char(buf: &[u8]) -> io::Result<Option<char>>
            {
                match from_utf8(buf)
                {
                    Ok(s) => Ok(s.chars().next()),
                    Err(e) =>
                    {
                        if e.error_len().is_some() { return Err(io::Error::new(io::ErrorKind::InvalidData, "invalid utf-8 input received")); }

                        let valid = e.valid_up_to();
                        let s = unsafe { from_utf8_unchecked(&buf[..valid]) };
                        Ok(s.chars().next())
                    }
                }
            }

            pub fn first_word(buf: &str, word_break: &str) -> Option<usize>
            {
                let mut chars = buf.char_indices();
                drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                chars.next().map(|(idx, _)| idx)
            }

            pub fn word_start(buf: &str, cur: usize, word_break: &str) -> usize
            {
                let fwd = match buf[cur..].chars().next()
                {
                    Some(ch) => word_break.contains(ch),
                    None => return buf.len()
                };

                if fwd { next_word(1, buf, cur, word_break) } 
                else
                {
                    let mut chars = buf[..cur].char_indices().rev();
                    drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

                    match chars.next()
                    {
                        Some((idx, ch)) => idx + ch.len_utf8(),
                        None => 0
                    }
                }
            }

            pub fn next_word(n: usize, buf: &str, cur: usize, word_break: &str) -> usize
            {
                let mut chars = buf[cur..].char_indices();
                
                for _ in 0..n
                {
                    drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));
                    if chars.clone().next().is_none() { break; }
                    drop_while(&mut chars, |(_, ch)| word_break.contains(ch));
                    if chars.clone().next().is_none() { break; }
                }

                match chars.next()
                {
                    Some((idx, _)) => cur + idx,
                    None => buf.len()
                }
            }

            pub fn word_end(buf: &str, cur: usize, word_break: &str) -> usize
            {
                let mut chars = buf[cur..].char_indices();
                drop_while(&mut chars, |(_, ch)| !word_break.contains(ch));

                match chars.next()
                {
                    Some((idx, _)) => cur + idx,
                    None => buf.len()
                }
            }

            pub fn drop_while<I, T, F>(iter: &mut I, mut f: F) where
            I: Iterator<Item=T> + Clone, F: FnMut(T) -> bool
            {
                loop
                {
                    let mut clone = iter.clone();

                    match clone.next()
                    {
                        None => break,
                        Some(t) =>
                        {
                            if f(t) { *iter = clone; } 
                            else { break; }
                        }
                    }
                }
            }

            pub fn get_open_paren(ch: char) -> Option<char>
            {
                match ch
                {
                    ')' => Some('('),
                    ']' => Some('['),
                    '}' => Some('{'),
                    _ => None
                }
            }

            pub fn find_matching_paren(s: &str, quotes: &str, open: char, close: char) -> Option<usize>
            {
                let mut chars = s.char_indices().rev();
                let mut level = 0;
                let mut string_delim = None;

                while let Some((ind, ch)) = chars.next()
                {
                    if string_delim == Some(ch) { string_delim = None; }
                    else if quotes.contains(ch) { string_delim = Some(ch); }
                    else if string_delim.is_none() && ch == close { level += 1; }

                    else if string_delim.is_none() && ch == open
                    {
                        level -= 1;

                        if level == 0 { }
                    }
                }

                None
            }

            pub fn is_combining_mark(ch: char) -> bool
            {
                is::combining_mark(ch)
            }

            pub fn is_wide(ch: char) -> bool 
            {
                ::char::char_width(ch) == Some(2)
            }

            pub fn match_name(name: &str, value: &str) -> bool
            {
                name == value || (name.starts_with(value) && name.as_bytes()[value.len()] == b'-')
            }
        }
        pub mod variables
        {
            //! Contains types associated with user-configurable variables
            use ::
            {
                borrow::{ Cow },
                mem::{ replace },
                time::{ Duration },
            };
            /// Default `keyseq_timeout`, in milliseconds
            const KEYSEQ_TIMEOUT_MS: u64 = 500;

            macro_rules! define_variables
            {
                ( $(
                    $field:ident : $ty:ty => 
                    (
                        $name:expr , $conv:ident , |$gr:ident| $getter:expr , |$sr:ident, $v:ident| $setter:expr
                    ) , 
                    )+ 
                ) =>
                {
                    static VARIABLE_NAMES: &[&str] = &[ $( $name ),+ ];

                    pub(crate) struct Variables 
                    { 
                        $( pub $field : $ty ),* 
                    }

                    impl Variables
                    {
                        pub fn get_variable(&self, name: &str) -> Option<Variable>
                        {
                            match name
                            {
                                $( $name =>
                                {
                                    let $gr = self;
                                    Some(Variable::from($getter))
                                } )+
                                _ => None
                            }
                        }

                        pub fn set_variable(&mut self, name: &str, value: &str) -> Option<Variable>
                        {
                            match name
                            {
                                $( $name =>
                                {
                                    if let Some($v) = $conv(value)
                                    {
                                        let $sr = self;
                                        Some(Variable::from($setter))
                                    }

                                    else { None }
                                } )+
                                _ => None
                            }
                        }

                        pub fn iter(&self) -> VariableIter
                        {
                            VariableIter{vars: self, n: 0}
                        }
                    }

                    impl<'a> Iterator for VariableIter<'a> {
                        type Item = (&'static str, Variable);

                        fn next(&mut self) -> Option<Self::Item> {
                            let res = match VARIABLE_NAMES.get(self.n).cloned() {
                                $( Some($name) => ($name, {
                                    let $gr = self.vars;
                                    Variable::from($getter)
                                }) , )+
                                _ => return None
                            };

                            self.n += 1;
                            Some(res)
                        }
                    }
                }
            }
            /// Iterator over `Reader` variable values
            #[derive(Clone)]
            pub struct VariableIter<'a>
            {
                vars: &'a Variables,
                n: usize,
            }
            /// Represents a `Reader` variable of a given type
            #[derive(Clone, Debug)]
            pub enum Variable
            {
                /// Boolean variable
                Boolean(bool),
                /// Integer variable
                Integer(i32),
                /// String variable
                String(Cow<'static, str>),
            }

            impl From<bool> for Variable
            {
                fn from(b: bool) -> Variable { Variable::Boolean(b) }
            }

            impl From<i32> for Variable
            {
                fn from(i: i32) -> Variable { Variable::Integer(i) }
            }

            impl From<&'static str> for Variable
            {
                fn from(s: &'static str) -> Variable { Variable::String(s.into()) }
            }

            impl From<Cow<'static, str>> for Variable
            {
                fn from(s: Cow<'static, str>) -> Variable { Variable::String(s) }
            }

            impl From<String> for Variable
            {
                fn from(s: String) -> Variable { Variable::String(s.into()) }
            }

            impl fmt::Display for Variable
            {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match *self
                    {
                        Variable::Boolean(b) => f.write_str(if b { "on" } else { "off" }),
                        Variable::Integer(n) => fmt::Display::fmt(&n, f),
                        Variable::String(ref s) => fmt::Display::fmt(&s[..], f),
                    }
                }
            }

            define_variables!
            {
                blink_matching_paren: bool => ("blink-matching-paren", parse_bool,
                    |r| r.blink_matching_paren,
                    |r, v| replace(&mut r.blink_matching_paren, v)),
                comment_begin: Cow<'static, str> => ("comment-begin", parse_string,
                    |r| r.comment_begin.clone(),
                    |r, v| replace(&mut r.comment_begin, v.into())),
                completion_display_width: usize => ("completion-display-width", parse_usize,
                    |r| usize_as_i32(r.completion_display_width),
                    |r, v| usize_as_i32(replace(&mut r.completion_display_width, v))),
                completion_query_items: usize => ("completion-query-items", parse_usize,
                    |r| usize_as_i32(r.completion_query_items),
                    |r, v| usize_as_i32(replace(&mut r.completion_query_items, v))),
                disable_completion: bool => ("disable-completion", parse_bool,
                    |r| r.disable_completion,
                    |r, v| replace(&mut r.disable_completion, v)),
                echo_control_characters: bool => ("echo-control-characters", parse_bool,
                    |r| r.echo_control_characters,
                    |r, v| replace(&mut r.echo_control_characters, v)),
                keyseq_timeout: Option<Duration> => ("keyseq-timeout", parse_duration,
                    |r| as_millis(r.keyseq_timeout),
                    |r, v| as_millis(replace(&mut r.keyseq_timeout, v))),
                page_completions: bool => ("page-completions", parse_bool,
                    |r| r.page_completions,
                    |r, v| replace(&mut r.page_completions, v)),
                print_completions_horizontally: bool => ("print-completions-horizontally", parse_bool,
                    |r| r.print_completions_horizontally,
                    |r, v| replace(&mut r.print_completions_horizontally, v)),
            }

            impl Default for Variables
            {
                fn default() -> Variables
                {
                    Variables
                    {
                        blink_matching_paren: false,
                        comment_begin: "#".into(),
                        completion_display_width: usize::max_value(),
                        completion_query_items: 100,
                        disable_completion: false,
                        echo_control_characters: true,
                        keyseq_timeout: Some(Duration::from_millis(KEYSEQ_TIMEOUT_MS)),
                        page_completions: true,
                        print_completions_horizontally: false,
                    }
                }
            }

            fn parse_bool(s: &str) -> Option<bool>
            {
                match s
                {
                    "0" => Some(false),
                    "1" => Some(true),
                    s if s.eq_ignore_ascii_case("off") => Some(false),
                    s if s.eq_ignore_ascii_case("on") => Some(true),
                    _ => None
                }
            }

            fn parse_string(s: &str) -> Option<String> { Some(s.to_owned()) }

            fn as_millis(timeout: Option<Duration>) -> i32
            {
                match timeout
                {
                    Some(t) =>
                    {
                        let s = (t.as_secs() * 1_000) as i32;
                        let ms = (t.subsec_nanos() / 1_000_000) as i32;
                        s + ms
                    }

                    None => -1
                }
            }

            fn parse_duration(s: &str) -> Option<Option<Duration>>
            {
                match s.parse::<i32>()
                {
                    Ok(n) if n <= 0 => Some(None),
                    Ok(n) => Some(Some(Duration::from_millis(n as u64))),
                    Err(_) => Some(None)
                }
            }

            fn usize_as_i32(u: usize) -> i32
            {
                match u
                {
                    u if u > i32::max_value() as usize => -1,
                    u => u as i32
                }
            }

            fn parse_usize(s: &str) -> Option<usize>
            {
                match s.parse::<i32>()
                {
                    Ok(n) if n < 0 => Some(usize::max_value()),
                    Ok(n) => Some(n as usize),
                    Err(_) => None
                }
            }
        }
        pub mod writer
        {
            //! Provides access to terminal write operations
            use ::
            {
                borrow::Cow::{ self, Borrowed, Owned },
                collections::{ vec_deque, VecDeque }, 
                iter::{ repeat, Skip },
                mem::{ swap },
                ops::{ Deref, DerefMut, Range },
                prompt::lines::
                {
                    reader::{ START_INVISIBLE, END_INVISIBLE },
                    chars::{ is_ctrl, unctrl, ESCAPE, RUBOUT },
                    terminal::{ CursorMode, Size, Terminal, TerminalWriter },
                    util::
                    { 
                        backward_char, forward_char, backward_search_char, forward_search_char, filter_visible, 
                        is_combining_mark, is_wide, RangeArgument, 
                    },
                },
                sync::{ MutexGuard },
                time::{ Duration, Instant },
                *,
            };
            
            /// Maximum value of digit input
            const NUMBER_MAX: i32 = 1_000_000;            
            /// Duration to wait for input when "blinking"
            pub(crate) const BLINK_DURATION: Duration = Duration::from_millis(500);
            // PRIVATE
            const COMPLETE_MORE: &'static str = "--More--";
            /// Default maximum history size
            const MAX_HISTORY: usize = !0;
            /// Tab column interval
            const TAB_STOP: usize = 8;
            // Length of "(arg: "
            const PROMPT_NUM_PREFIX: usize = 6;
            // Length of ") "
            const PROMPT_NUM_SUFFIX: usize = 2;
            // Length of "(i-search)`"
            const PROMPT_SEARCH_PREFIX: usize = 11;
            // Length of "failed "
            const PROMPT_SEARCH_FAILED_PREFIX: usize = 7;
            // Length of "reverse-"
            const PROMPT_SEARCH_REVERSE_PREFIX: usize = 8;
            // Length of "': "
            const PROMPT_SEARCH_SUFFIX: usize = 3;
            /// Provides an interface to write line-by-line output to the terminal device.
            pub struct Writer<'a, 'b: 'a, Term: 'b + Terminal>
            {
                write: WriterImpl<'a, 'b, Term>,
            }

            enum WriterImpl<'a, 'b: 'a, Term: 'b + Terminal>
            {
                Mutex(WriteLock<'b, Term>),
                MutRef(&'a mut WriteLock<'b, Term>),
            }

            pub(crate) struct Write
            {
                /// Input buffer
                pub buffer: String,
                /// Original buffer entered before searching through history
                pub backup_buffer: String,
                /// Position of the cursor
                pub cursor: usize,
                /// Position of the cursor if currently performing a blink
                blink: Option<Blink>,
                /// Stored history entries
                pub history: VecDeque<String>,
                /// History entry currently being edited;
                /// `None` if the new buffer is being edited
                pub history_index: Option<usize>,
                /// Maximum size of history
                history_size: usize,
                /// Number of history entries added since last loading history
                history_new_entries: usize,
                /// Whether the prompt is drawn; i.e. a `read_line` operation is in progress
                pub is_prompt_drawn: bool,
                /// Portion of prompt up to and including the final newline
                pub prompt_prefix: String,
                prompt_prefix_len: usize,
                /// Portion of prompt after the final newline
                pub prompt_suffix: String,
                prompt_suffix_len: usize,
                /// Current type of prompt
                pub prompt_type: PromptType,
                /// Whether a search in progress is a reverse search
                pub reverse_search: bool,
                /// Whether a search in progress has failed to find a match
                pub search_failed: bool,
                /// Current search string
                pub search_buffer: String,
                /// Last search string
                pub last_search: String,
                /// Selected history entry prior to a history search
                pub prev_history: Option<usize>,
                /// Position of the cursor prior to a history search
                pub prev_cursor: usize,
                /// Numerical argument
                pub input_arg: Digit,
                /// Whether a numerical argument was supplied
                pub explicit_arg: bool,
                /// Terminal size as of last draw operation
                pub screen_size: Size,
            }

            pub(crate) struct WriteLock<'a, Term: 'a + Terminal>
            {
                term: Box<dyn TerminalWriter<Term> + 'a>,
                data: MutexGuard<'a, Write>,
            }

            impl<'a, Term: Terminal> WriteLock<'a, Term>
            {
                pub fn new(term: Box<dyn TerminalWriter<Term> + 'a>, data: MutexGuard<'a, Write>) -> WriteLock<'a, Term>
                {
                    WriteLock{term, data}
                }

                pub fn size(&self) -> io::Result<Size> { self.term.size() }

                pub fn flush(&mut self) -> io::Result<()> { self.term.flush() }

                pub fn update_size(&mut self) -> io::Result<()>
                {
                    let size = self.size()?;
                    self.screen_size = size;
                    Ok(())
                }

                pub fn blink(&mut self, pos: usize) -> io::Result<()>
                {
                    self.expire_blink()?;
                    let orig = self.cursor;
                    self.move_to(pos)?;
                    self.cursor = orig;
                    let expiry = Instant::now() + BLINK_DURATION;
                    self.blink = Some(Blink
                    {
                        pos,
                        expiry,
                    });

                    Ok(())
                }

                pub fn check_expire_blink(&mut self, now: Instant) -> io::Result<bool>
                {
                    if let Some(blink) = self.data.blink
                    {
                        if now >= blink.expiry { self.expire_blink()?; }
                    }

                    Ok(self.blink.is_none())
                }

                pub fn expire_blink(&mut self) -> io::Result<()>
                {
                    if let Some(blink) = self.data.blink.take() { self.move_from(blink.pos)?; }

                    Ok(())
                }

                pub fn set_prompt(&mut self, prompt: &str) -> io::Result<()>
                {
                    self.expire_blink()?;
                    let redraw = self.is_prompt_drawn && self.prompt_type.is_normal();

                    if redraw { self.clear_full_prompt()?; }

                    self.data.set_prompt(prompt);

                    if redraw { self.draw_prompt()?; }

                    Ok(())
                }
                /// Draws the prompt and current input, assuming the cursor is at column 0
                pub fn draw_prompt(&mut self) -> io::Result<()>
                {
                    self.draw_prompt_prefix()?;
                    self.draw_prompt_suffix()
                }

                pub fn draw_prompt_prefix(&mut self) -> io::Result<()>
                {
                    match self.prompt_type
                    {
                        PromptType::CompleteMore => Ok(()),
                        _ =>
                        {
                            let pfx = self.prompt_prefix.clone();
                            self.draw_raw_prompt(&pfx)
                        }
                    }
                }

                pub fn draw_prompt_suffix(&mut self) -> io::Result<()>
                {
                    match self.prompt_type
                    {
                        PromptType::Normal =>
                        {
                            let sfx = self.prompt_suffix.clone();
                            self.draw_raw_prompt(&sfx)?;
                        }
                        
                        PromptType::Number =>
                        {
                            let n = self.input_arg.to_i32();
                            let s = format!("(arg: {}) ", n);
                            self.draw_text(0, &s)?;
                        }
                        
                        PromptType::Search =>
                        {
                            let pre = match (self.reverse_search, self.search_failed)
                            {
                                (false, false) => "(i-search)",
                                (false, true)  => "(failed i-search)",
                                (true,  false) => "(reverse-i-search)",
                                (true,  true)  => "(failed reverse-i-search)",
                            };

                            let ent = self.get_history(self.history_index).to_owned();
                            let s = format!("{}`{}': {}", pre, self.search_buffer, ent);
                            self.draw_text(0, &s)?;
                            let pos = self.cursor;
                            let (lines, cols) = self.move_delta(ent.len(), pos, &ent);
                            return self.move_rel(lines, cols);
                        }

                        PromptType::CompleteIntro(n) => { return self.term.write(&complete_intro(n)); }
                        PromptType::CompleteMore => { return self.term.write(COMPLETE_MORE); }
                    }

                    self.draw_buffer(0)?;
                    let len = self.buffer.len();
                    self.move_from(len)
                }

                pub fn redraw_prompt(&mut self, new_prompt: PromptType) -> io::Result<()>
                {
                    self.clear_prompt()?;
                    self.prompt_type = new_prompt;
                    self.draw_prompt_suffix()
                }
                /// Draws a portion of the buffer, starting from the given cursor position
                pub fn draw_buffer(&mut self, pos: usize) -> io::Result<()> 
                {
                    let (_, col) = self.line_col(pos);
                    let buf = self.buffer[pos..].to_owned();
                    self.draw_text(col, &buf)?;
                    Ok(())
                }
                /// Draw some text with the cursor beginning at the given column.
                fn draw_text(&mut self, start_col: usize, text: &str) -> io::Result<()>
                {
                    self.draw_text_impl(start_col, text, Display
                    {
                        allow_tab: true,
                        allow_newline: true,
                        .. Display::default()
                    }, false)
                }

                fn draw_raw_prompt(&mut self, text: &str) -> io::Result<()>
                {
                    self.draw_text_impl(0, text, Display{
                        allow_tab: true,
                        allow_newline: true,
                        allow_escape: true,
                    }, true)
                }

                fn draw_text_impl(&mut self, start_col: usize, text: &str, disp: Display, handle_invisible: bool) -> 
                io::Result<()>
                {
                    let width = self.screen_size.columns;
                    let mut col = start_col;
                    let mut out = String::with_capacity(text.len());
                    let mut clear = false;
                    let mut hidden = false;
                    for ch in text.chars()
                    {
                        if handle_invisible && ch == START_INVISIBLE { hidden = true; }
                        else if handle_invisible && ch == END_INVISIBLE { hidden = false; }
                        else if hidden { out.push(ch); } 
                        else
                        {
                            for ch in display(ch, disp)
                            {
                                if ch == '\t'
                                {
                                    let n = TAB_STOP - (col % TAB_STOP);

                                    if col + n > width
                                    {
                                        let pre = width - col;
                                        out.extend(repeat(' ').take(pre));
                                        out.push_str(" \r");
                                        out.extend(repeat(' ').take(n - pre));
                                        col = n - pre;
                                    }
                                    
                                    else
                                    {
                                        out.extend(repeat(' ').take(n));
                                        col += n;
                                        if col == width
                                        {
                                            out.push_str(" \r");
                                            col = 0;
                                        }
                                    }
                                }
                                
                                else if ch == '\n'
                                {
                                    if !clear
                                    {
                                        self.term.write(&out)?;
                                        out.clear();
                                        self.term.clear_to_screen_end()?;
                                        clear = true;
                                    }

                                    out.push('\n');
                                    col = 0;
                                }
                                
                                else if is_combining_mark(ch)
                                {
                                    out.push(ch);
                                }
                                
                                else if is_wide(ch)
                                {
                                    if col == width - 1
                                    {
                                        out.push_str("  \r");
                                        out.push(ch);
                                        col = 2;
                                    }
                                    
                                    else
                                    {
                                        out.push(ch);
                                        col += 2;
                                    }
                                } 
                                
                                else
                                {
                                    out.push(ch);
                                    col += 1;

                                    if col == width
                                    {
                                        out.push_str(" \r");
                                        col = 0;
                                    }
                                }
                            }
                        }
                    }

                    if col == width { out.push_str(" \r"); }

                    self.term.write(&out)
                }

                pub fn set_buffer(&mut self, buf: &str) -> io::Result<()>
                {
                    self.expire_blink()?;
                    self.move_to(0)?;
                    self.buffer.clear();
                    self.buffer.push_str(buf);
                    self.new_buffer()
                }

                pub fn set_cursor(&mut self, pos: usize) -> io::Result<()>
                {
                    self.expire_blink()?;
                    if !self.buffer.is_char_boundary(pos)
                    {
                        panic!("invalid cursor position {} in buffer {:?}", pos, self.buffer);
                    }

                    self.move_to(pos)
                }

                pub fn set_cursor_mode(&mut self, mode: CursorMode) -> io::Result<()> { self.term.set_cursor_mode(mode) }

                pub fn history_len(&self) -> usize { self.history.len() }

                pub fn history_size(&self) -> usize { self.history_size }

                pub fn set_history_size(&mut self, n: usize)
                {
                    self.history_size = n;
                    self.truncate_history(n);
                }

                pub fn write_str(&mut self, s: &str) -> io::Result<()> { self.term.write(s) }

                pub fn start_history_search(&mut self, reverse: bool) -> io::Result<()>
                {
                    self.search_buffer = self.buffer[..self.cursor].to_owned();
                    self.continue_history_search(reverse)
                }

                pub fn continue_history_search(&mut self, reverse: bool) -> io::Result<()>
                {
                    if let Some(idx) = self.find_history_search(reverse)
                    {
                        self.set_history_entry(Some(idx));

                        let pos = self.cursor;
                        let end = self.buffer.len();
                        self.draw_buffer(pos)?;
                        self.clear_to_screen_end()?;
                        self.move_from(end)?;
                    }

                    Ok(())
                }

                fn find_history_search(&self, reverse: bool) -> Option<usize>
                {
                    let len = self.history.len();
                    let idx = self.history_index.unwrap_or(len);
                    if reverse
                    {
                        self.history.iter().rev().skip(len - idx)
                        .position(|ent| ent.starts_with(&self.search_buffer))
                        .map(|pos| idx - (pos + 1))
                    } 
                    
                    else
                    {
                        self.history.iter().skip(idx + 1)
                        .position(|ent| ent.starts_with(&self.search_buffer))
                        .map(|pos| idx + (pos + 1))
                    }
                }

                pub fn start_search_history(&mut self, reverse: bool) -> io::Result<()>
                {
                    self.reverse_search = reverse;
                    self.search_failed = false;
                    self.search_buffer.clear();
                    self.prev_history = self.history_index;
                    self.prev_cursor = self.cursor;
                    self.redraw_prompt(PromptType::Search)
                }

                pub fn continue_search_history(&mut self, reverse: bool) -> io::Result<()>
                {
                    self.reverse_search = reverse;
                    self.search_failed = false;
                    {
                        let data = &mut *self.data;
                        data.search_buffer.clone_from(&data.last_search);
                    }
                    self.search_history_step()
                }

                pub fn end_search_history(&mut self) -> io::Result<()>
                { self.redraw_prompt(PromptType::Normal) }

                pub fn abort_search_history(&mut self) -> io::Result<()>
                {
                    self.clear_prompt()?;
                    let ent = self.prev_history;
                    self.set_history_entry(ent);
                    self.cursor = self.prev_cursor;
                    self.prompt_type = PromptType::Normal;
                    self.draw_prompt_suffix()
                }

                fn show_search_match(&mut self, next_match: Option<(Option<usize>, usize)>) -> io::Result<()>
                {
                    self.clear_prompt()?;
                    if let Some((idx, pos)) = next_match
                    {
                        self.search_failed = false;
                        self.set_history_entry(idx);
                        self.cursor = pos;
                    }
                    else { self.search_failed = true; }

                    self.prompt_type = PromptType::Search;
                    self.draw_prompt_suffix()
                }

                pub fn search_history_update(&mut self) -> io::Result<()> 
                {
                    let next_match = if self.reverse_search
                    { self.search_history_backward(&self.search_buffer, true) }
                    else { self.search_history_forward(&self.search_buffer, true) };
                    self.show_search_match(next_match)
                }

                fn search_history_step(&mut self) -> io::Result<()>
                {
                    if self.search_buffer.is_empty() { return self.redraw_prompt(PromptType::Search); }
                    
                    let next_match = if self.reverse_search { self.search_history_backward(&self.search_buffer, false) }
                    else { self.search_history_forward(&self.search_buffer, false) };

                    self.show_search_match(next_match)
                }

                fn search_history_backward(&self, s: &str, include_cur: bool) -> Option<(Option<usize>, usize)>
                {
                    let mut idx = self.history_index;
                    let mut pos = Some(self.cursor);
                    if include_cur && !self.search_failed
                    {
                        if let Some(p) = pos
                        {
                            if self.get_history(idx).is_char_boundary(p + s.len()) { pos = Some(p + s.len()); }
                        }
                    }

                    loop
                    {
                        let line = self.get_history(idx);

                        match line[..pos.unwrap_or(line.len())].rfind(s)
                        {
                            Some(found) =>
                            {
                                pos = Some(found);
                                break;
                            }
                            
                            None =>
                            {
                                match idx
                                {
                                    Some(0) => return None,
                                    Some(n) =>
                                    {
                                        idx = Some(n - 1);
                                        pos = None;
                                    }
                                    None =>
                                    {
                                        if self.history.is_empty() { return None; } 
                                        else
                                        {
                                            idx = Some(self.history.len() - 1);
                                            pos = None;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    pos.map(|pos| (idx, pos))
                }

                fn search_history_forward(&self, s: &str, include_cur: bool) -> Option<(Option<usize>, usize)>
                {
                    let mut idx = self.history_index;
                    let mut pos = Some(self.cursor);

                    if !include_cur
                    {
                        if let Some(p) = pos { pos = Some(forward_char(1, self.get_history(idx), p)); }
                    }

                    loop
                    {
                        let line = self.get_history(idx);
                        match line[pos.unwrap_or(0)..].find(s)
                        {
                            Some(found) =>
                            {
                                pos = pos.map(|n| n + found).or(Some(found));
                                break;
                            }
                            
                            None =>
                            {
                                if let Some(n) = idx
                                {
                                    if n + 1 == self.history.len() { idx = None; }
                                    else { idx = Some(n + 1); }
                                    pos = None;
                                } 
                                else { return None; }
                            }
                        }
                    }

                    pos.map(|pos| (idx, pos))
                }

                pub fn add_history(&mut self, line: String)
                {
                    if self.history.len() == self.history_size { self.history.pop_front(); }

                    self.history.push_back(line);
                    self.history_new_entries = self.history.len().min(self.history_new_entries + 1);
                }

                pub fn add_history_unique(&mut self, line: String)
                {
                    let is_duplicate = self.history.back().map_or(false, |ent| *ent == line);
                    if !is_duplicate { self.add_history(line); }
                }

                pub fn clear_history(&mut self)
                {
                    self.truncate_history(0);
                    self.history_new_entries = 0;
                }

                pub fn remove_history(&mut self, n: usize)
                {
                    if n < self.history.len()
                    {
                        let first_new = self.history.len() - self.history_new_entries;

                        if n >= first_new { self.history_new_entries -= 1; }

                        self.history.remove(n);
                    }
                }

                pub fn truncate_history(&mut self, n: usize)
                {
                    let len = self.history.len();

                    if n < len {
                        let _ = self.history.drain(..len - n);
                        self.history_new_entries = self.history_new_entries.max(n);
                    }
                }

                pub fn next_history(&mut self, n: usize) -> io::Result<()> {
                    if let Some(old) = self.history_index {
                        let new = old.saturating_add(n);

                        if new >= self.history.len() {
                            self.select_history_entry(None)?;
                        } else {
                            self.select_history_entry(Some(new))?;
                        }
                    }

                    Ok(())
                }

                pub fn prev_history(&mut self, n: usize) -> io::Result<()> {
                    if !self.history.is_empty() && self.history_index != Some(0) {
                        let new = if let Some(old) = self.history_index {
                            old.saturating_sub(n)
                        } else {
                            self.history.len().saturating_sub(n)
                        };

                        self.select_history_entry(Some(new))?;
                    }

                    Ok(())
                }

                pub fn select_history_entry(&mut self, new: Option<usize>) -> io::Result<()> {
                    if new != self.history_index {
                        self.move_to(0)?;
                        self.set_history_entry(new);
                        self.new_buffer()?;
                    }

                    Ok(())
                }

                pub fn set_history_entry(&mut self, new: Option<usize>) {
                    let old = self.history_index;

                    if old != new {
                        let data = &mut *self.data;
                        data.history_index = new;

                        if let Some(old) = old {
                            data.history[old].clone_from(&data.buffer);
                        } else {
                            swap(&mut data.buffer, &mut data.backup_buffer);
                        }

                        if let Some(new) = new {
                            data.buffer.clone_from(&data.history[new]);
                        } else {
                            data.buffer.clear();
                            swap(&mut data.buffer, &mut data.backup_buffer);
                        }
                    }
                }

                fn get_history(&self, n: Option<usize>) -> &str {
                    if self.history_index == n {
                        &self.buffer
                    } else if let Some(n) = n {
                        &self.history[n]
                    } else {
                        &self.backup_buffer
                    }
                }

                pub fn backward_char(&mut self, n: usize) -> io::Result<()> {
                    let pos = backward_char(n, &self.buffer, self.cursor);
                    self.move_to(pos)
                }

                pub fn forward_char(&mut self, n: usize) -> io::Result<()> {
                    let pos = forward_char(n, &self.buffer, self.cursor);
                    self.move_to(pos)
                }

                pub fn backward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> {
                    if let Some(pos) = backward_search_char(n, &self.buffer, self.cursor, ch) {
                        self.move_to(pos)?;
                    }

                    Ok(())
                }

                pub fn forward_search_char(&mut self, n: usize, ch: char) -> io::Result<()> {
                    if let Some(pos) = forward_search_char(n, &self.buffer, self.cursor, ch) {
                        self.move_to(pos)?;
                    }

                    Ok(())
                }

                /// Deletes a range from the buffer; the cursor is moved to the end
                /// of the given range.
                pub fn delete_range<R: RangeArgument<usize>>(&mut self, range: R) -> io::Result<()> {
                    let start = range.start().cloned().unwrap_or(0);
                    let end = range.end().cloned().unwrap_or_else(|| self.buffer.len());

                    self.move_to(start)?;

                    let _ = self.buffer.drain(start..end);

                    self.draw_buffer(start)?;
                    self.term.clear_to_screen_end()?;
                    let len = self.buffer.len();
                    self.move_from(len)?;

                    Ok(())
                }

                pub fn insert_str(&mut self, s: &str) -> io::Result<()> {
                    // If the string insertion moves a combining character,
                    // we must redraw starting from the character before the cursor.
                    let moves_combining = match self.buffer[self.cursor..].chars().next() {
                        Some(ch) if is_combining_mark(ch) => true,
                        _ => false
                    };

                    let cursor = self.cursor;
                    self.buffer.insert_str(cursor, s);

                    if moves_combining && cursor != 0 {
                        let pos = backward_char(1, &self.buffer, self.cursor);
                        // Move without updating the cursor
                        let (lines, cols) = self.move_delta(cursor, pos, &self.buffer);
                        self.move_rel(lines, cols)?;
                        self.draw_buffer(pos)?;
                    } else {
                        self.draw_buffer(cursor)?;
                    }

                    self.cursor += s.len();

                    let len = self.buffer.len();
                    self.move_from(len)
                }

                pub fn transpose_range(&mut self, src: Range<usize>, dest: Range<usize>)
                        -> io::Result<()> {
                    // Ranges must not overlap
                    assert!(src.end <= dest.start || src.start >= dest.end);

                    // Final cursor position
                    let final_cur = if src.start < dest.start {
                        dest.end
                    } else {
                        dest.start + (src.end - src.start)
                    };

                    let (left, right) = if src.start < dest.start {
                        (src, dest)
                    } else {
                        (dest, src)
                    };

                    self.move_to(left.start)?;

                    let a = self.buffer[left.clone()].to_owned();
                    let b = self.buffer[right.clone()].to_owned();

                    let _ = self.buffer.drain(right.clone());
                    self.buffer.insert_str(right.start, &a);

                    let _ = self.buffer.drain(left.clone());
                    self.buffer.insert_str(left.start, &b);

                    let cursor = self.cursor;
                    self.draw_buffer(cursor)?;
                    self.term.clear_to_screen_end()?;

                    self.cursor = final_cur;
                    let len = self.buffer.len();
                    self.move_from(len)
                }

                fn prompt_suffix_length(&self) -> usize {
                    match self.prompt_type {
                        PromptType::Normal => self.prompt_suffix_len,
                        PromptType::Number => {
                            let n = number_len(self.input_arg.to_i32());
                            PROMPT_NUM_PREFIX + PROMPT_NUM_SUFFIX + n
                        }
                        PromptType::Search => {
                            let mut prefix = PROMPT_SEARCH_PREFIX;

                            if self.reverse_search {
                                prefix += PROMPT_SEARCH_REVERSE_PREFIX;
                            }
                            if self.search_failed {
                                prefix += PROMPT_SEARCH_FAILED_PREFIX;
                            }

                            let n = self.display_size(&self.search_buffer, prefix);
                            prefix + n + PROMPT_SEARCH_SUFFIX
                        }
                        PromptType::CompleteIntro(n) => complete_intro(n).len(),
                        PromptType::CompleteMore => COMPLETE_MORE.len(),
                    }
                }

                fn line_col(&self, pos: usize) -> (usize, usize) {
                    let prompt_len = self.prompt_suffix_length();

                    match self.prompt_type {
                        PromptType::CompleteIntro(_) |
                        PromptType::CompleteMore => {
                            let width = self.screen_size.columns;
                            (prompt_len / width, prompt_len % width)
                        }
                        _ => self.line_col_with(pos, &self.buffer, prompt_len)
                    }
                }

                fn line_col_with(&self, pos: usize, buf: &str, start_col: usize) -> (usize, usize) {
                    let width = self.screen_size.columns;
                    if width == 0 {
                        return (0, 0);
                    }

                    let n = start_col + self.display_size(&buf[..pos], start_col);

                    (n / width, n % width)
                }

                pub fn clear_screen(&mut self) -> io::Result<()> {
                    self.term.clear_screen()?;
                    self.draw_prompt()?;

                    Ok(())
                }

                pub fn clear_to_screen_end(&mut self) -> io::Result<()> {
                    self.term.clear_to_screen_end()
                }

                /// Draws a new buffer on the screen. Cursor position is assumed to be `0`.
                pub fn new_buffer(&mut self) -> io::Result<()> {
                    self.draw_buffer(0)?;
                    self.cursor = self.buffer.len();

                    self.term.clear_to_screen_end()?;

                    Ok(())
                }

                pub fn clear_full_prompt(&mut self) -> io::Result<()> {
                    let prefix_lines = self.prompt_prefix_len / self.screen_size.columns;
                    let (line, _) = self.line_col(self.cursor);
                    self.term.move_up(prefix_lines + line)?;
                    self.term.move_to_first_column()?;
                    self.term.clear_to_screen_end()
                }

                pub(crate) fn clear_prompt(&mut self) -> io::Result<()> {
                    let (line, _) = self.line_col(self.cursor);

                    self.term.move_up(line)?;
                    self.term.move_to_first_column()?;
                    self.term.clear_to_screen_end()
                }

                /// Move back to true cursor position from some other position
                pub fn move_from(&mut self, pos: usize) -> io::Result<()> {
                    let (lines, cols) = self.move_delta(pos, self.cursor, &self.buffer);
                    self.move_rel(lines, cols)
                }

                pub fn move_to(&mut self, pos: usize) -> io::Result<()> {
                    if pos != self.cursor {
                        let (lines, cols) = self.move_delta(self.cursor, pos, &self.buffer);
                        self.move_rel(lines, cols)?;
                        self.cursor = pos;
                    }

                    Ok(())
                }

                pub fn move_to_end(&mut self) -> io::Result<()> {
                    let pos = self.buffer.len();
                    self.move_to(pos)
                }

                pub fn move_right(&mut self, n: usize) -> io::Result<()> {
                    self.term.move_right(n)
                }

                /// Moves from `old` to `new` cursor position, using the given buffer
                /// as current input.
                fn move_delta(&self, old: usize, new: usize, buf: &str) -> (isize, isize) {
                    let prompt_len = self.prompt_suffix_length();
                    let (old_line, old_col) = self.line_col_with(old, buf, prompt_len);
                    let (new_line, new_col) = self.line_col_with(new, buf, prompt_len);

                    (new_line as isize - old_line as isize,
                    new_col as isize - old_col as isize)
                }

                fn move_rel(&mut self, lines: isize, cols: isize) -> io::Result<()> {
                    if lines > 0 {
                        self.term.move_down(lines as usize)?;
                    } else if lines < 0 {
                        self.term.move_up((-lines) as usize)?;
                    }

                    if cols > 0 {
                        self.term.move_right(cols as usize)?;
                    } else if cols < 0 {
                        self.term.move_left((-cols) as usize)?;
                    }

                    Ok(())
                }

                pub fn reset_data(&mut self) {
                    self.data.reset_data();
                }

                pub fn set_digit_from_char(&mut self, ch: char) {
                    let digit = match ch {
                        '-' => Digit::NegNone,
                        '0' ..= '9' => Digit::from(ch),
                        _ => Digit::None
                    };

                    self.input_arg = digit;
                    self.explicit_arg = true;
                }
            }

            #[derive(Copy, Clone)]
            struct Blink
            {
                pos: usize,
                expiry: Instant,
            }

            impl<'a, 'b: 'a, Term: 'b + Terminal> Writer<'a, 'b, Term>
            {
                fn new(mut write: WriterImpl<'a, 'b, Term>, clear: bool) -> io::Result<Self>
                {
                    write.expire_blink()?;

                    if write.is_prompt_drawn
                    {
                        if clear { write.clear_full_prompt()?; }
                        else
                        {
                            write.move_to_end()?;
                            write.write_str("\n")?;
                        }
                    }

                    Ok(Writer{write})
                }

                pub(crate) fn with_lock(write: WriteLock<'b, Term>, clear: bool) -> io::Result<Self>
                {
                    Writer::new(WriterImpl::Mutex(write), clear)
                }

                pub(crate) fn with_ref(write: &'a mut WriteLock<'b, Term>, clear: bool) -> io::Result<Self>
                {
                    Writer::new(WriterImpl::MutRef(write), clear)
                }
                /// Returns an iterator over history entries.
                pub fn history(&self) -> HistoryIter
                {
                    self.write.history()
                }

                /// Writes some text to the terminal device.
                pub fn write_str(&mut self, s: &str) -> io::Result<()> { self.write.write_str(s) }
                /// Writes formatted text to the terminal display.
                pub fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()>
                {
                    let s = args.to_string();
                    self.write_str(&s)
                }
            }

            impl<'a, 'b: 'a, Term: 'b + Terminal> Drop for Writer<'a, 'b, Term>
            {
                fn drop(&mut self)
                {
                    if self.write.is_prompt_drawn { let _ = self.write.draw_prompt(); }
                }
            }

            impl<'a, Term: 'a + Terminal> Deref for WriteLock<'a, Term>
            {
                type Target = Write;
                fn deref(&self) -> &Write { &self.data }
            }

            impl<'a, Term: 'a + Terminal> DerefMut for WriteLock<'a, Term>
            {
                fn deref_mut(&mut self) -> &mut Write { &mut self.data }
            }

            impl Write
            {
                pub fn new(screen_size: Size) -> Write
                {
                    Write
                    {
                        buffer: String::new(),
                        backup_buffer: String::new(),
                        cursor: 0,
                        blink: None,
                        history: VecDeque::new(),
                        history_index: None,
                        history_size: MAX_HISTORY,
                        history_new_entries: 0,
                        is_prompt_drawn: false,
                        prompt_prefix: String::new(),
                        prompt_prefix_len: 0,
                        prompt_suffix: String::new(),
                        prompt_suffix_len: 0,
                        prompt_type: PromptType::Normal,
                        reverse_search: false,
                        search_failed: false,
                        search_buffer: String::new(),
                        last_search: String::new(),
                        prev_history: None,
                        prev_cursor: !0,
                        input_arg: Digit::None,
                        explicit_arg: false,
                        screen_size,
                    }
                }

                pub fn history(&self) -> HistoryIter { HistoryIter(self.history.iter()) }

                pub fn new_history(&self) -> Skip<HistoryIter>
                {
                    let first_new = self.history.len() - self.history_new_entries;
                    self.history().skip(first_new)
                }

                pub fn new_history_entries(&self) -> usize { self.history_new_entries }

                pub fn reset_data(&mut self)
                {
                    self.buffer.clear();
                    self.backup_buffer.clear();
                    self.cursor = 0;
                    self.history_index = None;
                    self.prompt_type = PromptType::Normal;
                    self.input_arg = Digit::None;
                    self.explicit_arg = false;
                }

                pub fn reset_new_history(&mut self) { self.history_new_entries = 0; }

                pub fn set_buffer(&mut self, buf: &str)
                {
                    self.buffer.clear();
                    self.buffer.push_str(buf);
                    self.cursor = buf.len();
                }

                pub fn set_cursor(&mut self, pos: usize)
                {
                    if !self.buffer.is_char_boundary(pos) 
                    { panic!("invalid cursor position {} in buffer {:?}", pos, self.buffer); }

                    self.cursor = pos;
                }

                pub fn set_prompt(&mut self, prompt: &str)
                {
                    let (pre, suf) = match prompt.rfind('\n')
                    {
                        Some(pos) => (&prompt[..pos + 1], &prompt[pos + 1..]),
                        None => (&prompt[..0], prompt)
                    };

                    self.prompt_prefix = pre.to_owned();
                    self.prompt_suffix = suf.to_owned();
                    
                    let pre_virt = filter_visible(pre);
                    self.prompt_prefix_len = self.display_size(&pre_virt, 0);

                    let suf_virt = filter_visible(suf);
                    self.prompt_suffix_len = self.display_size(&suf_virt, 0);
                }

                pub fn display_size(&self, s: &str, start_col: usize) -> usize
                {
                    let width = self.screen_size.columns;
                    let mut col = start_col;
                    let disp = Display
                    {
                        allow_tab: true,
                        allow_newline: true,
                        .. Display::default()
                    };

                    for ch in s.chars().flat_map(|ch| display(ch, disp))
                    {
                        let n = match ch
                        {
                            '\n' => width - (col % width),
                            '\t' => TAB_STOP - (col % TAB_STOP),
                            ch if is_combining_mark(ch) => 0,
                            ch if is_wide(ch) =>
                            {
                                if col % width == width - 1 { 3 }
                                else { 2 }
                            }
                            _ => 1
                        };

                        col += n;
                    }

                    col - start_col
                }
            }

            #[derive(Copy, Clone, Debug)]
            pub(crate) enum Digit
            {
                None,
                NegNone,
                Num(i32),
                NegNum(i32),
            }

            impl Digit
            {
                pub fn input(&mut self, n: i32)
                {
                    match *self
                    {
                        Digit::None => *self = Digit::Num(n),
                        Digit::NegNone => *self = Digit::NegNum(n),
                        Digit::Num(ref mut m) | Digit::NegNum(ref mut m) => {
                            *m *= 10;
                            *m += n;
                        }
                    }
                }

                pub fn is_out_of_bounds(&self) -> bool
                {
                    match *self
                    {
                        Digit::Num(n) | Digit::NegNum(n) if n > NUMBER_MAX => true,
                        _ => false
                    }
                }

                pub fn to_i32(&self) -> i32
                {
                    match *self
                    {
                        Digit::None => 1,
                        Digit::NegNone => -1,
                        Digit::Num(n) => n,
                        Digit::NegNum(n) => -n,
                    }
                }
            }

            impl From<char> for Digit
            {
                /// Convert a decimal digit character to a `Digit` value.
                fn from(ch: char) -> Digit
                {
                    let n = (ch as u8) - b'0';
                    Digit::Num(n as i32)
                }
            }

            #[derive(Copy, Clone, Debug, Eq, PartialEq)]
            pub(crate) enum PromptType
            {
                Normal,
                Number,
                Search,
                CompleteIntro(usize),
                CompleteMore,
            }

            impl PromptType
            {
                pub(crate) fn is_normal(&self) -> bool { *self == PromptType::Normal }
            }
            
            impl<'a, 'b, Term: 'b + Terminal> Deref for WriterImpl<'a, 'b, Term>
            {
                type Target = WriteLock<'b, Term>;
                fn deref(&self) -> &WriteLock<'b, Term>
                {
                    match *self
                    {
                        WriterImpl::Mutex(ref m) => m,
                        WriterImpl::MutRef(ref m) => m,
                    }
                }
            }
            
            impl<'a, 'b: 'a, Term: 'b + Terminal> DerefMut for WriterImpl<'a, 'b, Term>
            {
                fn deref_mut(&mut self) -> &mut WriteLock<'b, Term>
                {
                    match *self
                    {
                        WriterImpl::Mutex(ref mut m) => m,
                        WriterImpl::MutRef(ref mut m) => m,
                    }
                }
            }
            /// Iterator over `Interface` history entries
            pub struct HistoryIter<'a>(vec_deque::Iter<'a, String>);

            impl<'a> ExactSizeIterator for HistoryIter<'a> {}

            impl<'a> Iterator for HistoryIter<'a>
            {
                type Item = &'a str;

                #[inline] fn next(&mut self) -> Option<&'a str> { self.0.next().map(|s| &s[..]) }

                #[inline] fn nth(&mut self, n: usize) -> Option<&'a str> { self.0.nth(n).map(|s| &s[..]) }

                #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }
            }
            
            impl<'a> DoubleEndedIterator for HistoryIter<'a>
            {
                #[inline] fn next_back(&mut self) -> Option<&'a str> { self.0.next_back().map(|s| &s[..]) }
            }

            #[derive(Copy, Clone, Debug, Eq, PartialEq)]
            pub(crate) enum DisplaySequence
            {
                Char(char),
                Escape(char),
                End,
            }
            pub use self::DisplaySequence::*;
            
            impl Iterator for DisplaySequence
            {
                type Item = char;
                fn next(&mut self) -> Option<char>
                {
                    let (res, next) = match *self
                    {
                        Char(ch) => (ch, End),
                        Escape(ch) => ('^', Char(ch)),
                        End => return None
                    };

                    *self = next;
                    Some(res)
                }

                fn size_hint(&self) -> (usize, Option<usize>)
                {
                    let n = match *self
                    {
                        Char(_) => 1,
                        Escape(_) => 2,
                        End => 0,
                    };

                    (n, Some(n))
                }
            }

            #[derive(Copy, Clone, Debug, Default)]
            pub(crate) struct Display
            {
                allow_tab: bool,
                allow_newline: bool,
                allow_escape: bool,
            }

            pub(crate) fn display(ch: char, style: Display) -> DisplaySequence
            {
                match ch
                {
                    '\t' if style.allow_tab => DisplaySequence::Char(ch),
                    '\n' if style.allow_newline => DisplaySequence::Char(ch),
                    ESCAPE if style.allow_escape => DisplaySequence::Char(ch),
                    '\0' => DisplaySequence::Escape('@'),
                    RUBOUT => DisplaySequence::Escape('?'),
                    ch if is_ctrl(ch) => DisplaySequence::Escape(unctrl(ch)),
                    ch => DisplaySequence::Char(ch)
                }
            }

            pub(crate) fn display_str<'a>(s: &'a str, style: Display) -> Cow<'a, str>
            {
                if s.chars().all(|ch| display(ch, style) == DisplaySequence::Char(ch))
                { Borrowed(s) } 
                else { Owned(s.chars().flat_map(|ch| display(ch, style)).collect()) }
            }

            fn complete_intro(n: usize) -> String { format!("Display all {} possibilities? (y/n)", n) }

            fn number_len(n: i32) -> usize
            {
                match n
                {
                    -1_000_000              => 8,
                    -  999_999 ..= -100_000 => 7,
                    -   99_999 ..= - 10_000 => 6,
                    -    9_999 ..= -  1_000 => 5,
                    -      999 ..= -    100 => 4,
                    -       99 ..= -     10 => 3,
                    -        9 ..= -      1 => 2,
                            0 ..=        9 => 1,
                            10 ..=       99 => 2,
                        100 ..=      999 => 3,
                        1_000 ..=    9_999 => 4,
                        10_000 ..=   99_999 => 5,
                    100_000 ..=  999_999 => 6,
                    1_000_000              => 7,
                    _ => unreachable!()
                }
            }
        }
        pub use self::writer::Writer;
        
        mod sys
        {
            //! Unix platform support

            pub use self::terminal::terminal_read;

            pub mod path
            {
                use ::
                {
                    env::{ var_os },
                    path::{ home_dir, PathBuf },
                    *,
                };

                pub fn env_init_file() -> Option<PathBuf> { var_os("INPUTRC").map(PathBuf::from) }

                pub fn system_init_file() -> Option<PathBuf> { Some(PathBuf::from("/etc/inputrc")) }

                pub fn user_init_file() -> Option<PathBuf> { home_dir().map(|p| p.join(".inputrc")) }
            }
            pub mod terminal
            {
                use ::
                {
                    mortal::{ Event, TerminalReadGuard, unix::TerminalExt },
                    prompt::lines::terminal::{ RawRead },
                    time::{ Duration },
                    *,
                };
                
                pub fn terminal_read(term: &mut TerminalReadGuard, buf: &mut Vec<u8>) -> io::Result<RawRead>
                {
                    let mut buffer = [0; 1024];
                    
                    match term.read_raw(&mut buffer, Some(Duration::new(0, 0)))?
                    {
                        None => Ok(RawRead::Bytes(0)),
                        Some(Event::Raw(n)) =>
                        {
                            buf.extend(&buffer[..n]);
                            Ok(RawRead::Bytes(n))
                        }
                        Some(Event::Resize(size)) => Ok(RawRead::Resize(size)),
                        Some(Event::Signal(sig)) => Ok(RawRead::Signal(sig)),
                        _ => unreachable!()
                    }
                }
            }
        }
        /*
            #[cfg(windows)]
            #[path = "windows/mod.rs"]
            mod sys;
        */
    }

    pub mod main
    {
        use ::{ * };

        const DEFAULT_PROMPT:&str =  "${COLOR_STATUS}$USER${RESET}@${COLOR_STATUS}$HOSTNAME${RESET}:${COLOR_STATUS}$CWD${RESET}$ ";
        use super::preset::apply_preset_item;
        use super::preset::apply_pyenv;

        pub fn render_prompt( sh:&shell::Shell, ps:&str ) -> String
        {
            let mut prompt = String::new();
            apply_pyenv( &mut prompt );
            let mut met_dollar = false;
            let mut met_brace = false;
            let mut met_paren = false;
            let mut token = String::new();
            let mut prefix = String::new();
            let mut suffix = String::new();
            
            for c in ps.chars() 
            {
                if met_dollar
                {
                    if c == '(' && !met_brace && !met_paren
                    {
                        met_paren = true;
                        continue;
                    }

                    if c == ')' && met_paren
                    {
                        apply_command( &mut prompt, &token, &prefix, &suffix );
                        token.clear();
                        prefix.clear();
                        suffix.clear();
                        met_dollar = false;
                        met_paren = false;
                        continue;
                    }

                    if c == '{' && !met_brace && !met_paren
                    {
                        met_brace = true;
                        continue;
                    }
                    
                    else if c == '}' && met_brace
                    {
                        apply_prompt_item( sh, &mut prompt, &token );
                        token.clear();
                        met_dollar = false;
                        met_brace = false;
                        continue;
                    }
                    
                    else if c == '$'
                    {
                        if token.is_empty()
                        {
                            prompt.push( '$' );
                            met_dollar = true;
                            continue;
                        } 
                        else
                        {
                            apply_prompt_item( sh, &mut prompt, &token );
                            token.clear();
                            continue;
                        }
                    }
                    
                    else if met_paren
                    {
                        if is::prefix_char( c ) { prefix.push( c ); }
                        else if is::suffix_char( c ) { suffix.push( c ); }
                        else { token.push( c ); }
                        continue;
                    }
                    
                    else if is::prompt_item_char( c, &token )
                    {
                        token.push( c );
                        continue;
                    }
                    
                    else if token.is_empty()
                    {
                        prompt.push( '$' );
                        prompt.push( c );
                        met_dollar = false;
                        continue;
                    }
                }

                if c == '$'
                {
                    met_dollar = true;
                    continue;
                }

                if !token.is_empty()
                {
                    apply_prompt_item( sh, &mut prompt, &token );
                    token.clear();
                }

                prompt.push( c );
                met_dollar = false;
            }

            if !token.is_empty()
            {
                apply_prompt_item( sh, &mut prompt, &token );
                met_dollar = false;
            }

            if met_dollar { prompt.push( '$' ); }

            if prompt.trim().is_empty()
            {
                /*return format!( "pls-{} >> ", env!( "CARGO_PKG_VERSION" ) );*/
                return format!( "pls-{} >> ", ::env::var( "CARGO_PKG_VERSION" ) );
            }
            prompt
        }

        fn apply_prompt_item( sh:&shell::Shell, result:&mut String, token:&str )
        {
            if let Some( x ) = sh.get_env( token )
            {
                result.push_str( &x );
                return;
            }
            apply_preset_item( sh, result, token );
        }

        fn apply_command( result:&mut String, token:&str, prefix:&str, suffix:&str )
        {
            let cr = now::run( token );
            let output = cr.stdout.trim();
            if !output.is_empty()
            {
                result.push_str( prefix );
                result.push_str( output );
                result.push_str( suffix );
            }
        }
    }

    pub mod preset
    {
        use ::
        {
            fs::{ File },
            io::{Read, Write},
            path::{ Path },
            *,
        };

        pub fn apply_seq( prompt:&mut String ) { prompt.push_str( prompt::colored::SEQ ); }
        pub fn apply_end_seq( prompt:&mut String ) { prompt.push_str( prompt::colored::END_SEQ ); }
        pub fn apply_esc( prompt:&mut String ) { prompt.push_str( prompt::colored::ESC ); }
        pub fn apply_underlined( prompt:&mut String ) { prompt.push_str( prompt::colored::UNDERLINED ); }
        pub fn apply_user( prompt:&mut String )
        {
            let username = get::username();
            prompt.push_str( &username );
        }
        pub fn apply_black( prompt:&mut String ) { prompt.push_str( prompt::colored::BLACK ); }
        pub fn apply_black_b( prompt:&mut String ) { prompt.push_str( prompt::colored::BLACK_B ); }
        pub fn apply_black_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::BLACK_BG ); }
        pub fn apply_blue( prompt:&mut String ) { prompt.push_str( prompt::colored::BLUE ); }
        pub fn apply_blue_b( prompt:&mut String ) { prompt.push_str( prompt::colored::BLUE_B ); }
        pub fn apply_blue_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::BLUE_BG ); }
        pub fn apply_bold( prompt:&mut String ) { prompt.push_str( prompt::colored::BOLD ); }
        pub fn apply_green( prompt:&mut String ) { prompt.push_str( prompt::colored::GREEN ); }
        pub fn apply_green_b( prompt:&mut String ) { prompt.push_str( prompt::colored::GREEN_B ); }
        pub fn apply_green_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::GREEN_BG ); }
        pub fn apply_red( prompt:&mut String ) { prompt.push_str( prompt::colored::RED ); }
        pub fn apply_red_b( prompt:&mut String ) { prompt.push_str( prompt::colored::RED_B ); }
        pub fn apply_red_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::RED_BG ); }
        pub fn apply_white( prompt:&mut String ) { prompt.push_str( prompt::colored::WHITE ); }
        pub fn apply_white_b( prompt:&mut String ) { prompt.push_str( prompt::colored::WHITE_B ); }
        pub fn apply_white_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::WHITE_BG ); }
        pub fn apply_hidden( prompt:&mut String ) { prompt.push_str( prompt::colored::HIDDEN ); }
        pub fn apply_reset( prompt:&mut String ) { prompt.push_str( prompt::colored::RESET ); }
        pub fn apply_reverse( prompt:&mut String ) { prompt.push_str( prompt::colored::REVERSE ); }
        pub fn apply_dim( prompt:&mut String ) { prompt.push_str( prompt::colored::DIM ); }
        pub fn apply_blink( prompt:&mut String ) { prompt.push_str( prompt::colored::BLINK ); }
        pub fn apply_reset_underlined( prompt:&mut String ) { prompt.push_str( prompt::colored::RESET_UNDERLINED ); }
        pub fn apply_reset_dim( prompt:&mut String ) { prompt.push_str( prompt::colored::RESET_DIM ); }
        pub fn apply_reset_reverse( prompt:&mut String ) { prompt.push_str( prompt::colored::RESET_REVERSE ); }
        pub fn apply_reset_hidden( prompt:&mut String ) { prompt.push_str( prompt::colored::RESET_HIDDEN ); }
        pub fn apply_reset_blink( prompt:&mut String ) { prompt.push_str( prompt::colored::RESET_BLINK ); }
        pub fn apply_reset_bold( prompt:&mut String ) { prompt.push_str( prompt::colored::RESET_BOLD ); }
        pub fn apply_default( prompt:&mut String ) { prompt.push_str( prompt::colored::DEFAULT ); }
        pub fn apply_default_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::DEFAULT_BG ); }
        pub fn apply_cyan( prompt:&mut String ) { prompt.push_str( prompt::colored::CYAN ); }
        pub fn apply_cyan_l( prompt:&mut String ) { prompt.push_str( prompt::colored::CYAN_L ); }
        pub fn apply_cyan_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::CYAN_BG ); }
        pub fn apply_cyan_l_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::CYAN_L_BG ); }
        pub fn apply_red_l( prompt:&mut String ) { prompt.push_str( prompt::colored::RED_L ); }
        pub fn apply_red_l_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::RED_L_BG ); }
        pub fn apply_green_l( prompt:&mut String ) { prompt.push_str( prompt::colored::GREEN_L ); }
        pub fn apply_green_l_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::GREEN_L_BG ); }
        pub fn apply_gray_l( prompt:&mut String ) { prompt.push_str( prompt::colored::GRAY_L ); }
        pub fn apply_gray_l_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::GRAY_L_BG ); }
        pub fn apply_gray_d( prompt:&mut String ) { prompt.push_str( prompt::colored::GRAY_D ); }
        pub fn apply_gray_d_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::GRAY_D_BG ); }
        pub fn apply_magenta( prompt:&mut String ) { prompt.push_str( prompt::colored::MAGENTA ); }
        pub fn apply_magenta_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::MAGENTA_BG ); }
        pub fn apply_magenta_l( prompt:&mut String ) { prompt.push_str( prompt::colored::MAGENTA_L ); }
        pub fn apply_magenta_l_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::MAGENTA_L_BG ); }
        pub fn apply_yellow( prompt:&mut String ) { prompt.push_str( prompt::colored::YELLOW ); }
        pub fn apply_yellow_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::YELLOW_BG ); }
        pub fn apply_yellow_l( prompt:&mut String ) { prompt.push_str( prompt::colored::YELLOW_L ); }
        pub fn apply_yellow_l_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::YELLOW_L_BG ); }
        pub fn apply_blue_l( prompt:&mut String ) { prompt.push_str( prompt::colored::BLUE_L ); }
        pub fn apply_blue_l_bg( prompt:&mut String ) { prompt.push_str( prompt::colored::BLUE_L_BG ); }

        pub fn apply_color_status( sh:&shell::Shell, prompt:&mut String )
        {
            if sh.previous_status == 0 { prompt.push_str( prompt::colored::GREEN_B ); }
            else { prompt.push_str( prompt::colored::RED_B ); }
        }

        pub fn _find_git_root() -> String
        {
            let current_dir = path::current_dir();
            let dir_git = format!( "{}/.git", current_dir );
            if Path::new( &dir_git ).exists() { return current_dir; }

            let mut _dir = current_dir.clone();
            while Path::new( &_dir ).parent().is_some()
            {
                match Path::new( &_dir ).parent()
                {
                    Some( p ) =>
                    {
                        _dir = p.to_string_lossy().to_string();
                        let dir_git = format!( "{}/.git", _dir );
                        if Path::new( &dir_git ).exists() { return _dir; }
                    }

                    None => { break; }
                }
            }

            String::new()
        }

        pub fn apply_gitbr( prompt:&mut String )
        {
            let git_root = _find_git_root();
            if git_root.is_empty() { return; }

            let file_head = format!( "{}/.git/HEAD", git_root );
            if !Path::new( &file_head ).exists() { return; }

            let mut file;
            match File::open( &file_head )
            {
                Ok( x ) => file = x,
                Err( e ) =>
                {
                    println!( "pls:.git/HEAD err:{:?}", e );
                    return;
                }
            }

            let mut text = String::new();
            match file.read_to_string( &mut text )
            {
                Ok( _ ) => {}
                Err( e ) =>
                {
                    println!( "pls:read_to_string error:{:?}", e );
                    return;
                }
            }

            if let Some( branch ) = regex::find_first_group( r"^[a-z]+:?[a-z]+/[a-z]+/( .+ )$", text.trim() )
            {
                apply_blue_b( prompt );
                if let Ok( x ) = env::var( "CICADA_GITBR_PREFIX" )
                {
                    prompt.push_str( &x );
                }

                let _len_default:i32 = 32;
                let mut len_max = if let Ok( x ) = env::var( "CICADA_GITBR_MAX_LEN" )
                {
                    match x.parse::<i32>()
                    {
                        Ok( n ) => n,
                        Err( _ ) => _len_default,
                    }
                }
                else { _len_default };
                
                if len_max <= 0 { len_max = _len_default; }

                if branch.len() as i32 <= len_max { prompt.push_str( &branch ); } 
                
                else
                {
                    let len = branch.len() as i32;
                    let offset = ( len - len_max + 2 ) as usize;
                    let branch_short = format!( "..{}", &branch[offset..] );
                    prompt.push_str( &branch_short );
                }
                
                if let Ok( x ) = env::var( "CICADA_GITBR_SUFFIX" ) { prompt.push_str( &x ); }
                
                apply_reset( prompt );
            }
        }

        pub fn apply_cwd( prompt:&mut String )
        {
            let _current_dir = match env::current_dir()
            {
                Ok( x ) => x,
                Err( e ) =>
                {
                    println_stderr!( "pls:PROMPT:env current_dir error:{}", e );
                    return;
                }
            };

            let current_dir = match _current_dir.to_str()
            {
                Some( x ) => x,
                None =>
                {
                    println_stderr!( "pls:PROMPT:to_str error" );
                    return;
                }
            };

            let _tokens:Vec<&str> = current_dir.split( '/' ).collect();
            let last = match _tokens.last()
            {
                Some( x ) => x,
                None =>
                {
                    /*log!( "pls:PROMPT:token last error" );*/
                    return;
                }
            };

            let home = get::user_home();
            let pwd = if last.is_empty() { "/" } 
            else if current_dir == home { "~" }
            else { last };
            prompt.push_str( pwd );
        }

        pub fn apply_hostname( prompt:&mut String )
        {
            let hostname = get::hostname();
            prompt.push_str( &hostname );
        }

        pub fn apply_newline( prompt:&mut String ) { prompt.push( '\n' ); }

        pub fn apply_pyenv( prompt:&mut String )
        {
            if let Ok( x ) = env::var( "VIRTUAL_ENV" )
            {
                if !x.is_empty()
                {
                    let _tokens:Vec<&str> = x.split( '/' ).collect();
                    let env_name = match _tokens.last()
                    {
                        Some( x ) => x,
                        None =>
                        {
                            /*log!( "prompt token last error" );*/
                            return;
                        }
                    };

                    apply_blue_b( prompt );
                    prompt.push( '(' );
                    prompt.push_str( env_name );
                    prompt.push( ')' );
                    apply_reset( prompt );
                }
            }
        }

        pub fn apply_preset_item( sh:&shell::Shell, prompt:&mut String, token:&str )
        {
            match token.to_ascii_lowercase().as_ref()
            {
                "black" => apply_black( prompt ),
                "black_b" => apply_black_b( prompt ),
                "black_bg" => apply_black_bg( prompt ),
                "blink" => apply_blink( prompt ),
                "blue" => apply_blue( prompt ),
                "blue_b" => apply_blue_b( prompt ),
                "blue_bg" => apply_blue_bg( prompt ),
                "blue_l" => apply_blue_l( prompt ),
                "blue_l_bg" => apply_blue_l_bg( prompt ),
                "bold" => apply_bold( prompt ),
                "color_status" => apply_color_status( sh, prompt ),
                "cwd" => apply_cwd( prompt ),
                "cyan" => apply_cyan( prompt ),
                "cyan_bg" => apply_cyan_bg( prompt ),
                "cyan_l" => apply_cyan_l( prompt ),
                "cyan_l_bg" => apply_cyan_l_bg( prompt ),
                "default" => apply_default( prompt ),
                "default_bg" => apply_default_bg( prompt ),
                "dim" => apply_dim( prompt ),
                "end_seq" => apply_end_seq( prompt ),
                "esc" => apply_esc( prompt ),
                "gitbr" => apply_gitbr( prompt ),
                "gray_d" => apply_gray_d( prompt ),
                "gray_d_bg" => apply_gray_d_bg( prompt ),
                "gray_l" => apply_gray_l( prompt ),
                "gray_l_bg" => apply_gray_l_bg( prompt ),
                "green" => apply_green( prompt ),
                "green_b" => apply_green_b( prompt ),
                "green_bg" => apply_green_bg( prompt ),
                "green_l" => apply_green_l( prompt ),
                "green_l_bg" => apply_green_l_bg( prompt ),
                "hidden" => apply_hidden( prompt ),
                "hostname" => apply_hostname( prompt ),
                "magenta" => apply_magenta( prompt ),
                "magenta_bg" => apply_magenta_bg( prompt ),
                "magenta_l" => apply_magenta_l( prompt ),
                "magenta_l_bg" => apply_magenta_l_bg( prompt ),
                "newline" => apply_newline( prompt ),
                "red" => apply_red( prompt ),
                "red_b" => apply_red_b( prompt ),
                "red_bg" => apply_red_bg( prompt ),
                "red_l" => apply_red_l( prompt ),
                "red_l_bg" => apply_red_l_bg( prompt ),
                "reset" => apply_reset( prompt ),
                "reset_blink" => apply_reset_blink( prompt ),
                "reset_bold" => apply_reset_bold( prompt ),
                "reset_dim" => apply_reset_dim( prompt ),
                "reset_hidden" => apply_reset_hidden( prompt ),
                "reset_reverse" => apply_reset_reverse( prompt ),
                "reset_underlined" => apply_reset_underlined( prompt ),
                "reverse" => apply_reverse( prompt ),
                "seq" => apply_seq( prompt ),
                "underlined" => apply_underlined( prompt ),
                "user" => apply_user( prompt ),
                "white" => apply_white( prompt ),
                "white_b" => apply_white_b( prompt ),
                "white_bg" => apply_white_bg( prompt ),
                "yellow" => apply_yellow( prompt ),
                "yellow_bg" => apply_yellow_bg( prompt ),
                "yellow_l" => apply_yellow_l( prompt ),
                "yellow_l_bg" => apply_yellow_l_bg( prompt ),
                _ => (),
            }
        }
    }

    pub mod multilines
    {
        use ::
        {
            parsers::line::{ self },
            prompt::lines::{ Function, Prompter, Terminal },
            *,
        };

        pub struct EnterFunction;

        impl<T:Terminal> Function<T> for EnterFunction
        {
            fn execute( &self, prompter:&mut Prompter<T>, count:i32, _ch:char ) -> io::Result<()>
            {
                let buf = prompter.buffer();
                let linfo = parsers::line::parse_line( buf );
                if linfo.is_complete { prompter.accept_input() } 
                else if count > 0
                {
                    match prompter.insert( count as usize, '\n' )
                    {
                        Ok( _ ) => {},
                        Err( e ) => { println!( "sub-prompt error:{}", e ); }
                    }

                    prompter.insert_str( ">> " )
                }

                else { Ok(()) }
            }
        }
    }

    pub mod colored
    {
        pub const SEQ:&str = "\x01";
        pub const END_SEQ:&str = "\x02";
        pub const ESC:&str = "\x1B";
        pub const BOLD:&str = "\x01\x1B[1m\x02";
        pub const DIM:&str = "\x01\x1B[2m\x02";
        pub const UNDERLINED:&str = "\x01\x1B[4m\x02";
        pub const BLINK:&str = "\x01\x1B[5m\x02";
        pub const REVERSE:&str = "\x01\x1B[7m\x02";
        pub const HIDDEN:&str = "\x01\x1B[8m\x02";
        pub const RESET:&str = "\x01\x1B[0m\x02";
        pub const RESET_BOLD:&str = "\x01\x1B[21m\x02";
        pub const RESET_DIM:&str = "\x01\x1B[22m\x02";
        pub const RESET_UNDERLINED:&str = "\x01\x1B[24m\x02";
        pub const RESET_BLINK:&str = "\x01\x1B[25m\x02";
        pub const RESET_REVERSE:&str = "\x01\x1B[27m\x02";
        pub const RESET_HIDDEN:&str = "\x01\x1B[28m\x02";
        pub const DEFAULT:&str = "\x01\x1B[39m\x02";
        pub const BLACK:&str = "\x01\x1B[30m\x02";
        pub const RED:&str = "\x01\x1B[31m\x02";
        pub const GREEN:&str = "\x01\x1B[32m\x02";
        pub const YELLOW:&str = "\x01\x1B[33m\x02";
        pub const BLUE:&str = "\x01\x1B[34m\x02";
        pub const MAGENTA:&str = "\x01\x1B[35m\x02";
        pub const CYAN:&str = "\x01\x1B[36m\x02";
        pub const GRAY_L:&str = "\x01\x1B[37m\x02";
        pub const GRAY_D:&str = "\x01\x1B[90m\x02";
        pub const RED_L:&str = "\x01\x1B[91m\x02";
        pub const GREEN_L:&str = "\x01\x1B[92m\x02";
        pub const YELLOW_L:&str = "\x01\x1B[93m\x02";
        pub const BLUE_L:&str = "\x01\x1B[94m\x02";
        pub const MAGENTA_L:&str = "\x01\x1B[95m\x02";
        pub const CYAN_L:&str = "\x01\x1B[96m\x02";
        pub const WHITE:&str = "\x01\x1B[97m\x02";
        pub const BLUE_B:&str = "\x01\x1B[34m\x1B[1m\x02";
        pub const BLACK_B:&str = "\x01\x1B[30m\x1B[1m\x02";
        pub const WHITE_B:&str = "\x01\x1B[97m\x1B[1m\x02";
        pub const RED_B:&str = "\x01\x1B[31m\x1B[1m\x02";
        pub const GREEN_B:&str = "\x01\x1B[32m\x1B[1m\x02";
        pub const DEFAULT_BG:&str = "\x01\x1B[49m\x02";
        pub const BLACK_BG:&str   = "\x01\x1B[40m\x02";
        pub const RED_BG:&str     = "\x01\x1B[41m\x02";
        pub const GREEN_BG:&str   = "\x01\x1B[42m\x02";
        pub const YELLOW_BG:&str   = "\x01\x1B[43m\x02";
        pub const BLUE_BG:&str    = "\x01\x1B[44m\x02";
        pub const MAGENTA_BG:&str    = "\x01\x1B[45m\x02";
        pub const CYAN_BG:&str    = "\x01\x1B[46m\x02";
        pub const GRAY_L_BG:&str    = "\x01\x1B[47m\x02";
        pub const GRAY_D_BG:&str   = "\x01\x1B[100m\x02";
        pub const RED_L_BG:&str   = "\x01\x1B[101m\x02";
        pub const GREEN_L_BG:&str   = "\x01\x1B[102m\x02";
        pub const YELLOW_L_BG:&str   = "\x01\x1B[103m\x02";
        pub const BLUE_L_BG:&str   = "\x01\x1B[104m\x02";
        pub const MAGENTA_L_BG:&str   = "\x01\x1B[105m\x02";
        pub const CYAN_L_BG:&str   = "\x01\x1B[106m\x02";
        pub const WHITE_BG:&str   = "\x01\x1B[107m\x02";
    }
}
pub mod ptr { pub use std::ptr::{ * }; }
pub mod rc
{
    pub use std::rc::{ * };
    /* ./rcfile.rs */
    pub mod file
    {
        use ::
        {
            path::{ Path },
            *,
        };

        pub fn get_rc_file() -> String
        {
            let dir_config = get::configuration_directory();
            let rc_file = format!( "{}/plsrc", dir_config );
            if Path::new( &rc_file ).exists() { return rc_file; }
            
            let home = get::user_home();
            let rc_file_home = format!( "{}/{}", home, ".plsrc" );
            if Path::new( &rc_file_home ).exists() { return rc_file_home; }

            rc_file
        }

        pub fn load_rc_files( sh:&mut shell::Shell )
        {
            let rc_file = get_rc_file();
            if !Path::new( &rc_file ).exists() { return; }

            let args = vec!["source".to_string(), rc_file];
            scripts::run_script( sh, &args );
        }
    }
}
/*
regex v1.5.6 */
pub mod regex
{
    pub use re::{ * };

    pub fn find_first_group( ptn:&str, text:&str ) -> Option<String>
    {
        let rex = match re::Regex::new( ptn )
        {
            Ok( x ) => x,
            Err( _ ) => return None,
        };

        match rex.captures( text )
        {
            Some( caps ) => {
                if let Some( x ) = caps.get( 1 ) {
                    return Some( x.as_str().to_owned() );
                }
            }
            None => {
                return None;
            }
        }

        None
    }

    pub fn re_contains( text:&str, ptn:&str ) -> bool
    {
        let rex = match re::Regex::new( ptn )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println!( "Regex new error:{:?}", e );
                return false;
            }
        };

        rex.is_match( text )
    }

    pub fn replace_all( text:&str, ptn:&str, ptn_to:&str ) -> String
    {
        let rex = re::Regex::new( ptn ).unwrap();
        let result = rex.replace_all( text, ptn_to );
        result.to_string()
    }
}
pub mod result { pub use std::result::{ * }; }
pub mod rust { pub use std::prelude::v1::{ * }; }
pub mod scripts
{
    // use pest::iterators::Pair;
    use ::
    {
        fs::{ File },
        io::{ Read, Write, ErrorKind },
        path::{ Path },
        regex::{ Regex, RegexBuilder },
        types::{ self, CommandResult },
        *,
    };

    pub fn run_script( sh:&mut shell::Shell, args:&Vec<String> ) -> i32
    {
        let src_file = &args[1];
        let full_src_file:String;
        if src_file.contains( '/' ) { full_src_file = src_file.clone(); } 
        
        else
        {
            let full_path = path::find_file_in_path( src_file, false );
            if full_path.is_empty()
            {
                if !Path::new( src_file ).exists()
                {
                    println_stderr!( "pls:{}:no such file", src_file );
                    return 1;
                }
                
                full_src_file = format!( "./{}", src_file );
            }
            
            else { full_src_file = full_path.clone(); }
        }

        if !Path::new( &full_src_file ).exists()
        {
            println_stderr!( "pls:{}:no such file", src_file );
            return 1;
        }
        
        if Path::new( &full_src_file ).is_dir()
        {
            println_stderr!( "pls:{}:is a directory", src_file );
            return 1;
        }

        let mut file;
        match File::open( &full_src_file )
        {
            Ok( x ) => file = x,
            Err( e ) =>
            {
                println_stderr!( "pls:{}:failed to open file - {:?}", &full_src_file, e.kind() );
                return 1;
            }
        }

        let mut text = String::new();
        match file.read_to_string( &mut text )
        {
            Ok( _ ) => {}
            Err( e ) =>
            {
                match e.kind()
                {
                    ErrorKind::InvalidData => { println_stderr!( "pls:{}:not a valid script file", &full_src_file ); }
                    _ => { println_stderr!( "pls:{}:error:{:?}", &full_src_file, e ); }
                }
                return 1;
            }
        }

        if text.contains( "\\\n" )
        {
            let re = RegexBuilder::new( r#"( [ \t]*\\\n[ \t]+ )|( [ \t]+\\\n[ \t]* )"# )
            .multi_line( true ).build().unwrap();
            text = re.replace_all( &text, " " ).to_string();
            let re = RegexBuilder::new( r#"\\\n"# ).multi_line( true ).build().unwrap();
            text = re.replace_all( &text, "" ).to_string();
        }

        let re_func_head = Regex::new( r"^function ( [a-zA-Z_-][a-zA-Z0-9_-]* ) *( ?:\( \ ) )? *\{$" ).unwrap();
        let re_func_tail = Regex::new( r"^\}$" ).unwrap();
        let mut text_new = String::new();
        let mut enter_func = false;
        let mut func_name = String::new();
        let mut func_body = String::new();

        for line in text.clone().lines()
        {
            if re_func_head.is_match( line.trim() )
            {
                enter_func = true;
                let cap = re_func_head.captures( line.trim() ).unwrap();
                func_name = cap[1].to_string();
                func_body = String::new();
                continue;
            }
            
            if re_func_tail.is_match( line.trim() )
            {
                sh.set_func( &func_name, &func_body );
                enter_func = false;
                continue;
            }
            
            if enter_func
            {
                func_body.push_str( line );
                func_body.push( '\n' );
            } 
            
            else
            {
                text_new.push_str( line );
                text_new.push( '\n' );
            }
        }

        let mut status = 0;
        let cr_list = run_lines( sh, &text_new, args, false );

        if let Some( last ) = cr_list.last() { status = last.status; }

        sh.exit_on_error = false;
        status
    }

    pub fn run_lines( sh:&mut shell::Shell, lines:&str, args:&Vec<String>, capture:bool ) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        match parsers::locust::parse_lines( lines )
        {
            Ok( pairs_exp ) =>
            {
                for pair in pairs_exp
                {
                    let ( mut _cr_list, _cont, _brk ) = run_exp( sh, pair, args, false, capture );
                    cr_list.append( &mut _cr_list );
                }
            }
            
            Err( e ) =>
            {
                println_stderr!( "syntax error:{:?}", e );
                return cr_list;
            }
        }
        cr_list
    }

    pub fn run_exp_test_br
    ( 
        sh:&mut shell::Shell,
        pair_br:Pair<parsers::locust::Rule>,
        args:&Vec<String>,
        in_loop:bool,
        capture:bool
    ) -> ( Vec<CommandResult>, bool, bool, bool )
    {
        let mut cr_list = Vec::new();
        let pairs = pair_br.into_inner();
        let mut test_pass = false;
        /*
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::IF_HEAD ||
                    rule == parsers::locust::Rule::IF_ELSEIF_HEAD ||
                    rule == parsers::locust::Rule::WHILE_HEAD {
                let pairs_test:Vec<Pair<parsers::locust::Rule>> =
                    pair.into_inner().collect();
                let pair_test = &pairs_test[0];
                let line = pair_test.as_str().trim();
                let line_new = expand_args( line, &args[1..] );
                let mut _cr_list = now::run_command_line( sh, &line_new, true, capture );
                if let Some( last ) = _cr_list.last() {
                    if last.status == 0 {
                        test_pass = true;
                    }
                }
                continue;
            }

            if rule == parsers::locust::Rule::KW_ELSE {
                test_pass = true;
                continue;
            }

            if rule == parsers::locust::Rule::EXP_BODY {
                if !test_pass {
                    return ( cr_list, false, false, false );
                }
                let ( mut _cr_list, _cont, _brk ) = run_exp( sh, pair, args, in_loop, capture );
                cr_list.append( &mut _cr_list );
                
                return ( cr_list, true, _cont, _brk );
            }

            unreachable!();
        }
        */
        ( cr_list, test_pass, false, false )
    }

    pub fn run_exp_if
    ( 
        sh:&mut shell::Shell,
        pair_if:Pair<parsers::locust::Rule>,
        args:&Vec<String>,
        in_loop:bool,
        capture:bool
    ) -> ( Vec<CommandResult>, bool, bool )
    {
        let mut cr_list = Vec::new();
        let pairs = pair_if.into_inner();
        let mut met_continue = false;
        let mut met_break = false;
        /*
        for pair in pairs
        {
            let ( mut _cr_list, passed, _cont, _brk ) = run_exp_test_br( sh, pair, args, in_loop, capture );
            met_continue = _cont;
            met_break = _brk;
            cr_list.append( &mut _cr_list );
            if passed {
                break;
            }
        }
        */
        ( cr_list, met_continue, met_break )
    }

    pub fn run_exp_for
    ( 
        sh:&mut shell::Shell,
        pair_for:Pair<parsers::locust::Rule>,
        args:&Vec<String>,
        capture:bool
    ) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        /*
        let pairs = pair_for.into_inner();
        let mut result_list:Vec<String> = Vec::new();
        let mut var_name:String = String::new();
        for pair in pairs {
            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::FOR_HEAD {
                var_name = get_for_var_name( pair.clone() );
                result_list = get_for_result_list( sh, pair.clone(), args );
                continue;
            }
            if rule == parsers::locust::Rule::EXP_BODY {
                for value in &result_list {
                    sh.set_env( &var_name, value );
                    let ( mut _cr_list, _cont, _brk ) = run_exp( 
                        sh, pair.clone(), args, true, capture );
                    cr_list.append( &mut _cr_list );
                    if _brk {
                        break;
                    }
                }
            }
        }*/
        cr_list
    }

    pub fn run_exp_while
    ( 
        sh:&mut shell::Shell,
        pair_while:Pair<parsers::locust::Rule>,
        args:&Vec<String>,
        capture:bool
    ) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        loop
        {
            let ( mut _cr_list, passed, _cont, _brk ) = run_exp_test_br( sh, pair_while.clone(), args, true, capture );
            cr_list.append( &mut _cr_list );
            if !passed || _brk { break; }
        }
        cr_list
    }

    pub fn run_exp
    ( 
        sh:&mut shell::Shell,
        pair_in:Pair<parsers::locust::Rule>,
        args:&Vec<String>,
        in_loop:bool,
        capture:bool
    ) -> ( Vec<CommandResult>, bool, bool )
    {
        let mut cr_list = Vec::new();
        /*
        let pairs = pair_in.into_inner();
        for pair in pairs
        {
            let line = pair.as_str().trim();
            if line.is_empty() {
                continue;
            }

            let rule = pair.as_rule();
            if rule == parsers::locust::Rule::CMD {
                if line == "continue" {
                    if in_loop {
                        return ( cr_list, true, false );
                    } else {
                        println_stderr!( "pls:continue:only meaningful in loops" );
                        continue;
                    }
                }
                if line == "break" {
                    if in_loop {
                        return ( cr_list, false, true );
                    } else {
                        println_stderr!( "pls:break:only meaningful in loops" );
                        continue;
                    }
                }

                let line_new = expand_args( line, &args[1..] );
                let mut _cr_list = now::run_command_line( sh, &line_new, true, capture );
                cr_list.append( &mut _cr_list );
                if let Some( last ) = cr_list.last() {
                    let status = last.status;
                    if status != 0 && sh.exit_on_error {
                        return ( cr_list, false, false );
                    }
                }
            } else if rule == parsers::locust::Rule::EXP_IF {
                let ( mut _cr_list, _cont, _brk ) = run_exp_if( sh, pair, args, in_loop, capture );
                cr_list.append( &mut _cr_list );
                if _cont {
                    return ( cr_list, true, false );
                }
                if _brk {
                    return ( cr_list, false, true );
                }
            } else if rule == parsers::locust::Rule::EXP_FOR {
                let mut _cr_list = run_exp_for( sh, pair, args, capture );
                cr_list.append( &mut _cr_list );
            } else if rule == parsers::locust::Rule::EXP_WHILE {
                let mut _cr_list = run_exp_while( sh, pair, args, capture );
                cr_list.append( &mut _cr_list );
            }
        }
        */
        ( cr_list, false, false )
    }
}
mod shell
{
    // uuid::Uuid
    use ::
    {
        collections::{ HashMap, HashSet },
        error::{ no },
        ffi::{ CStr, CString },
        fs::{ File },
        io::{ Read, Write },
        os::
        {
            fd::RawFd,
            unix::io::FromRawFd,
        },
        nix::unistd::{ execve, ForkResult },
        regex::{ Regex },
        types::{ self, CommandLine, CommandOptions, CommandResult },
        *,
    };
    /**/
    pub fn try_run_builtin_in_subprocess
    ( 
        sh:&mut Shell,
        cl:&CommandLine,
        idx_cmd:usize,
        capture:bool,
    ) -> Option<i32>
    {
        if let Some( cr ) = try_run_builtin( sh, cl, idx_cmd, capture ) { return Some( cr.status ); }
        None
    }
    /**/
    pub fn try_run_builtin
    ( 
        sh:&mut Shell,
        cl:&CommandLine,
        idx_cmd:usize,
        capture:bool,
    ) -> Option<CommandResult>
    {
        let capture = capture && idx_cmd + 1 == cl.commands.len();

        if idx_cmd >= cl.commands.len()
        {
            println_stderr!( "unexpected error in try_run_builtin" );
            return None;
        }

        let cmd = &cl.commands[idx_cmd];
        let tokens = cmd.tokens.clone();
        let cname = tokens[0].1.clone();
        match cname
        {
            "alias" =>
            {
                let cr = builtins::alias::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "bg" =>
            {
                let cr = builtins::bg::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "cd" =>
            {
                let cr = builtins::cd::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "cinfo" =>
            {
                let cr = builtins::cinfo::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "exec" =>
            {
                let cr = builtins::exec::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "exit" =>
            {
                let cr = builtins::exit::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "export" =>
            {
                let cr = builtins::export::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "fg" =>
            {
                let cr = builtins::fg::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "history" =>
            {
                let cr = builtins::history::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "jobs" =>
            {
                let cr = builtins::jobs::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "minfd" =>
            {
                let cr = builtins::minfd::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "read" =>
            {
                let cr = builtins::read::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "set" =>
            {
                let cr = builtins::set::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "source" =>
            {
                let cr = builtins::source::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "ulimit" =>
            {
                let cr = builtins::ulimit::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "unalias" =>
            {
                let cr = builtins::unalias::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "unset" =>
            {
                let cr = builtins::unset::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "unpath" =>
            {
                let cr = builtins::unpath::run( sh, cl, cmd, capture );
                return Some( cr );
            }

            "vox" =>
            {
                let cr = builtins::vox::run( sh, cl, cmd, capture );
                return Some( cr );
            }
            _ =>  None,
        }
    }
    /// Run a pipeline ( e.g. `echo hi | wc -l` )
    /// returns:( is-terminal-given, command-result )
    pub fn run_pipeline
    ( 
        sh:&mut shell::Shell,
        cl:&CommandLine,
        tty:bool,
        capture:bool,
        log_cmd:bool,
    ) -> ( bool, CommandResult )
    {
        let mut term_given = false;
        if cl.background && capture 
        {
            println_stderr!( "pls:cannot capture output of background cmd" );
            return ( term_given, CommandResult::error() );
        }
        /*
        if let Some( cr ) = try_run_calculator( &cl.line, capture ) { return ( term_given, cr ); }
        FIXME:move func-run into run single command */
        if let Some( cr ) = try_run_func( sh, cl, capture, log_cmd ){ return ( term_given, cr ); }
        if log_cmd { /*log!( "run:{}", cl.line );*/ }

        let length = cl.commands.len();
        if length == 0
        {
            println!( "pls:invalid command:cmds with empty length" );
            return ( false, CommandResult::error() );
        }

        let mut pipes = Vec::new();
        let mut errored_pipes = false;
        for _ in 0..length - 1
        {
            match process::pipe()
            {
                Ok( fds ) => pipes.push( fds ),
                Err( e ) =>
                {
                    errored_pipes = true;
                    println_stderr!( "pls:pipeline1:{}", e );
                    break;
                }
            }
        }

        if errored_pipes
        {
            for fds in pipes
            {
                fs::close( fds.0 );
                fs::close( fds.1 );
            }
            return ( false, CommandResult::error() );
        }

        if pipes.len() + 1 != length
        {
            println!( "pls:invalid command:unmatched pipes count" );
            return ( false, CommandResult::error() );
        }

        let mut pgid:i32 = 0;
        let mut fg_pids:Vec<i32> = Vec::new();
        let isatty = if tty { unsafe { libc::isatty( 1 ) == 1 } } else { false };
        let options = CommandOptions
        {
            isatty,
            capture_output:capture,
            background:cl.background,
            envs:cl.envs.clone(),
        };
        let mut fds_capture_stdout = None;
        let mut fds_capture_stderr = None;
        if capture
        {
            match process::pipe()
            {
                Ok( fds ) => fds_capture_stdout = Some( fds ),
                Err( e ) =>
                {
                    println_stderr!( "pls:pipeline2:{}", e );
                    return ( false, CommandResult::error() );
                }
            }
            match process::pipe()
            {
                Ok( fds ) => fds_capture_stderr = Some( fds ),
                Err( e ) =>
                {
                    if let Some( fds ) = fds_capture_stdout
                    {
                        fs::close( fds.0 );
                        fs::close( fds.1 );
                    }
                    println_stderr!( "pls:pipeline3:{}", e );
                    return ( false, CommandResult::error() );
                }
            }
        }

        let mut cmd_result = CommandResult::new();
        for i in 0..length
        {
            let child_id:i32 = run_single_program
            ( 
                sh,
                cl,
                i,
                &options,
                &mut pgid,
                &mut term_given,
                &mut cmd_result,
                &pipes,
                &fds_capture_stdout,
                &fds_capture_stderr,
            );

            if child_id > 0 && !cl.background
            {
                fg_pids.push( child_id );
            }
        }

        if cl.is_single_and_builtin(){ return ( false, cmd_result ); }

        if cl.background 
        { 
            if let Some( job ) = sh.get_job_by_gid( pgid ){ println_stderr!( "[{}] {}", job.id, job.gid ); } 
        }

        if !fg_pids.is_empty()
        {
            let _cr = c::job::wait_fg_job( sh, pgid, &fg_pids );
            if !capture { cmd_result = _cr; }
        }

        ( term_given, cmd_result )
    }
    /// Run a single command.
    /// e.g. the `sort -k2` part of `ps ax | sort -k2 | head`
    pub fn run_single_program
    ( 
        sh:&mut shell::Shell,
        cl:&CommandLine,
        idx_cmd:usize,
        options:&CommandOptions,
        pgid:&mut i32,
        term_given:&mut bool,
        cmd_result:&mut CommandResult,
        pipes:&[( RawFd, RawFd )],
        fds_capture_stdout:&Option<( RawFd, RawFd )>,
        fds_capture_stderr:&Option<( RawFd, RawFd )>,
    ) -> i32
    {
        unsafe
        {
            let capture = options.capture_output;
            if cl.is_single_and_builtin()
            {
                if let Some( cr ) = try_run_builtin( sh, cl, idx_cmd, capture )
                {
                    *cmd_result = cr;
                    return unsafe { libc::getpid() };
                }

                println_stderr!( "pls:error when run singler builtin" );
                /* log!( "error when run singler builtin:{:?}", cl ); */
                return 1;
            }

            let pipes_count = pipes.len();
            let mut fds_stdin = None;
            let cmd = cl.commands.get( idx_cmd ).unwrap();

            if cmd.has_here_string()
            {
                match process::pipe()
                {
                    Ok( fds ) => fds_stdin = Some( fds ),
                    Err( e ) =>
                    {
                        println_stderr!( "pls:pipeline4:{}", e );
                        return 1;
                    }
                }
            }

            match process::fork()
            {
                Ok( ForkResult::Child ) =>
                {
                    libc::signal( libc::SIGTSTP, libc::SIG_DFL );
                    libc::signal( libc::SIGQUIT, libc::SIG_DFL );
                    
                    if idx_cmd > 0
                    {
                        for i in 0..idx_cmd - 1
                        {
                            let fds = pipes[i];
                            fs::close( fds.0 );
                            fs::close( fds.1 );
                        }
                    }
                    
                    for i in idx_cmd + 1..pipes_count
                    {
                        let fds = pipes[i];
                        fs::close( fds.0 );
                        fs::close( fds.1 );
                    }
                    
                    if idx_cmd < pipes_count
                    {
                        if let Some( fds ) = fds_capture_stdout
                        {
                            fs::close( fds.0 );
                            fs::close( fds.1 );
                        }
                        if let Some( fds ) = fds_capture_stderr
                        {
                            fs::close( fds.0 );
                            fs::close( fds.1 );
                        }
                    }

                    if idx_cmd == 0
                    {
                        let pid = libc::getpid();
                        libc::setpgid( 0, pid );
                    }
                    else { libc::setpgid( 0, *pgid ); }
                    
                    if idx_cmd > 0
                    {
                        let fds_prev = pipes[idx_cmd - 1];
                        fs::dup2( fds_prev.0, 0 );
                        fs::close( fds_prev.0 );
                        fs::close( fds_prev.1 );
                    }

                    if idx_cmd < pipes_count
                    {
                        let fds = pipes[idx_cmd];
                        fs::dup2( fds.1, 1 );
                        fs::close( fds.1 );
                        fs::close( fds.0 );
                    }

                    if cmd.has_redirect_from()
                    {
                        if let Some( redirect_from ) = &cmd.redirect_from
                        {
                            let fd = get::descriptor_from_file( &redirect_from.clone().1 );
                            if fd == -1 { process::exit( 1 ); }
                            fs::dup2( fd, 0 );
                            fs::close( fd );
                        }
                    }

                    if cmd.has_here_string()
                    {
                        if let Some( fds ) = fds_stdin
                        {
                            fs::close( fds.1 );
                            fs::dup2( fds.0, 0 );
                            fs::close( fds.0 );
                        }
                    }

                    let mut stdout_redirected = false;
                    let mut stderr_redirected = false;
                    for item in &cmd.redirects_to
                    {
                        let from_ = &item.0;
                        let op_ = &item.1;
                        let to_ = &item.2;
                        
                        if to_ == "&1" && from_ == "2"
                        {
                            if idx_cmd < pipes_count { fs::dup2( 1, 2 ); }

                            else if !options.capture_output
                            {
                                let fd = fs::dup( 1 );
                                if fd == -1
                                {
                                    println_stderr!( "pls:dup error" );
                                    process::exit( 1 );
                                }
                                
                                fs::dup2( fd, 2 );
                            }

                            else
                            {
                                
                            }
                        }

                        else if to_ == "&2" && from_ == "1"
                        {
                            if idx_cmd < pipes_count || !options.capture_output
                            {
                                let fd = fs::dup( 2 );
                                if fd == -1
                                {
                                    println_stderr!( "pls:dup error" );
                                    process::exit( 1 );
                                }

                                fs::dup2( fd, 1 );
                            }
                            else
                            {
                                
                            }
                        }

                        else
                        {
                            let append = op_ == ">>";
                            match fs::create_raw_fd_from_file( to_, append )
                            {
                                Ok( fd ) =>
                                {
                                    if fd == -1
                                    {
                                        println_stderr!( "pls:fork:fd error" );
                                        process::exit( 1 );
                                    }

                                    if from_ == "1"
                                    {
                                        fs::dup2( fd, 1 );
                                        stdout_redirected = true;
                                    }
                                    else
                                    {
                                        fs::dup2( fd, 2 );
                                        stderr_redirected = true;
                                    }
                                }
                                Err( e ) =>
                                {
                                    println_stderr!( "pls:fork:{}", e );
                                    process::exit( 1 );
                                }
                            }
                        }
                    }
                    
                    if idx_cmd == pipes_count && options.capture_output
                    {
                        if !stdout_redirected
                        {
                            if let Some( fds ) = fds_capture_stdout
                            {
                                fs::close( fds.0 );
                                fs::dup2( fds.1, 1 );
                                fs::close( fds.1 );
                            }
                        }

                        if !stderr_redirected
                        {
                            if let Some( fds ) = fds_capture_stderr
                            {
                                fs::close( fds.0 );
                                fs::dup2( fds.1, 2 );
                                fs::close( fds.1 );
                            }
                        }
                    }

                    if cmd.is_builtin()
                    {
                        if let Some( status ) = try_run_builtin_in_subprocess( sh, cl, idx_cmd, capture )
                        { process::exit( status ); }
                    }
                    /*
                    Our strings do not have '\x00' bytes in them, we can use CString::new().expect() safely. */
                    let mut c_envs:Vec<_> = env::vars()
                    .map( |( k, v )|
                    {
                        CString::new( format!( "{}={}", k, v ).as_str() ).expect( "CString error" )
                    } )
                    .collect();

                    for ( key, value ) in cl.envs.iter()
                    {
                        c_envs.push( CString::new( format!( "{}={}", key, value ).as_str() ).expect( "CString error" ), );
                    }

                    let program = &cmd.tokens[0].1;
                    let path = if program.contains( '/' ) { program.clone() } 
                    else { path::find_file_in_path( program, true ) };

                    if path.is_empty()
                    {
                        println_stderr!( "pls:{}:command not found", program );
                        process::exit( 127 );
                    }

                    let c_program = CString::new( path.as_str() ).expect( "CString::new failed" );
                    let c_args:Vec<_> = cmd
                    .tokens
                    .iter()
                    .map( |x| CString::new( x.1.as_str() )
                    .expect( "CString error" ) )
                    .collect();

                    let c_args:Vec<&CStr> = c_args.iter().map( |x| x.as_c_str() ).collect();
                    let c_envs:Vec<&CStr> = c_envs.iter().map( |x| x.as_c_str() ).collect();
                    match execve( &c_program, &c_args, &c_envs )
                    {
                        Ok( _ ) => {}
                        Err( e ) => match e
                        {
                            nix::Error::ENOEXEC => { println_stderr!( "pls: {}:exec format error ( ENOEXEC )", program ); }
                            nix::Error::ENOENT => { println_stderr!( "pls: {}:file does not exist", program ); }
                            nix::Error::EACCES => { println_stderr!( "pls: {}:Permission denied", program ); }
                            _ => { println_stderr!( "pls: {}:{:?}", program, e ); }
                        },
                    }

                    process::exit( 1 );
                }

                Ok( ForkResult::Parent { child, .. } ) =>
                {
                    let pid:i32 = child.into();
                    if idx_cmd == 0
                    {
                        *pgid = pid;

                        if sh.has_terminal && options.isatty && !cl.background
                        { *term_given = shell::give_terminal_to( pid ); }
                    }

                    if options.isatty && !options.capture_output
                    {
                        let _cmd = parsers::line::tokens_to_line( &cmd.tokens );
                        sh.insert_job( *pgid, pid, &_cmd, "Running", cl.background );
                    }

                    if let Some( redirect_from ) = &cmd.redirect_from
                    {
                        if redirect_from.0 == "<<<"
                        {
                            if let Some( fds ) = fds_stdin
                            {
                                fs::close( fds.0 );
                                let mut f = File::from_raw_fd( fds.1 );
                                match f.write_all( redirect_from.1.clone().as_bytes() )
                                {
                                    Ok( _ ) => {}
                                    Err( e ) => println_stderr!( "pls:write_all:{}", e ),
                                }
                                match f.write_all( b"\n" )
                                {
                                    Ok( _ ) => {}
                                    Err( e ) => println_stderr!( "pls:write_all:{}", e ),
                                }
                            }
                        }
                    }
                    
                    if idx_cmd < pipes_count
                    {
                        let fds = pipes[idx_cmd];
                        fs::close( fds.1 );
                    }
                    
                    if idx_cmd > 0
                    {
                        let fds = pipes[idx_cmd - 1];
                        fs::close( fds.0 );
                    }

                    if idx_cmd == pipes_count && options.capture_output
                    {
                        let mut s_out = String::new();
                        let mut s_err = String::new();

                        if let Some( fds ) = fds_capture_stdout
                        {
                                fs::close( fds.1 );
                                let mut f = File::from_raw_fd( fds.0 );
                                match f.read_to_string( &mut s_out )
                                {
                                    Ok( _ ) => {}
                                    Err( e ) => println_stderr!( "pls:readstr:{}", e ),
                                }
                        }

                        if let Some( fds ) = fds_capture_stderr
                        {
                            fs::close( fds.1 );
                            let mut f_err = File::from_raw_fd( fds.0 );
                            match f_err.read_to_string( &mut s_err )
                            {
                                Ok( _ ) => {}
                                Err( e ) => println_stderr!( "pls:readstr:{}", e ),
                            }
                        }

                        *cmd_result = CommandResult
                        {
                            gid:*pgid,
                            status:0,
                            stdout:s_out.clone(),
                            stderr:s_err.clone(),
                        };
                    }

                    pid
                }

                Err( _ ) =>
                {
                    println_stderr!( "Fork failed" );
                    *cmd_result = CommandResult::error();
                    0
                }
            }
        }
    }
    /**/
    pub fn try_run_func
    ( 
        sh:&mut Shell,
        cl:&CommandLine,
        capture:bool,
        log_cmd:bool,
    ) -> Option<CommandResult>
    {
        if cl.is_empty() { return None; }

        let command = &cl.commands[0];
        if let Some( func_body ) = sh.get_func( &command.tokens[0].1 )
        {
            let mut args = vec!["pls".to_string( )];
            
            for token in &command.tokens
            {
                args.push( token.1.to_string() );
            }

            if log_cmd { /*log!( "run func:{:?}", &args );*/ }
            let cr_list = scripts::run_lines( sh, &func_body, &args, capture );
            let mut stdout = String::new();
            let mut stderr = String::new();
            for cr in cr_list
            {
                stdout.push_str( cr.stdout.trim() );
                stdout.push( ' ' );
                stderr.push_str( cr.stderr.trim() );
                stderr.push( ' ' );
            }
            let mut cr = CommandResult::new();
            cr.stdout = stdout;
            cr.stderr = stderr;
            return Some( cr );
        }
        None
    }

    #[derive( Debug, Clone )]
    pub struct Shell
    {
        pub jobs:HashMap<i32, types::Job>,
        pub alias:HashMap<String, String>,
        pub envs:HashMap<String, String>,
        pub funcs:HashMap<String, String>,
        pub cmd:String,
        pub current_dir:String,
        pub previous_dir:String,
        pub previous_cmd:String,
        pub previous_status:i32,
        pub is_login:bool,
        pub exit_on_error:bool,
        pub has_terminal:bool,
        pub session_id:String,
    }

    impl Shell
    {
        pub fn new() -> Shell
        {
            let uuid = Uuid::new_v4().as_hyphenated().to_string();
            let current_dir = get::current_directory();
            let has_terminal = proc_has_terminal();
            let ( session_id, _ ) = uuid.split_at( 13 );
            Shell
            {
                jobs:HashMap::new(),
                alias:HashMap::new(),
                envs:HashMap::new(),
                funcs:HashMap::new(),
                cmd:String::new(),
                current_dir:current_dir.clone(),
                previous_dir:String::new(),
                previous_cmd:String::new(),
                previous_status:0,
                is_login:false,
                exit_on_error:false,
                has_terminal,
                session_id:session_id.to_string(),
            }
        }

        pub fn insert_job( &mut self, gid:i32, pid:i32, cmd:&str, status:&str, bg:bool )
        {
            let mut i = 1;
            loop
            {
                let mut indexed_job_missing = false;
                if let Some( x ) = self.jobs.get_mut( &i )
                {
                    if x.gid == gid
                    {
                        x.pids.push( pid );
                        x.cmd = format!( "{} | {}", x.cmd, cmd );
                        return;
                    }
                } 
                else { indexed_job_missing = true; }

                if indexed_job_missing
                {
                    self.jobs.insert
                    ( 
                        i,
                        types::Job
                        {
                            cmd:cmd.to_string(),
                            id:i,
                            gid,
                            pids:vec![pid],
                            pids_stopped:HashSet::new(),
                            status:status.to_string(),
                            is_bg:bg,
                        },
                    );
                    return;
                }
                i += 1;
            }
        }

        pub fn get_job_by_id( &self, job_id:i32 ) -> Option<&types::Job> { self.jobs.get( &job_id ) }

        pub fn mark_job_member_continued( &mut self, pid:i32, gid:i32 ) -> Option<&types::Job>
        {
            if self.jobs.is_empty() { return None; }

            let mut i = 1;
            let mut idx_found = 0;
            loop
            {
                if let Some( job ) = self.jobs.get_mut( &i )
                {
                    if job.gid == gid
                    {
                        job.pids_stopped.remove( &pid );
                        idx_found = i;
                        break;
                    }
                }

                i += 1;
                if i >= 65535 { break; }
            }

            self.jobs.get( &idx_found )
        }

        pub fn mark_job_member_stopped( &mut self, pid:i32, gid:i32 ) -> Option<&types::Job>
        {
            if self.jobs.is_empty() { return None; }

            let mut i = 1;
            let mut idx_found = 0;
            loop
            {
                if let Some( job ) = self.jobs.get_mut( &i )
                {
                    if job.gid == gid
                    {
                        job.pids_stopped.insert( pid );
                        idx_found = i;
                        break;
                    }
                }
                
                i += 1;
                if i >= 65535 { break; }
            }

            self.jobs.get( &idx_found )
        }

        pub fn get_job_by_gid( &self, gid:i32 ) -> Option<&types::Job>
        {
            if self.jobs.is_empty() { return None; }

            let mut i = 1;
            loop
            {
                if let Some( x ) = self.jobs.get( &i )
                {
                    if x.gid == gid { return Some( x ); }
                }

                i += 1;
                if i >= 65535 { break; }
            }
            None
        }

        pub fn mark_job_as_running( &mut self, gid:i32, bg:bool )
        {
            if self.jobs.is_empty() { return; }

            let mut i = 1;
            loop
            {
                if let Some( job ) = self.jobs.get_mut( &i )
                {
                    if job.gid == gid
                    {
                        job.status = "Running".to_string();
                        job.pids_stopped.clear();
                        job.is_bg = bg;
                        return;
                    }
                }

                i += 1;
                if i >= 65535 { break; }
            }
        }

        pub fn mark_job_as_stopped( &mut self, gid:i32 )
        {
            if self.jobs.is_empty() { return; }
            let mut i = 1;
            loop
            {
                if let Some( x ) = self.jobs.get_mut( &i )
                {
                    if x.gid == gid
                    {
                        x.status = "Stopped".to_string();
                        x.is_bg = true;
                        return;
                    }
                }

                i += 1;
                if i >= 65535 { break; }
            }
        }

        pub fn remove_pid_from_job( &mut self, gid:i32, pid:i32 ) -> Option<types::Job>
        {
            if self.jobs.is_empty() { return None; }

            let mut empty_pids = false;
            let mut i = 1;
            loop
            {
                if let Some( x ) = self.jobs.get_mut( &i )
                {
                    if x.gid == gid
                    {
                        if let Ok( i_pid ) = x.pids.binary_search( &pid ) { x.pids.remove( i_pid ); }
                        empty_pids = x.pids.is_empty();
                        break;
                    }
                }

                i += 1;
                if i >= 65535 { break; }
            }

            if empty_pids { return self.jobs.remove( &i ); }

            None
        }
        /*
        Update existing *ENV Variable* if such name exists in ENVs,
        so we define a local *Shell Variable*, which would not be exported into child processes. */
        pub fn set_env( &mut self, name:&str, value:&str )
        {
            if env::var( name ).is_ok() { env::set_var( name, value ); }
            else { self.envs.insert( name.to_string(), value.to_string() ); }
        }
        /// get *Shell Variable*, or *ENV Variable*.
        pub fn get_env( &self, name:&str ) -> Option<String>
        {
            match self.envs.get( name )
            {
                Some( x ) => Some( x.to_string() ),
                None =>
                {
                    match env::var( name )
                    {
                        Ok( x ) => Some( x ),
                        Err( _ ) => None,
                    }
                }
            }
        }
        /// Remove environment variable, function from the environment of the currently running process.
        pub fn remove_env( &mut self, name:&str ) -> bool
        {
            let ptn_env = Regex::new( r"^[a-zA-Z_][a-zA-Z0-9_-]*$" ).unwrap();
            if !ptn_env.is_match( name ) { return false; }
            env::remove_var( name );
            self.envs.remove( name );
            self.remove_func( name );
            true
        }

        pub fn remove_path( &mut self, path:&str )
        {
            if let Ok( paths ) = env::var( "PATH" )
            {
                let mut paths_new:Vec<&str> = paths.split( ":" ).collect();
                paths_new.retain( |&x| x != path );
                env::set_var( "PATH", paths_new.join( ":" ).as_str() );
            }
        }

        pub fn remove_func( &mut self, name:&str ) { self.funcs.remove( name ); }

        pub fn set_func( &mut self, name:&str, value:&str ) { self.funcs.insert( name.to_string(), value.to_string() ); }

        pub fn get_func( &self, name:&str ) -> Option<String> { self.funcs.get( name ).map( |x| x.to_string() ) }

        pub fn get_alias_list( &self ) -> Vec<( String, String )>
        {
            let mut result = Vec::new();
            for ( name, value ) in &self.alias
            {
                result.push( ( name.clone(), value.clone() ) );
            }
            
            result
        }

        pub fn add_alias( &mut self, name:&str, value:&str ) { self.alias.insert( name.to_string(), value.to_string() ); }

        pub fn is_alias( &self, name:&str ) -> bool { self.alias.contains_key( name ) }

        pub fn remove_alias( &mut self, name:&str ) -> bool
        {
            let opt = self.alias.remove( name );
            opt.is_some()
        }

        pub fn get_alias_content( &self, name:&str ) -> Option<String>
        {
            let result = match self.alias.get( name )
            {
                Some( x ) => x.to_string(),
                None => String::new(),
            };
            
            if result.is_empty() { None }
            else { Some( result ) }
        }
    }

    pub unsafe fn give_terminal_to( gid:i32 ) -> bool
    {
        let mut mask:libc::sigset_t = mem::zeroed();
        let mut old_mask:libc::sigset_t = mem::zeroed();

        libc::sigemptyset( &mut mask );
        libc::sigaddset( &mut mask, libc::SIGTSTP );
        libc::sigaddset( &mut mask, libc::SIGTTIN );
        libc::sigaddset( &mut mask, libc::SIGTTOU );
        libc::sigaddset( &mut mask, libc::SIGCHLD );

        let rcode = libc::pthread_sigmask( libc::SIG_BLOCK, &mask, &mut old_mask );
        if rcode != 0 { /* log!( "failed to call pthread_sigmask" ); */  }
        let rcode = libc::tcsetpgrp( 1, gid );
        let given;
        if rcode == -1
        {
            given = false;
            let e = no::errno();
            let code = e.0; // log!( "error in give_terminal_to() {}:{}", code, e );
        }
        else { given = true; }

        let rcode = libc::pthread_sigmask( libc::SIG_SETMASK, &old_mask, &mut mask );
        if rcode != 0 { /*log!( "failed to call pthread_sigmask" );*/ }
        given
    }

    pub fn brace_getitem( s:&str, depth:i32 ) -> ( Vec<String>, String )
    {
        let mut out:Vec<String> = vec![String::new( )];
        let mut ss = s.to_string();
        let mut tmp;
        while !ss.is_empty()
        {
            let c = match ss.chars().next()
            {
                Some( x ) => x,
                None => { return ( out, ss ); }
            };
            if depth > 0 && ( c == ',' || c == '}' ) { return ( out, ss ); }

            if c == '{'
            {
                let mut sss = ss.clone();
                sss.remove( 0 );
                let result_groups = brace_getgroup( &sss, depth + 1 );
                if let Some( ( out_group, s_group ) ) = result_groups
                {
                    let mut tmp_out = Vec::new();
                    for x in out.iter()
                    {
                        for y in out_group.iter()
                        {
                            let item = format!( "{}{}", x, y );
                            tmp_out.push( item );
                        }
                    }
                    out = tmp_out;
                    ss = s_group.clone();
                    continue;
                }
            }
            // FIXME:here we mean more than one char.
            if c == '\\' && ss.len() > 1
            {
                ss.remove( 0 );
                let c;
                match ss.chars().next()
                {
                    Some( x ) => c = x,
                    None => { return ( out, ss ) }
                }

                tmp = format!( "\\{}", c );
            }
            else { tmp = c.to_string(); }

            let mut result = Vec::new();
            for x in out.iter()
            {
                let item = format!( "{}{}", x, tmp );
                result.push( item );
            }
            out = result;
            ss.remove( 0 );
        }
        ( out, ss )
    }

    pub fn brace_getgroup( s:&str, depth:i32 ) -> Option<( Vec<String>, String )>
    {
        let mut out:Vec<String> = Vec::new();
        let mut comma = false;
        let mut ss = s.to_string();
        while !ss.is_empty()
        {
            let ( g, sss ) = brace_getitem( ss.as_str(), depth );
            ss = sss.clone();
            if ss.is_empty() { break; }

            for x in g.iter() { out.push( x.clone() ); }
            let c = match ss.chars().next()
            {
                Some( x ) => x,
                None => { break; }
            };

            if c == '}'
            {
                let mut sss = ss.clone();
                sss.remove( 0 );
                if comma { return Some( ( out, sss ) ); }

                let mut result = Vec::new();
                for x in out.iter()
                {
                    let item = format!( "{{{}}}", x );
                    result.push( item );
                }

                return Some( ( result, ss ) );
            }

            if c == ','
            {
                comma = true;
                ss.remove( 0 );
            }
        }

        None
    }

    pub fn should_do_dollar_command_extension( line:&str ) -> bool
    {
        regex::re_contains( line, r"\$\( [^\ )]+\ )" ) &&
        !regex::re_contains( line, r"='.*\$\( [^\ )]+\ ).*'$" )
    }

    pub fn do_command_substitution_for_dollar( sh:&mut Shell, tokens:&mut types::Tokens )
    {
        unsafe
        {
            let mut idx:usize = 0;
            let mut buff:HashMap<usize, String> = HashMap::new();

            for ( sep, token ) in tokens.iter()
            {
                if sep == "'" || sep == "\\" || !should_do_dollar_command_extension( token )
                {
                    idx += 1;
                    continue;
                }

                let mut line = token.to_string();
                loop
                {
                    if !should_do_dollar_command_extension( &line ) { break; }

                    let ptn_cmd = r"\$\( ( .+ )\ )";
                    let cmd = match regex::find_first_group( ptn_cmd, &line )
                    {
                        Some( x ) => x,
                        None =>
                        {
                            println_stderr!( "pls:calculator:no first group" );
                            return;
                        }
                    };

                    let cmd_result = match CommandLine::from_line( &cmd, sh )
                    {
                        Ok( c ) =>
                        {
                            //log!( "run subcmd dollar:{:?}", &cmd );
                            let ( term_given, cr ) = shell::run_pipeline( sh, &c, true, true, false );
                            if term_given
                            {
                                let gid = libc::getpgid( 0 );
                                give_terminal_to( gid );
                            }

                            cr
                        }

                        Err( e ) =>
                        {
                            println_stderr!( "pls:{}", e );
                            continue;
                        }
                    };

                    let output_txt = cmd_result.stdout.trim();
                    let ptn = r"( ?P<head>[^\$]* )\$\( .+\ )( ?P<tail>.* )";
                    let re;

                    if let Ok( x ) = Regex::new( ptn ) { re = x; }
                    else { return; }

                    let to = format!( "${{head}}{}${{tail}}", output_txt );
                    let line_ = line.clone();
                    let result = re.replace( &line_, to.as_str() );
                    line = result.to_string();
                }

                buff.insert( idx, line.clone() );
                idx += 1;
            }

            for ( i, text ) in buff.iter() { tokens[*i].1 = text.to_string(); }
        }
    }

    pub fn do_command_substitution_for_dot( sh:&mut Shell, tokens:&mut types::Tokens )
    {
        unsafe
        {
            let mut idx:usize = 0;
            let mut buff:HashMap<usize, String> = HashMap::new();
            for ( sep, token ) in tokens.iter()
            {
                let new_token:String;
                if sep == "`"
                {
                   // log!( "run subcmd dot1:{:?}", token );
                    let cr = match CommandLine::from_line( token, sh )
                    {
                        Ok( c ) =>
                        {
                            let ( term_given, _cr ) = shell::run_pipeline( sh, &c, true, true, false );
                            if term_given
                            {
                                let gid = libc::getpgid( 0 );
                                give_terminal_to( gid );
                            }

                            _cr
                        }

                        Err( e ) =>
                        {
                            println_stderr!( "pls:{}", e );
                            continue;
                        }
                    };

                    new_token = cr.stdout.trim().to_string();

                }
                else if sep == "\"" || sep.is_empty()
                {
                    let re;
                    if let Ok( x ) = Regex::new( r"^( [^`]* )`( [^`]+ )`( .* )$" ) { re = x; }
                    else
                    {
                        println_stderr!( "pls:re new error" );
                        return;
                    }

                    if !re.is_match( token )
                    {
                        idx += 1;
                        continue;
                    }
                    let mut _token = token.clone();
                    let mut _item = String::new();
                    let mut _head = String::new();
                    let mut _output = String::new();
                    let mut _tail = String::new();
                    loop
                    {
                        if !re.is_match( &_token )
                        {
                            if !_token.is_empty() { _item = format!( "{}{}", _item, _token ); }
                            break;
                        }

                        for cap in re.captures_iter( &_token )
                        {
                            _head = cap[1].to_string();
                            _tail = cap[3].to_string(); // log!( "run subcmd dot2:{:?}", &cap[2] );
                            let cr = match CommandLine::from_line( &cap[2], sh )
                            {
                                Ok( c ) =>
                                {
                                    let ( term_given, _cr ) = shell::run_pipeline( sh, &c, true, true, false );
                                    if term_given
                                    {
                                        let gid = libc::getpgid( 0 );
                                        give_terminal_to( gid );
                                    }

                                    _cr
                                }

                                Err( e ) =>
                                {
                                    println_stderr!( "pls:{}", e );
                                    continue;
                                }
                            };

                            _output = cr.stdout.trim().to_string();
                        }

                        _item = format!( "{}{}{}", _item, _head, _output );
                        if _tail.is_empty() { break; }
                        _token = _tail.clone();
                    }
                    new_token = _item;
                }
                else
                {
                    idx += 1;
                    continue;
                }

                buff.insert( idx, new_token.clone() );
                idx += 1;
            }

            for ( i, text ) in buff.iter() { tokens[*i].1 = text.to_string(); }
        }
    }

    pub fn do_command_substitution( sh:&mut Shell, tokens:&mut types::Tokens )
    {
        do_command_substitution_for_dot( sh, tokens );
        do_command_substitution_for_dollar( sh, tokens );
    }

    pub fn do_expansion( sh:&mut Shell, tokens:&mut types::Tokens )
    {
        let line = parsers::line::tokens_to_line( tokens );
        if is::arithmetic( &line ) { return; }
        if tokens.len() >= 2 && tokens[0].1 == "export" && tokens[1].1.starts_with( "PROMPT=" ) { return; }

        expand::alias( sh, tokens );
        expand::home( tokens );
        expand::environment( sh, tokens );
        expand::brace( tokens );
        expand::glob( tokens );
        do_command_substitution( sh, tokens );
        expand::brace_range( tokens );
    }

    pub fn trim_multiline_prompts( line:&str ) -> String
    {
        /*
        Remove sub-prompts from multiple line mode:
            1. assuming '\n' char cannot be typed manually?
            2. `>>` is defined as `src/prompt/multilines.rs` */
        let line_new = regex::replace_all( line, r"\\\n>> ", "" );
        let line_new = regex::replace_all( &line_new, r"\| *\n>> ", "| " );
        regex::replace_all( &line_new, r"( ?P<NEWLINE>\n )>> ", "$NEWLINE" )
    }

    pub fn proc_has_terminal() -> bool
    {
        unsafe
        {
            let tgid = libc::tcgetpgrp( 0 );
            let pgid = libc::getpgid( 0 );
            tgid == pgid
        }
    }
}
mod signals
{
    use ::
    {
        collections::{ HashMap, HashSet },
        error::no::{ errno, set_errno },
        nix::
        {
            sys::
            {
                signal,
                wait::{ WaitPidFlag as WF, WaitStatus as WS, waitpid },
            },
            unistd::{ Pid },
        },
        sync::{ Mutex },
        *,
    };
    
    lazy_static!
    {
        static ref REAP_MAP:Mutex<HashMap<i32, i32>> = Mutex::new( HashMap::new() );
        static ref STOP_MAP:Mutex<HashSet<i32>> = Mutex::new( HashSet::new() );
        static ref CONT_MAP:Mutex<HashSet<i32>> = Mutex::new( HashSet::new() );
        static ref KILL_MAP:Mutex<HashMap<i32, i32>> = Mutex::new( HashMap::new() );
    }

    pub fn killed_map_insert( pid:i32, sig:i32 )
    { if let Ok( mut m ) = KILL_MAP.try_lock() { m.insert( pid, sig ); } }

    pub fn killed_map_pop( pid:i32 ) -> Option<i32>
    { if let Ok( mut m ) = KILL_MAP.try_lock() { m.remove( &pid ) } else { None } }

    pub fn insert_cont_map( pid:i32 ) 
    { if let Ok( mut m ) = CONT_MAP.try_lock() { m.insert( pid ); } }

    pub fn pop_cont_map( pid:i32 ) -> bool
    {
        match CONT_MAP.try_lock()
        {
            Ok( mut m ) => m.remove( &pid ),
            Err( _ ) => false,
        }
    }

    pub fn insert_stopped_map( pid:i32 ) { if let Ok( mut m ) = STOP_MAP.try_lock() { m.insert( pid ); } }

    pub fn pop_stopped_map( pid:i32 ) -> bool
    {
        match STOP_MAP.try_lock()
        {
            Ok( mut m ) => m.remove( &pid ),
            Err( _ ) => false,
        }
    }

    pub fn insert_reap_map( pid:i32, status:i32 )
    { if let Ok( mut m ) = REAP_MAP.try_lock() { m.insert( pid, status ); } }

    pub fn pop_reap_map( pid:i32 ) -> Option<i32>
    {
        match REAP_MAP.try_lock()
        {
            Ok( mut m ) => m.remove( &pid ),
            Err( _ ) => None,
        }
    }

    pub fn block_signals()
    {
        let mut sigset = signal::SigSet::empty();
        sigset.add( signal::SIGCHLD );
        match signal::sigprocmask( signal::SigmaskHow::SIG_BLOCK, Some( &sigset ), None )
        {
            Ok( _ ) => {},
            Err( e ) => 
            { 
                // log!( "sigprocmask block error:{:?}", e );
            }
        }
    }

    pub fn unblock_signals()
    {
        let mut sigset = signal::SigSet::empty();
        sigset.add( signal::SIGCHLD );
        match signal::sigprocmask( signal::SigmaskHow::SIG_UNBLOCK, Some( &sigset ), None )
        {
            Ok( _ ) => {},
            Err( e ) => 
            { 
                // log!( "sigprocmask unblock error:{:?}", e );
            }
        }
    }
    
    pub extern fn handle_sigchld( _sig:i32 )
    {
        let saved_errno = errno();
        let options = Some( WF::WUNTRACED | WF::WNOHANG | WF::WCONTINUED );
        loop
        {
            match waitpid( Pid::from_raw( -1 ), options )
            {
                Ok( WS::Exited( pid, status ) ) => { insert_reap_map( i32::from( pid ), status ); }
                Ok( WS::Stopped( pid, _sig ) ) => { insert_stopped_map( i32::from( pid ) ); }
                Ok( WS::Continued( pid ) ) => { insert_cont_map( i32::from( pid ) ); }
                Ok( WS::Signaled( pid, sig, _core_dumped ) ) => { killed_map_insert( i32::from( pid ), sig as i32 ); }
                Ok( WS::StillAlive ) => { break; }
                Ok( _others ) => { /* log!( "sigchld others:{:?}", _others ); */ }
                Err( e ) =>
                {
                    if e == nix::Error::ECHILD { break; } //log!( "chld waitpid error:{:?}", e );
                    break;
                }
            }
        }
        set_errno( saved_errno );
    }

    pub fn setup_sigchld_handler()
    {
        unsafe
        {
            let sigset = signal::SigSet::empty();
            let handler = signal::SigHandler::Handler( handle_sigchld );
            let flags = signal::SaFlags::SA_RESTART;
            let sa = signal::SigAction::new( handler, flags, sigset );
            match signal::sigaction( signal::SIGCHLD, &sa )
            {
                Ok( _ ) => {},
                Err( e ) => {/* log!( "sigaction error:{:?}", e ); */}
            }
        }
    }
}
pub mod slice
{
    pub use std::slice::{ * };
    use ::
    {
        borrow::{ Cow },
        nom::
        { 

            branch::{ alt },
            character::streaming::{ char, line_ending as eol },
            combinator::{ eof },
            IResult
        },
        *,
    };

    pub fn ws( input:&[u8] ) -> IResult<&[u8], char> { alt( ( char( ' ' ), char( '\t' ) ) )( input ) }

    pub fn end( input:&[u8] ) -> IResult<&[u8], &[u8]> { alt( ( eof, eol ) )( input ) }
   /*
   */
   #[inline] pub fn number( i:&[u8] ) -> i32
    {
        let mut n:i32 = 0;
        for &ch in i
        {
            let d = ( ch as i32 ).wrapping_sub( b'0' as i32 );
            if d <= 9
            { n = n.saturating_mul( 10 ).saturating_add( d ); }
        }

        n
    }
    /**/
    pub fn unescape( i:&[u8] ) -> Cow<[u8]>
    {
    }
}
pub mod str
{
    pub use std::str::{ * };
    use ::
    {
        borrow::{ Borrow, BorrowMut, Cow },
        boxed::{ Box },
        collections::{ HashMap },
        cmp::{ Ordering },
        ffi::{OsStr, OsString},
        fmt,
        hash::{ Hash, Hasher },
        iter::{ FromIterator },
        marker::{ PhantomData },
        smallvec::{ Array, SmallVec },
        *,
    };
    /**/
    macro_rules! impl_index_str
    {
        ( $index_type:ty ) => 
        {
            impl<A:Array<Item = u8>> ops::Index<$index_type> for SmallString<A>
            {
                type Output = str;
                #[inline] fn index( &self, index:$index_type ) -> &str { &self.as_str()[index] }
            }

            impl<A:Array<Item = u8>> ops::IndexMut<$index_type> for SmallString<A>
            {
                #[inline] fn index_mut( &mut self, index:$index_type ) -> &mut str { &mut self.as_mut_str()[index] }
            }
        };
    }

    macro_rules! eq_str
    {
        ( $rhs:ty ) =>
        {
            impl<'a, A:Array<Item = u8>> PartialEq<$rhs> for SmallString<A>
            {
                #[inline] fn eq( &self, rhs:&$rhs ) -> bool { &self[..] == &rhs[..] }
                #[inline] fn ne( &self, rhs:&$rhs ) -> bool { &self[..] != &rhs[..] }
            }
        };
    }
    /*
    */
    pub fn unquote( s:&str ) -> String
    {
        let args = parsers::line::line_to_plain_tokens( s );
        if args.is_empty() { return String::new(); }
        args[0].clone()
    }
    /**/
    pub fn split_into_fields( sh:&shell::Shell, line:&str, envs:&HashMap<String, String>, ) -> Vec<String>
    {
        let ifs_chars;

        if envs.contains_key( "IFS" ) { ifs_chars = envs[&"IFS".to_string( )].chars().collect(); }
        else if let Some( x ) = sh.get_env( "IFS" ) { ifs_chars = x.chars().collect(); }
        else if let Ok( x ) = env::var( "IFS" ) { ifs_chars = x.chars().collect(); }
        else { ifs_chars = vec![]; }

        if ifs_chars.is_empty()
        {
            return line
            .split( &[' ', '\t', '\n'][..] )
            .map( |x| x.to_string() )
            .collect();
        }
        else { return line.split( &ifs_chars[..] ).map( |x| x.to_string() ).collect(); }
    }
    /**/
    pub fn wrap_sep_string( sep:&str, s:&str ) -> String
    {
        let mut _token = String::new();
        let mut met_subsep = false;
        let mut previous_subsep = 'N';
        for c in s.chars()
        {
            if sep.is_empty() && ( c == '`' || c == '"' )
            {
                if !met_subsep
                {
                    met_subsep = true;
                    previous_subsep = c;
                }
                else if c == previous_subsep
                {
                    met_subsep = false;
                    previous_subsep = 'N';
                }
            }
            if c.to_string() == sep { _token.push( '\\' ); }
            if c == ' ' && sep.is_empty() && !met_subsep
            {
                _token.push( '\\' );
            }
            _token.push( c );
        }
        format!( "{}{}{}", sep, _token, sep )
    }
    /*
    smallstr v0.0.0 
    Implements `SmallString`, a `String`-like container for small strings */
    /// A `String`-like container that can store a small number of bytes inline.
    #[derive( Clone, Default )]
    pub struct SmallString<A:Array<Item = u8>>
    {
        data:SmallVec<A>,
    }

    impl<A:Array<Item = u8>> SmallString<A>
    {
        /// Construct an empty string.
        #[inline] pub fn new() -> SmallString<A>
        {
            SmallString
            {
                data:SmallVec::new(),
            }
        }
        /// Construct an empty string with enough capacity pre-allocated to store at least `n` bytes.
        #[inline] pub fn with_capacity( n:usize ) -> SmallString<A>
        {
            SmallString
            {
                data:SmallVec::with_capacity( n ),
            }
        }
        /// Construct a `SmallString` by copying data from a `&str`.
        #[inline] pub fn from_str( s:&str ) -> SmallString<A>
        {
            SmallString
            {
                data:SmallVec::from_slice( s.as_bytes() ),
            }
        }
        /// Construct a `SmallString` by using an existing allocation.
        #[inline] pub fn from_string( s:String ) -> SmallString<A>
        {
            SmallString
            {
                data:SmallVec::from_vec( s.into_bytes() ),
            }
        }
        /// Constructs a new `SmallString` on the stack using UTF-8 bytes.
        #[inline] pub fn from_buf( buf:A ) -> Result<SmallString<A>, FromUtf8Error<A>>
        {
            let data = SmallVec::from_buf( buf );

            match str::from_utf8( &data )
            {
                Ok( _ ) => Ok( SmallString { data } ),
                Err( error ) =>
                {
                    let buf = data.into_inner().ok().unwrap();
                    Err( FromUtf8Error { buf, error } )
                }
            }
        }
        /// Constructs a new `SmallString` on stack using provided array without checking that it contains valid UTF-8.
        #[inline] pub unsafe fn from_buf_unchecked( buf:A ) -> SmallString<A>
        {
            SmallString
            {
                data:SmallVec::from_buf( buf ),
            }
        }
        /// The maximum number of bytes this string can hold inline.
        #[inline] pub fn inline_size( &self ) -> usize
        { A::size() }
        /// Returns the length of this string, in bytes.
        #[inline] pub fn len( &self ) -> usize
        { self.data.len() }
        /// Returns `true` if this string is empty.
        #[inline] pub fn is_empty( &self ) -> bool
        { self.data.is_empty() }
        /// Returns the number of bytes this string can hold without reallocating.
        #[inline] pub fn capacity( &self ) -> usize
        { self.data.capacity() }
        /// Returns `true` if the data has spilled into a separate heap-allocated buffer.
        #[inline] pub fn spilled( &self ) -> bool
        { self.data.spilled() }
        /// Empties the string and returns an iterator over its former contents.
        pub fn drain( &mut self ) -> Drain
        {
            unsafe
            {
                let len = self.len();
                self.data.set_len( 0 );
                let ptr = self.as_ptr();
                let slice = slice::from_raw_parts( ptr, len );
                let s = str::from_utf8_unchecked( slice );
                Drain { iter:s.chars() }
            }
        }
        /// Appends the given `char` to the end of this string.
        #[inline] pub fn push( &mut self, ch:char )
        {
            match ch.len_utf8() 
            {
                1 => self.data.push( ch as u8 ),
                _ => self.push_str( ch.encode_utf8( &mut [0; 4] ) ),
            }
        }
        /// Appends the given string slice to the end of this string.
        #[inline] pub fn push_str( &mut self, s:&str )
        { self.data.extend_from_slice( s.as_bytes() ); }
        /// Removes the last character from this string and returns it.
        #[inline] pub fn pop( &mut self ) -> Option<char>
        {
            unsafe
            {
                match self.chars().next_back()
                {
                    Some( ch ) =>
                    {
                        let new_len = self.len() - ch.len_utf8();
                        self.data.set_len( new_len );
                        Some( ch )
                    },
                    None => None,
                }
            }
        }
        /// Reallocates to set the new capacity to `new_cap`.
        #[inline] pub fn grow( &mut self, new_cap:usize )
        { self.data.grow( new_cap ); }
        /// Ensures that this string's capacity is at least `additional` bytes larger than its length.
        #[inline] pub fn reserve( &mut self, additional:usize )
        { self.data.reserve( additional ); }
        /// Ensures that this string's capacity is `additional` bytes larger than its length.
        #[inline] pub fn reserve_exact( &mut self, additional:usize )
        { self.data.reserve( additional ); }
        /// Shrink the capacity of the string as much as possible.
        #[inline] pub fn shrink_to_fit( &mut self )
        { self.data.shrink_to_fit(); }
        /// Shorten the string, keeping the first `len` bytes.
        #[inline] pub fn truncate( &mut self, len:usize )
        {
            assert!( self.is_char_boundary( len ) );
            self.data.truncate( len );
        }
        /// Extracts a string slice containing the entire string.
        #[inline] pub fn as_str( &self ) -> &str
        { self }
        /// Extracts a string slice containing the entire string.
        #[inline] pub fn as_mut_str( &mut self ) -> &mut str
        { self }
        /// Removes all contents of the string.
        #[inline] pub fn clear( &mut self )
        { self.data.clear(); }
        /// Removes a `char` from this string at a byte position and returns it.
        #[inline] pub fn remove( &mut self, idx:usize ) -> char
        {
            unsafe
            {
                let ch = match self[idx..].chars().next()
                {
                    Some( ch ) => ch,
                    None => panic!( "cannot remove a char from the end of a string" ),
                };
                let ch_len = ch.len_utf8();
                let next = idx + ch_len;
                let len = self.len();                
                ptr::copy
                (
                    self.as_ptr().add( next ),
                    self.as_mut_ptr().add( idx ),
                    len - next,
                );
                self.data.set_len( len - ch_len );
                ch
            }
        }
        /// Inserts a `char` into this string at the given byte position.
        #[inline] pub fn insert( &mut self, idx:usize, ch:char )
        {
            assert!( self.is_char_boundary( idx ) );
            match ch.len_utf8()
            {
                1 => self.data.insert( idx, ch as u8 ),
                _ => self.insert_str( idx, ch.encode_utf8( &mut [0; 4] ) ),
            }
        }
        /// Inserts a `&str` into this string at the given byte position.
        #[inline] pub fn insert_str( &mut self, idx:usize, s:&str )
        {
            unsafe
            {
                assert!( self.is_char_boundary( idx ) );
                let len = self.len();
                let amt = s.len();
                self.data.reserve( amt );                
                ptr::copy
                ( 
                    self.as_ptr().add( idx ),
                    self.as_mut_ptr().add( idx + amt ),
                    len - idx,
                );
                ptr::copy_nonoverlapping( s.as_ptr(), self.as_mut_ptr().add( idx ), amt );
                self.data.set_len( len + amt );
            }
        }
        /// Returns a mutable reference to the contents of the `SmallString`.
        #[inline] pub unsafe fn as_mut_vec( &mut self ) -> &mut SmallVec<A>
        { &mut self.data }
        /// Converts the `SmallString` into a `String`, without reallocating if it has already spilled onto the heap.
        #[inline] pub fn into_string( self ) -> String
        { unsafe { String::from_utf8_unchecked( self.data.into_vec() ) } }
        /// Converts the `SmallString` into a `Box<str>`, without reallocating if it has already spilled onto the heap.
        #[inline] pub fn into_boxed_str( self ) -> Box<str>
        { self.into_string().into_boxed_str() }
        /// Convert the `SmallString` into `A`, if possible. Otherwise, return `Err( self )`.
        #[inline] pub fn into_inner( self ) -> Result<A, Self>
        { self.data.into_inner().map_err( |data| SmallString { data } ) }
        /// Retains only the characters specified by the predicate.
        #[inline] pub fn retain<F:FnMut( char ) -> bool>( &mut self, mut f:F )
        {
            unsafe
            {            
                struct SetLenOnDrop<'a, A:Array<Item = u8>>
                {
                    s:&'a mut SmallString<A>,
                    idx:usize,
                    del_bytes:usize,
                }

                impl<'a, A:Array<Item = u8>> Drop for SetLenOnDrop<'a, A>
                {
                    fn drop( &mut self )
                    {
                        let new_len = self.idx - self.del_bytes;
                        debug_assert!( new_len <= self.s.len() );
                        self.s.data.set_len( new_len );
                    }
                }

                let len = self.len();
                let mut guard = SetLenOnDrop
                {
                    s:self,
                    idx:0,
                    del_bytes:0,
                };

                while guard.idx < len
                {
                    let ch = guard
                    .s
                    .get_unchecked( guard.idx..len )
                    .chars()
                    .next()
                    .unwrap();
                    let ch_len = ch.len_utf8();

                    if !f( ch ) { guard.del_bytes += ch_len; }
                    else if guard.del_bytes > 0
                    {
                        ptr::copy
                        (
                            guard.s.data.as_ptr().add( guard.idx ),
                            guard.s.data.as_mut_ptr().add( guard.idx - guard.del_bytes ),
                            ch_len,
                        );
                    }
                    
                    guard.idx += ch_len;
                }

                drop( guard );
            }
        }

        fn as_mut_ptr( &mut self ) -> *mut u8 { self.as_ptr() as *mut u8 }
    }

    impl<A:Array<Item = u8>> ops::Deref for SmallString<A>
    {
        type Target = str;
        #[inline] fn deref( &self ) -> &str
        {
            unsafe 
            { 
                let bytes:&[u8] = &self.data;
                str::from_utf8_unchecked( bytes ) 
            }
        }
    }

    impl<A:Array<Item = u8>> ops::DerefMut for SmallString<A>
    {
        #[inline] fn deref_mut( &mut self ) -> &mut str
        {
            unsafe
            {
                let bytes:&mut [u8] = &mut self.data;
                str::from_utf8_unchecked_mut( bytes ) 
            }
        }
    }

    impl<A:Array<Item = u8>> AsRef<str> for SmallString<A>
    {
        #[inline] fn as_ref( &self ) -> &str { self }
    }

    impl<A:Array<Item = u8>> AsMut<str> for SmallString<A>
    {
        #[inline] fn as_mut( &mut self ) -> &mut str { self }
    }

    impl<A:Array<Item = u8>> Borrow<str> for SmallString<A>
    {
        #[inline] fn borrow( &self ) -> &str { self }
    }

    impl<A:Array<Item = u8>> BorrowMut<str> for SmallString<A>
    {
        #[inline] fn borrow_mut( &mut self ) -> &mut str { self }
    }

    impl<A:Array<Item = u8>> AsRef<[u8]> for SmallString<A>
    {
        #[inline] fn as_ref( &self ) -> &[u8] { self.data.as_ref() }
    }

    impl<A:Array<Item = u8>> fmt::Write for SmallString<A>
    {
        #[inline] fn write_str( &mut self, s:&str ) -> fmt::Result
        {
            self.push_str( s );
            Ok( () )
        }

        #[inline] fn write_char( &mut self, ch:char ) -> fmt::Result
        {
            self.push( ch );
            Ok( () )
        }
    }

    impl<A:Array<Item = u8>> From<char> for SmallString<A>
    {
        #[inline] fn from( ch:char ) -> SmallString<A> { SmallString::from_str( ch.encode_utf8( &mut [0; 4] ) ) }
    }

    impl<'a, A:Array<Item = u8>> From<&'a str> for SmallString<A>
    {
        #[inline] fn from( s:&str ) -> SmallString<A> { SmallString::from_str( s ) }
    }

    impl<A:Array<Item = u8>> From<Box<str>> for SmallString<A>
    {
        #[inline] fn from( s:Box<str> ) -> SmallString<A> { SmallString::from_string( s.into() ) }
    }

    impl<A:Array<Item = u8>> From<String> for SmallString<A>
    {
        #[inline] fn from( s:String ) -> SmallString<A> { SmallString::from_string( s ) }
    }

    impl<'a, A:Array<Item = u8>> From<Cow<'a, str>> for SmallString<A>
    {
        fn from( value:Cow<'a, str> ) -> Self
        {
            match value
            {
                Cow::Borrowed( s ) => Self::from_str( s ),
                Cow::Owned( s ) => Self::from_string( s ),
            }
        }
    }

    impl_index_str!( ops::Range<usize> );
    impl_index_str!( ops::RangeFrom<usize> );
    impl_index_str!( ops::RangeTo<usize> );
    impl_index_str!( ops::RangeFull );

    impl<A:Array<Item = u8>> FromIterator<char> for SmallString<A>
    {
        fn from_iter<I:IntoIterator<Item = char>>( iter:I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<'a, A:Array<Item = u8>> FromIterator<&'a char> for SmallString<A>
    {
        fn from_iter<I:IntoIterator<Item = &'a char>>( iter:I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter.into_iter().cloned() );
            s
        }
    }

    impl<'a, A:Array<Item = u8>> FromIterator<Cow<'a, str>> for SmallString<A>
    {
        fn from_iter<I:IntoIterator<Item = Cow<'a, str>>>( iter:I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<'a, A:Array<Item = u8>> FromIterator<&'a str> for SmallString<A>
    {
        fn from_iter<I:IntoIterator<Item = &'a str>>( iter:I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<A:Array<Item = u8>> FromIterator<String> for SmallString<A>
    {
        fn from_iter<I:IntoIterator<Item = String>>( iter:I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<A:Array<Item = u8>> Extend<char> for SmallString<A>
    {
        fn extend<I:IntoIterator<Item = char>>( &mut self, iter:I )
        {
            let iter = iter.into_iter();
            let ( lo, _ ) = iter.size_hint();
            self.reserve( lo );
            for ch in iter
            {
                self.push( ch );
            }
        }
    }

    impl<'a, A:Array<Item = u8>> Extend<&'a char> for SmallString<A>
    {
        fn extend<I:IntoIterator<Item = &'a char>>( &mut self, iter:I ){ self.extend( iter.into_iter().cloned() ); }
    }

    impl<'a, A:Array<Item = u8>> Extend<Cow<'a, str>> for SmallString<A>
    {
        fn extend<I:IntoIterator<Item = Cow<'a, str>>>( &mut self, iter:I )
        {
            for s in iter
            {
                self.push_str( &s );
            }
        }
    }

    impl<'a, A:Array<Item = u8>> Extend<&'a str> for SmallString<A>
    {
        fn extend<I:IntoIterator<Item = &'a str>>( &mut self, iter:I )
        {
            for s in iter
            {
                self.push_str( s );
            }
        }
    }

    impl<A:Array<Item = u8>> Extend<String> for SmallString<A>
    {
        fn extend<I:IntoIterator<Item = String>>( &mut self, iter:I )
        {
            for s in iter
            {
                self.push_str( &s );
            }
        }
    }

    impl<A:Array<Item = u8>> fmt::Debug for SmallString<A>
    {
        #[inline] fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result { fmt::Debug::fmt( &**self, f ) }
    }

    impl<A:Array<Item = u8>> fmt::Display for SmallString<A>
    {
        #[inline] fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result { fmt::Display::fmt( &**self, f ) }
    }

    eq_str!( str );
    eq_str!( &'a str );
    eq_str!( String );
    eq_str!( Cow<'a, str> );
    
    impl<A:Array<Item = u8>> PartialEq<OsStr> for SmallString<A>
    {
        #[inline] fn eq( &self, rhs:&OsStr ) -> bool{ &self[..] == rhs }
        #[inline] fn ne( &self, rhs:&OsStr ) -> bool{ &self[..] != rhs }
    }
    
    impl<'a, A:Array<Item = u8>> PartialEq<&'a OsStr> for SmallString<A>
    {
        #[inline] fn eq( &self, rhs:&&OsStr ) -> bool { &self[..] == *rhs }
        #[inline] fn ne( &self, rhs:&&OsStr ) -> bool { &self[..] != *rhs }
    }
    
    impl<A:Array<Item = u8>> PartialEq<OsString> for SmallString<A>
    {
        #[inline] fn eq( &self, rhs:&OsString ) -> bool { &self[..] == rhs }
        #[inline] fn ne( &self, rhs:&OsString ) -> bool { &self[..] != rhs }
    }
    
    impl<'a, A:Array<Item = u8>> PartialEq<Cow<'a, OsStr>> for SmallString<A>
    {
        #[inline] fn eq( &self, rhs:&Cow<OsStr> ) -> bool { self[..] == **rhs }
        #[inline] fn ne( &self, rhs:&Cow<OsStr> ) -> bool { self[..] != **rhs }
    }

    impl<A, B> PartialEq<SmallString<B>> for SmallString<A> where
    A:Array<Item = u8>,
    B:Array<Item = u8>,
    {
        #[inline] fn eq( &self, rhs:&SmallString<B> ) -> bool { &self[..] == &rhs[..] }
        #[inline] fn ne( &self, rhs:&SmallString<B> ) -> bool { &self[..] != &rhs[..] }
    }

    impl<A:Array<Item = u8>> Eq for SmallString<A> {}

    impl<A:Array<Item = u8>> PartialOrd for SmallString<A>
    {
        #[inline] fn partial_cmp( &self, rhs:&SmallString<A> ) -> Option<Ordering> { self[..].partial_cmp( &rhs[..] ) }
    }

    impl<A:Array<Item = u8>> Ord for SmallString<A>
    {
        #[inline] fn cmp( &self, rhs:&SmallString<A> ) -> Ordering { self[..].cmp( &rhs[..] ) }
    }

    impl<A:Array<Item = u8>> Hash for SmallString<A>
    {
        #[inline] fn hash<H:Hasher>( &self, state:&mut H ){ self[..].hash( state ) }
    }
    /// A draining iterator for `SmallString`.
    pub struct Drain<'a>
    {
        iter:Chars<'a>,
    }

    impl<'a> Iterator for Drain<'a>
    {
        type Item = char;
        #[inline] fn next( &mut self ) -> Option<char> { self.iter.next() }
        #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) { self.iter.size_hint() }
    }

    impl<'a> DoubleEndedIterator for Drain<'a>
    {
        #[inline] fn next_back( &mut self ) -> Option<char> { self.iter.next_back() }
    }
    /// A possible error value when creating a `SmallString` from a byte array.
    #[derive( Debug )] pub struct FromUtf8Error<A:Array<Item = u8>>
    {
        buf:A,
        error:Utf8Error,
    }

    impl<A:Array<Item = u8>> FromUtf8Error<A>
    {
        /// Returns the slice of `[u8]` bytes that were attempted to convert to a `SmallString`.
        #[inline] pub fn as_bytes( &self ) -> &[u8]
        {
            unsafe 
            {
                let ptr = &self.buf as *const _ as *const u8;
                slice::from_raw_parts( ptr, A::size() ) 
            }
        }
        /// Returns the byte array that was attempted to convert into a `SmallString`.
        #[inline] pub fn into_buf( self ) -> A { self.buf }
        /// Returns the `Utf8Error` to get more details about the conversion failure.
        #[inline] pub fn utf8_error( &self ) -> Utf8Error { self.error }
    }

    impl<A:Array<Item = u8>> fmt::Display for FromUtf8Error<A>
    {
        #[inline] fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result { fmt::Display::fmt( &self.error, f ) }
    }
}
pub mod string { pub use std::string::{ * }; }
pub mod sync
{
    pub use std::sync::{ atomic as libatom, * };
    pub mod atomic
    {
        pub use std::sync::atomic::{ * };
    }
}
pub mod task { pub use std::task::{ * }; }
#[macro_use] pub mod thread { pub use std::thread::{ * }; }
pub mod terminal
{
    /*
    terminfo v0.9.0 */
    pub mod info
    {
        /// String capability expansion.
        #[macro_use] pub mod expand
        {
            use ::
            {
                io::{BufWriter, Write},
                terminal::info::
                {
                    error::{ self },
                    parser::expansion::{ * },
                },
                *,
            };
            /// Expand a parametrized string.
            #[macro_export] macro_rules! expand
            {
                ($value:expr) => ( $crate::terminal::info::expand!($value;) );

                ($value:expr => $context:expr) => ( $crate::terminal::info::expand!($value => $context;) );

                ($value:expr; $($item:expr),*) => 
                ( $crate::terminal::info::expand!($value => &mut ::default::Default::default(); $($item),*) );

                ($value:expr => $context:expr; $($item:expr),*) => 
                ({
                    let mut output = ::vec::Vec::new();
                    $crate::terminal::info::expand!(&mut output, $value => $context; $($item),*).map(|()| output)
                });

                ($output:expr, $value:expr) =>  ( $crate::terminal::info::expand!($output, $value;) );

                ($output:expr, $value:expr => $context:expr) => 
                ( $crate::terminal::info::expand!($output, $value => $context;) );

                ($output:expr, $value:expr; $($item:expr),*) => 
                ( $crate::terminal::info::expand!($output, $value => &mut ::default::Default::default(); $($item),*) );

                ($output:expr, $value:expr => $context:expr; $($item:expr),*) => 
                ({
                    use $crate::terminal::info::Expand;
                    $value.expand($output, &[$($item.into()),*], $context)
                })
            }

            macro_rules! from 
            {
                (number $ty:ty) =>
                {
                    impl From<$ty> for Parameter
                    {
                        fn from(value: $ty) -> Self { Parameter::Number(value as i32) }
                    }
                };

                (string ref $ty:ty) =>
                {
                    impl<'a> From<&'a $ty> for Parameter
                    {
                        fn from(value: &'a $ty) -> Self { Parameter::String(value.into()) }
                    }
                };

                (string $ty:ty) =>
                {
                    impl From<$ty> for Parameter
                    {
                        fn from(value: $ty) -> Self { Parameter::String(value.into()) }
                    }
                };
            }
            /// Trait for items that can be expanded.
            pub trait Expand
            {
                fn expand<W: Write>( &self, output:W, parameters: &[Parameter], context: &mut Context ) -> error::Result<()>;
            }
            /// An expansion parameter.
            #[derive( Eq, PartialEq, Clone, Debug )]
            pub enum Parameter
            {
                /// A number.
                Number(i32),
                /// An ASCII string.
                String(Vec<u8>),
            }

            impl Default for Parameter
            {
                fn default() -> Self { Parameter::Number(0) }
            }

            from!(number bool);
            from!(number u8);
            from!(number i8);
            from!(number u16);
            from!(number i16);
            from!(number u32);
            from!(number i32);

            from!(string String);
            from!(string ref str);
            from!(string Vec<u8>);
            from!(string ref [u8]);

            /// The expansion context.
            #[derive( Eq, PartialEq, Default, Debug )]
            pub struct Context
            {
                pub fixed: [Parameter; 26],
                pub dynamic: [Parameter; 26],
            }
            
            impl Expand for [u8]
            {
                fn expand<W: Write> ( &self, output:W, parameters: &[Parameter], context:&mut Context ) -> error::Result<()> 
                {
                    let mut output = BufWriter::new(output);
                    let mut input = self;
                    let mut params: [Parameter; 9] = Default::default();
                    let mut stack = Vec::new();
                    let mut conditional = false;
                    let mut incremented = false;

                    for (dest, source) in params.iter_mut().zip(parameters.iter())
                    {
                        *dest = source.clone();
                    }

                    macro_rules! next
                    {
                        () =>
                        {
                            match parse(input)
                            {
                                Ok((rest, item)) =>
                                {
                                    input = rest;
                                    item
                                }

                                Err(_) => return Err(error::Expand::Invalid.into()),
                            }
                        };
                    }

                    'main: while !input.is_empty()
                    {
                        match next!()
                        {
                            Item::Conditional(Conditional::If ) => { conditional = true; }
                            Item::Conditional(Conditional::End) if conditional => { conditional = false; }
                            Item::Conditional(Conditional::Then) if conditional => match stack.pop()
                            {
                                Some(Parameter::Number(0)) => 
                                {
                                    let mut level = 0;

                                    while !input.is_empty()
                                    {
                                        match next!()
                                        {
                                            Item::Conditional(Conditional::End) | Item::Conditional(Conditional::Else) 
                                            if level == 0 =>
                                            {
                                                continue 'main
                                            }

                                            Item::Conditional(Conditional::If) => level += 1,

                                            Item::Conditional(Conditional::End) => level -= 1,

                                            _ => (),
                                        }
                                    }

                                    return Err(error::Expand::Invalid.into());
                                }

                                Some(_) => (),

                                None => return Err(error::Expand::StackUnderflow.into()),
                            },
                            Item::Conditional(Conditional::Else) if conditional => 
                            {
                                let mut level = 0;

                                while !input.is_empty()
                                {
                                    match next!()
                                    {
                                        Item::Conditional(Conditional::End) if level == 0 => continue 'main,
                                        Item::Conditional(Conditional::If) => level += 1,
                                        Item::Conditional(Conditional::End) => level -= 1,
                                        _ => (),
                                    }
                                }

                                return Err(error::Expand::Invalid.into());
                            }
                            Item::Conditional(..) => return Err(error::Expand::Invalid.into()),
                            Item::String(value) => output.write_all(value)?,
                            Item::Constant(Constant::Character(ch) ) => { stack.push(Parameter::Number(ch as i32)); }
                            Item::Constant(Constant::Integer(value) ) => { stack.push(Parameter::Number(value)); }
                            Item::Variable(Variable::Length) => match stack.pop()
                            {
                                Some(Parameter::String( ref value) ) => { stack.push(Parameter::Number(value.len() as i32)); }

                                Some(_ ) => { return Err(error::Expand::TypeMismatch.into()); }

                                None => { return Err(error::Expand::StackUnderflow.into()); }
                            },
                            Item::Variable(Variable::Push(index) ) => { stack.push(params[index as usize].clone()); }
                            Item::Variable(Variable::Set(dynamic, index)) =>
                            {
                                if let Some(value) = stack.pop()
                                {
                                    if dynamic
                                    { context.dynamic[index as usize] = value.clone(); } 
                                    else { context.fixed[index as usize] = value.clone();  }
                                }
                                
                                else { return Err(error::Expand::StackUnderflow.into()); }
                            }
                            Item::Variable(Variable::Get(dynamic, index)) =>
                            {
                                if dynamic { stack.push(context.dynamic[index as usize].clone()); } 
                                else { stack.push(context.fixed[index as usize].clone()); }
                            }
                            Item::Operation(Operation::Increment) if !incremented =>
                            {
                                incremented = true;
                                if let (&Parameter::Number(x), &Parameter::Number(y)) = (&params[0], &params[1])
                                {
                                    params[0] = Parameter::Number(x + 1);
                                    params[1] = Parameter::Number(y + 1);
                                }
                                else { return Err(error::Expand::TypeMismatch.into()); }
                            }
                            Item::Operation(Operation::Increment) => (),
                            Item::Operation(Operation::Binary(operation)) => match (stack.pop(), stack.pop())
                            {
                                (Some(Parameter::Number(y)), Some(Parameter::Number(x))) =>
                                {
                                    stack.push(Parameter::Number(match operation
                                    {
                                        Binary::Add => x + y,
                                        Binary::Subtract => x - y,
                                        Binary::Multiply => x * y,
                                        Binary::Divide =>
                                        {
                                            if y != 0 { x / y }
                                            else { 0 }
                                        }

                                        Binary::Remainder =>
                                        {
                                            if y != 0 { x % y } 
                                            else { 0 }
                                        }

                                        Binary::AND => x & y,
                                        Binary::OR => x | y,
                                        Binary::XOR => x ^ y,

                                        Binary::And => (x != 0 && y != 0) as i32,
                                        Binary::Or => (x != 0 || y != 0) as i32,

                                        Binary::Equal => (x == y) as i32,
                                        Binary::Greater => (x > y) as i32,
                                        Binary::Lesser => (x < y) as i32,
                                    }))
                                }

                                (Some(_), Some(_)) => return Err(error::Expand::TypeMismatch.into()),

                                _ => return Err(error::Expand::StackUnderflow.into()),
                            },
                            Item::Operation(Operation::Unary(operation)) => match stack.pop()
                            {
                                Some(Parameter::Number(x)) => stack.push(Parameter::Number(match operation
                                {
                                    Unary::Not => (x != 0) as i32,
                                    Unary::NOT => !x,
                                })),

                                Some(_) => return Err(error::Expand::TypeMismatch.into()),

                                _ => return Err(error::Expand::StackUnderflow.into()),
                            },
                            Item::Print(p) =>
                            {
                                /// Calculate the length of a formatted number.
                                fn length(value: i32, p: &Print) -> usize
                                {
                                    let digits = match p.format
                                    {
                                        Format::Dec => (value as f32).abs().log(10.0).floor() as usize + 1,
                                        Format::Oct => (value as f32).abs().log(8.0).floor() as usize + 1,
                                        Format::Hex | Format::HEX => { (value as f32).abs().log(16.0).floor() as usize + 1 }
                                        _ => unreachable!(),
                                    };

                                    let mut length = digits;
                                    if p.flags.precision > digits { length += p.flags.precision - digits; }
                                    
                                    if p.format == Format::Dec && (value < 0 || p.flags.sign) { length += 1; }
                                    
                                    if p.flags.alternate
                                    {
                                        match p.format
                                        {
                                            Format::Hex | Format::HEX => length += 2,
                                            Format::Oct => length += 1,

                                            _ => (),
                                        }
                                    }

                                    length
                                }

                                macro_rules! w
                                {
                                    ($value:expr) => ( output.write_all($value)? );
                                    ($($item:tt)*) => ( write!(output, $($item)*)? );
                                }

                                macro_rules! f
                                {
                                    (by $length:expr) =>
                                    (
                                        for _ in 0 .. p.flags.width - $length
                                        {
                                            output.write_all(if p.flags.space { b" " } else { b"0" })?;
                                        }
                                    );

                                    (before by $length:expr) =>
                                    (
                                        if !p.flags.left && p.flags.width > $length { f!(by $length); }
                                    );

                                    (after by $length:expr) => 
                                    (
                                        if p.flags.left && p.flags.width > $length { f!(by $length); }
                                    );

                                    (before $value:expr) => 
                                    (
                                        f!(before by length($value, &p));
                                    );

                                    (after $value:expr) =>
                                    (
                                        f!(after by length($value, &p));
                                    );
                                }

                                match (p.format, stack.pop())
                                {
                                    (Format::Str, Some(Parameter::String( ref value))) =>
                                    {
                                        let mut value = &value[..];

                                        if p.flags.precision > 0 && p.flags.precision < value.len()
                                        { value = &value[..p.flags.precision]; }

                                        f!(before by value.len());
                                        w!(value);
                                        f!(after by value.len());
                                    }

                                    (Format::Chr, Some(Parameter::Number(value)) ) => { w!("{}", value as u8 as char) }

                                    (Format::Uni, Some(Parameter::Number(value))) => w!
                                    (
                                        "{}",
                                        char::from_u32(value as u32).ok_or(error::Expand::TypeMismatch)?
                                    ),

                                    (Format::Dec, Some(Parameter::Number(value))) => 
                                    {
                                        f!(before value);

                                        if p.flags.sign && value >= 0 { w!(b"+"); }

                                        w!("{:.1$}", value, p.flags.precision);
                                        f!(after value);
                                    }

                                    (Format::Oct, Some(Parameter::Number(value))) =>
                                    {
                                        f!(before value);

                                        if p.flags.alternate { w!(b"0"); }

                                        w!("{:.1$o}", value, p.flags.precision);
                                        f!(after value);
                                    }

                                    (Format::Hex, Some(Parameter::Number(value))) =>
                                    {
                                        f!(before value);

                                        if p.flags.alternate { w!(b"0x"); }

                                        w!("{:.1$x}", value, p.flags.precision);
                                        f!(after value);
                                    }

                                    (Format::HEX, Some(Parameter::Number(value))) =>
                                    {
                                        f!(before value);

                                        if p.flags.alternate { w!(b"0X"); }

                                        w!("{:.1$X}", value, p.flags.precision);
                                        f!(after value);
                                    }

                                    (_, Some(_)) => return Err(error::Expand::TypeMismatch.into()),

                                    (_, None) => return Err(error::Expand::StackUnderflow.into()),
                                }
                            }
                        }
                    }

                    Ok(())
                }
            }
        }
        pub use self::expand::{ Expand };

        mod error
        {
            use ::
            {
                *,
            };

            #[derive( Debug )]
            pub enum Error 
            {
                /// IO error.
                Io(io::Error),
                /// Database not found.
                NotFound,
                /// Parsing error.
                Parse,
                /// Expansion error.
                Expand(Expand),
            }

            #[derive( Eq, PartialEq, Copy, Clone, Debug )]
            pub enum Expand
            {
                /// The expansion string is invalid.
                Invalid,
                /// There was a type mismatch while expanding.
                TypeMismatch,
                /// The stack underflowed while expanding.
                StackUnderflow,
            }

            pub type Result<T> = result::Result<T, Error>;

            impl From<io::Error> for Error
            {
                fn from(value: io::Error) -> Self { Error::Io(value) }
            }

            impl From<Expand> for Error 
            {
                fn from(value: Expand) -> Self { Error::Expand(value) }
            }

            impl fmt::Display for Error
            {
                fn fmt(&self, f: &mut fmt::Formatter) -> ::std::result::Result<(), fmt::Error>
                {
                    match *self
                    {
                        Error::Io( ref err) => err.fmt(f),
                        Error::NotFound => f.write_str("Capability database not found."),
                        Error::Parse => f.write_str("Failed to parse capability database."),
                        Error::Expand( ref err) => match *err
                        {
                            Expand::Invalid => f.write_str("The expansion string is invalid."),
                            Expand::StackUnderflow => f.write_str("Not enough elements on the stack."),
                            Expand::TypeMismatch => f.write_str("Type mismatch."),
                        },
                    }
                }
            }

            impl error::Error for Error {}
        }
        pub use self::error::{ Error, Result };
        /// Parsers for various formats.
        mod parser
        {
            #[macro_use] mod util
            {
                use ::
                {
                    borrow::{ Cow },
                    is::{ digit },
                    nom::
                    {
                        branch::{ alt },
                        character::streaming::{ char, line_ending as eol },
                        combinator::{ eof },
                        IResult
                    },
                    *,
                };

                const NONE: u8 = 0b000000;
                const PRINT: u8 = 0b000001;
                const SPACE: u8 = 0b000010;
                const CONTROL: u8 = 0b000100;
                const PIPE: u8 = 0b001000;
                const COMMA: u8 = 0b010000;
                const EOL: u8 = 0b100000;
                
                static ASCII: [u8; 256] = 
                [
                    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, SPACE, EOL, NONE, NONE, EOL, NONE, NONE,
                    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                    PRINT | SPACE, PRINT, PRINT, PRINT | CONTROL, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, 
                    PRINT, PRINT | COMMA | CONTROL, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, 
                    PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT | CONTROL, PRINT, PRINT, PRINT, PRINT, 
                    PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT,
                    PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, 
                    PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, 
                    PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, PRINT, 
                    PRINT, PRINT, PRINT | PIPE, PRINT, PRINT, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
                ];

                #[inline(always )] pub fn is_ws(ch: u8) -> bool 
                { unsafe { ASCII.get_unchecked(ch as usize) & SPACE == SPACE } }

                #[inline(always )] pub fn is_eol(ch: u8) -> bool 
                { unsafe { ASCII.get_unchecked(ch as usize) & EOL == EOL } }

                #[inline(always )] pub fn is_printable_no_pipe(ch: u8) -> bool 
                { unsafe { ASCII.get_unchecked(ch as usize) & (PRINT | PIPE) == PRINT } }

                #[inline(always )] pub fn is_printable_no_comma(ch: u8) -> bool
                { unsafe { ASCII.get_unchecked(ch as usize) & (PRINT | COMMA) == PRINT } }

                #[inline(always )] pub fn is_printable_no_control(ch: u8) -> bool 
                { unsafe { ASCII.get_unchecked(ch as usize) & (PRINT | CONTROL) == PRINT } }

                pub fn ws(input: &[u8]) -> IResult<&[u8], char> { alt((char(' '), char('\t')))(input) }

                pub fn end(input: &[u8]) -> IResult<&[u8], &[u8]> { alt((eof, eol))(input) }

                #[inline] pub fn number(i: &[u8]) -> i32 
                {
                    let mut n: i32 = 0;

                    for &ch in i 
                    {
                        let d = (ch as i32).wrapping_sub(b'0' as i32);

                        if d <= 9 { n = n.saturating_mul(10).saturating_add(d); }
                    }

                    n
                }

                pub fn unescape(i: &[u8]) -> Cow<[u8]>
                {
                    fn escape<I: Iterator<Item = u8>>(output: &mut Vec<u8>, iter: &mut I)
                    {
                        match iter.next() 
                        {
                            None => (),
                            Some(b'a') => output.push(0x07),
                            Some(b'b') => output.push(0x08),
                            Some(b'E') | Some(b'e') => output.push(0x1B),
                            Some(b'f') => output.push(0x0C),
                            Some(b'l') | Some(b'n') => output.push(b'\n'),
                            Some(b'r') => output.push(b'\r'),
                            Some(b's') => output.push(b' '),
                            Some(b't') => output.push(b'\t'),
                            Some(b'^') => output.push(b'^'),
                            Some(b'\\') => output.push(b'\\'),
                            Some(b',') => output.push(b','),
                            Some(b':') => output.push(b':'),
                            Some(b'0') => output.push(0x00),
                            Some(a) if is::digit(a) => match (iter.next(), iter.next())
                            {
                                (Some(b), Some(c)) if is::digit(b) && is::digit(c) => 
                                {
                                    if let Ok(number) = u8::from_str_radix
                                    (unsafe { str::from_utf8_unchecked(&[a, b, c]) }, 8) { output.push(number); }
                                    
                                    else { output.extend(&[a, b, c]); }
                                }

                                (Some(b), None) => output.extend(&[b'\\', a, b]),
                                (None, None) => output.extend(&[b'\\', a]),
                                _ => unreachable!(),
                            },
                            Some(ch) => output.extend(&[b'\\', ch]),
                        }
                    }

                    fn control<I: Iterator<Item = u8>>(output: &mut Vec<u8>, iter: &mut I)
                    {
                        match iter.next() 
                        {
                            None => (),
                            Some(ch) if ch.is_ascii_uppercase() => output.push(ch - b'A' + 1),
                            Some(ch) if ch.is_ascii_lowercase() => output.push(ch - b'a' + 1),
                            Some(ch) => output.extend(&[b'^', ch]),
                        }
                    }

                    let mut chars = i.iter().cloned();
                    let mut offset = 0;

                    while let Some(ch) = chars.next()
                    {
                        if ch == b'\\' || ch == b'^'
                        {
                            let mut output = i[..offset].to_vec();

                            match ch
                            {
                                b'\\' => escape(&mut output, &mut chars),
                                b'^' => control(&mut output, &mut chars),
                                _ => unreachable!(),
                            }

                            while let Some(ch) = chars.next()
                            {
                                match ch
                                {
                                    b'\\' => escape(&mut output, &mut chars),
                                    b'^' => control(&mut output, &mut chars),
                                    ch => output.push(ch),
                                }
                            }

                            return Cow::Owned(output);
                        }

                        offset += 1;
                    }

                    Cow::Borrowed(i)
                }
            }

            pub mod compiled
            {
                use ::
                {
                    nom::
                    {
                        branch::alt,
                        bytes::streaming::{tag, take, take_until},
                        combinator::{complete, cond, map, map_opt, map_parser, opt},
                        multi::count,
                        number::streaming::{le_i16, le_i32},
                        IResult,
                    },
                    terminal::info::
                    {
                        capability::{ Value },
                        names::{ self },
                    },
                    *,
                };

                #[derive(Eq, PartialEq, Clone, Debug)]
                pub struct Database<'a> 
                {
                    names: &'a [u8],
                    standard: Standard<'a>,
                    extended: Option<Extended<'a>>,
                }

                impl<'a> From<Database<'a>> for Database<'a>
                {
                    fn from(source: Database<'a>) -> Self
                    {
                        let mut names = source
                        .names
                        .split(|&c| c == b'|')
                        .map(|s| unsafe { str::from_utf8_unchecked(s) })
                        .map(|s| s.trim())
                        .collect::<Vec<_>>();

                        let mut database = Database::new();
                        database.name(names.remove(0));
                        names.pop().map(|name| database.description(name));
                        database.aliases(names);

                        for (index, _) in source.standard.booleans.iter().enumerate().filter(|&(_, &value)| value)
                        {
                            if let Some(&name) = names::BOOLEAN.get(&(index as u16))
                            { database.raw(name, Value::True); }
                        }

                        for (index, &value) in source.standard.numbers.iter().enumerate().filter(|&(_, &n)| n >= 0)
                        {
                            if let Some(&name) = names::NUMBER.get(&(index as u16))
                            { database.raw(name, Value::Number(value)); }
                        }

                        for (index, &offset) in source.standard.strings.iter().enumerate().filter(|&(_, &n)| n >= 0)
                        {
                            if let Some(&name) = names::STRING.get(&(index as u16))
                            {
                                let string = &source.standard.table[offset as usize..];
                                let edge = string.iter().position(|&c| c == 0).unwrap();
                                database.raw(name, Value::String(Vec::from(&string[..edge])));
                            }
                        }

                        if let Some(extended) = source.extended
                        {
                            let names = extended
                            .table
                            .split(|&c| c == 0)
                            .skip(extended.strings.iter().cloned().filter(|&n| n >= 0).count())
                            .map(|s| unsafe { str::from_utf8_unchecked(s) })
                            .collect::<Vec<_>>();

                            for (index, _) in extended.booleans.iter().enumerate().filter(|&(_, &value)| value)
                            { database.raw(names[index], Value::True); }

                            for (index, &value) in extended.numbers.iter().enumerate().filter(|&(_, &n)| n >= 0)
                            { database.raw(names[extended.booleans.len() + index], Value::Number(value)); }

                            for (index, &offset) in extended.strings.iter().enumerate().filter(|&(_, &n)| n >= 0)
                            {
                                let string = &extended.table[offset as usize..];
                                let edge = string.iter().position(|&c| c == 0).unwrap();
                                database.raw
                                (
                                    names[extended.booleans.len() + extended.numbers.len() + index],
                                    Value::String(Vec::from(&string[..edge])),
                                );
                            }
                        }

                        database.build().unwrap()
                    }
                }

                #[derive(Eq, PartialEq, Clone, Debug)]
                pub struct Standard<'a> 
                {
                    booleans: Vec<bool>,
                    numbers: Vec<i32>,
                    strings: Vec<i32>,
                    table: &'a [u8],
                }

                #[derive(Eq, PartialEq, Clone, Debug)]
                pub struct Extended<'a>
                {
                    booleans: Vec<bool>,
                    numbers: Vec<i32>,
                    strings: Vec<i32>,
                    names: Vec<i32>,
                    table: &'a [u8],
                }

                fn bit_size(magic: &[u8]) -> usize
                {
                    match magic[1]
                    {
                        0x01 => 16,
                        0x02 => 32,
                        _ => unreachable!("unknown magic number"),
                    }
                }

                pub fn parse( input:&[u8] ) -> IResult<&[u8], Database>
                {
                    let ( this, magic) = alt((tag([0x1A, 0x01]), tag([0x1E, 0x02])))( this )?;
                    let (input, name_size) = size(input)?;
                    let (input, bool_count) = size(input)?;
                    let (input, num_count) = size(input)?;
                    let (input, string_count) = size(input)?;
                    let (input, table_size) = size(input)?;
                    let (input, names) = map_parser(take(name_size), take_until("\x00"))(input)?;
                    let (input, booleans) = count(boolean, bool_count)(input)?;
                    let (input, _) = cond((name_size + bool_count) % 2 != 0, take(1_usize))(input)?;
                    let (input, numbers) = count(|input| capability(input, bit_size(magic)), num_count)(input)?;
                    let (input, strings) = count(|input| capability(input, 16), string_count)(input)?;
                    let (input, table) = take(table_size)(input)?;
                    let (input, extended) = opt(complete(|input|
                    {
                        let (input, _) = cond(table_size % 2 != 0, take(1_usize))(input)?;
                        let (input, ext_bool_count) = size(input)?;
                        let (input, ext_num_count) = size(input)?;
                        let (input, ext_string_count) = size(input)?;
                        let (input, _ext_offset_count) = size(input)?;
                        let (input, ext_table_size) = size(input)?;
                        let (input, booleans) = count(boolean, ext_bool_count)(input)?;
                        let (input, _) = cond(ext_bool_count % 2 != 0, take(1_usize))(input)?;
                        let (input, numbers) = count(|input| capability(input, bit_size(magic)), ext_num_count)(input)?;
                        let (input, strings) = count(|input| capability(input, 16), ext_string_count)(input)?;
                        let (input, names) = count
                        (
                            |input| capability(input, 16), ext_bool_count + ext_num_count + ext_string_count,
                        )(input)?;

                        let (input, table) = take(ext_table_size)(input)?;
                        Ok((input, Extended { booleans, numbers, strings, names, table }))
                    }
                    ))(input)?;

                    Ok
                    ((
                        input,
                        Database { names, standard: Standard { booleans, numbers, strings, table }, extended },
                    ))
                }

                fn boolean(input: &[u8]) -> IResult<&[u8], bool> 
                { alt((map(tag([0]), |_| false), map(tag([1]), |_| true)))(input) }

                fn size(input: &[u8]) -> IResult<&[u8], usize>
                {
                    map_opt(le_i16, |n| match n
                    {
                        -1 => Some(0),
                        n if n >= 0 => Some(n as usize),
                        _ => None,
                    })(input)
                }

                fn capability(input: &[u8], bits: usize) -> IResult<&[u8], i32>
                {
                    alt
                    ((
                        map_opt
                        (
                            cond(bits == 16, map_opt(le_i16, |n| if n >= -2 { Some(n as i32) } else { None })),
                            |o| o,
                        ),
                        map_opt(cond(bits == 32, map_opt(le_i32, |n| if n >= -2 { Some(n) } else { None })), |o| o),
                    ))(input)
                }
            }

            pub mod expansion
            {
                use ::
                {
                    is::{ digit },
                    nom::
                    {
                        branch::alt,
                        bytes::complete,
                        bytes::streaming::{tag, take, take_while},
                        character::streaming::one_of,
                        combinator::{map, opt, value},
                        error::{make_error, ErrorKind},
                        IResult,
                    },
                    terminal::info::
                    {
                        parser::util::number,
                    },
                    *,
                };

                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub enum Item<'a>
                {
                    String(&'a [u8]),
                    Constant(Constant),
                    Variable(Variable),
                    Operation(Operation),
                    Conditional(Conditional),
                    Print(Print),
                }

                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub enum Constant
                {
                    Character(u8),
                    Integer(i32),
                }

                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub enum Variable
                {
                    Length,
                    Push(u8),
                    Set(bool, u8),
                    Get(bool, u8),
                }

                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub enum Operation
                {
                    Increment,
                    Unary(Unary),
                    Binary(Binary),
                }

                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub enum Unary
                {
                    Not,
                    NOT,
                }

                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub enum Binary
                {
                    Add,
                    Subtract,
                    Multiply,
                    Divide,
                    Remainder,

                    AND,
                    OR,
                    XOR,

                    And,
                    Or,

                    Equal,
                    Greater,
                    Lesser,
                }

                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub enum Conditional 
                {
                    If,
                    Then,
                    Else,
                    End,
                }

                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub struct Print
                {
                    pub flags: Flags,
                    pub format: Format,
                }

                #[derive(Eq, PartialEq, Copy, Clone, Debug)]
                pub enum Format
                {
                    Chr,
                    Uni,
                    Str,
                    Dec,
                    Oct,
                    Hex,
                    HEX,
                }

                #[derive(Eq, PartialEq, Copy, Clone, Default, Debug)]
                pub struct Flags
                {
                    pub width: usize,
                    pub precision: usize,

                    pub alternate: bool,
                    pub left: bool,
                    pub sign: bool,
                    pub space: bool,
                }

                pub fn parse(input: &[u8]) -> IResult<&[u8], Item>
                {
                    alt((expansion, string))(input)
                }

                fn string(input: &[u8]) -> IResult<&[u8], Item>
                {
                    map(complete::take_till(|b| b == b'%'), Item::String)(input)
                }

                fn expansion(input: &[u8]) -> IResult<&[u8], Item>
                {
                    let (input, _) = tag("%")(input)?;
                    let (input, item) = alt((percent, constant, variable, operation, conditional, print))(input)?;
                    Ok((input, item))
                }

                fn percent(input: &[u8]) -> IResult<&[u8], Item>
                {
                    value(Item::String(b"%"), tag("%"))(input)
                }

                fn constant(input: &[u8]) -> IResult<&[u8], Item>
                {
                    alt((constant_char, constant_integer))(input)
                }

                fn constant_char(input: &[u8]) -> IResult<&[u8], Item> 
                {
                    let (input, _) = tag("'")(input)?;
                    let (input, ch) = take(1_usize)(input)?;
                    let (input, _) = tag("'")(input)?;
                    Ok((input, Item::Constant(Constant::Character(ch[0]))))
                }

                fn constant_integer(input: &[u8]) -> IResult<&[u8], Item> 
                {
                    let (input, _) = tag("{")(input)?;
                    let (input, digit) = take_while(is_digit)(input)?;
                    let (input, _) = tag("}")(input)?;
                    Ok((input, Item::Constant(Constant::Integer(number(digit)))))
                }

                fn variable(input: &[u8]) -> IResult<&[u8], Item>
                {
                    let (input, c) = take(1_usize)(input)?;
                    match c
                    {
                        b"l" => Ok((input, Item::Variable(Variable::Length))),
                        b"p" => map(one_of("123456789"), |n| Item::Variable(Variable::Push(n as u8 - b'1')))(input),
                        b"P" => alt
                        ((
                            map(one_of("abcdefghijklmnopqrstuvwxyz"), |n| { Item::Variable(Variable::Set(true, n as u8 - b'a')) }),
                            map(one_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ"), |n| { Item::Variable(Variable::Set(false, n as u8 - b'A')) }),

                        ))(input),

                        b"g" => alt
                        ((
                            map(one_of("abcdefghijklmnopqrstuvwxyz"), |n| { Item::Variable(Variable::Get(true, n as u8 - b'a')) }),
                            map(one_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ"), |n| { Item::Variable(Variable::Get(false, n as u8 - b'A')) }),
                        ))(input),

                        _ => Err(nom::Err::Error(make_error(input, ErrorKind::Switch))),
                    }
                }

                fn operation(input: &[u8]) -> IResult<&[u8], Item>
                {
                    let (input, c) = take(1_usize)(input)?;
                    match c
                    {
                        b"+" => Ok((input, Item::Operation(Operation::Binary(Binary::Add)))),
                        b"-" => Ok((input, Item::Operation(Operation::Binary(Binary::Subtract)))),
                        b"*" => Ok((input, Item::Operation(Operation::Binary(Binary::Multiply)))),
                        b"/" => Ok((input, Item::Operation(Operation::Binary(Binary::Divide)))),
                        b"m" => Ok((input, Item::Operation(Operation::Binary(Binary::Remainder)))),
                        b"i" => Ok((input, Item::Operation(Operation::Increment))),

                        b"&" => Ok((input, Item::Operation(Operation::Binary(Binary::AND)))),
                        b"|" => Ok((input, Item::Operation(Operation::Binary(Binary::OR)))),
                        b"^" => Ok((input, Item::Operation(Operation::Binary(Binary::XOR)))),
                        b"~" => Ok((input, Item::Operation(Operation::Unary(Unary::NOT)))),

                        b"A" => Ok((input, Item::Operation(Operation::Binary(Binary::And)))),
                        b"O" => Ok((input, Item::Operation(Operation::Binary(Binary::Or)))),
                        b"!" => Ok((input, Item::Operation(Operation::Unary(Unary::Not)))),

                        b"=" => Ok((input, Item::Operation(Operation::Binary(Binary::Equal)))),
                        b">" => Ok((input, Item::Operation(Operation::Binary(Binary::Greater)))),
                        b"<" => Ok((input, Item::Operation(Operation::Binary(Binary::Lesser)))),

                        _ => Err(nom::Err::Error(make_error(input, ErrorKind::Switch))),
                    }
                }

                fn conditional(input: &[u8]) -> IResult<&[u8], Item>
                {
                    let (input, c) = take(1_usize)(input)?;
                    match c
                    {
                        b"?" => Ok((input, Item::Conditional(Conditional::If))),
                        b"t" => Ok((input, Item::Conditional(Conditional::Then))),
                        b"e" => Ok((input, Item::Conditional(Conditional::Else))),
                        b";" => Ok((input, Item::Conditional(Conditional::End))),

                        _ => Err(nom::Err::Error(make_error(input, ErrorKind::Switch))),
                    }
                }

                fn print(input: &[u8]) -> IResult<&[u8], Item> 
                {
                    let (input, _) = opt(tag(":"))(input)?;
                    let (input, flags) = take_while(is_flag)(input)?;
                    let (input, width) = opt(take_while(is_digit))(input)?;
                    let (input, precision) = opt(|input|
                    {
                        let (input, _) = tag(".")(input)?;
                        let (input, amount) = take_while(is_digit)(input)?;
                        Ok((input, amount))
                    })(input)?;

                    let (input, format) = one_of("doxXsc")(input)?;
                    Ok
                    ((
                        input,
                        Item::Print(Print 
                        {
                            flags: Flags
                            {
                                width: number(width.unwrap_or(b"0")) as usize,
                                precision: number(precision.unwrap_or(b"0")) as usize,

                                alternate: flags.contains(&b'#'),
                                left: flags.contains(&b'-'),
                                sign: flags.contains(&b'+'),
                                space: flags.contains(&b' '),
                            },

                            format: match format
                            {
                                'd' => Format::Dec,
                                'o' => Format::Oct,
                                'x' => Format::Hex,
                                'X' => Format::HEX,
                                's' => Format::Str,
                                'c' => Format::Chr,
                                'u' => Format::Uni,
                                _ => unreachable!(),
                            },
                        }),
                    ))
                }

                fn is_flag(i: u8) -> bool { i == b' ' || i == b'-' || i == b'+' || i == b'#' }
            }

            pub mod source
            {
                use ::
                {
                    borrow::{ Cow },
                    nom::
                    {
                        branch::alt,
                        bytes::streaming::{tag, take, take_until, take_while},
                        character::streaming::{line_ending as eol},
                        combinator::{complete, map, map_res, opt},
                        error::{make_error, ErrorKind},
                        sequence::terminated,
                        IResult,
                    },
                    terminal::info::
                    {
                        parser::
                        {
                            util::
                            {
                                unescape, end, is_eol, is_ws, ws,is_printable_no_comma, is_printable_no_control, is_printable_no_pipe,
                            },
                        },
                    },
                    *,
                };

                #[derive(Eq, PartialEq, Clone, Debug)]
                pub enum Item<'a>
                {
                    Comment(&'a str),
                    Definition { name: &'a str, aliases: Vec<&'a str>, description: &'a str },
                    True(&'a str),
                    Number(&'a str, i16),
                    String(&'a str, Cow<'a, [u8]>),
                    Disable(&'a str),
                }

                pub fn parse(input: &[u8]) -> IResult<&[u8], Item> 
                { alt((comment, definition, disable, entry))(input) }

                fn comment(input: &[u8]) -> IResult<&[u8], Item>
                {
                    let (input, _) = tag("#")(input)?;
                    let (input, content) = map_res(terminated(take_until("\n"), tag("\n")), str::from_utf8)(input)?;
                    let (input, _) = opt(complete(take_while(is_eol)))(input)?;
                    Ok((input, Item::Comment(content.trim())))
                }

                fn definition(input: &[u8]) -> IResult<&[u8], Item>
                {
                    unsafe
                    {
                        
                        let (input, name) =
                        map(take_while(is_printable_no_pipe), |n| str::from_utf8_unchecked(n) )(input)?;
                        let (input, _) = tag("|")(input)?;
                        let (input, content) =
                        map(take_while(is_printable_no_comma), |n| str::from_utf8_unchecked(n) )(input)?;
                        let (input, _) = tag(",")(input)?;
                        let (input, _) = take_while(is_ws)(input)?;
                        let (input, _) = eol(input)?;
                        let (input, _) = opt(complete(take_while(is_eol)))(input)?;
                        Ok((input,
                        {
                            let mut aliases = content.split(|c| c == '|').map(|n| n.trim()).collect::<Vec<_>>();
                            Item::Definition { name, description: aliases.pop().unwrap(), aliases }
                        }))
                    }
                }

                fn disable(input: &[u8]) -> IResult<&[u8], Item>
                {
                    let (input, _) = ws(input)?;
                    let (input, _) = take_while(is_ws)(input)?;
                    let (input, _) = tag("@")(input)?;
                    let (input, name) =
                    map(take_while(is_printable_no_control), |n| unsafe { str::from_utf8_unchecked(n) })
                    ( input )?;
                    
                    let (input, _) = tag(",")(input)?;
                    let (input, _) = take_while(is_ws)(input)?;
                    let (input, _) = end(input)?;
                    let (input, _) = opt(complete(take_while(is_eol)))(input)?;
                    Ok((input, Item::Disable(name)))
                }

                fn entry(input: &[u8]) -> IResult<&[u8], Item>
                {
                    let (input, _) = ws(input)?;
                    let (input, _) = take_while(is_ws)(input)?;
                    let (input, name) =
                    map(take_while(is_printable_no_control), |n| unsafe { str::from_utf8_unchecked(n) })
                    ( input )?;

                    let (input, c) = take(1_usize)(input)?;
                    let (input, value) = match c
                    {
                        b"," => (input, Item::True(name)),

                        b"#" => {
                            let (input, value) =
                                map(take_while(is_digit), |n| unsafe { str::from_utf8_unchecked(n) })(input)?;

                            let (input, _) = tag(",")(input)?;

                            (input, Item::Number(name, value.parse().unwrap()))
                        }

                        b"=" => {
                            let (input, value) = take_while(is_printable_no_comma)(input)?;

                            let (input, _) = tag(",")(input)?;

                            (input, Item::String(name, unescape(value)))
                        }

                        _ => Err(nom::Err::Error(make_error(input, ErrorKind::Switch)))?,
                    };

                    let (input, _) = take_while(is_ws)(input)?;
                    let (input, _) = end(input)?;
                    let (input, _) = opt(complete(take_while(is_eol)))(input)?;

                    Ok((input, value))
                }
            }
        }
        /// Standard terminal capabilities.
        pub mod capability
        {
            use ::
            {
                borrow::{ Cow },
                io::{ Write },
                terminal::info::
                {
                    error::{ self },
                    expand::{ Context, Expand, Parameter },
                },
                *,
            };

            macro_rules! from 
            {
                (number $ty:ty) =>
                {
                    impl From<$ty> for Value
                    {
                        fn from(value: $ty) -> Self { Value::Number(value as i32) }
                    }
                };

                (string ref $ty:ty) =>
                {
                    impl<'a> From<&'a $ty> for Value
                    {
                        fn from(value: &'a $ty) -> Self { Value::String(value.into()) }
                    }
                };

                (string $ty:ty) =>
                {
                    impl From<$ty> for Value
                    {
                        fn from(value: $ty) -> Self { Value::String(value.into()) }
                    }
                };
            }
            /// A trait for any object that will represent a terminal capability.
            pub trait Capability<'a>: Sized
            {
                /// Returns the name of the capability in its long form.
                fn name() -> &'static str;
                /// Parse the capability from its raw value.
                fn from(value: Option<&'a Value>) -> Option<Self>;
                /// Convert the capability into its raw value.
                fn into( self ) -> Option<Value>;
            }

            /// Possible value types for capabilities.
            #[derive( Eq, PartialEq, Clone, Debug )]
            pub enum Value 
            {
                /// A boolean.
                True,
                /// A number.
                Number(i32),
                /// An ASCII string requiring expansion.
                String(Vec<u8>),
            }
            /// Expansion helper struct.
            #[derive( Debug )]
            pub struct Expansion<'a, T: 'a + AsRef<[u8]>>
            {
                string: &'a T,
                params: [Parameter; 9],
                context: Option<&'a mut Context>,
            }

            impl<'a, T: AsRef<[u8]>> Expansion<'a, T>
            {
                /// Expand using the given context.
                pub fn with<'c: 'a>(mut self, context: &'c mut Context) -> Self
                {
                    self.context = Some(context);
                    self
                }
                /// Expand to the given output.
                pub fn to<W: Write>(self, output: W) -> error::Result<()> 
                { self.string.as_ref().expand( output, &self.params, self.context.unwrap_or(&mut Default::default()) ) }
                /// Expand into a vector.
                pub fn to_vec( self ) -> error::Result<Vec<u8>> 
                {
                    let mut result = Vec::with_capacity(self.string.as_ref().len());
                    self.to(&mut result)?;
                    Ok(result)
                }
            }

            impl From<()> for Value 
            {
                fn from(_: ()) -> Self { Value::True }
            }

            from!(number u8);
            from!(number i8);
            from!(number u16);
            from!(number i16);
            from!(number u32);
            from!(number i32);
            from!(string String);
            from!(string ref str);
            from!(string Vec<u8>);
            from!(string ref [u8]);

            macro_rules! define
            {
                (boolean $ident:ident => $capability:expr) =>
                (
                    #[derive( Eq, PartialEq, Copy, Clone, Debug )]
                    pub struct $ident(pub bool);

                    impl<'a> Capability<'a> for $ident
                    {
                        #[inline] fn name() -> &'static str { $capability }

                        #[inline] fn from(value: Option<&Value>) -> Option<Self>
                        {
                            if let Some(&Value::True) = value { Some($ident(true)) }                            
                            else { Some($ident(false)) }
                        }

                        #[inline] fn into( self ) -> Option<Value>
                        {
                            if self.0 { Some(Value::True) }

                            else { None }
                        }
                    }

                    impl From<$ident> for bool
                    {
                        fn from(cap: $ident) -> Self { cap.0 }
                    }
                );

                (number $ident:ident => $capability:expr) =>
                (
                    #[derive( Eq, PartialEq, Copy, Clone, Debug )]
                    pub struct $ident(pub i32);

                    impl<'a> Capability<'a> for $ident
                    {
                        #[inline] fn name() -> &'static str { $capability }

                        #[inline] fn from(value: Option<&Value>) -> Option<Self>
                        {
                            if let Some(&Value::Number(value)) = value { Some($ident(value)) }
                            else { None }
                        }

                        #[inline] fn into( self ) -> Option<Value> { Some(Value::Number(self.0)) }
                    }

                    impl From<$ident> for i32 { fn from(cap: $ident) -> Self { cap.0 } }
                );

                (string define $ident:ident => $capability:expr) =>
                (
                    #[derive( Eq, PartialEq, Clone, Debug )]
                    pub struct $ident<'a>(Cow<'a, [u8]>);

                    impl<'a> Capability<'a> for $ident<'a>
                    {
                        #[inline] fn name() -> &'static str { $capability }

                        #[inline] fn from(value: Option<&'a Value>) -> Option<$ident<'a>>
                        {
                            if let Some(&Value::String( ref value)) = value { Some($ident(Cow::Borrowed(value))) }                            
                            else { None }
                        }

                        #[inline] fn into( self ) -> Option<Value>
                        {
                            Some(Value::String(match self.0
                            {
                                Cow::Borrowed(value) => value.into(),
                                Cow::Owned(value) => value
                            }))
                        }
                    }

                    impl<'a, T: AsRef<&'a [u8]>> From<T> for $ident<'a>
                    {
                        #[inline] fn from(value: T) -> Self { $ident(Cow::Borrowed(value.as_ref())) }
                    }

                    impl<'a> AsRef<[u8]> for $ident<'a>
                    {
                        #[inline] fn as_ref(&self) -> &[u8] { &self.0 }
                    }

                    impl<'a> $ident<'a>
                    {
                        /// Begin expanding the capability.
                        #[inline] pub fn expand(&self) -> Expansion<$ident>
                        {
                            Expansion
                            {
                                string:  self,
                                params:  Default::default(),
                                context: None,
                            }
                        }
                    }
                );

                (string $ident:ident => $capability:expr) => ( define!(string define $ident => $capability); );

                (string $ident:ident => $capability:expr; $($rest:tt)+) =>
                (
                    define!(string define $ident => $capability);
                    define!(string parameters $ident; $($rest)+);
                    define!(string builder $ident; 0, $($rest)+, );
                );

                (string parameters $ident:ident; $($name:ident : $ty:ty),+) =>
                (
                    impl<'a> Expansion<'a, $ident<'a>> 
                    {
                        /// Pass all expansion parameters at once.
                        #[inline] pub fn parameters(mut self, $($name: $ty),*) -> Self
                        {
                            let mut index = 0;
                            $({
                                self.params[index]  = $name.into();
                                index              += 1;
                            })*;

                            self
                        }
                    }
                );

                (string builder $ident:ident; $index:expr, ) => ();

                (string builder $ident:ident; $index:expr, $name:ident : u8, $($rest:tt)*) =>
                (
                    define!(string builder direct $ident; $index, $name : u8);
                    define!(string builder $ident; $index + 1, $($rest)*);
                );

                (string builder $ident:ident; $index:expr, $name:ident : i8, $($rest:tt)*) =>
                (
                    define!(string builder direct $ident; $index, $name : i8);
                    define!(string builder $ident; $index + 1, $($rest)*);
                );

                (string builder $ident:ident; $index:expr, $name:ident : u16, $($rest:tt)*) =>
                (
                    define!(string builder direct $ident; $index, $name : u16);
                    define!(string builder $ident; $index + 1, $($rest)*);
                );

                (string builder $ident:ident; $index:expr, $name:ident : i16 $($rest:tt)*) =>
                (
                    define!(string builder direct $ident; $index, $name : i16);
                    define!(string builder $ident; $index + 1, $($rest)*);
                );

                (string builder $ident:ident; $index:expr, $name:ident : u32, $($rest:tt)*) =>
                (
                    define!(string builder direct $ident; $index, $name : u32);
                    define!(string builder $ident; $index + 1, $($rest)*);
                );

                (string builder $ident:ident; $index:expr, $name:ident : i32, $($rest:tt)*) =>
                (
                    define!(string builder direct $ident; $index, $name : i32);
                    define!(string builder $ident; $index + 1, $($rest)*);
                );

                (string builder $ident:ident; $index:expr, $name:ident : $ty:ty, $($rest:tt)*) =>
                (
                    define!(string builder into $ident; $index, $name : $ty);
                    define!(string builder $ident; $index + 1, $($rest)*);
                );

                (string builder direct $ident:ident; $index:expr, $name:ident : $ty:ty) =>
                (
                    impl<'a> Expansion<'a, $ident<'a>>
                    {
                        /// Set the given parameter.
                        #[inline] pub fn $name(mut self, value: $ty) -> Self
                        {
                            self.params[$index] = value.into();
                            self
                        }
                    }
                );

                (string builder into $ident:ident; $index:expr, $name:ident : $ty:ty) =>
                (
                    impl<'a> Expansion<'a, $ident<'a>>
                    {
                        /// Set the given parameter.
                        #[inline] pub fn $name<T: Into<$ty>>(mut self, value: T) -> Self
                        {
                            self.params[$index] = value.into().into();
                            self
                        }
                    }
                );
            }

            define!(boolean AutoLeftMargin => "auto_left_margin");
            define!(boolean AutoRightMargin => "auto_right_margin");
            define!(boolean NoEscCtlc => "no_esc_ctlc");
            define!(boolean CeolStandoutGlitch => "ceol_standout_glitch");
            define!(boolean EatNewlineGlitch => "eat_newline_glitch");
            define!(boolean EraseOverstrike => "erase_overstrike");
            define!(boolean GenericType => "generic_type");
            define!(boolean HardCopy => "hard_copy");
            define!(boolean HasMetaKey => "has_meta_key");
            define!(boolean HasStatusLine => "has_status_line");
            define!(boolean InsertNullGlitch => "insert_null_glitch");
            define!(boolean MemoryAbove => "memory_above");
            define!(boolean MemoryBelow => "memory_below");
            define!(boolean MoveInsertMode => "move_insert_mode");
            define!(boolean MoveStandoutMode => "move_standout_mode");
            define!(boolean OverStrike => "over_strike");
            define!(boolean StatusLineEscOk => "status_line_esc_ok");
            define!(boolean DestTabsMagicSmso => "dest_tabs_magic_smso");
            define!(boolean TildeGlitch => "tilde_glitch");
            define!(boolean TransparentUnderline => "transparent_underline");
            define!(boolean XonXoff => "xon_xoff");
            define!(boolean NeedsXonXoff => "needs_xon_xoff");
            define!(boolean PrtrSilent => "prtr_silent");
            define!(boolean HardCursor => "hard_cursor");
            define!(boolean NonRevRmcup => "non_rev_rmcup");
            define!(boolean NoPadChar => "no_pad_char");
            define!(boolean NonDestScrollRegion => "non_dest_scroll_region");
            define!(boolean CanChange => "can_change");
            define!(boolean BackColorErase => "back_color_erase");
            define!(boolean HueLightnessSaturation => "hue_lightness_saturation");
            define!(boolean ColAddrGlitch => "col_addr_glitch");
            define!(boolean CrCancelsMicroMode => "cr_cancels_micro_mode");
            define!(boolean HasPrintWheel => "has_print_wheel");
            define!(boolean RowAddrGlitch => "row_addr_glitch");
            define!(boolean SemiAutoRightMargin => "semi_auto_right_margin");
            define!(boolean CpiChangesRes => "cpi_changes_res");
            define!(boolean LpiChangesRes => "lpi_changes_res");
            define!(boolean BackspacesWithBs => "backspaces_with_bs");
            define!(boolean CrtNoScrolling => "crt_no_scrolling");
            define!(boolean NoCorrectlyWorkingCr => "no_correctly_working_cr");
            define!(boolean GnuHasMetaKey => "gnu_has_meta_key");
            define!(boolean LinefeedIsNewline => "linefeed_is_newline");
            define!(boolean HasHardwareTabs => "has_hardware_tabs");
            define!(boolean ReturnDoesClrEol => "return_does_clr_eol");
            define!(number Columns => "columns");
            define!(number InitTabs => "init_tabs");
            define!(number Lines => "lines");
            define!(number LinesOfMemory => "lines_of_memory");
            define!(number MagicCookieGlitch => "magic_cookie_glitch");
            define!(number PaddingBaudRate => "padding_baud_rate");
            define!(number VirtualTerminal => "virtual_terminal");
            define!(number WidthStatusLine => "width_status_line");
            define!(number NumLabels => "num_labels");
            define!(number LabelHeight => "label_height");
            define!(number LabelWidth => "label_width");
            define!(number MaxAttributes => "max_attributes");
            define!(number MaximumWindows => "maximum_windows");
            define!(number MaxColors => "max_colors");
            define!(number MaxPairs => "max_pairs");
            define!(number NoColorVideo => "no_color_video");
            define!(number BufferCapacity => "buffer_capacity");
            define!(number DotVertSpacing => "dot_vert_spacing");
            define!(number DotHorzSpacing => "dot_horz_spacing");
            define!(number MaxMicroAddress => "max_micro_address");
            define!(number MaxMicroJump => "max_micro_jump");
            define!(number MicroColSize => "micro_col_size");
            define!(number MicroLineSize => "micro_line_size");
            define!(number NumberOfPins => "number_of_pins");
            define!(number OutputResChar => "output_res_char");
            define!(number OutputResLine => "output_res_line");
            define!(number OutputResHorzInch => "output_res_horz_inch");
            define!(number OutputResVertInch => "output_res_vert_inch");
            define!(number PrintRate => "print_rate");
            define!(number WideCharSize => "wide_char_size");
            define!(number Buttons => "buttons");
            define!(number BitImageEntwining => "bit_image_entwining");
            define!(number BitImageType => "bit_image_type");
            define!(number MagicCookieGlitchUl => "magic_cookie_glitch_ul");
            define!(number CarriageReturnDelay => "carriage_return_delay");
            define!(number NewLineDelay => "new_line_delay");
            define!(number BackspaceDelay => "backspace_delay");
            define!(number HorizontalTabDelay => "horizontal_tab_delay");
            define!(number NumberOfFunctionKeys => "number_of_function_keys");
            define!(string BackTab => "back_tab");
            define!(string Bell => "bell");
            define!(string CarriageReturn => "carriage_return");
            define!(string ClearAllTabs => "clear_all_tabs");
            define!(string ClearScreen => "clear_screen");
            define!(string ClrEol => "clr_eol");
            define!(string ClrEos => "clr_eos");
            define!(string CommandCharacter => "command_character");
            define!(string CursorDown => "cursor_down");
            define!(string CursorHome => "cursor_home");
            define!(string CursorInvisible => "cursor_invisible");
            define!(string CursorLeft => "cursor_left");
            define!(string CursorMemAddress => "cursor_mem_address");
            define!(string CursorNormal => "cursor_normal");
            define!(string CursorRight => "cursor_right");
            define!(string CursorToLl => "cursor_to_ll");
            define!(string CursorUp => "cursor_up");
            define!(string CursorVisible => "cursor_visible");
            define!(string DeleteCharacter => "delete_character");
            define!(string DeleteLine => "delete_line");
            define!(string DisStatusLine => "dis_status_line");
            define!(string DownHalfLine => "down_half_line");
            define!(string EnterAltCharsetMode => "enter_alt_charset_mode");
            define!(string EnterBlinkMode => "enter_blink_mode");
            define!(string EnterBoldMode => "enter_bold_mode");
            define!(string EnterCaMode => "enter_ca_mode");
            define!(string EnterDeleteMode => "enter_delete_mode");
            define!(string EnterDimMode => "enter_dim_mode");
            define!(string EnterInsertMode => "enter_insert_mode");
            define!(string EnterSecureMode => "enter_secure_mode");
            define!(string EnterProtectedMode => "enter_protected_mode");
            define!(string EnterReverseMode => "enter_reverse_mode");
            define!(string EnterStandoutMode => "enter_standout_mode");
            define!(string EnterUnderlineMode => "enter_underline_mode");
            define!(string ExitAltCharsetMode => "exit_alt_charset_mode");
            define!(string ExitAttributeMode => "exit_attribute_mode");
            define!(string ExitCaMode => "exit_ca_mode");
            define!(string ExitDeleteMode => "exit_delete_mode");
            define!(string ExitInsertMode => "exit_insert_mode");
            define!(string ExitStandoutMode => "exit_standout_mode");
            define!(string ExitUnderlineMode => "exit_underline_mode");
            define!(string FlashScreen => "flash_screen");
            define!(string FormFeed => "form_feed");
            define!(string FromStatusLine => "from_status_line");
            define!(string Init1String => "init_1string");
            define!(string Init2String => "init_2string");
            define!(string Init3String => "init_3string");
            define!(string InitFile => "init_file");
            define!(string InsertCharacter => "insert_character");
            define!(string InsertLine => "insert_line");
            define!(string InsertPadding => "insert_padding");
            define!(string KeyBackspace => "key_backspace");
            define!(string KeyCATab => "key_catab");
            define!(string KeyClear => "key_clear");
            define!(string KeyCTab => "key_ctab");
            define!(string KeyDc => "key_dc");
            define!(string KeyDl => "key_dl");
            define!(string KeyDown => "key_down");
            define!(string KeyEic => "key_eic");
            define!(string KeyEol => "key_eol");
            define!(string KeyEos => "key_eos");
            define!(string KeyF0 => "key_f0");
            define!(string KeyF1 => "key_f1");
            define!(string KeyF10 => "key_f10");
            define!(string KeyF2 => "key_f2");
            define!(string KeyF3 => "key_f3");
            define!(string KeyF4 => "key_f4");
            define!(string KeyF5 => "key_f5");
            define!(string KeyF6 => "key_f6");
            define!(string KeyF7 => "key_f7");
            define!(string KeyF8 => "key_f8");
            define!(string KeyF9 => "key_f9");
            define!(string KeyHome => "key_home");
            define!(string KeyIc => "key_ic");
            define!(string KeyIl => "key_il");
            define!(string KeyLeft => "key_left");
            define!(string KeyLl => "key_ll");
            define!(string KeyNPage => "key_npage");
            define!(string KeyPPage => "key_ppage");
            define!(string KeyRight => "key_right");
            define!(string KeySf => "key_sf");
            define!(string KeySr => "key_sr");
            define!(string KeySTab => "key_stab");
            define!(string KeyUp => "key_up");
            define!(string KeypadLocal => "keypad_local");
            define!(string KeypadXmit => "keypad_xmit");
            define!(string LabF0 => "lab_f0");
            define!(string LabF1 => "lab_f1");
            define!(string LabF10 => "lab_f10");
            define!(string LabF2 => "lab_f2");
            define!(string LabF3 => "lab_f3");
            define!(string LabF4 => "lab_f4");
            define!(string LabF5 => "lab_f5");
            define!(string LabF6 => "lab_f6");
            define!(string LabF7 => "lab_f7");
            define!(string LabF8 => "lab_f8");
            define!(string LabF9 => "lab_f9");
            define!(string MetaOff => "meta_off");
            define!(string MetaOn => "meta_on");
            define!(string Newline => "newline");
            define!(string PadChar => "pad_char");
            define!(string PKeyKey => "pkey_key");
            define!(string PKeyLocal => "pkey_local");
            define!(string PKeyXmit => "pkey_xmit");
            define!(string PrintScreen => "print_screen");
            define!(string PrtrOff => "prtr_off");
            define!(string PrtrOn => "prtr_on");
            define!(string RepeatChar => "repeat_char");
            define!(string Reset1String => "reset_1string");
            define!(string Reset2String => "reset_2string");
            define!(string Reset3String => "reset_3string");
            define!(string ResetFile => "reset_file");
            define!(string RestoreCursor => "restore_cursor");
            define!(string SaveCursor => "save_cursor");
            define!(string ScrollForward => "scroll_forward");
            define!(string ScrollReverse => "scroll_reverse");
            define!(string SetTab => "set_tab");
            define!(string SetWindow => "set_window");
            define!(string Tab => "tab");
            define!(string ToStatusLine => "to_status_line");
            define!(string UnderlineChar => "underline_char");
            define!(string UpHalfLine => "up_half_line");
            define!(string InitProg => "init_prog");
            define!(string KeyA1 => "key_a1");
            define!(string KeyA3 => "key_a3");
            define!(string KeyB2 => "key_b2");
            define!(string KeyC1 => "key_c1");
            define!(string KeyC3 => "key_c3");
            define!(string PrtrNon => "prtr_non");
            define!(string CharPadding => "char_padding");
            define!(string AcsChars => "acs_chars");
            define!(string PlabNorm => "plab_norm");
            define!(string KeyBTab => "key_btab");
            define!(string EnterXonMode => "enter_xon_mode");
            define!(string ExitXonMode => "exit_xon_mode");
            define!(string EnterAmMode => "enter_am_mode");
            define!(string ExitAmMode => "exit_am_mode");
            define!(string XonCharacter => "xon_character");
            define!(string XoffCharacter => "xoff_character");
            define!(string EnaAcs => "ena_acs");
            define!(string LabelOn => "label_on");
            define!(string LabelOff => "label_off");
            define!(string KeyBeg => "key_beg");
            define!(string KeyCancel => "key_cancel");
            define!(string KeyClose => "key_close");
            define!(string KeyCommand => "key_command");
            define!(string KeyCopy => "key_copy");
            define!(string KeyCreate => "key_create");
            define!(string KeyEnd => "key_end");
            define!(string KeyEnter => "key_enter");
            define!(string KeyExit => "key_exit");
            define!(string KeyFind => "key_find");
            define!(string KeyHelp => "key_help");
            define!(string KeyMark => "key_mark");
            define!(string KeyMessage => "key_message");
            define!(string KeyMove => "key_move");
            define!(string KeyNext => "key_next");
            define!(string KeyOpen => "key_open");
            define!(string KeyOptions => "key_options");
            define!(string KeyPrevious => "key_previous");
            define!(string KeyPrint => "key_print");
            define!(string KeyRedo => "key_redo");
            define!(string KeyReference => "key_reference");
            define!(string KeyRefresh => "key_refresh");
            define!(string KeyReplace => "key_replace");
            define!(string KeyRestart => "key_restart");
            define!(string KeyResume => "key_resume");
            define!(string KeySave => "key_save");
            define!(string KeySuspend => "key_suspend");
            define!(string KeyUndo => "key_undo");
            define!(string KeySBeg => "key_sbeg");
            define!(string KeySCancel => "key_scancel");
            define!(string KeySCommand => "key_scommand");
            define!(string KeySCopy => "key_scopy");
            define!(string KeySCreate => "key_screate");
            define!(string KeySDc => "key_sdc");
            define!(string KeySDl => "key_sdl");
            define!(string KeySelect => "key_select");
            define!(string KeySEnd => "key_send");
            define!(string KeySEol => "key_seol");
            define!(string KeySExit => "key_sexit");
            define!(string KeySFind => "key_sfind");
            define!(string KeySHelp => "key_shelp");
            define!(string KeySHome => "key_shome");
            define!(string KeySIc => "key_sic");
            define!(string KeySLeft => "key_sleft");
            define!(string KeySMessage => "key_smessage");
            define!(string KeySMove => "key_smove");
            define!(string KeySNext => "key_snext");
            define!(string KeySOptions => "key_soptions");
            define!(string KeySPrevious => "key_sprevious");
            define!(string KeySPrint => "key_sprint");
            define!(string KeySRedo => "key_sredo");
            define!(string KeySReplace => "key_sreplace");
            define!(string KeySRight => "key_sright");
            define!(string KeySRsume => "key_srsume");
            define!(string KeySSave => "key_ssave");
            define!(string KeySSuspend => "key_ssuspend");
            define!(string KeySUndo => "key_sundo");
            define!(string ReqForInput => "req_for_input");
            define!(string KeyF11 => "key_f11");
            define!(string KeyF12 => "key_f12");
            define!(string KeyF13 => "key_f13");
            define!(string KeyF14 => "key_f14");
            define!(string KeyF15 => "key_f15");
            define!(string KeyF16 => "key_f16");
            define!(string KeyF17 => "key_f17");
            define!(string KeyF18 => "key_f18");
            define!(string KeyF19 => "key_f19");
            define!(string KeyF20 => "key_f20");
            define!(string KeyF21 => "key_f21");
            define!(string KeyF22 => "key_f22");
            define!(string KeyF23 => "key_f23");
            define!(string KeyF24 => "key_f24");
            define!(string KeyF25 => "key_f25");
            define!(string KeyF26 => "key_f26");
            define!(string KeyF27 => "key_f27");
            define!(string KeyF28 => "key_f28");
            define!(string KeyF29 => "key_f29");
            define!(string KeyF30 => "key_f30");
            define!(string KeyF31 => "key_f31");
            define!(string KeyF32 => "key_f32");
            define!(string KeyF33 => "key_f33");
            define!(string KeyF34 => "key_f34");
            define!(string KeyF35 => "key_f35");
            define!(string KeyF36 => "key_f36");
            define!(string KeyF37 => "key_f37");
            define!(string KeyF38 => "key_f38");
            define!(string KeyF39 => "key_f39");
            define!(string KeyF40 => "key_f40");
            define!(string KeyF41 => "key_f41");
            define!(string KeyF42 => "key_f42");
            define!(string KeyF43 => "key_f43");
            define!(string KeyF44 => "key_f44");
            define!(string KeyF45 => "key_f45");
            define!(string KeyF46 => "key_f46");
            define!(string KeyF47 => "key_f47");
            define!(string KeyF48 => "key_f48");
            define!(string KeyF49 => "key_f49");
            define!(string KeyF50 => "key_f50");
            define!(string KeyF51 => "key_f51");
            define!(string KeyF52 => "key_f52");
            define!(string KeyF53 => "key_f53");
            define!(string KeyF54 => "key_f54");
            define!(string KeyF55 => "key_f55");
            define!(string KeyF56 => "key_f56");
            define!(string KeyF57 => "key_f57");
            define!(string KeyF58 => "key_f58");
            define!(string KeyF59 => "key_f59");
            define!(string KeyF60 => "key_f60");
            define!(string KeyF61 => "key_f61");
            define!(string KeyF62 => "key_f62");
            define!(string KeyF63 => "key_f63");
            define!(string ClrBol => "clr_bol");
            define!(string ClearMargins => "clear_margins");
            define!(string SetLeftMargin => "set_left_margin");
            define!(string SetRightMargin => "set_right_margin");
            define!(string LabelFormat => "label_format");
            define!(string SetClock => "set_clock");
            define!(string DisplayClock => "display_clock");
            define!(string RemoveClock => "remove_clock");
            define!(string CreateWindow => "create_window");
            define!(string GotoWindow => "goto_window");
            define!(string Hangup => "hangup");
            define!(string DialPhone => "dial_phone");
            define!(string QuickDial => "quick_dial");
            define!(string Tone => "tone");
            define!(string Pulse => "pulse");
            define!(string FlashHook => "flash_hook");
            define!(string FixedPause => "fixed_pause");
            define!(string WaitTone => "wait_tone");
            define!(string User0 => "user0");
            define!(string User1 => "user1");
            define!(string User2 => "user2");
            define!(string User3 => "user3");
            define!(string User4 => "user4");
            define!(string User5 => "user5");
            define!(string User6 => "user6");
            define!(string User7 => "user7");
            define!(string User8 => "user8");
            define!(string User9 => "user9");
            define!(string OrigPair => "orig_pair");
            define!(string OrigColors => "orig_colors");
            define!(string InitializeColor => "initialize_color");
            define!(string InitializePair => "initialize_pair");
            define!(string SetColorPair => "set_color_pair");
            define!(string ChangeCharPitch => "change_char_pitch");
            define!(string ChangeLinePitch => "change_line_pitch");
            define!(string ChangeResHorz => "change_res_horz");
            define!(string ChangeResVert => "change_res_vert");
            define!(string DefineChar => "define_char");
            define!(string EnterDoublewideMode => "enter_doublewide_mode");
            define!(string EnterDraftQuality => "enter_draft_quality");
            define!(string EnterItalicsMode => "enter_italics_mode");
            define!(string EnterLeftwardMode => "enter_leftward_mode");
            define!(string EnterMicroMode => "enter_micro_mode");
            define!(string EnterNearLetterQuality => "enter_near_letter_quality");
            define!(string EnterNormalQuality => "enter_normal_quality");
            define!(string EnterShadowMode => "enter_shadow_mode");
            define!(string EnterSubscriptMode => "enter_subscript_mode");
            define!(string EnterSuperscriptMode => "enter_superscript_mode");
            define!(string EnterUpwardMode => "enter_upward_mode");
            define!(string ExitDoublewideMode => "exit_doublewide_mode");
            define!(string ExitItalicsMode => "exit_italics_mode");
            define!(string ExitLeftwardMode => "exit_leftward_mode");
            define!(string ExitMicroMode => "exit_micro_mode");
            define!(string ExitShadowMode => "exit_shadow_mode");
            define!(string ExitSubscriptMode => "exit_subscript_mode");
            define!(string ExitSuperscriptMode => "exit_superscript_mode");
            define!(string ExitUpwardMode => "exit_upward_mode");
            define!(string MicroColumnAddress => "micro_column_address");
            define!(string MicroDown => "micro_down");
            define!(string MicroLeft => "micro_left");
            define!(string MicroRight => "micro_right");
            define!(string MicroRowAddress => "micro_row_address");
            define!(string MicroUp => "micro_up");
            define!(string OrderOfPins => "order_of_pins");
            define!(string SelectCharSet => "select_char_set");
            define!(string SetBottomMargin => "set_bottom_margin");
            define!(string SetBottomMarginParm => "set_bottom_margin_parm");
            define!(string SetLeftMarginParm => "set_left_margin_parm");
            define!(string SetRightMarginParm => "set_right_margin_parm");
            define!(string SetTopMargin => "set_top_margin");
            define!(string SetTopMarginParm => "set_top_margin_parm");
            define!(string StartBitImage => "start_bit_image");
            define!(string StartCharSetDef => "start_char_set_def");
            define!(string StopBitImage => "stop_bit_image");
            define!(string StopCharSetDef => "stop_char_set_def");
            define!(string SubscriptCharacters => "subscript_characters");
            define!(string SuperscriptCharacters => "superscript_characters");
            define!(string TheseCauseCr => "these_cause_cr");
            define!(string ZeroMotion => "zero_motion");
            define!(string CharSetNames => "char_set_names");
            define!(string KeyMouse => "key_mouse");
            define!(string MouseInfo => "mouse_info");
            define!(string ReqMousePos => "req_mouse_pos");
            define!(string GetMouse => "get_mouse");
            define!(string PkeyPlab => "pkey_plab");
            define!(string DeviceType => "device_type");
            define!(string CodeSetInit => "code_set_init");
            define!(string Set0DesSeq => "set0_des_seq");
            define!(string Set1DesSeq => "set1_des_seq");
            define!(string Set2DesSeq => "set2_des_seq");
            define!(string Set3DesSeq => "set3_des_seq");
            define!(string SetLrMargin => "set_lr_margin");
            define!(string SetTbMargin => "set_tb_margin");
            define!(string BitImageRepeat => "bit_image_repeat");
            define!(string BitImageNewline => "bit_image_newline");
            define!(string BitImageCarriageReturn => "bit_image_carriage_return");
            define!(string ColorNames => "color_names");
            define!(string DefineBitImageRegion => "define_bit_image_region");
            define!(string EndBitImageRegion => "end_bit_image_region");
            define!(string SetColorBand => "set_color_band");
            define!(string SetPageLength => "set_page_length");
            define!(string DisplayPcChar => "display_pc_char");
            define!(string EnterPcCharsetMode => "enter_pc_charset_mode");
            define!(string ExitPcCharsetMode => "exit_pc_charset_mode");
            define!(string EnterScancodeMode => "enter_scancode_mode");
            define!(string ExitScancodeMode => "exit_scancode_mode");
            define!(string PcTermOptions => "pc_term_options");
            define!(string ScancodeEscape => "scancode_escape");
            define!(string AltScancodeEsc => "alt_scancode_esc");
            define!(string EnterHorizontalHlMode => "enter_horizontal_hl_mode");
            define!(string EnterLeftHlMode => "enter_left_hl_mode");
            define!(string EnterLowHlMode => "enter_low_hl_mode");
            define!(string EnterRightHlMode => "enter_right_hl_mode");
            define!(string EnterTopHlMode => "enter_top_hl_mode");
            define!(string EnterVerticalHlMode => "enter_vertical_hl_mode");
            define!(string SetAAttributes => "set_a_attributes");
            define!(string SetPglenInch => "set_pglen_inch");
            define!(string TermcapInit2 => "termcap_init2");
            define!(string TermcapReset => "termcap_reset");
            define!(string LinefeedIfNotLf => "linefeed_if_not_lf");
            define!(string BackspaceIfNotBs => "backspace_if_not_bs");
            define!(string OtherNonFunctionKeys => "other_non_function_keys");
            define!(string ArrowKeyMap => "arrow_key_map");
            define!(string AcsULcorner => "acs_ulcorner");
            define!(string AcsLLcorner => "acs_llcorner");
            define!(string AcsURcorner => "acs_urcorner");
            define!(string AcsLRcorner => "acs_lrcorner");
            define!(string AcsLTee => "acs_ltee");
            define!(string AcsRTee => "acs_rtee");
            define!(string AcsBTee => "acs_btee");
            define!(string AcsTTee => "acs_ttee");
            define!(string AcsHLine => "acs_hline");
            define!(string AcsVLine => "acs_vline");
            define!(string AcsPlus => "acs_plus");
            define!(string MemoryLock => "memory_lock");
            define!(string MemoryUnlock => "memory_unlock");
            define!(string BoxChars1 => "box_chars_1");
            define!(string ChangeScrollRegion => "change_scroll_region"; top: u32, bottom: u32);
            define!(string ColumnAddress => "column_address"; x: u32);
            define!(string CursorAddress => "cursor_address"; y:u32, x:u32);
            define!(string EraseChars => "erase_chars"; count: u32);
            define!(string ParmDch => "parm_dch"; count: u32);
            define!(string ParmDeleteLine => "parm_delete_line"; count: u32);
            define!(string ParmDownCursor => "parm_down_cursor"; count: u32);
            define!(string ParmIch => "parm_ich"; count: u32);
            define!(string ParmIndex => "parm_index"; count: u32);
            define!(string ParmInsertLine => "parm_insert_line"; count: u32);
            define!(string ParmLeftCursor => "parm_left_cursor"; count: u32);
            define!(string ParmRightCursor => "parm_right_cursor"; count: u32);
            define!(string ParmRindex => "parm_rindex"; count: u32);
            define!(string ParmUpCursor => "parm_up_cursor"; count: u32);
            define!(string ParmDownMicro => "parm_down_micro"; count: u32);
            define!(string ParmLeftMicro => "parm_left_micro"; count: u32);
            define!(string ParmRightMicro => "parm_right_micro"; count: u32);
            define!(string ParmUpMicro => "parm_up_micro"; count: u32);
            define!(string RowAddress => "row_address"; y: u32);
            define!(string SetAttributes => "set_attributes";
                standout:    bool,
                underline:   bool,
                reverse:     bool,
                blink:       bool,
                dim:         bool,
                bold:        bool,
                invisible:   bool,
                protected:   bool,
                alt_charset: bool);
            define!(string SetAForeground => "set_a_foreground"; color: u8);
            define!(string SetABackground => "set_a_background"; color: u8);
            define!(string SetForeground => "set_foreground"; color: u8); 
            define!(string SetBackground => "set_background"; color: u8);
            define!(boolean XTermTitle => "XT");
            define!(boolean BrightAttribute => "AX");
            define!(boolean XTermMouse => "XM");            
            define!(boolean TrueColor => "Tc");
            define!(string SetClipboard => "Ms"; selection: String, content:   Vec<u8>);
            define!(string SetCursorStyle => "Ss"; kind: u8);
            define!(string ResetCursorStyle => "Se");            
            define!(string SetTrueColorForeground => "8f"; r: u8, g: u8, b: u8);
            define!(string SetTrueColorBackground => "8b"; r: u8, g: u8, b: u8);
            define!(string ResetCursorColor => "Cr");
            define!(string SetCursorColor => "Cs"; color: String);
        }
        pub use self::capability::{ Capability, Value };

        mod database
        {
            use ::
            {
                collections::{ HashMap },
                fnv::{ FnvHasher },
                fs::{self, File},
                hash::{ BuildHasherDefault },
                io::{ Read },
                path::{Path, PathBuf},
                terminal::info::
                {
                    capability::{ Capability, Value },
                    error::{ self, Error },
                    names::{ self },
                    parser::{ compiled },
                },
                *,
            };
            /// A capability database.
            #[derive( Eq, PartialEq, Clone, Debug )]
            pub struct Database
            {
                name: String,
                aliases: Vec<String>,
                description: String,
                inner: HashMap<String, Value, BuildHasherDefault<FnvHasher>>,
            }
            /// Builder for a new `Database`.
            #[derive( Default, Debug )]
            pub struct Builder 
            {
                name: Option<String>,
                aliases: Vec<String>,
                description: Option<String>,
                inner: HashMap<String, Value, BuildHasherDefault<FnvHasher>>,
            }

            impl Builder
            {
                /// Build the database.
                pub fn build( self ) -> Result<Database, ()>
                {
                    Ok(Database
                    {
                        name: self.name.ok_or(())?,
                        aliases: self.aliases,
                        description: self.description.unwrap_or_default(),
                        inner: self.inner,
                    })
                }
                /// Set the terminal name.
                pub fn name<T: Into<String>>(&mut self, name: T) -> &mut Self
                {
                    self.name = Some(name.into());
                    self
                }
                /// Set the terminal aliases.
                pub fn aliases<T, I>(&mut self, iter: I) -> &mut Self where
                T: Into<String>,
                I: IntoIterator<Item = T>
                {
                    self.aliases = iter.into_iter().map(|a| a.into()).collect();
                    self
                }
                /// Set the terminal description.
                pub fn description<T: Into<String>>(&mut self, description: T) -> &mut Self
                {
                    self.description = Some(description.into());
                    self
                }
                /// Set a capability.
                pub fn set<'a, C: Capability<'a>>(&'a mut self, value: C) -> &mut Self
                {
                    if !self.inner.contains_key(C::name())
                    {
                        if let Some(value) = C::into(value) { self.inner.insert(C::name().into(), value); }
                    }

                    self
                }
                /// Set a raw capability.
                pub fn raw<S: AsRef<str>, V: Into<Value>>(&mut self, name: S, value: V) -> &mut Self
                {
                    let name = name.as_ref();
                    let name = names::ALIASES.get(name).copied().unwrap_or(name);

                    if !self.inner.contains_key(name) { self.inner.insert(name.into(), value.into()); }

                    self
                }
            }

            impl Database
            {
                /// Create a database builder for constucting a database.
                pub fn new() -> Builder { Builder::default() }
                /// Load a database from the current environment.
                pub fn from_env() -> error::Result<Self>
                {
                    if let Ok(name) = env::var("TERM") { Self::from_name(name) } 
                    else { Err(Error::NotFound) }
                }
                /// Load a database for the given name.
                pub fn from_name<N: AsRef<str>>(name: N) -> error::Result<Self>
                {
                    let name = name.as_ref();
                    let first = name.chars().next().ok_or(Error::NotFound)?;
                    let mut search = Vec::<PathBuf>::new();
                    
                    if let Some(dir) = env::var_os("TERMINFO") { search.push(dir.into()); }
                    
                    else if let Some(mut home) = env::home_dir()
                    {
                        home.push(".terminfo");
                        search.push(home);
                    }

                    if let Ok(dirs) = env::var("TERMINFO_DIRS")
                    {
                        for dir in dirs.split(':')
                        {
                            search.push(dir.into());
                        }
                    }
                    
                    if let Ok(prefix) = env::var("PREFIX")
                    {
                        let path = Path::new(&prefix);
                        search.push(path.join("etc/terminfo"));
                        search.push(path.join("lib/terminfo"));
                        search.push(path.join("share/terminfo"));
                    }

                    search.push("/etc/terminfo".into());
                    search.push("/lib/terminfo".into());
                    search.push("/usr/share/terminfo".into());
                    search.push("/usr/local/share/terminfo".into());
                    search.push("/usr/local/share/site-terminfo".into());
                    search.push("/boot/system/data/terminfo".into());

                    for path in search 
                    {
                        if fs::metadata(&path).is_err() { continue; }
                        {
                            let mut path = path.clone();
                            path.push(first.to_string());
                            path.push(name);

                            if fs::metadata(&path).is_ok() { return Self::from_path(path); }
                        }
                        
                        {
                            let mut path = path.clone();
                            path.push(format!("{:x}", first as usize));
                            path.push(name);

                            if fs::metadata(&path).is_ok() { return Self::from_path(path); }
                        }
                    }

                    Err(Error::NotFound)
                }
                /// Load a database from the given path.
                pub fn from_path<P: AsRef<Path>>(path: P) -> error::Result<Self>
                {
                    let mut file = File::open(path)?;
                    let mut buffer = Vec::new();
                    file.read_to_end(&mut buffer)?;
                    Self::from_buffer(buffer)
                }
                /// Load a database from a buffer.
                pub fn from_buffer<T: AsRef<[u8]>>(buffer: T) -> error::Result<Self>
                {
                    if let Ok((_, database)) = compiled::parse(buffer.as_ref()) { Ok(database.into()) }
                    else { Err(Error::Parse) }
                }
                /// The terminal name.
                pub fn name(&self) -> &str { &self.name }
                /// The terminal aliases.
                pub fn aliases(&self) -> &[String] { &self.aliases }
                /// The terminal description.
                pub fn description(&self) -> &str { &self.description }
                /// Get a capability.
                pub fn get<'a, C: Capability<'a>>(&'a self) -> Option<C> { C::from(self.inner.get(C::name())) }
                /// Get a capability by name.
                pub fn raw<S: AsRef<str>>(&self, name: S) -> Option<&Value>
                {
                    let name = name.as_ref();
                    let name = names::ALIASES.get(name).copied().unwrap_or(name);
                    self.inner.get(name)
                }
            }
        }
        pub use self::database::{ Database };
        /// Constants to deal with name differences across terminfo and termcap.
        pub mod names
        {            
            const BOOLEAN: &[&str] = &
            [
                "auto_left_margin", "auto_right_margin", "no_esc_ctlc", "ceol_standout_glitch", "eat_newline_glitch",
                "erase_overstrike", "generic_type", "hard_copy", "has_meta_key", "has_status_line", "insert_null_glitch",
                "memory_above", "memory_below", "move_insert_mode", "move_standout_mode", "over_strike", 
                "status_line_esc_ok", "dest_tabs_magic_smso", "tilde_glitch", "transparent_underline", "xon_xoff", 
                "needs_xon_xoff", "prtr_silent", "hard_cursor", "non_rev_rmcup", "no_pad_char", "non_dest_scroll_region", 
                "can_change", "back_color_erase", "hue_lightness_saturation", "col_addr_glitch", "cr_cancels_micro_mode", 
                "has_print_wheel", "row_addr_glitch", "semi_auto_right_margin", "cpi_changes_res", "lpi_changes_res", 
                "backspaces_with_bs", "crt_no_scrolling", "no_correctly_working_cr", "gnu_has_meta_key", 
                "linefeed_is_newline", "has_hardware_tabs", "return_does_clr_eol"
            ];
            
            const NUMBER: &[&str] = &
            [
                "columns", "init_tabs", "lines", "lines_of_memory", "magic_cookie_glitch", "padding_baud_rate",
                "virtual_terminal", "width_status_line", "num_labels", "label_height", "label_width", "max_attributes",
                "maximum_windows", "max_colors", "max_pairs", "no_color_video", "buffer_capacity", "dot_vert_spacing",
                "dot_horz_spacing", "max_micro_address", "max_micro_jump", "micro_col_size", "micro_line_size",
                "number_of_pins", "output_res_char", "output_res_line", "output_res_horz_inch", "output_res_vert_inch",
                "print_rate", "wide_char_size", "buttons", "bit_image_entwining", "bit_image_type", "magic_cookie_glitch_ul",
                "carriage_return_delay", "new_line_delay", "backspace_delay", "horizontal_tab_delay",
                "number_of_function_keys"
            ];
            
            const STRING: &[&str] = &
            [
                "back_tab", "bell", "carriage_return", "change_scroll_region", "clear_all_tabs", "clear_screen", "clr_eol",
                "clr_eos", "column_address", "command_character", "cursor_address", "cursor_down", "cursor_home",
                "cursor_invisible", "cursor_left", "cursor_mem_address", "cursor_normal", "cursor_right", "cursor_to_ll", 
                "cursor_up", "cursor_visible", "delete_character", "delete_line", "dis_status_line", "down_half_line", 
                "enter_alt_charset_mode", "enter_blink_mode", "enter_bold_mode", "enter_ca_mode", "enter_delete_mode", 
                "enter_dim_mode", "enter_insert_mode", "enter_secure_mode", "enter_protected_mode", "enter_reverse_mode", 
                "enter_standout_mode", "enter_underline_mode", "erase_chars", "exit_alt_charset_mode", 
                "exit_attribute_mode", "exit_ca_mode", "exit_delete_mode", "exit_insert_mode", "exit_standout_mode", 
                "exit_underline_mode", "flash_screen", "form_feed", "from_status_line", "init_1string", "init_2string", 
                "init_3string", "init_file", "insert_character", "insert_line", "insert_padding", "key_backspace", 
                "key_catab", "key_clear", "key_ctab", "key_dc", "key_dl", "key_down", "key_eic", "key_eol", "key_eos", 
                "key_f0", "key_f1", "key_f10", "key_f2", "key_f3", "key_f4", "key_f5", "key_f6", "key_f7", "key_f8", 
                "key_f9", "key_home", "key_ic", "key_il", "key_left", "key_ll", "key_npage", "key_ppage", "key_right", 
                "key_sf", "key_sr", "key_stab", "key_up", "keypad_local", "keypad_xmit", "lab_f0", "lab_f1", "lab_f10", 
                "lab_f2", "lab_f3", "lab_f4", "lab_f5", "lab_f6", "lab_f7", "lab_f8", "lab_f9", "meta_off", "meta_on", 
                "newline", "pad_char", "parm_dch", "parm_delete_line", "parm_down_cursor", "parm_ich", "parm_index", 
                "parm_insert_line", "parm_left_cursor", "parm_right_cursor", "parm_rindex", "parm_up_cursor", "pkey_key", 
                "pkey_local", "pkey_xmit", "print_screen", "prtr_off", "prtr_on", "repeat_char", "reset_1string", 
                "reset_2string", "reset_3string", "reset_file", "restore_cursor", "row_address", "save_cursor", 
                "scroll_forward", "scroll_reverse", "set_attributes", "set_tab", "set_window", "tab", "to_status_line", 
                "underline_char", "up_half_line", "init_prog", "key_a1", "key_a3", "key_b2", "key_c1", "key_c3", 
                "prtr_non", "char_padding", "acs_chars", "plab_norm", "key_btab", "enter_xon_mode", "exit_xon_mode", 
                "enter_am_mode", "exit_am_mode", "xon_character", "xoff_character", "ena_acs", "label_on", "label_off", 
                "key_beg", "key_cancel", "key_close", "key_command", "key_copy", "key_create", "key_end", "key_enter", 
                "key_exit", "key_find", "key_help", "key_mark", "key_message", "key_move", "key_next", "key_open", 
                "key_options", "key_previous", "key_print", "key_redo", "key_reference", "key_refresh", "key_replace", 
                "key_restart", "key_resume", "key_save", "key_suspend", "key_undo", "key_sbeg", "key_scancel", 
                "key_scommand", "key_scopy", "key_screate", "key_sdc", "key_sdl", "key_select", "key_send", "key_seol", 
                "key_sexit", "key_sfind", "key_shelp", "key_shome", "key_sic", "key_sleft", "key_smessage", "key_smove", 
                "key_snext", "key_soptions", "key_sprevious", "key_sprint", "key_sredo", "key_sreplace", "key_sright", 
                "key_srsume", "key_ssave", "key_ssuspend", "key_sundo", "req_for_input", "key_f11", "key_f12", "key_f13", 
                "key_f14", "key_f15", "key_f16", "key_f17", "key_f18", "key_f19", "key_f20", "key_f21", "key_f22", 
                "key_f23", "key_f24", "key_f25", "key_f26", "key_f27", "key_f28", "key_f29", "key_f30", "key_f31", 
                "key_f32", "key_f33", "key_f34", "key_f35", "key_f36", "key_f37", "key_f38", "key_f39", "key_f40", 
                "key_f41", "key_f42", "key_f43", "key_f44", "key_f45", "key_f46", "key_f47", "key_f48", "key_f49", 
                "key_f50", "key_f51", "key_f52", "key_f53", "key_f54", "key_f55", "key_f56", "key_f57", "key_f58", 
                "key_f59", "key_f60", "key_f61", "key_f62", "key_f63", "clr_bol", "clear_margins", "set_left_margin", 
                "set_right_margin", "label_format", "set_clock", "display_clock", "remove_clock", "create_window", 
                "goto_window", "hangup", "dial_phone", "quick_dial", "tone", "pulse", "flash_hook", "fixed_pause", 
                "wait_tone", "user0", "user1", "user2", "user3", "user4", "user5", "user6", "user7", "user8", "user9", 
                "orig_pair", "orig_colors", "initialize_color", "initialize_pair", "set_color_pair", "set_foreground", 
                "set_background", "change_char_pitch", "change_line_pitch", "change_res_horz", "change_res_vert", 
                "define_char", "enter_doublewide_mode", "enter_draft_quality", "enter_italics_mode", "enter_leftward_mode", 
                "enter_micro_mode", "enter_near_letter_quality", "enter_normal_quality", "enter_shadow_mode", 
                "enter_subscript_mode", "enter_superscript_mode", "enter_upward_mode", "exit_doublewide_mode", 
                "exit_italics_mode", "exit_leftward_mode", "exit_micro_mode", "exit_shadow_mode", "exit_subscript_mode", 
                "exit_superscript_mode", "exit_upward_mode", "micro_column_address", "micro_down", "micro_left", 
                "micro_right", "micro_row_address", "micro_up", "order_of_pins", "parm_down_micro", "parm_left_micro", 
                "parm_right_micro", "parm_up_micro", "select_char_set", "set_bottom_margin", "set_bottom_margin_parm", 
                "set_left_margin_parm", "set_right_margin_parm", "set_top_margin", "set_top_margin_parm", 
                "start_bit_image", "start_char_set_def", "stop_bit_image", "stop_char_set_def", "subscript_characters", 
                "superscript_characters", "these_cause_cr", "zero_motion", "char_set_names", "key_mouse", "mouse_info", 
                "req_mouse_pos", "get_mouse", "set_a_foreground", "set_a_background", "pkey_plab", "device_type", 
                "code_set_init", "set0_des_seq", "set1_des_seq", "set2_des_seq", "set3_des_seq", "set_lr_margin", 
                "set_tb_margin", "bit_image_repeat", "bit_image_newline", "bit_image_carriage_return", "color_names", 
                "define_bit_image_region", "end_bit_image_region", "set_color_band", "set_page_length", "display_pc_char", 
                "enter_pc_charset_mode", "exit_pc_charset_mode", "enter_scancode_mode", "exit_scancode_mode", 
                "pc_term_options", "scancode_escape", "alt_scancode_esc", "enter_horizontal_hl_mode", "enter_left_hl_mode",
                "enter_low_hl_mode", "enter_right_hl_mode", "enter_top_hl_mode", "enter_vertical_hl_mode", 
                "set_a_attributes", "set_pglen_inch", "termcap_init2", "termcap_reset", "linefeed_if_not_lf", 
                "backspace_if_not_bs", "other_non_function_keys", "arrow_key_map", "acs_ulcorner", "acs_llcorner",
                 "acs_urcorner", "acs_lrcorner", "acs_ltee", "acs_rtee", "acs_btee", "acs_ttee", "acs_hline", "acs_vline", 
                 "acs_plus", "memory_lock", "memory_unlock", "box_chars_1"
            ];

            const TERMINFO: &[(&str, &str)] = &
            [
                // Boolean names.
                ("auto_left_margin", "bw"), ("auto_right_margin", "am"), ("back_color_erase", "bce"), ("can_change", "ccc"), 
                ("ceol_standout_glitch", "xhp"), ("col_addr_glitch", "xhpa"), ("cpi_changes_res", "cpix"), 
                ("cr_cancels_micro_mode", "crxm"), ("dest_tabs_magic_smso", "xt"), ("eat_newline_glitch", "xenl"), 
                ("erase_overstrike", "eo"), ("generic_type", "gn"), ("hard_copy", "hc"), ("hard_cursor", "chts"), 
                ("has_meta_key", "km"), ("has_print_wheel", "daisy"), ("has_status_line", "hs"), 
                ("hue_lightness_saturation", "hls"), ("insert_null_glitch", "in"), ("lpi_changes_res", "lpix"),
                ("memory_above", "da"), ("memory_below", "db"), ("move_insert_mode", "mir"), ("move_standout_mode", "msgr"), 
                ("needs_xon_xoff", "nxon"), ("no_esc_ctlc", "xsb"), ("no_pad_char", "npc"), 
                ("non_dest_scroll_region", "ndscr"), ("non_rev_rmcup", "nrrmc"), ("over_strike", "os"), 
                ("prtr_silent", "mc5i"), ("row_addr_glitch", "xvpa"), ("semi_auto_right_margin", "sam"), 
                ("status_line_esc_ok", "eslok"), ("tilde_glitch", "hz"), ("transparent_underline", "ul"), ("xon_xoff", "xon"),
                // Number names.
                ("bit_image_entwining", "bitwin"), ("bit_image_type", "bitype"), ("buffer_capacity", "bufsz"), 
                ("buttons", "btns"), ("columns", "cols"), ("dot_horz_spacing", "spinh"), ("dot_vert_spacing", "spinv"), 
                ("init_tabs", "it"), ("label_height", "lh"), ("label_width", "lw"), ("lines", "lines"), 
                ("lines_of_memory", "lm"), ("max_attributes", "ma"), ("magic_cookie_glitch", "xmc"), ("max_colors", "colors"),
                ("max_micro_address", "maddr"), ("max_micro_jump", "mjump"), ("max_pairs", "pairs"), 
                ("maximum_windows", "wnum"), ("micro_col_size", "mcs"), ("micro_line_size", "mls"), ("no_color_video", "ncv"),
                ("num_labels", "nlab"), ("number_of_pins", "npins"), ("output_res_char", "orc"), ("output_res_line", "orl"),
                ("output_res_horz_inch", "orhi"), ("output_res_vert_inch", "orvi"), ("padding_baud_rate", "pb"),
                ("print_rate", "cps"), ("virtual_terminal", "vt"), ("wide_char_size", "widcs"), ("width_status_line", "wsl"),
                // String names.
                ("acs_chars", "acsc"), ("alt_scancode_esc", "scesa"), ("back_tab", "cbt"), ("bell", "bel"), 
                ("bit_image_carriage_return", "bicr"), ("bit_image_newline", "binel"), ("bit_image_repeat", "birep"), 
                ("carriage_return", "cr"), ("change_char_pitch", "cpi"), ("change_line_pitch", "lpi"), 
                ("change_res_horz", "chr"), ("change_res_vert", "cvr"), ("change_scroll_region", "csr"), 
                ("char_padding", "rmp"), ("char_set_names", "csnm"), ("clear_all_tabs", "tbc"), ("clear_margins", "mgc"), 
                ("clear_screen", "clear"), ("clr_bol", "el1"), ("clr_eol", "el"), ("clr_eos", "ed"), ("code_set_init", "csin"),
                ("color_names", "colornm"), ("column_address", "hpa"), ("command_character", "cmdch"), 
                ("create_window", "cwin"), ("cursor_address", "cup"), ("cursor_down", "cud1"), ("cursor_home", "home"), 
                ("cursor_invisible", "civis"), ("cursor_left", "cub1"), ("cursor_mem_address", "mrcup"), 
                ("cursor_normal", "cnorm"), ("cursor_right", "cuf1"), ("cursor_to_ll", "ll"), ("cursor_up", "cuu1"), 
                ("cursor_visible", "cvvis"), ("define_bit_image_region", "defbi"), ("define_char", "defc"), 
                ("delete_character", "dch1"), ("delete_line", "dl1"), ("device_type", "devt"), ("dial_phone", "dial"), 
                ("dis_status_line", "dsl"), ("display_clock", "dclk"), ("display_pc_char", "dispc"), ("down_half_line", "hd"), 
                ("ena_acs", "enacs"), ("end_bit_image_region", "endbi"), ("enter_alt_charset_mode", "smacs"), 
                ("enter_am_mode", "smam"), ("enter_blink_mode", "blink"), ("enter_bold_mode", "bold"), 
                ("enter_ca_mode", "smcup"), ("enter_delete_mode", "smdc"), ("enter_dim_mode", "dim"), 
                ("enter_doublewide_mode", "swidm"), ("enter_draft_quality", "sdrfq"), ("enter_horizontal_hl_mode", "ehhlm"), 
                ("enter_insert_mode", "smir"), ("enter_italics_mode", "sitm"), ("enter_left_hl_mode", "elhlm"), 
                ("enter_leftward_mode", "slm"), ("enter_low_hl_mode", "elohlm"), ("enter_micro_mode", "smicm"), 
                ("enter_near_letter_quality", "snlq"), ("enter_normal_quality", "snrmq"), ("enter_pc_charset_mode", "smpch"), 
                ("enter_protected_mode", "prot"), ("enter_reverse_mode", "rev"), ("enter_right_hl_mode", "erhlm"), 
                ("enter_scancode_mode", "smsc"), ("enter_secure_mode", "invis"), ("enter_shadow_mode", "sshm"), 
                ("enter_standout_mode", "smso"), ("enter_subscript_mode", "ssubm"), ("enter_superscript_mode", "ssupm"), 
                ("enter_top_hl_mode", "ethlm"), ("enter_underline_mode", "smul"), ("enter_upward_mode", "sum"), 
                ("enter_vertical_hl_mode", "evhlm"), ("enter_xon_mode", "smxon"), ("erase_chars", "ech"), 
                ("exit_alt_charset_mode", "rmacs"), ("exit_am_mode", "rmam"), ("exit_attribute_mode", "sgr0"), 
                ("exit_ca_mode", "rmcup"), ("exit_delete_mode", "rmdc"), ("exit_doublewide_mode", "rwidm"), 
                ("exit_insert_mode", "rmir"), ("exit_italics_mode", "ritm"), ("exit_leftward_mode", "rlm"), 
                ("exit_micro_mode", "rmicm"), ("exit_pc_charset_mode", "rmpch"), ("exit_scancode_mode", "rmsc"), 
                ("exit_shadow_mode", "rshm"), ("exit_standout_mode", "rmso"), ("exit_subscript_mode", "rsubm"), 
                ("exit_superscript_mode", "rsupm"), ("exit_underline_mode", "rmul"), ("exit_upward_mode", "rum"), 
                ("exit_xon_mode", "rmxon"), ("fixed_pause", "pause"), ("flash_hook", "hook"), ("flash_screen", "flash"), 
                ("form_feed", "ff"), ("from_status_line", "fsl"), ("get_mouse", "getm"), ("goto_window", "wingo"), 
                ("hangup", "hup"), ("init_1string", "is1"), ("init_2string", "is2"), ("init_3string", "is3"), 
                ("init_file", "if"), ("init_prog", "iprog"), ("initialize_color", "initc"), ("initialize_pair", "initp"), 
                ("insert_character", "ich1"), ("insert_line", "il1"), ("insert_padding", "ip"), ("key_a1", "ka1"), 
                ("key_a3", "ka3"), ("key_b2", "kb2"), ("key_backspace", "kbs"), ("key_beg", "kbeg"), ("key_btab", "kcbt"), 
                ("key_c1", "kc1"), ("key_c3", "kc3"), ("key_cancel", "kcan"), ("key_catab", "ktbc"), ("key_clear", "kclr"), 
                ("key_close", "kclo"), ("key_command", "kcmd"), ("key_copy", "kcpy"), ("key_create", "kcrt"), 
                ("key_ctab", "kctab"), ("key_dc", "kdch1"), ("key_dl", "kdl1"), ("key_down", "kcud1"), ("key_eic", "krmir"), 
                ("key_end", "kend"), ("key_enter", "kent"), ("key_eol", "kel"), ("key_eos", "ked"), ("key_exit", "kext"), 
                ("key_f0", "kf0"), ("key_f1", "kf1"), ("key_f62", "kf62"), ("key_f63", "kf63"), ("key_find", "kfnd"), 
                ("key_help", "khlp"), ("key_home", "khome"), ("key_ic", "kich1"), ("key_il", "kil1"), ("key_left", "kcub1"), 
                ("key_ll", "kll"), ("key_mark", "kmrk"), ("key_message", "kmsg"), ("key_mouse", "kmous"), ("key_move", "kmov"),
                ("key_next", "knxt"), ("key_npage", "knp"), ("key_open", "kopn"), ("key_options", "kopt"), ("key_ppage", "kpp"),
                ("key_previous", "kprv"), ("key_print", "kprt"), ("key_redo", "krdo"), ("key_reference", "kref"), 
                ("key_refresh", "krfr"), ("key_replace", "krpl"), ("key_restart", "krst"), ("key_resume", "kres"), 
                ("key_right", "kcuf1"), ("key_save", "ksav"), ("key_sbeg", "kBEG"), ("key_scancel", "kCAN"), 
                ("key_scommand", "kCMD"), ("key_scopy", "kCPY"), ("key_screate", "kCRT"), ("key_sdc", "kDC"), 
                ("key_sdl", "kDL"), ("key_select", "kslt"), ("key_send", "kEND"), ("key_seol", "kEOL"), ("key_sexit", "kEXT"), 
                ("key_sf", "kind"), ("key_sfind", "kFND"), ("key_shelp", "kHLP"), ("key_shome", "kHOM"), ("key_sic", "kIC"), 
                ("key_sleft", "kLFT"), ("key_smessage", "kMSG"), ("key_smove", "kMOV"), ("key_snext", "kNXT"), 
                ("key_soptions", "kOPT"), ("key_sprevious", "kPRV"), ("key_sprint", "kPRT"), ("key_sr", "kri"), 
                ("key_sredo", "kRDO"), ("key_sreplace", "kRPL"), ("key_sright", "kRIT"), ("key_srsume", "kRES"), 
                ("key_ssave", "kSAV"), ("key_ssuspend", "kSPD"), ("key_stab", "khts"), ("key_sundo", "kUND"), 
                ("key_suspend", "kspd"), ("key_undo", "kund"), ("key_up", "kcuu1"), ("keypad_local", "rmkx"), 
                ("keypad_xmit", "smkx"), ("lab_f0", "lf0"), ("lab_f1", "lf1"), ("lab_f2", "lf2"), ("lab_f3", "lf3"), 
                ("lab_f4", "lf4"), ("lab_f5", "lf5"), ("lab_f6", "lf6"), ("lab_f7", "lf7"), ("lab_f8", "lf8"),
                ("lab_f9", "lf9"), ("lab_f10", "lf10"), ("label_format", "fln"), ("label_off", "rmln"), 
                ("label_on", "smln"), ("meta_off", "rmm"), ("meta_on", "smm"), ("micro_column_address", "mhpa"), 
                ("micro_down", "mcud1"), ("micro_left", "mcub1"), ("micro_right", "mcuf1"), ("micro_row_address", "mvpa"), 
                ("micro_up", "mcuu1"), ("mouse_info", "minfo"), ("newline", "nel"), ("order_of_pins", "porder"), 
                ("orig_colors", "oc"), ("orig_pair", "op"), ("pad_char", "pad"), ("parm_dch", "dch"), 
                ("parm_delete_line", "dl"), ("parm_down_cursor", "cud"), ("parm_down_micro", "mcud"), ("parm_ich", "ich"), 
                ("parm_index", "indn"), ("parm_insert_line", "il"), ("parm_left_cursor", "cub"), 
                ("parm_left_micro", "mcub"), ("parm_right_cursor", "cuf"), ("parm_right_micro", "mcuf"), 
                ("parm_rindex", "rin"), ("parm_up_cursor", "cuu"), ("parm_up_micro", "mcuu"), ("pc_term_options", "pctrm"), 
                ("pkey_key", "pfkey"), ("pkey_local", "pfloc"), ("pkey_plab", "pfxl"), ("pkey_xmit", "pfx"), 
                ("plab_norm", "pln"), ("print_screen", "mc0"), ("prtr_non", "mc5p"), ("prtr_off", "mc4"), 
                ("prtr_on", "mc5"), ("pulse", "pulse"), ("quick_dial", "qdial"), ("remove_clock", "rmclk"), 
                ("repeat_char", "rep"), ("req_for_input", "rfi"), ("req_mouse_pos", "reqmp"), ("reset_1string", "rs1"), 
                ("reset_2string", "rs2"), ("reset_3string", "rs3"), ("reset_file", "rf"), ("restore_cursor", "rc"), 
                ("row_address", "vpa"), ("save_cursor", "sc"), ("scancode_escape", "scesc"), ("scroll_forward", "ind"), 
                ("scroll_reverse", "ri"), ("select_char_set", "scs"), ("set0_des_seq", "s0ds"), ("set1_des_seq", "s1ds"), 
                ("set2_des_seq", "s2ds"), ("set3_des_seq", "s3ds"), ("set_a_attributes", "sgr1"), 
                ("set_a_background", "setab"), ("set_a_foreground", "setaf"), ("set_attributes", "sgr"), 
                ("set_background", "setb"), ("set_bottom_margin", "smgb"), ("set_bottom_margin_parm", "smgbp"), 
                ("set_clock", "sclk"), ("set_color_band", "setcolor"), ("set_color_pair", "scp"), 
                ("set_foreground", "setf"), ("set_left_margin", "smgl"), ("set_left_margin_parm", "smglp"), 
                ("set_lr_margin", "smglr"), ("set_page_length", "slines"), ("set_pglen_inch", "slength"), 
                ("set_right_margin", "smgr"), ("set_right_margin_parm", "smgrp"), ("set_tab", "hts"), 
                ("set_tb_margin", "smgtb"), ("set_top_margin", "smgt"), ("set_top_margin_parm", "smgtp"), 
                ("set_window", "wind"), ("start_bit_image", "sbim"), ("start_char_set_def", "scsd"), 
                ("stop_bit_image", "rbim"), ("stop_char_set_def", "rcsd"), ("subscript_characters", "subcs"), 
                ("superscript_characters", "supcs"), ("tab", "ht"), ("these_cause_cr", "docr"), ("to_status_line", "tsl"), 
                ("tone", "tone"), ("user0", "u0"), ("user1", "u1"), ("user2", "u2"), ("user3", "u3"), ("user4", "u4"), 
                ("user5", "u5"), ("user6", "u6"), ("user7", "u7"), ("user8", "u8"), ("user9", "u9"), 
                ("underline_char", "uc"), ("up_half_line", "hu"), ("wait_tone", "wait"), ("xoff_character", "xoffc"), 
                ("xon_character", "xonc"), ("zero_motion", "zerom"),
            ];

            const TERMCAP: &[(&str, &str)] = &
            [
                // Boolean names.
                ("auto_left_margin", "bw"), ("auto_right_margin", "am"), ("back_color_erase", "ut"), ("can_change", "cc"), 
                ("ceol_standout_glitch", "xs"), ("col_addr_glitch", "YA"), ("cpi_changes_res", "YF"), 
                ("cr_cancels_micro_mode", "YB"), ("dest_tabs_magic_smso", "xt"), ("eat_newline_glitch", "xn"), 
                ("erase_overstrike", "eo"), ("generic_type", "gn"), ("hard_copy", "hc"), ("hard_cursor", "HC"), 
                ("has_meta_key", "km"), ("has_print_wheel", "YC"), ("has_status_line", "hs"), 
                ("hue_lightness_saturation", "hl"), ("insert_null_glitch", "in"), ("lpi_changes_res", "YG"), 
                ("memory_above", "da"), ("memory_below", "db"), ("move_insert_mode", "mi"), ("move_standout_mode", "ms"), 
                ("needs_xon_xoff", "nx"), ("no_esc_ctlc", "xb"), ("no_pad_char", "NP"), ("non_dest_scroll_region", "ND"), 
                ("non_rev_rmcup", "NR"), ("over_strike", "os"), ("prtr_silent", "5i"), ("row_addr_glitch", "YD"), 
                ("semi_auto_right_margin", "YE"), ("status_line_esc_ok", "es"), ("tilde_glitch", "hz"), 
                ("transparent_underline", "ul"), ("xon_xoff", "xo"),
                // Number names.
                ("bit_image_entwining", "Yo"), ("bit_image_type", "Yp"), ("buffer_capacity", "Ya"), ("buttons", "BT"), 
                ("columns", "co"), ("dot_horz_spacing", "Yc"), ("dot_vert_spacing", "Yb"), ("init_tabs", "it"), 
                ("label_height", "lh"), ("label_width", "lw"), ("lines", "li"), ("lines_of_memory", "lm"), 
                ("max_attributes", "ma"), ("magic_cookie_glitch", "sg"), ("max_colors", "Co"), ("max_micro_address", "Yd"), 
                ("max_micro_jump", "Ye"), ("max_pairs", "pa"), ("maximum_windows", "MW"), ("micro_col_size", "Yf"), 
                ("micro_line_size", "Yg"), ("no_color_video", "NC"), ("num_labels", "Nl"), ("number_of_pins", "Yh"), 
                ("output_res_char", "Yi"), ("output_res_line", "Yj"), ("output_res_horz_inch", "Yk"), 
                ("output_res_vert_inch", "Yl"), ("padding_baud_rate", "pb"), ("print_rate", "Ym"), 
                ("virtual_terminal", "vt"), ("wide_char_size", "Yn"), ("width_status_line", "ws"),
                // String names.
                ("acs_chars", "ac"), ("alt_scancode_esc", "S8"), ("back_tab", "bt"), ("bell", "bl"), 
                ("bit_image_carriage_return", "Yv"), ("bit_image_newline", "Zz"), ("bit_image_repeat", "Xy"), 
                ("carriage_return", "cr"), ("change_char_pitch", "ZA"), ("change_line_pitch", "ZB"), 
                ("change_res_horz", "ZC"), ("change_res_vert", "ZD"), ("change_scroll_region", "cs"), 
                ("char_padding", "rP"), ("char_set_names", "Zy"), ("clear_all_tabs", "ct"), ("clear_margins", "MC"), 
                ("clear_screen", "cl"), ("clr_bol", "cb"), ("clr_eol", "ce"), ("clr_eos", "cd"), ("code_set_init", "ci"), 
                ("color_names", "Yw"), ("column_address", "ch"), ("command_character", "CC"), ("cursor_address", "cm"), 
                ("cursor_down", "do"), ("cursor_home", "ho"), ("cursor_invisible", "vi"), ("cursor_left", "le"), 
                ("cursor_mem_address", "CM"), ("cursor_normal", "ve"), ("cursor_right", "nd"), ("cursor_to_ll", "ll"), 
                ("cursor_up", "up"), ("cursor_visible", "vs"), ("define_bit_image_region", "Yx"), ("define_char", "ZE"), 
                ("delete_character", "dc"), ("delete_line", "dl"), ("device_type", "dv"), ("dial_phone", "DI"), 
                ("dis_status_line", "ds"), ("display_clock", "DK"), ("display_pc_char", "S1"), ("down_half_line", "hd"), 
                ("ena_acs", "eA"), ("end_bit_image_region", "Yy"), ("enter_alt_charset_mode", "as"), 
                ("enter_am_mode", "SA"), ("enter_blink_mode", "mb"), ("enter_bold_mode", "md"), ("enter_ca_mode", "ti"), 
                ("enter_delete_mode", "dm"), ("enter_dim_mode", "mh"), ("enter_doublewide_mode", "ZF"), 
                ("enter_draft_quality", "ZG"), ("enter_insert_mode", "im"), ("enter_italics_mode", "ZH"), 
                ("enter_leftward_mode", "ZI"), ("enter_micro_mode", "ZJ"), ("enter_near_letter_quality", "ZK"), 
                ("enter_normal_quality", "ZL"), ("enter_pc_charset_mode", "S2"), ("enter_protected_mode", "mp"), 
                ("enter_reverse_mode", "mr"), ("enter_scancode_mode", "S4"), ("enter_secure_mode", "mk"), 
                ("enter_shadow_mode", "ZM"), ("enter_standout_mode", "so"), ("enter_subscript_mode", "ZN"), 
                ("enter_superscript_mode", "ZO"), ("enter_underline_mode", "us"), ("enter_upward_mode", "ZP"), 
                ("enter_xon_mode", "SX"), ("erase_chars", "ec"), ("exit_alt_charset_mode", "ae"), ("exit_am_mode", "RA"), 
                ("exit_attribute_mode", "me"), ("exit_ca_mode", "te"), ("exit_delete_mode", "ed"), 
                ("exit_doublewide_mode", "ZQ"), ("exit_insert_mode", "ei"), ("exit_italics_mode", "ZR"), 
                ("exit_leftward_mode", "ZS"), ("exit_micro_mode", "ZT"), ("exit_pc_charset_mode", "S3"), 
                ("exit_scancode_mode", "S5"), ("exit_shadow_mode", "ZU"), ("exit_standout_mode", "se"), 
                ("exit_subscript_mode", "ZV"), ("exit_superscript_mode", "ZW"), ("exit_underline_mode", "ue"), 
                ("exit_upward_mode", "ZX"), ("exit_xon_mode", "RX"), ("fixed_pause", "PA"), ("flash_hook", "fh"), 
                ("flash_screen", "vb"), ("form_feed", "ff"), ("from_status_line", "fs"), ("get_mouse", "Gm"), 
                ("goto_window", "WG"), ("hangup", "HU"), ("init_1string", "i1"), ("init_2string", "is"), 
                ("init_3string", "i3"), ("init_file", "if"), ("init_prog", "iP"), ("initialize_color", "Ic"), 
                ("initialize_pair", "Ip"), ("insert_character", "ic"), ("insert_line", "al"), ("insert_padding", "ip"), 
                ("key_a1", "K1"), ("key_a3", "K3"), ("key_b2", "K2"), ("key_backspace", "kb"), ("key_btab", "kB"), 
                ("key_c1", "K4"), ("key_c3", "K5"), ("key_catab", "ka"), ("key_clear", "kC"), ("key_ctab", "kt"), 
                ("key_dc", "kD"), ("key_dl", "kL"), ("key_down", "kd"), ("key_eic", "kM"), ("key_eol", "kE"), 
                ("key_eos", "kS"), ("key_f0", "k0"), ("key_f1", "k1"), ("key_f62", "Fq"), ("key_f63", "Fr"), 
                ("key_help", "%1"), ("key_home", "kh"), ("key_ic", "kI"), ("key_il", "kA"), ("key_left", "kl"), 
                ("key_ll", "kH"), ("key_mark", "%2"), ("key_message", "%3"), ("key_mouse", "Km"), ("key_move", "%4"), 
                ("key_next", "%5"), ("key_npage", "kN"), ("key_open", "%6"), ("key_options", "%7"), ("key_ppage", "kP"), 
                ("key_previous", "%8"), ("key_print", "%9"), ("key_redo", "%0"), ("key_reference", "&1"), 
                ("key_refresh", "&2"), ("key_replace", "&3"), ("key_restart", "&4"), ("key_resume", "&5"), 
                ("key_right", "kr"), ("key_save", "&6"), ("key_sbeg", "&9"), ("key_scancel", "&0"), ("key_scommand", "*1"), 
                ("key_scopy", "*2"), ("key_screate", "*3"), ("key_sdc", "*4"), ("key_sdl", "*5"), ("key_select", "*6"), 
                ("key_send", "*7"), ("key_seol", "*8"), ("key_sexit", "*9"), ("key_sf", "kF"), ("key_sfind", "*0"), 
                ("key_shelp", "#1"), ("key_shome", "#2"), ("key_sic", "#3"), ("key_sleft", "#4"), ("key_smessage", "%a"), 
                ("key_smove", "%b"), ("key_snext", "%c"), ("key_soptions", "%d"), ("key_sprevious", "%e"), 
                ("key_sprint", "%f"), ("key_sr", "kR"), ("key_sredo", "%g"), ("key_sreplace", "%h"), ("key_sright", "%i"), 
                ("key_srsume", "%j"), ("key_ssave", "!1"), ("key_ssuspend", "!2"), ("key_stab", "kT"), ("key_sundo", "!3"), 
                ("key_suspend", "&7"), ("key_undo", "&8"), ("key_up", "ku"), ("keypad_local", "ke"), ("keypad_xmit", "ks"), 
                ("lab_f0", "l0"), ("lab_f1", "l1"), ("lab_f2", "l2"), ("lab_f3", "l3"), ("lab_f4", "l4"), ("lab_f5", "l5"), 
                ("lab_f6", "l6"), ("lab_f7", "l7"), ("lab_f8", "l8"), ("lab_f9", "l9"), ("lab_f10", "la"), 
                ("label_format", "Lf"), ("label_off", "LF"), ("label_on", "LO"), ("meta_off", "mo"), ("meta_on", "mm"), 
                ("micro_column_address", "ZY"), ("micro_down", "ZZ"), ("micro_left", "Za"), ("micro_right", "Zb"), 
                ("micro_row_address", "Zc"), ("micro_up", "Zd"), ("mouse_info", "Mi"), ("newline", "nw"), 
                ("order_of_pins", "Ze"), ("orig_colors", "oc"), ("orig_pair", "op"), ("pad_char", "pc"), 
                ("parm_dch", "DC"), ("parm_delete_line", "DL"), ("parm_down_cursor", "DO"), ("parm_down_micro", "Zf"), 
                ("parm_ich", "IC"), ("parm_index", "SF"), ("parm_insert_line", "AL"), ("parm_left_cursor", "LE"), 
                ("parm_left_micro", "Zg"), ("parm_right_cursor", "RI"), ("parm_right_micro", "Zh"), ("parm_rindex", "SR"), 
                ("parm_up_cursor", "UP"), ("parm_up_micro", "Zi"), ("pc_term_options", "S6"), ("pkey_key", "pk"), 
                ("pkey_local", "pl"), ("pkey_plab", "xl"), ("pkey_xmit", "px"), ("plab_norm", "pn"), 
                ("print_screen", "ps"), ("prtr_non", "pO"), ("prtr_off", "pf"), ("prtr_on", "po"), ("pulse", "PU"), 
                ("quick_dial", "QD"), ("remove_clock", "RC"), ("repeat_char", "rp"), ("req_for_input", "RF"), 
                ("req_mouse_pos", "RQ"), ("reset_1string", "r1"), ("reset_2string", "r2"), ("reset_3string", "r3"), 
                ("reset_file", "rf"), ("restore_cursor", "rc"), ("row_address", "cv"), ("save_cursor", "sc"), 
                ("scancode_escape", "S7"), ("scroll_forward", "sf"), ("scroll_reverse", "sr"), ("select_char_set", "Zj"), 
                ("set0_des_seq", "s0"), ("set1_des_seq", "s1"), ("set2_des_seq", "s2"), ("set3_des_seq", "s3"), 
                ("set_a_background", "AB"), ("set_a_foreground", "AF"), ("set_attributes", "sa"), ("set_background", "Sb"), 
                ("set_bottom_margin", "Zk"), ("set_bottom_margin_parm", "Zl"), ("set_clock", "SC"), 
                ("set_color_band", "Yz"), ("set_color_pair", "sp"), ("set_foreground", "Sf"), ("set_left_margin", "ML"), 
                ("set_left_margin_parm", "Zm"), ("set_page_length", "YZ"), ("set_pglen_inch", "YI"), 
                ("set_right_margin", "MR"), ("set_right_margin_parm", "Zn"), ("set_tab", "st"), ("set_tb_margin", "MT"), 
                ("set_top_margin", "Zo"), ("set_top_margin_parm", "Zp"), ("set_window", "wi"), ("start_bit_image", "Zq"), 
                ("start_char_set_def", "Zr"), ("stop_bit_image", "Zs"), ("stop_char_set_def", "Zt"), 
                ("subscript_characters", "Zu"), ("superscript_characters", "Zv"), ("tab", "ta"), ("these_cause_cr", "Zw"), 
                ("to_status_line", "ts"), ("tone", "TO"), ("user0", "u0"), ("user1", "u1"), ("user2", "u2"), 
                ("user3", "u3"), ("user4", "u4"), ("user5", "u5"), ("user6", "u6"), ("user7", "u7"), ("user8", "u8"), 
                ("user9", "u9"), ("underline_char", "uc"), ("up_half_line", "hu"), ("wait_tone", "WA"), 
                ("xoff_character", "XF"), ("xon_character", "XN"), ("zero_motion", "Zx"),
            ];
        }
    }
}
pub mod time
{
    pub use std::time::{ * };
    pub mod extension
    {
        pub use timing::{ * };
    }
}
mod types
{
    use ::
    {
        collections::{ HashMap, HashSet },
        parsers::{ self, line::{ tokens_to_redirections }, },
        regex::{ Regex },
        *,
    };

    pub type Token = ( String, String );
    pub type Tokens = Vec<Token>;
    pub type Redirection = ( String, String, String );

    #[derive( Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash )]
    pub struct WaitStatus( i32, i32, i32 );

    impl WaitStatus
    {
        pub fn from_exited( pid:i32, status:i32 ) -> Self { WaitStatus( pid, 0, status ) }

        pub fn from_signaled( pid:i32, sig:i32 ) -> Self { WaitStatus( pid, 1, sig ) }

        pub fn from_stopped( pid:i32, sig:i32 ) -> Self { WaitStatus( pid, 2, sig ) }

        pub fn from_continuted( pid:i32 ) -> Self { WaitStatus( pid, 3, 0 ) }

        pub fn from_others() -> Self { WaitStatus( 0, 9, 9 ) }

        pub fn from_error( errno:i32 ) -> Self { WaitStatus( 0, 255, errno ) }

        pub fn empty() -> Self { WaitStatus( 0, 0, 0 ) }

        pub fn is_error( &self ) -> bool { self.1 == 255 }

        pub fn is_others( &self ) -> bool { self.1 == 9 }

        pub fn is_signaled( &self ) -> bool { self.1 == 1 }

        pub fn get_errno( &self ) -> nix::Error { nix::Error::from_raw( self.2 ) }

        pub fn is_exited( &self ) -> bool { self.0 != 0 && self.1 == 0 }

        pub fn is_stopped( &self ) -> bool { self.1 == 2 }

        pub fn is_continued( &self ) -> bool { self.1 == 3 }

        pub fn get_pid( &self ) -> i32 { self.0 }

        fn _get_signaled_status( &self ) -> i32 { self.2 + 128 }

        pub fn get_signal( &self ) -> i32 { self.2 }

        pub fn get_name( &self ) -> String
        {
            if self.is_exited() { "Exited".to_string() } 
            else if self.is_stopped() { "Stopped".to_string() }
            else if self.is_continued() { "Continued".to_string() } 
            else if self.is_signaled() { "Signaled".to_string() } 
            else if self.is_others() { "Others".to_string() }
            else if self.is_error() { "Error".to_string() }
            else { format!( "unknown:{}", self.2 ) }
        }

        pub fn get_status( &self ) -> i32
        {
            if self.is_exited() { self.2 } else { self._get_signaled_status() }
        }
    }

    impl fmt::Debug for WaitStatus
    {
        fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
        {
            let mut formatter = f.debug_struct( "WaitStatus" );
            formatter.field( "pid", &self.0 );
            let name = self.get_name();
            formatter.field( "name", &name );
            formatter.field( "ext", &self.2 );
            formatter.finish()
        }
    }

    #[derive( Debug )]
    pub struct LineInfo
    {
        pub tokens:Tokens,
        pub is_complete:bool,
    }

    impl LineInfo
    {
        pub fn new( tokens:Tokens ) -> Self { LineInfo { tokens, is_complete:true } }
    }
    /*
    command line:`ls 'foo bar' 2>&1 > /dev/null < one-file` would be:
    Command
    {
        tokens:[( "", "ls" ), ( "", "-G" ), ( "\'", "foo bar" )],
        redirects_to:
        [
            ( "2", ">", "&1" ),
            ( "1", ">", "/dev/null" ),
        ],
        redirect_from:Some( ( "<", "one-file" ) ),
    } */
    #[derive( Debug )]
    pub struct Command
    {
        pub tokens:Tokens,
        pub redirects_to:Vec<Redirection>,
        pub redirect_from:Option<Token>,
    }

    #[derive( Debug )]
    pub struct CommandLine
    {
        pub line:String,
        pub commands:Vec<Command>,
        pub envs:HashMap<String, String>,
        pub background:bool,
    }

    impl Command
    {
        pub fn from_tokens( tokens:Tokens ) -> Result<Command, String>
        {
            let mut tokens_new = tokens.clone();
            let mut redirects_from_type = String::new();
            let mut redirects_from_value = String::new();
            let mut has_redirect_from = tokens_new.iter().any( |x| x.1 == "<" || x.1 == "<<<" );
            let mut len = tokens_new.len();

            while has_redirect_from
            {
                if let Some( idx ) = tokens_new.iter().position( |x| x.1 == "<" )
                {
                    redirects_from_type = "<".to_string();
                    tokens_new.remove( idx );
                    len -= 1;
                    if len > idx
                    {
                        redirects_from_value = tokens_new.remove( idx ).1;
                        len -= 1;
                    }
                }

                if let Some( idx ) = tokens_new.iter().position( |x| x.1 == "<<<" )
                {
                    redirects_from_type = "<<<".to_string();
                    tokens_new.remove( idx );
                    len -= 1;
                    if len > idx
                    {
                        redirects_from_value = tokens_new.remove( idx ).1;
                        len -= 1;
                    }
                }

                has_redirect_from = tokens_new.iter().any( |x| x.1 == "<" || x.1 == "<<<" );
            }

            let tokens_final;
            let redirects_to;
            match tokens_to_redirections( &tokens_new )
            {
                Ok( ( _tokens, _redirects_to ) ) =>
                {
                    tokens_final = _tokens;
                    redirects_to = _redirects_to;
                }

                Err( e ) => { return Err( e ); }
            }

            let redirect_from = if redirects_from_type.is_empty() { None } 
            else { Some( ( redirects_from_type, redirects_from_value ) ) };

            Ok
            ( 
                Command
                {
                    tokens:tokens_final,
                    redirects_to,
                    redirect_from,
                }
            )
        }

        pub fn has_redirect_from( &self ) -> bool
        {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<"
        }

        pub fn has_here_string( &self ) -> bool
        {
            self.redirect_from.is_some() &&
            self.redirect_from.clone().unwrap().0 == "<<<"
        }

        pub fn is_builtin( &self ) -> bool { is::builtin( &self.tokens[0].1 ) }
    }

    #[derive( Debug, Clone, Default )]
    pub struct Job
    {
        pub cmd:String,
        pub id:i32,
        pub gid:i32,
        pub pids:Vec<i32>,
        pub pids_stopped:HashSet<i32>,
        pub status:String,
        pub is_bg:bool,
    }

    impl Job
    {
        pub fn all_members_stopped( &self ) -> bool
        {
            for pid in &self.pids
            {
                if !self.pids_stopped.contains( pid ) { return false; }
            }

            true
        }

        pub fn all_members_running( &self ) -> bool { self.pids_stopped.is_empty() }
    }

    #[derive( Clone, Debug, Default )]
    pub struct CommandResult
    {
        pub gid:i32,
        pub status:i32,
        pub stdout:String,
        pub stderr:String,
    }

    impl CommandResult
    {
        pub fn new() -> CommandResult
        {
            CommandResult
            {
                gid:0,
                status:0,
                stdout:String::new(),
                stderr:String::new(),
            }
        }

        pub fn from_status( gid:i32, status:i32 ) -> CommandResult
        {
            CommandResult
            {
                gid,
                status,
                stdout:String::new(),
                stderr:String::new(),
            }
        }

        pub fn error() -> CommandResult
        {
            CommandResult
            {
                gid:0,
                status:1,
                stdout:String::new(),
                stderr:String::new(),
            }
        }
    }

    #[derive( Clone, Debug, Default )]
    pub struct CommandOptions
    {
        pub background:bool,
        pub isatty:bool,
        pub capture_output:bool,
        pub envs:HashMap<String, String>,
    }

    fn split_tokens_by_pipes( tokens:&[Token] ) -> Vec<Tokens>
    {
        let mut cmd = Vec::new();
        let mut cmds = Vec::new();

        for token in tokens
        {
            let sep = &token.0;
            let value = &token.1;
            if sep.is_empty() && value == "|"
            {
                if cmd.is_empty() { return Vec::new(); }
                cmds.push( cmd.clone() );
                cmd = Vec::new();
            }
            else
            {
                cmd.push( token.clone() );
            }
        }

        if cmd.is_empty() { return Vec::new(); }
        cmds.push( cmd.clone() );
        cmds
    }

    fn drain_env_tokens( tokens:&mut Tokens ) -> HashMap<String, String>
    {
        let mut envs:HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let re = Regex::new( r"^( [a-zA-Z0-9_]+ )=( .* )$" ).unwrap();

        for ( sep, text ) in tokens.iter()
        {
            if !sep.is_empty() || !regex::re_contains( text, r"^( [a-zA-Z0-9_]+ )=( .* )$" ) { break; }
            for cap in re.captures_iter( text )
            {
                let name = cap[1].to_string();
                let value = parsers::line::unquote( &cap[2] );
                envs.insert( name, value );
            }

            n += 1;
        }

        if n > 0 { tokens.drain( 0..n ); }
        envs
    }

    impl CommandLine
    {
        pub fn from_line( line:&str, sh:&mut shell::Shell ) -> Result<CommandLine, String>
        {
            let linfo = parsers::line::parse_line( line );
            let mut tokens = linfo.tokens;
            shell::do_expansion( sh, &mut tokens );
            let envs = drain_env_tokens( &mut tokens );
            let mut background = false;
            let len = tokens.len();

            if len > 1 && tokens[len - 1].1 == "&"
            {
                background = true;
                tokens.pop();
            }

            let mut commands = Vec::new();
            for sub_tokens in split_tokens_by_pipes( &tokens )
            {
                match Command::from_tokens( sub_tokens )
                {
                    Ok( c ) => { commands.push( c ); }
                    Err( e ) => { return Err( e ); }
                }
            }

            Ok
            ( 
                CommandLine
                {
                    line:line.to_string(),
                    commands,
                    envs,
                    background,
                }
            )
        }

        pub fn is_empty( &self ) -> bool { self.commands.is_empty() }

        pub fn with_pipeline( &self ) -> bool { self.commands.len() > 1 }

        pub fn is_single_and_builtin( &self ) -> bool { self.commands.len() == 1 && self.commands[0].is_builtin() }
    }
}
pub mod vec { pub use std::vec::{ * }; }
pub unsafe fn domain()
{
    env::initialize_path_environment();
    let mut sh = shell::Shell::new();
    let args:Vec<String> = env::args().collect();
    if is::login( &args )
    {
        rc::file::load_rc_files( &mut sh );
        sh.is_login = true;
    }

    if is::script( &args )
    {
        let status = scripts::run_script( &mut sh, &args ); // log!( "run script:{:?} ", &args );
        ::process::exit( status );
    }

    if is::command_string( &args )
    {
        let line = env::arguments_to_command_line(); // log!( "run with -c args:{}", &line );
        now::run_command_line( &mut sh, &line, false, false );
        ::process::exit( sh.previous_status );
    }

    if is::non_tty()
    {
        now::run_procs_for_non_tty( &mut sh );
        return;
    }

    let mut rl;
    match Interface::new( "pls" )
    {
        Ok( x ) => { rl = x; }
        Err( e ) =>
        {
            println!( "pls:linefeed error:{}", e );
            return;
        }
    }

    rl.define_function( "enter-function", Arc::new( prompt::EnterFunction ) );
    rl.bind_sequence( "\r", Command::from_str( "enter-function" ) );
    history::init( &mut rl );
    rl.set_completer
    ( 
        Arc::new
        ( 
            completers::CicadaCompleter
            {
                sh:Arc::new( sh.clone() ),
            }
        )
    );

    let sig_handler_enabled = is::signal_handler_enabled();
    if sig_handler_enabled
    {
        signals::setup_sigchld_handler();
        signals::block_signals();
    }

    loop
    {
        let prompt = get::prompt( &sh );
        match rl.set_prompt( &prompt )
        {
            Ok( _ ) => {}
            Err( e ) => { println_stderr!( "pls:prompt error:{}", e ); }
        }

        if sig_handler_enabled { signals::unblock_signals(); }

        match rl.read_line()
        {
            Ok( ReadResult::Input( line ) ) =>
            {
                if sig_handler_enabled { signals::block_signals(); }

                let line = shell::trim_multiline_prompts( &line );
                if line.trim() == ""
                {
                    c::job::try_wait_bg_jobs( &mut sh, true, sig_handler_enabled );
                    continue;
                }
                sh.cmd = line.clone();

                let tsb = c::time::DateTime::now().unix_timestamp();
                let mut line = line.clone();
                path::extend_bangbang( &sh, &mut line );

                let mut status = 0; //log!( "run now::run_command_line:{}", line );

                let cr_list = now::run_command_line( &mut sh, &line, true, false );
                if let Some( last ) = cr_list.last() { status = last.status; }

                let tse = c::time::DateTime::now().unix_timestamp();
                if !sh.cmd.starts_with( ' ' ) && line != sh.previous_cmd
                {
                    history::add( &sh, &mut rl, &line, status, tsb, tse );
                    sh.previous_cmd = line.clone();
                }

                if is::shell_altering_command( &line )
                {
                    rl.set_completer
                    ( 
                        Arc::new
                        ( 
                            completers::CicadaCompleter
                            {
                                sh:Arc::new( sh.clone() ),
                            }
                        )
                    );
                }

                c::job::try_wait_bg_jobs( &mut sh, true, sig_handler_enabled );
                continue;
            }

            Ok( ReadResult::Eof ) =>
            {
                if let Ok( x ) = env::var( "NO_EXIT_ON_CTRL_D" ) { if x == "1" { println!(); } }
                else
                {
                    println!( "exit" );
                    break;
                }
            }

            Ok( ReadResult::Signal( s ) ) => { println_stderr!( "readline signal:{:?}", s ); }

            Err( e ) =>
            {
                println_stderr!( "readline error:{}", e );
                let gid = libc::getpgid( 0 );
                shell::give_terminal_to( gid );
            }
        }

        if sig_handler_enabled { signals::block_signals(); }
    }
}

fn main()
{
    unsafe
    {
        libc::signal( libc::SIGPIPE, libc::SIG_DFL );
        libc::signal( libc::SIGTSTP, libc::SIG_IGN );
        libc::signal( libc::SIGQUIT, libc::SIG_IGN );
        domain();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 36602
