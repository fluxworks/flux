/*!
*/
#![feature
(

)]
#![allow
(
    non_camel_case_types,
    unused_attributes,
    unused_imports,
    unused_macros,
)]

#[macro_use] extern crate cfg_if;

extern crate libc;

/*
openssl-sys = { version = "0.9.103", optional = true }
    [package]
        name = "openssl"
        version = "0.10.65"
        authors = ["Steven Fackler <sfackler@gmail.com>"]
        license = "Apache-2.0"
        description = "OpenSSL bindings"
        repository = "https://github.com/sfackler/rust-openssl"
        readme = "README.md"
        keywords = ["crypto", "tls", "ssl", "dtls"]
        categories = ["cryptography", "api-bindings"]
        edition = "2018"
        
        [features]
            v101 = []
            v102 = []
            v110 = []
            v111 = []

            vendored = ['ffi/vendored']
            bindgen = ['ffi/bindgen']
            unstable_boringssl = ["ffi/unstable_boringssl"]
            default = []

        [dependencies]
                foreign-types-shared = "0.1.0"
                foreign-types = "0.3.1"

            openssl-macros = { version = "0.1.0", path = "../openssl-macros" }
            ffi = { package = "openssl-sys", version = "0.9.103", path = "../openssl-sys" }
                bitflags = "2.2.1"
                cfg-if = "1.0"
                libc = "0.2"
                once_cell = "1.5.2"

[package]
    name = "libsqlite3-sys"
    version = "0.35.0"
    authors = ["The rusqlite developers"]
    edition = "2021"
    repository = "https://github.com/rusqlite/rusqlite"
    description = "Native bindings to the libsqlite3 library"
    license = "MIT"
    links = "sqlite3"
    build = "build.rs"
    keywords = ["sqlite", "sqlcipher", "ffi"]
    categories = ["external-ffi-bindings"]

[features]
    default = ["min_sqlite_version_3_14_0"]
    bundled = ["cc", "bundled_bindings"]
    bundled-windows = ["cc", "bundled_bindings"]
    bundled-sqlcipher = ["bundled"]
    bundled-sqlcipher-vendored-openssl = 
    [
        "bundled-sqlcipher",
        "openssl-sys/vendored",
    ]
    buildtime_bindgen = ["bindgen", "pkg-config", "vcpkg"]
    sqlcipher = []
    min_sqlite_version_3_14_0 = ["pkg-config", "vcpkg"]
    # Bundle only the bindings file. Note that this does nothing if `buildtime_bindgen` is enabled.
    bundled_bindings = []
    loadable_extension = ["prettyplease", "quote", "syn"]
    unlock_notify = []
    column_metadata = []
    preupdate_hook = ["buildtime_bindgen"]
    session = ["preupdate_hook", "buildtime_bindgen"]
    in_gecko = []
    with-asan = []
    wasm32-wasi-vfs = []

[dependencies]
    

[build-dependencies]
    bindgen =
    { 
        version = "0.72", optional = true, default-features = false, features = 
        [
            "runtime",
        ]
    }
    pkg-config = { version = "0.3.19", optional = true }
    cc = { version = "1.1.6", optional = true }
    vcpkg = { version = "0.2.15", optional = true }
    prettyplease = { version = "0.2.20", optional = true }
    quote = { version = "1.0.36", optional = true, default-features = false }
    syn = 
    { 
        version = "2.0.72", optional = true, features = 
        [
            "full",
            "extra-traits",
            "visit-mut",
        ] 
    }


{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
}

pub mod _
{
    pub use std::_::{ * };
}
*/

#[macro_use] pub mod macros
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
    // vendored from the cfg-if crate to avoid breaking ctest
    macro_rules! cfg_if 
    {
        // match if/else chains with a final `else`
        ($(
            if #[cfg($($meta:meta),*)] { $($it:item)* }
        ) else * else {
            $($it2:item)*
        }) => {
            cfg_if! {
                @__items
                () ;
                $( ( ($($meta),*) ($($it)*) ), )*
                ( () ($($it2)*) ),
            }
        };

        // match if/else chains lacking a final `else`
        (
            if #[cfg($($i_met:meta),*)] { $($i_it:item)* }
            $(
                else if #[cfg($($e_met:meta),*)] { $($e_it:item)* }
            )*
        ) => {
            cfg_if! {
                @__items
                () ;
                ( ($($i_met),*) ($($i_it)*) ),
                $( ( ($($e_met),*) ($($e_it)*) ), )*
                ( () () ),
            }
        };

        // Internal and recursive macro to emit all the items
        //
        // Collects all the negated cfgs in a list at the beginning and after the
        // semicolon is all the remaining items
        (@__items ($($not:meta,)*) ; ) => {};
        (@__items ($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {
            // Emit all items within one block, applying an appropriate #[cfg]. The
            // #[cfg] will require all `$m` matchers specified and must also negate
            // all previous matchers.
            cfg_if! { @__apply cfg(all($($m,)* not(any($($not),*)))), $($it)* }

            // Recurse to emit all other items in `$rest`, and when we do so add all
            // our `$m` matchers to the list of `$not` matchers as future emissions
            // will have to negate everything we just matched as well.
            cfg_if! { @__items ($($not,)* $($m,)*) ; $($rest)* }
        };

        // Internal macro to Apply a cfg attribute to a list of items
        (@__apply $m:meta, $($it:item)*) => {
            $(#[$m] $it)*
        };
    }

    macro_rules! stack 
    {
        ($t:ident) => {
            cfg_if! {
                if #[cfg(any(ossl110, libressl390))] {
                    pub enum $t {}
                } else {
                    #[repr(C)]
                    pub struct $t {
                        pub stack: $crate::_STACK,
                    }
                }
            }
        };
    }

    // openssl changes `*mut` to `*const` in certain parameters in certain versions;
    // in C this is ABI and (mostly) API compatible.
    //
    // We need to handle this explicitly, and this macro helps annotate which
    // parameter got converted in which version.
    //
    // Input is:
    //    extern "C" {
    //        #[attributes...]
    //        pub fn name(args) -> rettype; // `-> rettype` optional
    //        // more functions...
    //    }
    //
    // This macro replaces `#[const_ptr_if(...)]` in types with `*const` or `*mut`
    // (depending on the inner cfg flags)
    //
    // Walks through all argument and return types, but only finds inner types of
    // `*const` and `*mut`; doesn't walk arrays or generics.
    //
    // NOTE: can't abstract `pub` as `$fn_vis:vis`, as ctest macro handling doesn't
    // support it (old syntax crate). But we really only need `pub` anyway.
    //
    // NOTE: ctest seams to simply ignore macros it can't expand (whatever the
    // reason)
    macro_rules! const_ptr_api 
    {
        // ----------------------------------------------------------------
        // (partialarg): partial argument, waiting for "final" argument type
        // MAGIC PART 1: hande conditional const ptr in argument type
        ( (partialarg)
            { $(#[$fn_attr:meta])* pub fn $fn_name:ident }
            $args_packed:tt
            [ $($part_arg:tt)* ]
            [ #[const_ptr_if( $($cfg:tt)* )] $($arg_rem:tt)* ]
            $ret_packed:tt
        ) => {
            const_ptr_api!( (partialarg) { #[cfg($($cfg)*)]      $(#[$fn_attr])* pub fn $fn_name } $args_packed [ $($part_arg)* *const ] [ $($arg_rem)* ] $ret_packed );
            const_ptr_api!( (partialarg) { #[cfg(not($($cfg)*))] $(#[$fn_attr])* pub fn $fn_name } $args_packed [ $($part_arg)* *mut   ] [ $($arg_rem)* ] $ret_packed );
        };
        // continue partial argument with `*mut` pointer (might need special const handling in inner type)
        ( (partialarg)
            $def_packed:tt
            $args_packed:tt
            [ $($part_arg:tt)* ]
            [ *mut $($arg_rem:tt)* ]
            $ret_packed:tt
        ) => {
            const_ptr_api!( (partialarg) $def_packed $args_packed [ $($part_arg)* *mut ] [ $($arg_rem)* ] $ret_packed );
        };
        // continue partial argument with `*const` pointer (might need special const handling in inner type)
        ( (partialarg)
            $def_packed:tt
            $args_packed:tt
            [ $($part_arg:tt)* ]
            [ *const $($arg_rem:tt)* ]
            $ret_packed:tt
        ) => {
            const_ptr_api!( (partialarg) $def_packed $args_packed [ $($part_arg)* *const ] [ $($arg_rem)* ] $ret_packed );
        };
        // finish partial argument with trailing comma
        ( (partialarg)
            $def_packed:tt
            { $($args_tt:tt)* }
            [ $($part_arg:tt)* ]
            [ $arg_ty:ty, $($arg_rem:tt)* ]
            $ret_packed:tt
        ) => {
            const_ptr_api!( (parseargs) $def_packed { $($args_tt)* { $($part_arg)* $arg_ty } } [ $($arg_rem)* ] $ret_packed );
        };
        // finish final partial argument (no trailing comma)
        ( (partialarg)
            $def_packed:tt
            { $($args_tt:tt)* }
            [ $($part_arg:tt)* ]
            [ $arg_ty:ty ]
            $ret_packed:tt
        ) => {
            const_ptr_api!( (parseargs) $def_packed { $($args_tt)* { $($part_arg)* $arg_ty } } [ ] $ret_packed );
        };

        // ----------------------------------------------------------------
        // (parseargs): parsing arguments
        // start next argument
        ( (parseargs)
            $def_packed:tt
            $args_packed:tt
            [ $arg_name:ident : $($arg_rem:tt)* ]
            $ret_packed:tt
        ) => {
            const_ptr_api!( (partialarg) $def_packed $args_packed [ $arg_name: ] [ $($arg_rem)* ] $ret_packed );
        };
        // end of arguments, there is a return type; start parsing it
        ( (parseargs)
            $def_packed:tt
            $args_packed:tt
            [ ]
            [ -> $($rem:tt)* ]
        ) => {
            const_ptr_api!( (partialret) $def_packed $args_packed [] [ $($rem)* ] );
        };
        // end of arguments, no return type
        ( (parseargs)
            $def_packed:tt
            $args_packed:tt
            [ ]
            [ ]
        ) => {
            const_ptr_api!( (generate) $def_packed $args_packed { () } );
        };

        // ----------------------------------------------------------------
        // (partialret): have partial return type, waiting for final return type
        // MAGIC PART 2: hande conditional const ptr in return type
        ( (partialret)
            { $(#[$fn_attr:meta])* pub fn $fn_name:ident }
            $args_packed:tt
            [ $($part_ret:tt)* ]
            [ #[const_ptr_if( $($cfg:tt)* )] $($rem:tt)* ]
        ) => {
            const_ptr_api!( (partialret) { #[cfg($($cfg)*)]      $(#[$fn_attr])* pub fn $fn_name } $args_packed [ $($part_ret)* *const ] [ $($rem)* ] );
            const_ptr_api!( (partialret) { #[cfg(not($($cfg)*))] $(#[$fn_attr])* pub fn $fn_name } $args_packed [ $($part_ret)* *mut   ] [ $($rem)* ] );
        };
        // `* mut` part in return type; continue parsing to find inner conditional const ptr
        ( (partialret)
            $def_packed:tt
            $args_packed:tt
            [ $($part_ret:tt)* ]
            [ *mut $($rem:tt)* ]
        ) => {
            const_ptr_api!( (partialret) $def_packed $args_packed [ $($part_ret)* *mut ] [ $($rem)* ] );
        };
        // `* const` part in return type; continue parsing to find inner conditional const ptr
        ( (partialret)
            $def_packed:tt
            $args_packed:tt
            [ $($part_ret:tt)* ]
            [ *const $($rem:tt)* ]
        ) => {
            const_ptr_api!( (partialret) $def_packed $args_packed [ $($part_ret)* *const ] [ $($rem)* ] );
        };
        // final part of return type
        ( (partialret)
            $def_packed:tt
            $args_packed:tt
            [ $($part_ret:tt)* ]
            [ $ret_ty:ty ]
        ) => {
            const_ptr_api!( (generate) $def_packed $args_packed { $($part_ret)* $ret_ty } );
        };

        // ----------------------------------------------------------------
        // generate
        ( (generate)
            { $(#[$fn_attr:meta])* pub fn $fn_name:ident }
            { $({ $arg_name:ident: $($arg_ty:tt)* })* }
            { $ret_ty:ty }
        ) => {
            extern "C" {
                $(#[$fn_attr])*
                pub fn $fn_name( $(
                    $arg_name: $($arg_ty)*
                ),* ) -> $ret_ty;
            }
        };

        // ----------------------------------------------------------------
        // (fn): gather tokens for return type until ";"
        // found end; start parsing current function, and parse remaining functions
        ( (fn)
            $def_packed:tt
            $arg_tts_packed:tt
            $ret_packed:tt
            [ ; $($rem:tt)* ]
        ) => {
            const_ptr_api!( (parseargs) $def_packed {} $arg_tts_packed $ret_packed );
            const_ptr_api!( (extern) [ $($rem)* ] );
        };
        // not ";" - all other tokens are part of the return type.
        // don't expand return type yet; otherwise we'd have to remember in which branch `rem` needs
        // to be used to parse further functions.
        ( (fn)
            $def_packed:tt
            $arg_tts_packed:tt
            [ $($ret_tt:tt)* ]
            [ $tt:tt $($rem:tt)* ]
        ) => {
            const_ptr_api!( (fn) $def_packed $arg_tts_packed [ $($ret_tt)* $tt ] [ $($rem)* ] );
        };

        // ----------------------------------------------------------------
        // (extern): in extern block, find next function
        // try to split into functions as fast as possible to reduce recursion depth
        ( (extern) [
            $(#[$fn_attr:meta])*
            pub fn $fn_name:ident( $($arg_rem:tt)* ) $($rem:tt)*
        ] ) => {
            const_ptr_api!( (fn)
                { $(#[$fn_attr])* pub fn $fn_name } [ $($arg_rem)* ] [] [ $($rem)* ]
            );
        };
        // end of extern block
        ( (extern) [] ) => {};

        // ----------------------------------------------------------------
        // macro start; find extern block
        ( extern "C" { $($rem:tt)* } ) => {
            const_ptr_api!( (extern) [ $($rem)* ] );
        };
    }
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod convert
{
    pub use std::convert::{ * };
}

pub mod cell
{
    pub use std::cell::{ * };
}

pub mod foreign
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
    pub mod shared
    {
        /*!
        An internal crate used by foreign-types */
        use ::
        {
            cell::{ UnsafeCell },
            *,
        };
        /*
        */
        /// An opaque type used to define `ForeignTypeRef` types.
        pub struct Opaque( UnsafeCell<()> );
        /// A trait implemented by types which reference borrowed foreign types.
        pub trait ForeignTypeRef:Sized
        {
            /// The raw C type.
            type CType;
            /// Constructs a shared instance of this type from its raw type.
            #[inline] unsafe fn from_ptr<'a>(ptr: *mut Self::CType) -> &'a Self
            {
                &*(ptr as *mut _)
            }
            /// Constructs a mutable reference of this type from its raw type.
            #[inline] unsafe fn from_ptr_mut<'a>(ptr: *mut Self::CType) -> &'a mut Self
            {
                &mut *(ptr as *mut _)
            }
            /// Returns a raw pointer to the wrapped value.
            #[inline] fn as_ptr(&self) -> *mut Self::CType
            {
                self as *const _ as *mut _
            }
        }
        /// A type implemented by wrappers over foreign types.
        pub trait ForeignType:Sized
        {
            /// The raw C type.
            type CType;
            /// The type representing a reference to this type.
            type Ref: ForeignTypeRef<CType = Self::CType>;
            /// Constructs an instance of this type from its raw type.
            unsafe fn from_ptr(ptr: *mut Self::CType) -> Self;
            /// Returns a raw pointer to the wrapped value.
            fn as_ptr(&self) -> *mut Self::CType;
        }

    }
    /*
    */
    pub mod types
    {
        /*!
        A framework for Rust wrappers over C APIs. */
        use ::
        {
            foreign::shared::{ self, * },
            *,
        };
        /*
        */
        /// A macro to easily define wrappers for foreign types.
        #[macro_export] macro_rules! foreign_type
        {
            (
                $(#[$impl_attr:meta])*
                type CType = $ctype:ty;
                fn drop = $drop:expr;
                $(fn clone = $clone:expr;)*
                $(#[$owned_attr:meta])*
                pub struct $owned:ident;
                $(#[$borrowed_attr:meta])*
                pub struct $borrowed:ident;
            ) =>
            {
                $(#[$owned_attr])*
                pub struct $owned(*mut $ctype);

                $(#[$impl_attr])*
                impl ::foreign::types::ForeignType for $owned
                {
                    type CType = $ctype;
                    type Ref = $borrowed;
                    #[inline] unsafe fn from_ptr(ptr: *mut $ctype) -> $owned 
                    {
                        $owned(ptr)
                    }

                    #[inline] fn as_ptr(&self) -> *mut $ctype
                    {
                        self.0
                    }
                }

                impl Drop for $owned
                {
                    #[inline] fn drop(&mut self) { unsafe { $drop(self.0) } }
                }

                $(
                    impl Clone for $owned
                    {
                        #[inline] fn clone(&self) -> $owned
                        {
                            unsafe
                            {
                                let handle: *mut $ctype = $clone(self.0);
                                ::foreign::types::ForeignType::from_ptr( handle )
                            }
                        }
                    }

                    impl ::borrow::ToOwned for $borrowed 
                    {
                        type Owned = $owned;
                        #[inline] fn to_owned(&self) -> $owned
                        {
                            unsafe
                            {
                                let handle: *mut $ctype = $clone( ::foreign::types::ForeignTypeRef::as_ptr( self ) );
                                ::foreign::types::ForeignType::from_ptr( handle )
                            }
                        }
                    }
                )*

                impl ::ops::Deref for $owned
                {
                    type Target = $borrowed;
                    #[inline] fn deref(&self) -> &$borrowed
                    {
                        unsafe { ::foreign::types::ForeignTypeRef::from_ptr(self.0) }
                    }
                }

                impl ::ops::DerefMut for $owned
                {
                    #[inline] fn deref_mut(&mut self) -> &mut $borrowed
                    {
                        unsafe { ::foreign::types::ForeignTypeRef::from_ptr_mut(self.0) }
                    }
                }

                impl ::borrow::Borrow<$borrowed> for $owned
                {
                    #[inline] fn borrow(&self) -> &$borrowed { &**self }
                }

                impl ::convert::AsRef<$borrowed> for $owned
                {
                    #[inline] fn as_ref(&self) -> &$borrowed { &**self }
                }

                $(#[$borrowed_attr])*
                pub struct $borrowed($crate::Opaque);

                $(#[$impl_attr])*
                impl ::foreign::types::ForeignTypeRef for $borrowed
                {
                    type CType = $ctype;
                }
            }
        }
    }
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod ops
{
    pub use std::ops::{ * };
}

pub mod option
{
    pub use std::option::{ * };
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };
}

pub mod system
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
    pub mod openssl
    {
        /*!
        */
        use ::
        {
            libc::{ * },
            sync::{ Once },
            system::
            {
                openssl::crypto::{ CRYPTO_LOCK, },
            },
            *,
        };
        /*
        */
        // explicitly initialize to work around https://github.com/openssl/openssl/issues/3505
        static INIT: Once = Once::new();
        
        pub mod aes
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            pub const AES_ENCRYPT:c_int = 1;
            pub const AES_DECRYPT:c_int = 0;
            pub const AES_MAXNR:c_int = 14;
            pub const AES_BLOCK_SIZE:c_int = 16;
            
            #[repr(C)]
            pub struct AES_KEY {
                // There is some business with AES_LONG which is there to ensure the values here are 32 bits
                rd_key: [u32; 4 * (AES_MAXNR as usize + 1)],
                rounds: c_int,
            }

            extern "C" {
                pub fn AES_set_encrypt_key(userKey: *const c_uchar, bits: c_int, key: *mut AES_KEY) -> c_int;
                pub fn AES_set_decrypt_key(userKey: *const c_uchar, bits: c_int, key: *mut AES_KEY) -> c_int;

                #[cfg(not(osslconf = "OPENSSL_NO_DEPRECATED_3_0"))]
                pub fn AES_ige_encrypt(
                    in_: *const c_uchar,
                    out: *mut c_uchar,
                    length: size_t,
                    key: *const AES_KEY,
                    ivec: *mut c_uchar,
                    enc: c_int,
                );

                pub fn AES_wrap_key(
                    key: *mut AES_KEY,
                    iv: *const c_uchar,
                    out: *mut c_uchar,
                    in_: *const c_uchar,
                    inlen: c_uint,
                ) -> c_int;

                pub fn AES_unwrap_key(
                    key: *mut AES_KEY,
                    iv: *const c_uchar,
                    out: *mut c_uchar,
                    in_: *const c_uchar,
                    inlen: c_uint,
                ) -> c_int;
            }
        }

        pub mod asn1
        {
            /*!
            ASN.1 tag values */
            use ::
            {
                libc::{ c_int },
                *,
            };
            /*
            */
            pub const V_ASN1_EOC: c_int = 0;
            pub const V_ASN1_BOOLEAN: c_int = 1;
            pub const V_ASN1_INTEGER: c_int = 2;
            pub const V_ASN1_BIT_STRING: c_int = 3;
            pub const V_ASN1_OCTET_STRING: c_int = 4;
            pub const V_ASN1_NULL: c_int = 5;
            pub const V_ASN1_OBJECT: c_int = 6;
            pub const V_ASN1_OBJECT_DESCRIPTOR: c_int = 7;
            pub const V_ASN1_EXTERNAL: c_int = 8;
            pub const V_ASN1_REAL: c_int = 9;
            pub const V_ASN1_ENUMERATED: c_int = 10;
            pub const V_ASN1_UTF8STRING: c_int = 12;
            pub const V_ASN1_SEQUENCE: c_int = 16;
            pub const V_ASN1_SET: c_int = 17;
            pub const V_ASN1_NUMERICSTRING: c_int = 18;
            pub const V_ASN1_PRINTABLESTRING: c_int = 19;
            pub const V_ASN1_T61STRING: c_int = 20;
            pub const V_ASN1_TELETEXSTRING: c_int = 20;
            pub const V_ASN1_VIDEOTEXSTRING: c_int = 21;
            pub const V_ASN1_IA5STRING: c_int = 22;
            pub const V_ASN1_UTCTIME: c_int = 23;
            pub const V_ASN1_GENERALIZEDTIME: c_int = 24;
            pub const V_ASN1_GRAPHICSTRING: c_int = 25;
            pub const V_ASN1_ISO64STRING: c_int = 26;
            pub const V_ASN1_VISIBLESTRING: c_int = 26;
            pub const V_ASN1_GENERALSTRING: c_int = 27;
            pub const V_ASN1_UNIVERSALSTRING: c_int = 28;
            pub const V_ASN1_BMPSTRING: c_int = 30;
            pub const MBSTRING_FLAG: c_int = 0x1000;
            pub const MBSTRING_UTF8: c_int = MBSTRING_FLAG;
            pub const MBSTRING_ASC: c_int = MBSTRING_FLAG | 1;
            pub const MBSTRING_BMP: c_int = MBSTRING_FLAG | 2;
            pub const MBSTRING_UNIV: c_int = MBSTRING_FLAG | 4;
        }

        pub mod bio
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            pub const BIO_TYPE_NONE: c_int = 0;

            pub const BIO_CTRL_EOF: c_int = 2;
            pub const BIO_CTRL_INFO: c_int = 3;
            pub const BIO_CTRL_FLUSH: c_int = 11;
            pub const BIO_CTRL_DGRAM_QUERY_MTU: c_int = 40;
            pub const BIO_C_SET_BUF_MEM_EOF_RETURN: c_int = 130;

            pub unsafe fn BIO_set_retry_read(b: *mut BIO) {
                BIO_set_flags(b, BIO_FLAGS_READ | BIO_FLAGS_SHOULD_RETRY)
            }

            pub unsafe fn BIO_set_retry_write(b: *mut BIO) {
                BIO_set_flags(b, BIO_FLAGS_WRITE | BIO_FLAGS_SHOULD_RETRY)
            }

            pub unsafe fn BIO_clear_retry_flags(b: *mut BIO) {
                BIO_clear_flags(b, BIO_FLAGS_RWS | BIO_FLAGS_SHOULD_RETRY)
            }

            pub const BIO_FLAGS_READ: c_int = 0x01;
            pub const BIO_FLAGS_WRITE: c_int = 0x02;
            pub const BIO_FLAGS_IO_SPECIAL: c_int = 0x04;
            pub const BIO_FLAGS_RWS: c_int = BIO_FLAGS_READ | BIO_FLAGS_WRITE | BIO_FLAGS_IO_SPECIAL;
            pub const BIO_FLAGS_SHOULD_RETRY: c_int = 0x08;

            pub unsafe fn BIO_get_mem_data(b: *mut BIO, pp: *mut *mut c_char) -> c_long {
                BIO_ctrl(b, BIO_CTRL_INFO, 0, pp as *mut c_void)
            }

            extern "C" 
            {
                #[deprecated(note = "use BIO_meth_set_write__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_write(
                    biom: *mut BIO_METHOD,
                    write: unsafe extern "C" fn(*mut BIO, *const c_char, c_int) -> c_int,
                ) -> c_int;
                
                #[deprecated(note = "use BIO_meth_set_read__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_read(
                    biom: *mut BIO_METHOD,
                    read: unsafe extern "C" fn(*mut BIO, *mut c_char, c_int) -> c_int,
                ) -> c_int;

                #[deprecated(note = "use BIO_meth_set_puts__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_puts(
                    biom: *mut BIO_METHOD,
                    read: unsafe extern "C" fn(*mut BIO, *const c_char) -> c_int,
                ) -> c_int;

                #[deprecated(note = "use BIO_meth_set_ctrl__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_ctrl(
                    biom: *mut BIO_METHOD,
                    read: unsafe extern "C" fn(*mut BIO, c_int, c_long, *mut c_void) -> c_long,
                ) -> c_int;

                #[deprecated(note = "use BIO_meth_set_create__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_create(
                    biom: *mut BIO_METHOD,
                    create: unsafe extern "C" fn(*mut BIO) -> c_int,
                ) -> c_int;

                #[deprecated(note = "use BIO_meth_set_destroy__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_destroy(
                    biom: *mut BIO_METHOD,
                    destroy: unsafe extern "C" fn(*mut BIO) -> c_int,
                ) -> c_int;
            }

            cfg_if!
            {
                if #[cfg(ossl320)]
                {
                    use ::ptr;

                    pub const BIO_CTRL_DGRAM_GET_MTU: c_int = 41;
                    pub const BIO_CTRL_DGRAM_SET_MTU: c_int = 42;
                    pub const BIO_CTRL_DGRAM_GET_LOCAL_ADDR_CAP: c_int = 82;
                    pub const BIO_CTRL_DGRAM_GET_LOCAL_ADDR_ENABLE: c_int = 83;
                    pub const BIO_CTRL_DGRAM_SET_LOCAL_ADDR_ENABLE: c_int = 84;
                    pub const BIO_CTRL_DGRAM_GET_CAPS: c_int = 86;
                    pub const BIO_CTRL_DGRAM_SET_CAPS: c_int = 87;
                    pub const BIO_CTRL_DGRAM_GET_NO_TRUNC: c_int = 88;
                    pub const BIO_CTRL_DGRAM_SET_NO_TRUNC: c_int = 89;

                    pub unsafe fn BIO_dgram_get_no_trunc(bio: *mut BIO) -> c_int { BIO_ctrl(bio, BIO_CTRL_DGRAM_GET_NO_TRUNC, 0, ptr::null_mut()) as c_int }
                    
                    pub unsafe fn BIO_dgram_set_no_trunc(bio: *mut BIO, enable: c_int) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_SET_NO_TRUNC, enable as c_long, ptr::null_mut()) as c_int }
                    
                    pub unsafe fn BIO_dgram_get_cap(bio: *mut BIO) -> u32
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_GET_CAPS, 0, ptr::null_mut()) as u32 }
                    
                    pub unsafe fn BIO_dgram_set_cap(bio: *mut BIO, cap: u32) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_SET_CAPS, cap as c_long, ptr::null_mut()) as c_int }
                    
                    pub unsafe fn BIO_dgram_get_local_addr_cap(bio: *mut BIO) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_GET_LOCAL_ADDR_CAP, 0, ptr::null_mut()) as c_int }
                    
                    pub unsafe fn BIO_dgram_get_local_addr_enable(bio: *mut BIO, enable: *mut c_int) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_GET_LOCAL_ADDR_ENABLE, 0, enable as *mut c_void) as c_int }

                    pub unsafe fn BIO_dgram_set_local_addr_enable(bio: *mut BIO, enable: c_int) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_SET_LOCAL_ADDR_ENABLE, enable as c_long, ptr::null_mut()) as c_int }

                    pub unsafe fn BIO_dgram_get_mtu(bio: *mut BIO) -> c_uint
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_GET_MTU, 0, ptr::null_mut()) as c_uint }

                    pub unsafe fn BIO_dgram_set_mtu(bio: *mut BIO, mtu: c_uint) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_SET_MTU, mtu as c_long, ptr::null_mut()) as c_int }
                }
            }
        }

        pub mod bn
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            pub const BIO_TYPE_NONE: c_int = 0;
            pub const BIO_CTRL_EOF: c_int = 2;
            pub const BIO_CTRL_INFO: c_int = 3;
            pub const BIO_CTRL_FLUSH: c_int = 11;
            pub const BIO_CTRL_DGRAM_QUERY_MTU: c_int = 40;
            pub const BIO_C_SET_BUF_MEM_EOF_RETURN: c_int = 130;
            pub const BIO_FLAGS_READ: c_int = 0x01;
            pub const BIO_FLAGS_WRITE: c_int = 0x02;
            pub const BIO_FLAGS_IO_SPECIAL: c_int = 0x04;
            pub const BIO_FLAGS_RWS: c_int = BIO_FLAGS_READ | BIO_FLAGS_WRITE | BIO_FLAGS_IO_SPECIAL;
            pub const BIO_FLAGS_SHOULD_RETRY: c_int = 0x08;

            pub unsafe fn BIO_set_retry_read(b: *mut BIO) 
            {
                BIO_set_flags(b, BIO_FLAGS_READ | BIO_FLAGS_SHOULD_RETRY)
            }

            pub unsafe fn BIO_set_retry_write(b: *mut BIO) 
            {
                BIO_set_flags(b, BIO_FLAGS_WRITE | BIO_FLAGS_SHOULD_RETRY)
            }

            pub unsafe fn BIO_clear_retry_flags(b: *mut BIO) 
            {
                BIO_clear_flags(b, BIO_FLAGS_RWS | BIO_FLAGS_SHOULD_RETRY)
            }

            pub unsafe fn BIO_get_mem_data(b: *mut BIO, pp: *mut *mut c_char) -> c_long 
            {
                BIO_ctrl(b, BIO_CTRL_INFO, 0, pp as *mut c_void)
            }

            extern "C" 
            {
                #[deprecated(note = "use BIO_meth_set_write__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_write(
                    biom: *mut BIO_METHOD,
                    write: unsafe extern "C" fn(*mut BIO, *const c_char, c_int) -> c_int,
                ) -> c_int;
                
                #[deprecated(note = "use BIO_meth_set_read__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_read(
                    biom: *mut BIO_METHOD,
                    read: unsafe extern "C" fn(*mut BIO, *mut c_char, c_int) -> c_int,
                ) -> c_int;
                
                #[deprecated(note = "use BIO_meth_set_puts__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_puts(
                    biom: *mut BIO_METHOD,
                    read: unsafe extern "C" fn(*mut BIO, *const c_char) -> c_int,
                ) -> c_int;
                
                #[deprecated(note = "use BIO_meth_set_ctrl__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_ctrl(
                    biom: *mut BIO_METHOD,
                    read: unsafe extern "C" fn(*mut BIO, c_int, c_long, *mut c_void) -> c_long,
                ) -> c_int;
                
                #[deprecated(note = "use BIO_meth_set_create__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_create
                (
                    biom: *mut BIO_METHOD,
                    create: unsafe extern "C" fn(*mut BIO) -> c_int,
                ) -> c_int;

                #[deprecated(note = "use BIO_meth_set_destroy__fixed_rust instead")]
                #[cfg(any(ossl110, libressl273))]
                pub fn BIO_meth_set_destroy
                (
                    biom: *mut BIO_METHOD,
                    destroy: unsafe extern "C" fn(*mut BIO) -> c_int,
                ) -> c_int;
            }

            cfg_if! 
            {
                if #[cfg(ossl320)]
                {
                    use ::ptr;

                    pub const BIO_CTRL_DGRAM_GET_MTU: c_int = 41;
                    pub const BIO_CTRL_DGRAM_SET_MTU: c_int = 42;
                    pub const BIO_CTRL_DGRAM_GET_LOCAL_ADDR_CAP: c_int = 82;
                    pub const BIO_CTRL_DGRAM_GET_LOCAL_ADDR_ENABLE: c_int = 83;
                    pub const BIO_CTRL_DGRAM_SET_LOCAL_ADDR_ENABLE: c_int = 84;
                    pub const BIO_CTRL_DGRAM_GET_CAPS: c_int = 86;
                    pub const BIO_CTRL_DGRAM_SET_CAPS: c_int = 87;
                    pub const BIO_CTRL_DGRAM_GET_NO_TRUNC: c_int = 88;
                    pub const BIO_CTRL_DGRAM_SET_NO_TRUNC: c_int = 89;

                    pub unsafe fn BIO_dgram_get_no_trunc(bio: *mut BIO) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_GET_NO_TRUNC, 0, ptr::null_mut()) as c_int }
                    
                    pub unsafe fn BIO_dgram_set_no_trunc(bio: *mut BIO, enable: c_int) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_SET_NO_TRUNC, enable as c_long, ptr::null_mut()) as c_int }
                    
                    pub unsafe fn BIO_dgram_get_cap(bio: *mut BIO) -> u32
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_GET_CAPS, 0, ptr::null_mut()) as u32 }
                    
                    pub unsafe fn BIO_dgram_set_cap(bio: *mut BIO, cap: u32) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_SET_CAPS, cap as c_long, ptr::null_mut()) as c_int }
                    
                    pub unsafe fn BIO_dgram_get_local_addr_cap(bio: *mut BIO) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_GET_LOCAL_ADDR_CAP, 0, ptr::null_mut()) as c_int }
                    
                    pub unsafe fn BIO_dgram_get_local_addr_enable(bio: *mut BIO, enable: *mut c_int) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_GET_LOCAL_ADDR_ENABLE, 0, enable as *mut c_void) as c_int }
                    
                    pub unsafe fn BIO_dgram_set_local_addr_enable(bio: *mut BIO, enable: c_int) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_SET_LOCAL_ADDR_ENABLE, enable as c_long, ptr::null_mut()) as c_int }
                    
                    pub unsafe fn BIO_dgram_get_mtu(bio: *mut BIO) -> c_uint
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_GET_MTU, 0, ptr::null_mut()) as c_uint }
                    
                    pub unsafe fn BIO_dgram_set_mtu(bio: *mut BIO, mtu: c_uint) -> c_int
                    { BIO_ctrl(bio, BIO_CTRL_DGRAM_SET_MTU, mtu as c_long, ptr::null_mut()) as c_int }
                }
            }
        }

        pub mod cms
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            #[cfg(ossl101)]
            pub const CMS_TEXT: c_uint = 0x1;
            #[cfg(ossl101)]
            pub const CMS_NOCERTS: c_uint = 0x2;
            #[cfg(ossl101)]
            pub const CMS_NO_CONTENT_VERIFY: c_uint = 0x4;
            #[cfg(ossl101)]
            pub const CMS_NO_ATTR_VERIFY: c_uint = 0x8;
            #[cfg(ossl101)]
            pub const CMS_NOSIGS: c_uint = 0x4 | 0x8;
            #[cfg(ossl101)]
            pub const CMS_NOINTERN: c_uint = 0x10;
            #[cfg(ossl101)]
            pub const CMS_NO_SIGNER_CERT_VERIFY: c_uint = 0x20;
            #[cfg(ossl101)]
            pub const CMS_NOVERIFY: c_uint = 0x20;
            #[cfg(ossl101)]
            pub const CMS_DETACHED: c_uint = 0x40;
            #[cfg(ossl101)]
            pub const CMS_BINARY: c_uint = 0x80;
            #[cfg(ossl101)]
            pub const CMS_NOATTR: c_uint = 0x100;
            #[cfg(ossl101)]
            pub const CMS_NOSMIMECAP: c_uint = 0x200;
            #[cfg(ossl101)]
            pub const CMS_NOOLDMIMETYPE: c_uint = 0x400;
            #[cfg(ossl101)]
            pub const CMS_CRLFEOL: c_uint = 0x800;
            #[cfg(ossl101)]
            pub const CMS_STREAM: c_uint = 0x1000;
            #[cfg(ossl101)]
            pub const CMS_NOCRL: c_uint = 0x2000;
            #[cfg(ossl101)]
            pub const CMS_PARTIAL: c_uint = 0x4000;
            #[cfg(ossl101)]
            pub const CMS_REUSE_DIGEST: c_uint = 0x8000;
            #[cfg(ossl101)]
            pub const CMS_USE_KEYID: c_uint = 0x10000;
            #[cfg(ossl101)]
            pub const CMS_DEBUG_DECRYPT: c_uint = 0x20000;
            #[cfg(ossl102)]
            pub const CMS_KEY_PARAM: c_uint = 0x40000;
            #[cfg(ossl110)]
            pub const CMS_ASCIICRLF: c_uint = 0x80000;
        }

        pub mod crypto
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            extern "C"
            {
                #[deprecated(note = "use CRYPTO_set_locking_callback__fixed_rust instead")]
                #[cfg(not(ossl110))]
                pub fn CRYPTO_set_locking_callback(
                    func: unsafe extern "C" fn(mode: c_int, n: c_int, file: *const c_char, line: c_int),
                );

                #[deprecated(note = "use CRYPTO_set_id_callback__fixed_rust instead")]
                #[cfg(not(ossl110))]
                pub fn CRYPTO_set_id_callback(func: unsafe extern "C" fn() -> c_ulong);
            }

            cfg_if! {
                if #[cfg(ossl110)] {
                    type CRYPTO_EX_new_ret = ();
                    type CRYPTO_EX_dup_from = *const CRYPTO_EX_DATA;
                } else {
                    type CRYPTO_EX_new_ret = c_int;
                    type CRYPTO_EX_dup_from = *mut CRYPTO_EX_DATA;
                }
            }

            cfg_if! {
                if #[cfg(ossl300)] {
                    type CRYPTO_EX_dup_from_d = *mut *mut c_void;
                } else {
                    type CRYPTO_EX_dup_from_d = *mut c_void;
                }
            }

            // FIXME should be options
            pub type CRYPTO_EX_new = unsafe extern "C" fn(
                parent: *mut c_void,
                ptr: *mut c_void,
                ad: *mut CRYPTO_EX_DATA,
                idx: c_int,
                argl: c_long,
                argp: *mut c_void,
            ) -> CRYPTO_EX_new_ret;
            pub type CRYPTO_EX_dup = unsafe extern "C" fn(
                to: *mut CRYPTO_EX_DATA,
                from: CRYPTO_EX_dup_from,
                from_d: CRYPTO_EX_dup_from_d,
                idx: c_int,
                argl: c_long,
                argp: *mut c_void,
            ) -> c_int;
            pub type CRYPTO_EX_free = unsafe extern "C" fn(
                parent: *mut c_void,
                ptr: *mut c_void,
                ad: *mut CRYPTO_EX_DATA,
                idx: c_int,
                argl: c_long,
                argp: *mut c_void,
            );

            #[cfg(any(ossl110, libressl390))]
            #[inline]
            #[track_caller]
            pub unsafe fn OPENSSL_malloc(num: usize) -> *mut c_void {
                CRYPTO_malloc(
                    num,
                    concat!(file!(), "\0").as_ptr() as *const _,
                    line!() as _,
                )
            }

            #[cfg(not(any(ossl110, libressl390)))]
            #[inline]
            #[track_caller]
            pub unsafe fn OPENSSL_malloc(num: c_int) -> *mut c_void {
                CRYPTO_malloc(
                    num,
                    concat!(file!(), "\0").as_ptr() as *const _,
                    line!() as _,
                )
            }

            #[cfg(any(ossl110, libressl390))]
            #[inline]
            #[track_caller]
            pub unsafe fn OPENSSL_free(addr: *mut c_void) {
                CRYPTO_free(
                    addr,
                    concat!(file!(), "\0").as_ptr() as *const _,
                    line!() as _,
                )
            }

            #[cfg(not(any(ossl110, libressl390)))]
            #[inline]
            pub unsafe fn OPENSSL_free(addr: *mut c_void) {
                CRYPTO_free(addr)
            }

            #[cfg(not(ossl110))]
            pub const CRYPTO_LOCK_X509: c_int = 3;
            #[cfg(not(ossl110))]
            pub const CRYPTO_LOCK_EVP_PKEY: c_int = 10;
            #[cfg(not(ossl110))]
            pub const CRYPTO_LOCK_SSL_CTX: c_int = 12;
            #[cfg(not(ossl110))]
            pub const CRYPTO_LOCK_SSL_SESSION: c_int = 14;

            cfg_if! {
                if #[cfg(any(ossl110, libressl381))] {
                    pub const CRYPTO_EX_INDEX_SSL: c_int = 0;
                    pub const CRYPTO_EX_INDEX_SSL_CTX: c_int = 1;
                } else if #[cfg(libressl)] {
                    pub const CRYPTO_EX_INDEX_SSL: c_int = 1;
                    pub const CRYPTO_EX_INDEX_SSL_CTX: c_int = 2;
                }
            }

            cfg_if! {
                if #[cfg(any(ossl110, libressl271))] {
                    pub const OPENSSL_VERSION: c_int = 0;
                    pub const OPENSSL_CFLAGS: c_int = 1;
                    pub const OPENSSL_BUILT_ON: c_int = 2;
                    pub const OPENSSL_PLATFORM: c_int = 3;
                    pub const OPENSSL_DIR: c_int = 4;
                } else {
                    pub const SSLEAY_VERSION: c_int = 0;
                    pub const SSLEAY_CFLAGS: c_int = 2;
                    pub const SSLEAY_BUILT_ON: c_int = 3;
                    pub const SSLEAY_PLATFORM: c_int = 4;
                    pub const SSLEAY_DIR: c_int = 5;
                }
            }

            pub const CRYPTO_LOCK: c_int = 1;
        }

        pub mod dtls1
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            cfg_if!
            {
                if #[cfg(ossl300)]
                { pub const DTLS1_COOKIE_LENGTH: c_uint = 255; }
                
                else
                { pub const DTLS1_COOKIE_LENGTH: c_uint = 256; }
            }
        }

        pub mod ec
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */

            pub const OPENSSL_EC_NAMED_CURVE: c_int = 1;

            #[cfg(ossl300)]
            pub unsafe fn EVP_EC_gen(curve: *const c_char) -> *mut EVP_PKEY {
                EVP_PKEY_Q_keygen(
                    ptr::null_mut(),
                    ptr::null_mut(),
                    "EC\0".as_ptr().cast(),
                    curve,
                )
            }
            
        }

        pub mod err
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            pub const ERR_TXT_MALLOCED: c_int = 0x01;
            pub const ERR_TXT_STRING: c_int = 0x02;
            pub const ERR_LIB_SYS: c_int = 2;
            pub const ERR_LIB_PEM: c_int = 9;
            pub const ERR_LIB_ASN1: c_int = 13;

            cfg_if! 
            {
                if #[cfg(ossl300)] 
                {
                    pub const ERR_SYSTEM_FLAG: c_ulong = c_int::MAX as c_ulong + 1;
                    pub const ERR_SYSTEM_MASK: c_ulong = c_int::MAX as c_ulong;

                    pub const ERR_LIB_OFFSET: c_ulong = 23;
                    pub const ERR_LIB_MASK: c_ulong = 0xff;
                    pub const ERR_RFLAGS_OFFSET: c_ulong = 18;
                    pub const ERR_RFLAGS_MASK: c_ulong = 0x1f;
                    pub const ERR_REASON_MASK: c_ulong = 0x7FFFFF;

                    pub const ERR_RFLAG_FATAL: c_ulong = 0x1 << ERR_RFLAGS_OFFSET;

                    pub const fn ERR_SYSTEM_ERROR(errcode: c_ulong) -> bool {
                        errcode & ERR_SYSTEM_FLAG != 0
                    }

                    pub const fn ERR_GET_LIB(errcode: c_ulong) -> c_int {
                        // hacks since `if` isn't yet stable in const functions :(
                        ((ERR_LIB_SYS as c_ulong * (ERR_SYSTEM_ERROR(errcode) as c_ulong)) |
                        (((errcode >> ERR_LIB_OFFSET) & ERR_LIB_MASK) * (!ERR_SYSTEM_ERROR(errcode) as c_ulong))) as c_int
                    }

                    pub const fn ERR_GET_FUNC(_errcode: c_ulong) -> c_int {
                        0
                    }

                    pub const fn ERR_GET_REASON(errcode: c_ulong) -> c_int {
                        // hacks since `if` isn't yet stable in const functions :(
                        ((ERR_LIB_SYS as c_ulong * (ERR_SYSTEM_ERROR(errcode) as c_ulong)) |
                        ((errcode & ERR_REASON_MASK) * (!ERR_SYSTEM_ERROR(errcode) as c_ulong))) as c_int
                    }

                    pub const fn ERR_PACK(lib: c_int, _func: c_int, reason: c_int) -> c_ulong {
                        ((lib as c_ulong & ERR_LIB_MASK) << ERR_LIB_OFFSET) |
                        (reason as c_ulong & ERR_REASON_MASK)
                    }
                } else {
                    pub const fn ERR_PACK(l: c_int, f: c_int, r: c_int) -> c_ulong {
                        ((l as c_ulong & 0x0FF) << 24) |
                        ((f as c_ulong & 0xFFF) << 12) |
                        (r as c_ulong & 0xFFF)
                    }

                    pub const fn ERR_GET_LIB(l: c_ulong) -> c_int {
                        ((l >> 24) & 0x0FF) as c_int
                    }

                    pub const fn ERR_GET_FUNC(l: c_ulong) -> c_int {
                        ((l >> 12) & 0xFFF) as c_int
                    }

                    pub const fn ERR_GET_REASON(l: c_ulong) -> c_int {
                        (l & 0xFFF) as c_int
                    }
                }
            }
        }

        pub mod evp
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                system::
                {
                    openssl::
                    {
                        obj_mac::{ * },
                        types::{ * },
                    },
                },
                *,
            };
            /*
            */
            pub const EVP_MAX_MD_SIZE: c_uint = 64;

            pub const PKCS5_SALT_LEN: c_int = 8;
            pub const PKCS12_DEFAULT_ITER: c_int = 2048;

            pub const EVP_PKEY_RSA: c_int = NID_rsaEncryption;
            #[cfg(any(ossl111, libressl310, boringssl))]
            pub const EVP_PKEY_RSA_PSS: c_int = NID_rsassaPss;
            pub const EVP_PKEY_DSA: c_int = NID_dsa;
            pub const EVP_PKEY_DH: c_int = NID_dhKeyAgreement;
            #[cfg(ossl110)]
            pub const EVP_PKEY_DHX: c_int = NID_dhpublicnumber;
            pub const EVP_PKEY_EC: c_int = NID_X9_62_id_ecPublicKey;
            #[cfg(ossl111)]
            pub const EVP_PKEY_SM2: c_int = NID_sm2;
            #[cfg(any(ossl111, libressl370))]
            pub const EVP_PKEY_X25519: c_int = NID_X25519;
            #[cfg(any(ossl111, libressl370))]
            pub const EVP_PKEY_ED25519: c_int = NID_ED25519;
            #[cfg(ossl111)]
            pub const EVP_PKEY_X448: c_int = NID_X448;
            #[cfg(ossl111)]
            pub const EVP_PKEY_ED448: c_int = NID_ED448;
            pub const EVP_PKEY_HMAC: c_int = NID_hmac;
            pub const EVP_PKEY_CMAC: c_int = NID_cmac;
            #[cfg(ossl111)]
            pub const EVP_PKEY_POLY1305: c_int = NID_poly1305;
            #[cfg(any(ossl110, libressl360))]
            pub const EVP_PKEY_HKDF: c_int = NID_hkdf;

            #[cfg(ossl102)]
            pub const EVP_CIPHER_CTX_FLAG_WRAP_ALLOW: c_int = 0x1;

            pub const EVP_CTRL_GCM_SET_IVLEN: c_int = 0x9;
            pub const EVP_CTRL_GCM_GET_TAG: c_int = 0x10;
            pub const EVP_CTRL_GCM_SET_TAG: c_int = 0x11;

            pub unsafe fn EVP_get_digestbynid(type_: c_int) -> *const EVP_MD {
                EVP_get_digestbyname(OBJ_nid2sn(type_))
            }

            cfg_if! {
                if #[cfg(ossl300)] {
                    #[inline]
                    pub unsafe fn EVP_MD_CTX_md(ctx: *const EVP_MD_CTX) -> *const EVP_MD {
                        EVP_MD_CTX_get0_md(ctx)
                    }

                    #[inline]
                    pub unsafe fn EVP_MD_CTX_get_size(ctx: *const EVP_MD_CTX) -> c_int {
                        EVP_MD_get_size(EVP_MD_CTX_get0_md(ctx))
                    }

                    #[inline]
                    pub unsafe fn EVP_MD_CTX_size(ctx: *const EVP_MD_CTX) -> c_int {
                        EVP_MD_CTX_get_size(ctx)
                    }

                    #[inline]
                    pub unsafe fn EVP_MD_block_size(md: *const EVP_MD) -> c_int {
                        EVP_MD_get_block_size(md)
                    }

                    #[inline]
                    pub unsafe fn EVP_MD_size(md: *const EVP_MD) -> c_int {
                        EVP_MD_get_size(md)
                    }

                    #[inline]
                    pub unsafe fn EVP_MD_type(md: *const EVP_MD) -> c_int {
                        EVP_MD_get_type(md)
                    }

                    #[inline]
                    pub unsafe fn EVP_CIPHER_key_length(cipher: *const EVP_CIPHER) -> c_int {
                        EVP_CIPHER_get_key_length(cipher)
                    }

                    #[inline]
                    pub unsafe fn EVP_CIPHER_block_size(cipher: *const EVP_CIPHER) -> c_int {
                        EVP_CIPHER_get_block_size(cipher)
                    }

                    #[inline]
                    pub unsafe fn EVP_CIPHER_iv_length(cipher: *const EVP_CIPHER) -> c_int {
                        EVP_CIPHER_get_iv_length(cipher)
                    }

                    #[inline]
                    pub unsafe fn EVP_CIPHER_nid(cipher: *const EVP_CIPHER) -> c_int {
                        EVP_CIPHER_get_nid(cipher)
                    }

                    #[inline]
                    pub unsafe fn EVP_CIPHER_CTX_block_size(ctx: *const EVP_CIPHER_CTX) -> c_int {
                        EVP_CIPHER_CTX_get_block_size(ctx)
                    }

                    #[inline]
                    pub unsafe fn EVP_CIPHER_CTX_key_length(ctx: *const EVP_CIPHER_CTX) -> c_int {
                        EVP_CIPHER_CTX_get_key_length(ctx)
                    }

                    #[inline]
                    pub unsafe fn EVP_CIPHER_CTX_iv_length(ctx: *const EVP_CIPHER_CTX) -> c_int {
                        EVP_CIPHER_CTX_get_iv_length(ctx)
                    }

                    #[inline]
                    pub unsafe fn EVP_CIPHER_CTX_num(ctx: *const EVP_CIPHER_CTX) -> c_int {
                        EVP_CIPHER_CTX_get_num(ctx)
                    }
                } else {
                    pub unsafe fn EVP_MD_CTX_size(ctx: *const EVP_MD_CTX) -> c_int {
                        EVP_MD_size(EVP_MD_CTX_md(ctx))
                    }
                }
            }
            #[cfg(not(ossl300))]
            #[inline]
            pub unsafe fn EVP_DigestSignUpdate(
                ctx: *mut EVP_MD_CTX,
                data: *const c_void,
                dsize: size_t,
            ) -> c_int {
                EVP_DigestUpdate(ctx, data, dsize)
            }
            #[cfg(not(ossl300))]
            #[inline]
            pub unsafe fn EVP_DigestVerifyUpdate(
                ctx: *mut EVP_MD_CTX,
                data: *const c_void,
                dsize: size_t,
            ) -> c_int {
                EVP_DigestUpdate(ctx, data, dsize)
            }
            #[cfg(ossl300)]
            #[inline]
            pub unsafe fn EVP_PKEY_size(pkey: *const EVP_PKEY) -> c_int {
                EVP_PKEY_get_size(pkey)
            }

            cfg_if! {
                if #[cfg(ossl300)] {
                    #[inline]
                    pub unsafe fn EVP_PKEY_id(pkey: *const EVP_PKEY) -> c_int {
                        EVP_PKEY_get_id(pkey)
                    }

                    #[inline]
                    pub unsafe fn EVP_PKEY_bits(pkey: *const EVP_PKEY) -> c_int {
                        EVP_PKEY_get_bits(pkey)
                    }

                    #[inline]
                    pub unsafe fn EVP_PKEY_security_bits(pkey: *const EVP_PKEY) -> c_int {
                        EVP_PKEY_get_security_bits(pkey)
                    }
                }
            }

            pub const EVP_PKEY_OP_KEYGEN: c_int = 1 << 2;
            cfg_if! {
                if #[cfg(ossl300)] {
                    pub const EVP_PKEY_OP_SIGN: c_int = 1 << 4;
                    pub const EVP_PKEY_OP_VERIFY: c_int = 1 << 5;
                    pub const EVP_PKEY_OP_VERIFYRECOVER: c_int = 1 << 6;
                    pub const EVP_PKEY_OP_SIGNCTX: c_int = 1 << 7;
                    pub const EVP_PKEY_OP_VERIFYCTX: c_int = 1 << 8;
                    pub const EVP_PKEY_OP_ENCRYPT: c_int = 1 << 9;
                    pub const EVP_PKEY_OP_DECRYPT: c_int = 1 << 10;
                    pub const EVP_PKEY_OP_DERIVE: c_int = 1 << 11;
                } else {
                    pub const EVP_PKEY_OP_SIGN: c_int = 1 << 3;
                    pub const EVP_PKEY_OP_VERIFY: c_int = 1 << 4;
                    pub const EVP_PKEY_OP_VERIFYRECOVER: c_int = 1 << 5;
                    pub const EVP_PKEY_OP_SIGNCTX: c_int = 1 << 6;
                    pub const EVP_PKEY_OP_VERIFYCTX: c_int = 1 << 7;
                    pub const EVP_PKEY_OP_ENCRYPT: c_int = 1 << 8;
                    pub const EVP_PKEY_OP_DECRYPT: c_int = 1 << 9;
                    pub const EVP_PKEY_OP_DERIVE: c_int = 1 << 10;
                }
            }

            pub const EVP_PKEY_OP_TYPE_SIG: c_int = EVP_PKEY_OP_SIGN
                | EVP_PKEY_OP_VERIFY
                | EVP_PKEY_OP_VERIFYRECOVER
                | EVP_PKEY_OP_SIGNCTX
                | EVP_PKEY_OP_VERIFYCTX;

            pub const EVP_PKEY_OP_TYPE_CRYPT: c_int = EVP_PKEY_OP_ENCRYPT | EVP_PKEY_OP_DECRYPT;

            pub const EVP_PKEY_CTRL_MD: c_int = 1;

            pub const EVP_PKEY_CTRL_SET_MAC_KEY: c_int = 6;

            pub const EVP_PKEY_CTRL_CIPHER: c_int = 12;

            pub const EVP_PKEY_ALG_CTRL: c_int = 0x1000;

            #[cfg(any(ossl111, libressl360))]
            pub const EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND: c_int = 0;

            #[cfg(any(ossl111, libressl360))]
            pub const EVP_PKEY_HKDEF_MODE_EXTRACT_ONLY: c_int = 1;

            #[cfg(any(ossl111, libressl360))]
            pub const EVP_PKEY_HKDEF_MODE_EXPAND_ONLY: c_int = 2;

            #[cfg(any(ossl110, libressl360))]
            pub const EVP_PKEY_CTRL_HKDF_MD: c_int = EVP_PKEY_ALG_CTRL + 3;

            #[cfg(any(ossl110, libressl360))]
            pub const EVP_PKEY_CTRL_HKDF_SALT: c_int = EVP_PKEY_ALG_CTRL + 4;

            #[cfg(any(ossl110, libressl360))]
            pub const EVP_PKEY_CTRL_HKDF_KEY: c_int = EVP_PKEY_ALG_CTRL + 5;

            #[cfg(any(ossl110, libressl360))]
            pub const EVP_PKEY_CTRL_HKDF_INFO: c_int = EVP_PKEY_ALG_CTRL + 6;

            #[cfg(any(ossl111, libressl360))]
            pub const EVP_PKEY_CTRL_HKDF_MODE: c_int = EVP_PKEY_ALG_CTRL + 7;

            #[cfg(any(all(ossl111, not(ossl300)), libressl360))]
            pub unsafe fn EVP_PKEY_CTX_set_hkdf_mode(ctx: *mut EVP_PKEY_CTX, mode: c_int) -> c_int {
                EVP_PKEY_CTX_ctrl(
                    ctx,
                    -1,
                    EVP_PKEY_OP_DERIVE,
                    EVP_PKEY_CTRL_HKDF_MODE,
                    mode,
                    std::ptr::null_mut(),
                )
            }

            #[cfg(any(all(ossl110, not(ossl300)), libressl360))]
            pub unsafe fn EVP_PKEY_CTX_set_hkdf_md(ctx: *mut EVP_PKEY_CTX, md: *const EVP_MD) -> c_int {
                EVP_PKEY_CTX_ctrl(
                    ctx,
                    -1,
                    EVP_PKEY_OP_DERIVE,
                    EVP_PKEY_CTRL_HKDF_MD,
                    0,
                    md as *mut c_void,
                )
            }

            #[cfg(any(all(ossl110, not(ossl300)), libressl360))]
            pub unsafe fn EVP_PKEY_CTX_set1_hkdf_salt(
                ctx: *mut EVP_PKEY_CTX,
                salt: *const u8,
                saltlen: c_int,
            ) -> c_int {
                EVP_PKEY_CTX_ctrl(
                    ctx,
                    -1,
                    EVP_PKEY_OP_DERIVE,
                    EVP_PKEY_CTRL_HKDF_SALT,
                    saltlen,
                    salt as *mut c_void,
                )
            }

            #[cfg(any(all(ossl110, not(ossl300)), libressl360))]
            pub unsafe fn EVP_PKEY_CTX_set1_hkdf_key(
                ctx: *mut EVP_PKEY_CTX,
                key: *const u8,
                keylen: c_int,
            ) -> c_int {
                EVP_PKEY_CTX_ctrl(
                    ctx,
                    -1,
                    EVP_PKEY_OP_DERIVE,
                    EVP_PKEY_CTRL_HKDF_KEY,
                    keylen,
                    key as *mut c_void,
                )
            }

            #[cfg(any(all(ossl110, not(ossl300)), libressl360))]
            pub unsafe fn EVP_PKEY_CTX_add1_hkdf_info(
                ctx: *mut EVP_PKEY_CTX,
                info: *const u8,
                infolen: c_int,
            ) -> c_int {
                EVP_PKEY_CTX_ctrl(
                    ctx,
                    -1,
                    EVP_PKEY_OP_DERIVE,
                    EVP_PKEY_CTRL_HKDF_INFO,
                    infolen,
                    info as *mut c_void,
                )
            }

            #[cfg(all(not(ossl300), not(boringssl)))]
            pub unsafe fn EVP_PKEY_CTX_set_signature_md(cxt: *mut EVP_PKEY_CTX, md: *mut EVP_MD) -> c_int {
                EVP_PKEY_CTX_ctrl(
                    cxt,
                    -1,
                    EVP_PKEY_OP_TYPE_SIG,
                    EVP_PKEY_CTRL_MD,
                    0,
                    md as *mut c_void,
                )
            }

            pub unsafe fn EVP_PKEY_assign_RSA(pkey: *mut EVP_PKEY, rsa: *mut RSA) -> c_int {
                EVP_PKEY_assign(pkey, EVP_PKEY_RSA, rsa as *mut c_void)
            }

            pub unsafe fn EVP_PKEY_assign_DSA(pkey: *mut EVP_PKEY, dsa: *mut DSA) -> c_int {
                EVP_PKEY_assign(pkey, EVP_PKEY_DSA, dsa as *mut c_void)
            }

            pub unsafe fn EVP_PKEY_assign_DH(pkey: *mut EVP_PKEY, dh: *mut DH) -> c_int {
                EVP_PKEY_assign(pkey, EVP_PKEY_DH, dh as *mut c_void)
            }

            pub unsafe fn EVP_PKEY_assign_EC_KEY(pkey: *mut EVP_PKEY, ec_key: *mut EC_KEY) -> c_int {
                EVP_PKEY_assign(pkey, EVP_PKEY_EC, ec_key as *mut c_void)
            }
        }

        pub mod obj_mac
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            pub const NID_undef: c_int = 0;
            pub const NID_itu_t: c_int = 645;
            pub const NID_ccitt: c_int = 404;
            pub const NID_iso: c_int = 181;
            pub const NID_joint_iso_itu_t: c_int = 646;
            pub const NID_joint_iso_ccitt: c_int = 393;
            pub const NID_member_body: c_int = 182;
            pub const NID_identified_organization: c_int = 676;
            pub const NID_hmac_md5: c_int = 780;
            pub const NID_hmac_sha1: c_int = 781;
            pub const NID_certicom_arc: c_int = 677;
            pub const NID_international_organizations: c_int = 647;
            pub const NID_wap: c_int = 678;
            pub const NID_wap_wsg: c_int = 679;
            pub const NID_selected_attribute_types: c_int = 394;
            pub const NID_clearance: c_int = 395;
            pub const NID_ISO_US: c_int = 183;
            pub const NID_X9_57: c_int = 184;
            pub const NID_X9cm: c_int = 185;
            pub const NID_dsa: c_int = 116;
            pub const NID_dsaWithSHA1: c_int = 113;
            pub const NID_ansi_X9_62: c_int = 405;
            pub const NID_X9_62_prime_field: c_int = 406;
            pub const NID_X9_62_characteristic_two_field: c_int = 407;
            pub const NID_X9_62_id_characteristic_two_basis: c_int = 680;
            pub const NID_X9_62_onBasis: c_int = 681;
            pub const NID_X9_62_tpBasis: c_int = 682;
            pub const NID_X9_62_ppBasis: c_int = 683;
            pub const NID_X9_62_id_ecPublicKey: c_int = 408;
            pub const NID_X9_62_c2pnb163v1: c_int = 684;
            pub const NID_X9_62_c2pnb163v2: c_int = 685;
            pub const NID_X9_62_c2pnb163v3: c_int = 686;
            pub const NID_X9_62_c2pnb176v1: c_int = 687;
            pub const NID_X9_62_c2tnb191v1: c_int = 688;
            pub const NID_X9_62_c2tnb191v2: c_int = 689;
            pub const NID_X9_62_c2tnb191v3: c_int = 690;
            pub const NID_X9_62_c2onb191v4: c_int = 691;
            pub const NID_X9_62_c2onb191v5: c_int = 692;
            pub const NID_X9_62_c2pnb208w1: c_int = 693;
            pub const NID_X9_62_c2tnb239v1: c_int = 694;
            pub const NID_X9_62_c2tnb239v2: c_int = 695;
            pub const NID_X9_62_c2tnb239v3: c_int = 696;
            pub const NID_X9_62_c2onb239v4: c_int = 697;
            pub const NID_X9_62_c2onb239v5: c_int = 698;
            pub const NID_X9_62_c2pnb272w1: c_int = 699;
            pub const NID_X9_62_c2pnb304w1: c_int = 700;
            pub const NID_X9_62_c2tnb359v1: c_int = 701;
            pub const NID_X9_62_c2pnb368w1: c_int = 702;
            pub const NID_X9_62_c2tnb431r1: c_int = 703;
            pub const NID_X9_62_prime192v1: c_int = 409;
            pub const NID_X9_62_prime192v2: c_int = 410;
            pub const NID_X9_62_prime192v3: c_int = 411;
            pub const NID_X9_62_prime239v1: c_int = 412;
            pub const NID_X9_62_prime239v2: c_int = 413;
            pub const NID_X9_62_prime239v3: c_int = 414;
            pub const NID_X9_62_prime256v1: c_int = 415;
            pub const NID_ecdsa_with_SHA1: c_int = 416;
            pub const NID_ecdsa_with_Recommended: c_int = 791;
            pub const NID_ecdsa_with_Specified: c_int = 792;
            pub const NID_ecdsa_with_SHA224: c_int = 793;
            pub const NID_ecdsa_with_SHA256: c_int = 794;
            pub const NID_ecdsa_with_SHA384: c_int = 795;
            pub const NID_ecdsa_with_SHA512: c_int = 796;
            pub const NID_secp112r1: c_int = 704;
            pub const NID_secp112r2: c_int = 705;
            pub const NID_secp128r1: c_int = 706;
            pub const NID_secp128r2: c_int = 707;
            pub const NID_secp160k1: c_int = 708;
            pub const NID_secp160r1: c_int = 709;
            pub const NID_secp160r2: c_int = 710;
            pub const NID_secp192k1: c_int = 711;
            pub const NID_secp224k1: c_int = 712;
            pub const NID_secp224r1: c_int = 713;
            pub const NID_secp256k1: c_int = 714;
            pub const NID_secp384r1: c_int = 715;
            pub const NID_secp521r1: c_int = 716;
            pub const NID_sect113r1: c_int = 717;
            pub const NID_sect113r2: c_int = 718;
            pub const NID_sect131r1: c_int = 719;
            pub const NID_sect131r2: c_int = 720;
            pub const NID_sect163k1: c_int = 721;
            pub const NID_sect163r1: c_int = 722;
            pub const NID_sect163r2: c_int = 723;
            pub const NID_sect193r1: c_int = 724;
            pub const NID_sect193r2: c_int = 725;
            pub const NID_sect233k1: c_int = 726;
            pub const NID_sect233r1: c_int = 727;
            pub const NID_sect239k1: c_int = 728;
            pub const NID_sect283k1: c_int = 729;
            pub const NID_sect283r1: c_int = 730;
            pub const NID_sect409k1: c_int = 731;
            pub const NID_sect409r1: c_int = 732;
            pub const NID_sect571k1: c_int = 733;
            pub const NID_sect571r1: c_int = 734;

            #[cfg(ossl110)]
            pub const NID_brainpoolP256r1: c_int = 927;
            #[cfg(libressl)]
            pub const NID_brainpoolP256r1: c_int = 928;

            #[cfg(ossl110)]
            pub const NID_brainpoolP320r1: c_int = 929;
            #[cfg(libressl)]
            pub const NID_brainpoolP320r1: c_int = 930;

            #[cfg(ossl110)]
            pub const NID_brainpoolP384r1: c_int = 931;
            #[cfg(libressl)]
            pub const NID_brainpoolP384r1: c_int = 932;

            #[cfg(ossl110)]
            pub const NID_brainpoolP512r1: c_int = 933;
            #[cfg(libressl)]
            pub const NID_brainpoolP512r1: c_int = 934;

            pub const NID_wap_wsg_idm_ecid_wtls1: c_int = 735;
            pub const NID_wap_wsg_idm_ecid_wtls3: c_int = 736;
            pub const NID_wap_wsg_idm_ecid_wtls4: c_int = 737;
            pub const NID_wap_wsg_idm_ecid_wtls5: c_int = 738;
            pub const NID_wap_wsg_idm_ecid_wtls6: c_int = 739;
            pub const NID_wap_wsg_idm_ecid_wtls7: c_int = 740;
            pub const NID_wap_wsg_idm_ecid_wtls8: c_int = 741;
            pub const NID_wap_wsg_idm_ecid_wtls9: c_int = 742;
            pub const NID_wap_wsg_idm_ecid_wtls10: c_int = 743;
            pub const NID_wap_wsg_idm_ecid_wtls11: c_int = 744;
            pub const NID_wap_wsg_idm_ecid_wtls12: c_int = 745;
            pub const NID_cast5_cbc: c_int = 108;
            pub const NID_cast5_ecb: c_int = 109;
            pub const NID_cast5_cfb64: c_int = 110;
            pub const NID_cast5_ofb64: c_int = 111;
            pub const NID_pbeWithMD5AndCast5_CBC: c_int = 112;
            pub const NID_id_PasswordBasedMAC: c_int = 782;
            pub const NID_id_DHBasedMac: c_int = 783;
            pub const NID_rsadsi: c_int = 1;
            pub const NID_pkcs: c_int = 2;
            pub const NID_pkcs1: c_int = 186;
            pub const NID_rsaEncryption: c_int = 6;
            pub const NID_md2WithRSAEncryption: c_int = 7;
            pub const NID_md4WithRSAEncryption: c_int = 396;
            pub const NID_md5WithRSAEncryption: c_int = 8;
            pub const NID_sha1WithRSAEncryption: c_int = 65;
            pub const NID_rsaesOaep: c_int = 919;
            pub const NID_mgf1: c_int = 911;
            pub const NID_rsassaPss: c_int = 912;
            pub const NID_sha256WithRSAEncryption: c_int = 668;
            pub const NID_sha384WithRSAEncryption: c_int = 669;
            pub const NID_sha512WithRSAEncryption: c_int = 670;
            pub const NID_sha224WithRSAEncryption: c_int = 671;
            pub const NID_pkcs3: c_int = 27;
            pub const NID_dhKeyAgreement: c_int = 28;
            #[cfg(ossl110)]
            pub const NID_dhpublicnumber: c_int = 920;
            pub const NID_pkcs5: c_int = 187;
            pub const NID_pbeWithMD2AndDES_CBC: c_int = 9;
            pub const NID_pbeWithMD5AndDES_CBC: c_int = 10;
            pub const NID_pbeWithMD2AndRC2_CBC: c_int = 168;
            pub const NID_pbeWithMD5AndRC2_CBC: c_int = 169;
            pub const NID_pbeWithSHA1AndDES_CBC: c_int = 170;
            pub const NID_pbeWithSHA1AndRC2_CBC: c_int = 68;
            pub const NID_id_pbkdf2: c_int = 69;
            pub const NID_pbes2: c_int = 161;
            pub const NID_pbmac1: c_int = 162;
            pub const NID_pkcs7: c_int = 20;
            pub const NID_pkcs7_data: c_int = 21;
            pub const NID_pkcs7_signed: c_int = 22;
            pub const NID_pkcs7_enveloped: c_int = 23;
            pub const NID_pkcs7_signedAndEnveloped: c_int = 24;
            pub const NID_pkcs7_digest: c_int = 25;
            pub const NID_pkcs7_encrypted: c_int = 26;
            pub const NID_pkcs9: c_int = 47;
            pub const NID_pkcs9_emailAddress: c_int = 48;
            pub const NID_pkcs9_unstructuredName: c_int = 49;
            pub const NID_pkcs9_contentType: c_int = 50;
            pub const NID_pkcs9_messageDigest: c_int = 51;
            pub const NID_pkcs9_signingTime: c_int = 52;
            pub const NID_pkcs9_countersignature: c_int = 53;
            pub const NID_pkcs9_challengePassword: c_int = 54;
            pub const NID_pkcs9_unstructuredAddress: c_int = 55;
            pub const NID_pkcs9_extCertAttributes: c_int = 56;
            pub const NID_ext_req: c_int = 172;
            pub const NID_SMIMECapabilities: c_int = 167;
            pub const NID_SMIME: c_int = 188;
            pub const NID_id_smime_mod: c_int = 189;
            pub const NID_id_smime_ct: c_int = 190;
            pub const NID_id_smime_aa: c_int = 191;
            pub const NID_id_smime_alg: c_int = 192;
            pub const NID_id_smime_cd: c_int = 193;
            pub const NID_id_smime_spq: c_int = 194;
            pub const NID_id_smime_cti: c_int = 195;
            pub const NID_id_smime_mod_cms: c_int = 196;
            pub const NID_id_smime_mod_ess: c_int = 197;
            pub const NID_id_smime_mod_oid: c_int = 198;
            pub const NID_id_smime_mod_msg_v3: c_int = 199;
            pub const NID_id_smime_mod_ets_eSignature_88: c_int = 200;
            pub const NID_id_smime_mod_ets_eSignature_97: c_int = 201;
            pub const NID_id_smime_mod_ets_eSigPolicy_88: c_int = 202;
            pub const NID_id_smime_mod_ets_eSigPolicy_97: c_int = 203;
            pub const NID_id_smime_ct_receipt: c_int = 204;
            pub const NID_id_smime_ct_authData: c_int = 205;
            pub const NID_id_smime_ct_publishCert: c_int = 206;
            pub const NID_id_smime_ct_TSTInfo: c_int = 207;
            pub const NID_id_smime_ct_TDTInfo: c_int = 208;
            pub const NID_id_smime_ct_contentInfo: c_int = 209;
            pub const NID_id_smime_ct_DVCSRequestData: c_int = 210;
            pub const NID_id_smime_ct_DVCSResponseData: c_int = 211;
            pub const NID_id_smime_ct_compressedData: c_int = 786;
            pub const NID_id_ct_asciiTextWithCRLF: c_int = 787;
            pub const NID_id_smime_aa_receiptRequest: c_int = 212;
            pub const NID_id_smime_aa_securityLabel: c_int = 213;
            pub const NID_id_smime_aa_mlExpandHistory: c_int = 214;
            pub const NID_id_smime_aa_contentHint: c_int = 215;
            pub const NID_id_smime_aa_msgSigDigest: c_int = 216;
            pub const NID_id_smime_aa_encapContentType: c_int = 217;
            pub const NID_id_smime_aa_contentIdentifier: c_int = 218;
            pub const NID_id_smime_aa_macValue: c_int = 219;
            pub const NID_id_smime_aa_equivalentLabels: c_int = 220;
            pub const NID_id_smime_aa_contentReference: c_int = 221;
            pub const NID_id_smime_aa_encrypKeyPref: c_int = 222;
            pub const NID_id_smime_aa_signingCertificate: c_int = 223;
            pub const NID_id_smime_aa_smimeEncryptCerts: c_int = 224;
            pub const NID_id_smime_aa_timeStampToken: c_int = 225;
            pub const NID_id_smime_aa_ets_sigPolicyId: c_int = 226;
            pub const NID_id_smime_aa_ets_commitmentType: c_int = 227;
            pub const NID_id_smime_aa_ets_signerLocation: c_int = 228;
            pub const NID_id_smime_aa_ets_signerAttr: c_int = 229;
            pub const NID_id_smime_aa_ets_otherSigCert: c_int = 230;
            pub const NID_id_smime_aa_ets_contentTimestamp: c_int = 231;
            pub const NID_id_smime_aa_ets_CertificateRefs: c_int = 232;
            pub const NID_id_smime_aa_ets_RevocationRefs: c_int = 233;
            pub const NID_id_smime_aa_ets_certValues: c_int = 234;
            pub const NID_id_smime_aa_ets_revocationValues: c_int = 235;
            pub const NID_id_smime_aa_ets_escTimeStamp: c_int = 236;
            pub const NID_id_smime_aa_ets_certCRLTimestamp: c_int = 237;
            pub const NID_id_smime_aa_ets_archiveTimeStamp: c_int = 238;
            pub const NID_id_smime_aa_signatureType: c_int = 239;
            pub const NID_id_smime_aa_dvcs_dvc: c_int = 240;
            pub const NID_id_smime_alg_ESDHwith3DES: c_int = 241;
            pub const NID_id_smime_alg_ESDHwithRC2: c_int = 242;
            pub const NID_id_smime_alg_3DESwrap: c_int = 243;
            pub const NID_id_smime_alg_RC2wrap: c_int = 244;
            pub const NID_id_smime_alg_ESDH: c_int = 245;
            pub const NID_id_smime_alg_CMS3DESwrap: c_int = 246;
            pub const NID_id_smime_alg_CMSRC2wrap: c_int = 247;
            pub const NID_id_alg_PWRI_KEK: c_int = 893;
            pub const NID_id_smime_cd_ldap: c_int = 248;
            pub const NID_id_smime_spq_ets_sqt_uri: c_int = 249;
            pub const NID_id_smime_spq_ets_sqt_unotice: c_int = 250;
            pub const NID_id_smime_cti_ets_proofOfOrigin: c_int = 251;
            pub const NID_id_smime_cti_ets_proofOfReceipt: c_int = 252;
            pub const NID_id_smime_cti_ets_proofOfDelivery: c_int = 253;
            pub const NID_id_smime_cti_ets_proofOfSender: c_int = 254;
            pub const NID_id_smime_cti_ets_proofOfApproval: c_int = 255;
            pub const NID_id_smime_cti_ets_proofOfCreation: c_int = 256;
            pub const NID_friendlyName: c_int = 156;
            pub const NID_localKeyID: c_int = 157;
            pub const NID_ms_csp_name: c_int = 417;
            pub const NID_LocalKeySet: c_int = 856;
            pub const NID_x509Certificate: c_int = 158;
            pub const NID_sdsiCertificate: c_int = 159;
            pub const NID_x509Crl: c_int = 160;
            pub const NID_pbe_WithSHA1And128BitRC4: c_int = 144;
            pub const NID_pbe_WithSHA1And40BitRC4: c_int = 145;
            pub const NID_pbe_WithSHA1And3_Key_TripleDES_CBC: c_int = 146;
            pub const NID_pbe_WithSHA1And2_Key_TripleDES_CBC: c_int = 147;
            pub const NID_pbe_WithSHA1And128BitRC2_CBC: c_int = 148;
            pub const NID_pbe_WithSHA1And40BitRC2_CBC: c_int = 149;
            pub const NID_keyBag: c_int = 150;
            pub const NID_pkcs8ShroudedKeyBag: c_int = 151;
            pub const NID_certBag: c_int = 152;
            pub const NID_crlBag: c_int = 153;
            pub const NID_secretBag: c_int = 154;
            pub const NID_safeContentsBag: c_int = 155;
            pub const NID_md2: c_int = 3;
            pub const NID_md4: c_int = 257;
            pub const NID_md5: c_int = 4;
            pub const NID_md5_sha1: c_int = 114;
            pub const NID_hmacWithMD5: c_int = 797;
            pub const NID_hmacWithSHA1: c_int = 163;
            pub const NID_hmacWithSHA224: c_int = 798;
            pub const NID_hmacWithSHA256: c_int = 799;
            pub const NID_hmacWithSHA384: c_int = 800;
            pub const NID_hmacWithSHA512: c_int = 801;
            pub const NID_rc2_cbc: c_int = 37;
            pub const NID_rc2_ecb: c_int = 38;
            pub const NID_rc2_cfb64: c_int = 39;
            pub const NID_rc2_ofb64: c_int = 40;
            pub const NID_rc2_40_cbc: c_int = 98;
            pub const NID_rc2_64_cbc: c_int = 166;
            pub const NID_rc4: c_int = 5;
            pub const NID_rc4_40: c_int = 97;
            pub const NID_des_ede3_cbc: c_int = 44;
            pub const NID_rc5_cbc: c_int = 120;
            pub const NID_rc5_ecb: c_int = 121;
            pub const NID_rc5_cfb64: c_int = 122;
            pub const NID_rc5_ofb64: c_int = 123;
            pub const NID_ms_ext_req: c_int = 171;
            pub const NID_ms_code_ind: c_int = 134;
            pub const NID_ms_code_com: c_int = 135;
            pub const NID_ms_ctl_sign: c_int = 136;
            pub const NID_ms_sgc: c_int = 137;
            pub const NID_ms_efs: c_int = 138;
            pub const NID_ms_smartcard_login: c_int = 648;
            pub const NID_ms_upn: c_int = 649;
            pub const NID_idea_cbc: c_int = 34;
            pub const NID_idea_ecb: c_int = 36;
            pub const NID_idea_cfb64: c_int = 35;
            pub const NID_idea_ofb64: c_int = 46;
            pub const NID_bf_cbc: c_int = 91;
            pub const NID_bf_ecb: c_int = 92;
            pub const NID_bf_cfb64: c_int = 93;
            pub const NID_bf_ofb64: c_int = 94;
            pub const NID_id_pkix: c_int = 127;
            pub const NID_id_pkix_mod: c_int = 258;
            pub const NID_id_pe: c_int = 175;
            pub const NID_id_qt: c_int = 259;
            pub const NID_id_kp: c_int = 128;
            pub const NID_id_it: c_int = 260;
            pub const NID_id_pkip: c_int = 261;
            pub const NID_id_alg: c_int = 262;
            pub const NID_id_cmc: c_int = 263;
            pub const NID_id_on: c_int = 264;
            pub const NID_id_pda: c_int = 265;
            pub const NID_id_aca: c_int = 266;
            pub const NID_id_qcs: c_int = 267;
            pub const NID_id_cct: c_int = 268;
            pub const NID_id_ppl: c_int = 662;
            pub const NID_id_ad: c_int = 176;
            pub const NID_id_pkix1_explicit_88: c_int = 269;
            pub const NID_id_pkix1_implicit_88: c_int = 270;
            pub const NID_id_pkix1_explicit_93: c_int = 271;
            pub const NID_id_pkix1_implicit_93: c_int = 272;
            pub const NID_id_mod_crmf: c_int = 273;
            pub const NID_id_mod_cmc: c_int = 274;
            pub const NID_id_mod_kea_profile_88: c_int = 275;
            pub const NID_id_mod_kea_profile_93: c_int = 276;
            pub const NID_id_mod_cmp: c_int = 277;
            pub const NID_id_mod_qualified_cert_88: c_int = 278;
            pub const NID_id_mod_qualified_cert_93: c_int = 279;
            pub const NID_id_mod_attribute_cert: c_int = 280;
            pub const NID_id_mod_timestamp_protocol: c_int = 281;
            pub const NID_id_mod_ocsp: c_int = 282;
            pub const NID_id_mod_dvcs: c_int = 283;
            pub const NID_id_mod_cmp2000: c_int = 284;
            pub const NID_info_access: c_int = 177;
            pub const NID_biometricInfo: c_int = 285;
            pub const NID_qcStatements: c_int = 286;
            pub const NID_ac_auditEntity: c_int = 287;
            pub const NID_ac_targeting: c_int = 288;
            pub const NID_aaControls: c_int = 289;
            pub const NID_sbgp_ipAddrBlock: c_int = 290;
            pub const NID_sbgp_autonomousSysNum: c_int = 291;
            pub const NID_sbgp_routerIdentifier: c_int = 292;
            pub const NID_ac_proxying: c_int = 397;
            pub const NID_sinfo_access: c_int = 398;
            pub const NID_proxyCertInfo: c_int = 663;
            pub const NID_id_qt_cps: c_int = 164;
            pub const NID_id_qt_unotice: c_int = 165;
            pub const NID_textNotice: c_int = 293;
            pub const NID_server_auth: c_int = 129;
            pub const NID_client_auth: c_int = 130;
            pub const NID_code_sign: c_int = 131;
            pub const NID_email_protect: c_int = 132;
            pub const NID_ipsecEndSystem: c_int = 294;
            pub const NID_ipsecTunnel: c_int = 295;
            pub const NID_ipsecUser: c_int = 296;
            pub const NID_time_stamp: c_int = 133;
            pub const NID_OCSP_sign: c_int = 180;
            pub const NID_dvcs: c_int = 297;
            pub const NID_id_it_caProtEncCert: c_int = 298;
            pub const NID_id_it_signKeyPairTypes: c_int = 299;
            pub const NID_id_it_encKeyPairTypes: c_int = 300;
            pub const NID_id_it_preferredSymmAlg: c_int = 301;
            pub const NID_id_it_caKeyUpdateInfo: c_int = 302;
            pub const NID_id_it_currentCRL: c_int = 303;
            pub const NID_id_it_unsupportedOIDs: c_int = 304;
            pub const NID_id_it_subscriptionRequest: c_int = 305;
            pub const NID_id_it_subscriptionResponse: c_int = 306;
            pub const NID_id_it_keyPairParamReq: c_int = 307;
            pub const NID_id_it_keyPairParamRep: c_int = 308;
            pub const NID_id_it_revPassphrase: c_int = 309;
            pub const NID_id_it_implicitConfirm: c_int = 310;
            pub const NID_id_it_confirmWaitTime: c_int = 311;
            pub const NID_id_it_origPKIMessage: c_int = 312;
            pub const NID_id_it_suppLangTags: c_int = 784;
            pub const NID_id_regCtrl: c_int = 313;
            pub const NID_id_regInfo: c_int = 314;
            pub const NID_id_regCtrl_regToken: c_int = 315;
            pub const NID_id_regCtrl_authenticator: c_int = 316;
            pub const NID_id_regCtrl_pkiPublicationInfo: c_int = 317;
            pub const NID_id_regCtrl_pkiArchiveOptions: c_int = 318;
            pub const NID_id_regCtrl_oldCertID: c_int = 319;
            pub const NID_id_regCtrl_protocolEncrKey: c_int = 320;
            pub const NID_id_regInfo_utf8Pairs: c_int = 321;
            pub const NID_id_regInfo_certReq: c_int = 322;
            pub const NID_id_alg_des40: c_int = 323;
            pub const NID_id_alg_noSignature: c_int = 324;
            pub const NID_id_alg_dh_sig_hmac_sha1: c_int = 325;
            pub const NID_id_alg_dh_pop: c_int = 326;
            pub const NID_id_cmc_statusInfo: c_int = 327;
            pub const NID_id_cmc_identification: c_int = 328;
            pub const NID_id_cmc_identityProof: c_int = 329;
            pub const NID_id_cmc_dataReturn: c_int = 330;
            pub const NID_id_cmc_transactionId: c_int = 331;
            pub const NID_id_cmc_senderNonce: c_int = 332;
            pub const NID_id_cmc_recipientNonce: c_int = 333;
            pub const NID_id_cmc_addExtensions: c_int = 334;
            pub const NID_id_cmc_encryptedPOP: c_int = 335;
            pub const NID_id_cmc_decryptedPOP: c_int = 336;
            pub const NID_id_cmc_lraPOPWitness: c_int = 337;
            pub const NID_id_cmc_getCert: c_int = 338;
            pub const NID_id_cmc_getCRL: c_int = 339;
            pub const NID_id_cmc_revokeRequest: c_int = 340;
            pub const NID_id_cmc_regInfo: c_int = 341;
            pub const NID_id_cmc_responseInfo: c_int = 342;
            pub const NID_id_cmc_queryPending: c_int = 343;
            pub const NID_id_cmc_popLinkRandom: c_int = 344;
            pub const NID_id_cmc_popLinkWitness: c_int = 345;
            pub const NID_id_cmc_confirmCertAcceptance: c_int = 346;
            pub const NID_id_on_personalData: c_int = 347;
            pub const NID_id_on_permanentIdentifier: c_int = 858;
            pub const NID_id_pda_dateOfBirth: c_int = 348;
            pub const NID_id_pda_placeOfBirth: c_int = 349;
            pub const NID_id_pda_gender: c_int = 351;
            pub const NID_id_pda_countryOfCitizenship: c_int = 352;
            pub const NID_id_pda_countryOfResidence: c_int = 353;
            pub const NID_id_aca_authenticationInfo: c_int = 354;
            pub const NID_id_aca_accessIdentity: c_int = 355;
            pub const NID_id_aca_chargingIdentity: c_int = 356;
            pub const NID_id_aca_group: c_int = 357;
            pub const NID_id_aca_role: c_int = 358;
            pub const NID_id_aca_encAttrs: c_int = 399;
            pub const NID_id_qcs_pkixQCSyntax_v1: c_int = 359;
            pub const NID_id_cct_crs: c_int = 360;
            pub const NID_id_cct_PKIData: c_int = 361;
            pub const NID_id_cct_PKIResponse: c_int = 362;
            pub const NID_id_ppl_anyLanguage: c_int = 664;
            pub const NID_id_ppl_inheritAll: c_int = 665;
            pub const NID_Independent: c_int = 667;
            pub const NID_ad_OCSP: c_int = 178;
            pub const NID_ad_ca_issuers: c_int = 179;
            pub const NID_ad_timeStamping: c_int = 363;
            pub const NID_ad_dvcs: c_int = 364;
            pub const NID_caRepository: c_int = 785;
            pub const NID_id_pkix_OCSP_basic: c_int = 365;
            pub const NID_id_pkix_OCSP_Nonce: c_int = 366;
            pub const NID_id_pkix_OCSP_CrlID: c_int = 367;
            pub const NID_id_pkix_OCSP_acceptableResponses: c_int = 368;
            pub const NID_id_pkix_OCSP_noCheck: c_int = 369;
            pub const NID_id_pkix_OCSP_archiveCutoff: c_int = 370;
            pub const NID_id_pkix_OCSP_serviceLocator: c_int = 371;
            pub const NID_id_pkix_OCSP_extendedStatus: c_int = 372;
            pub const NID_id_pkix_OCSP_valid: c_int = 373;
            pub const NID_id_pkix_OCSP_path: c_int = 374;
            pub const NID_id_pkix_OCSP_trustRoot: c_int = 375;
            pub const NID_algorithm: c_int = 376;
            pub const NID_md5WithRSA: c_int = 104;
            pub const NID_des_ecb: c_int = 29;
            pub const NID_des_cbc: c_int = 31;
            pub const NID_des_ofb64: c_int = 45;
            pub const NID_des_cfb64: c_int = 30;
            pub const NID_rsaSignature: c_int = 377;
            pub const NID_dsa_2: c_int = 67;
            pub const NID_dsaWithSHA: c_int = 66;
            pub const NID_shaWithRSAEncryption: c_int = 42;
            pub const NID_des_ede_ecb: c_int = 32;
            pub const NID_des_ede3_ecb: c_int = 33;
            pub const NID_des_ede_cbc: c_int = 43;
            pub const NID_des_ede_cfb64: c_int = 60;
            pub const NID_des_ede3_cfb64: c_int = 61;
            pub const NID_des_ede_ofb64: c_int = 62;
            pub const NID_des_ede3_ofb64: c_int = 63;
            pub const NID_desx_cbc: c_int = 80;
            pub const NID_sha: c_int = 41;
            pub const NID_sha1: c_int = 64;
            pub const NID_dsaWithSHA1_2: c_int = 70;
            pub const NID_sha1WithRSA: c_int = 115;
            pub const NID_ripemd160: c_int = 117;
            pub const NID_ripemd160WithRSA: c_int = 119;
            pub const NID_sxnet: c_int = 143;
            pub const NID_X500: c_int = 11;
            pub const NID_X509: c_int = 12;
            pub const NID_commonName: c_int = 13;
            pub const NID_surname: c_int = 100;
            pub const NID_serialNumber: c_int = 105;
            pub const NID_countryName: c_int = 14;
            pub const NID_localityName: c_int = 15;
            pub const NID_stateOrProvinceName: c_int = 16;
            pub const NID_streetAddress: c_int = 660;
            pub const NID_organizationName: c_int = 17;
            pub const NID_organizationalUnitName: c_int = 18;
            pub const NID_title: c_int = 106;
            pub const NID_description: c_int = 107;
            pub const NID_searchGuide: c_int = 859;
            pub const NID_businessCategory: c_int = 860;
            pub const NID_postalAddress: c_int = 861;
            pub const NID_postalCode: c_int = 661;
            pub const NID_postOfficeBox: c_int = 862;
            pub const NID_physicalDeliveryOfficeName: c_int = 863;
            pub const NID_telephoneNumber: c_int = 864;
            pub const NID_telexNumber: c_int = 865;
            pub const NID_teletexTerminalIdentifier: c_int = 866;
            pub const NID_facsimileTelephoneNumber: c_int = 867;
            pub const NID_x121Address: c_int = 868;
            pub const NID_internationaliSDNNumber: c_int = 869;
            pub const NID_registeredAddress: c_int = 870;
            pub const NID_destinationIndicator: c_int = 871;
            pub const NID_preferredDeliveryMethod: c_int = 872;
            pub const NID_presentationAddress: c_int = 873;
            pub const NID_supportedApplicationContext: c_int = 874;
            pub const NID_member: c_int = 875;
            pub const NID_owner: c_int = 876;
            pub const NID_roleOccupant: c_int = 877;
            pub const NID_seeAlso: c_int = 878;
            pub const NID_userPassword: c_int = 879;
            pub const NID_userCertificate: c_int = 880;
            pub const NID_cACertificate: c_int = 881;
            pub const NID_authorityRevocationList: c_int = 882;
            pub const NID_certificateRevocationList: c_int = 883;
            pub const NID_crossCertificatePair: c_int = 884;
            pub const NID_name: c_int = 173;
            pub const NID_givenName: c_int = 99;
            pub const NID_initials: c_int = 101;
            pub const NID_generationQualifier: c_int = 509;
            pub const NID_x500UniqueIdentifier: c_int = 503;
            pub const NID_dnQualifier: c_int = 174;
            pub const NID_enhancedSearchGuide: c_int = 885;
            pub const NID_protocolInformation: c_int = 886;
            pub const NID_distinguishedName: c_int = 887;
            pub const NID_uniqueMember: c_int = 888;
            pub const NID_houseIdentifier: c_int = 889;
            pub const NID_supportedAlgorithms: c_int = 890;
            pub const NID_deltaRevocationList: c_int = 891;
            pub const NID_dmdName: c_int = 892;
            pub const NID_pseudonym: c_int = 510;
            pub const NID_role: c_int = 400;
            pub const NID_X500algorithms: c_int = 378;
            pub const NID_rsa: c_int = 19;
            pub const NID_mdc2WithRSA: c_int = 96;
            pub const NID_mdc2: c_int = 95;
            pub const NID_id_ce: c_int = 81;
            pub const NID_subject_directory_attributes: c_int = 769;
            pub const NID_subject_key_identifier: c_int = 82;
            pub const NID_key_usage: c_int = 83;
            pub const NID_private_key_usage_period: c_int = 84;
            pub const NID_subject_alt_name: c_int = 85;
            pub const NID_issuer_alt_name: c_int = 86;
            pub const NID_basic_constraints: c_int = 87;
            pub const NID_crl_number: c_int = 88;
            pub const NID_crl_reason: c_int = 141;
            pub const NID_invalidity_date: c_int = 142;
            pub const NID_delta_crl: c_int = 140;
            pub const NID_issuing_distribution_point: c_int = 770;
            pub const NID_certificate_issuer: c_int = 771;
            pub const NID_name_constraints: c_int = 666;
            pub const NID_crl_distribution_points: c_int = 103;
            pub const NID_certificate_policies: c_int = 89;
            pub const NID_any_policy: c_int = 746;
            pub const NID_policy_mappings: c_int = 747;
            pub const NID_authority_key_identifier: c_int = 90;
            pub const NID_policy_constraints: c_int = 401;
            pub const NID_ext_key_usage: c_int = 126;
            pub const NID_freshest_crl: c_int = 857;
            pub const NID_inhibit_any_policy: c_int = 748;
            pub const NID_target_information: c_int = 402;
            pub const NID_no_rev_avail: c_int = 403;
            pub const NID_anyExtendedKeyUsage: c_int = 910;
            pub const NID_netscape: c_int = 57;
            pub const NID_netscape_cert_extension: c_int = 58;
            pub const NID_netscape_data_type: c_int = 59;
            pub const NID_netscape_cert_type: c_int = 71;
            pub const NID_netscape_base_url: c_int = 72;
            pub const NID_netscape_revocation_url: c_int = 73;
            pub const NID_netscape_ca_revocation_url: c_int = 74;
            pub const NID_netscape_renewal_url: c_int = 75;
            pub const NID_netscape_ca_policy_url: c_int = 76;
            pub const NID_netscape_ssl_server_name: c_int = 77;
            pub const NID_netscape_comment: c_int = 78;
            pub const NID_netscape_cert_sequence: c_int = 79;
            pub const NID_ns_sgc: c_int = 139;
            pub const NID_org: c_int = 379;
            pub const NID_dod: c_int = 380;
            pub const NID_iana: c_int = 381;
            pub const NID_Directory: c_int = 382;
            pub const NID_Management: c_int = 383;
            pub const NID_Experimental: c_int = 384;
            pub const NID_Private: c_int = 385;
            pub const NID_Security: c_int = 386;
            pub const NID_SNMPv2: c_int = 387;
            pub const NID_Mail: c_int = 388;
            pub const NID_Enterprises: c_int = 389;
            pub const NID_dcObject: c_int = 390;
            pub const NID_mime_mhs: c_int = 504;
            pub const NID_mime_mhs_headings: c_int = 505;
            pub const NID_mime_mhs_bodies: c_int = 506;
            pub const NID_id_hex_partial_message: c_int = 507;
            pub const NID_id_hex_multipart_message: c_int = 508;
            pub const NID_zlib_compression: c_int = 125;
            pub const NID_aes_128_ecb: c_int = 418;
            pub const NID_aes_128_cbc: c_int = 419;
            pub const NID_aes_128_ofb128: c_int = 420;
            pub const NID_aes_128_cfb128: c_int = 421;
            pub const NID_id_aes128_wrap: c_int = 788;
            pub const NID_aes_128_gcm: c_int = 895;
            pub const NID_aes_128_ccm: c_int = 896;
            pub const NID_id_aes128_wrap_pad: c_int = 897;
            pub const NID_aes_192_ecb: c_int = 422;
            pub const NID_aes_192_cbc: c_int = 423;
            pub const NID_aes_192_ofb128: c_int = 424;
            pub const NID_aes_192_cfb128: c_int = 425;
            pub const NID_id_aes192_wrap: c_int = 789;
            pub const NID_aes_192_gcm: c_int = 898;
            pub const NID_aes_192_ccm: c_int = 899;
            pub const NID_id_aes192_wrap_pad: c_int = 900;
            pub const NID_aes_256_ecb: c_int = 426;
            pub const NID_aes_256_cbc: c_int = 427;
            pub const NID_aes_256_ofb128: c_int = 428;
            pub const NID_aes_256_cfb128: c_int = 429;
            pub const NID_id_aes256_wrap: c_int = 790;
            pub const NID_aes_256_gcm: c_int = 901;
            pub const NID_aes_256_ccm: c_int = 902;
            pub const NID_id_aes256_wrap_pad: c_int = 903;
            pub const NID_aes_128_cfb1: c_int = 650;
            pub const NID_aes_192_cfb1: c_int = 651;
            pub const NID_aes_256_cfb1: c_int = 652;
            pub const NID_aes_128_cfb8: c_int = 653;
            pub const NID_aes_192_cfb8: c_int = 654;
            pub const NID_aes_256_cfb8: c_int = 655;
            pub const NID_aes_128_ctr: c_int = 904;
            pub const NID_aes_192_ctr: c_int = 905;
            pub const NID_aes_256_ctr: c_int = 906;
            pub const NID_aes_128_xts: c_int = 913;
            pub const NID_aes_256_xts: c_int = 914;
            pub const NID_des_cfb1: c_int = 656;
            pub const NID_des_cfb8: c_int = 657;
            pub const NID_des_ede3_cfb1: c_int = 658;
            pub const NID_des_ede3_cfb8: c_int = 659;
            pub const NID_sha256: c_int = 672;
            pub const NID_sha384: c_int = 673;
            pub const NID_sha512: c_int = 674;
            pub const NID_sha224: c_int = 675;
            pub const NID_dsa_with_SHA224: c_int = 802;
            pub const NID_dsa_with_SHA256: c_int = 803;
            pub const NID_hold_instruction_code: c_int = 430;
            pub const NID_hold_instruction_none: c_int = 431;
            pub const NID_hold_instruction_call_issuer: c_int = 432;
            pub const NID_hold_instruction_reject: c_int = 433;
            pub const NID_data: c_int = 434;
            pub const NID_pss: c_int = 435;
            pub const NID_ucl: c_int = 436;
            pub const NID_pilot: c_int = 437;
            pub const NID_pilotAttributeType: c_int = 438;
            pub const NID_pilotAttributeSyntax: c_int = 439;
            pub const NID_pilotObjectClass: c_int = 440;
            pub const NID_pilotGroups: c_int = 441;
            pub const NID_iA5StringSyntax: c_int = 442;
            pub const NID_caseIgnoreIA5StringSyntax: c_int = 443;
            pub const NID_pilotObject: c_int = 444;
            pub const NID_pilotPerson: c_int = 445;
            pub const NID_account: c_int = 446;
            pub const NID_document: c_int = 447;
            pub const NID_room: c_int = 448;
            pub const NID_documentSeries: c_int = 449;
            pub const NID_Domain: c_int = 392;
            pub const NID_rFC822localPart: c_int = 450;
            pub const NID_dNSDomain: c_int = 451;
            pub const NID_domainRelatedObject: c_int = 452;
            pub const NID_friendlyCountry: c_int = 453;
            pub const NID_simpleSecurityObject: c_int = 454;
            pub const NID_pilotOrganization: c_int = 455;
            pub const NID_pilotDSA: c_int = 456;
            pub const NID_qualityLabelledData: c_int = 457;
            pub const NID_userId: c_int = 458;
            pub const NID_textEncodedORAddress: c_int = 459;
            pub const NID_rfc822Mailbox: c_int = 460;
            pub const NID_info: c_int = 461;
            pub const NID_favouriteDrink: c_int = 462;
            pub const NID_roomNumber: c_int = 463;
            pub const NID_photo: c_int = 464;
            pub const NID_userClass: c_int = 465;
            pub const NID_host: c_int = 466;
            pub const NID_manager: c_int = 467;
            pub const NID_documentIdentifier: c_int = 468;
            pub const NID_documentTitle: c_int = 469;
            pub const NID_documentVersion: c_int = 470;
            pub const NID_documentAuthor: c_int = 471;
            pub const NID_documentLocation: c_int = 472;
            pub const NID_homeTelephoneNumber: c_int = 473;
            pub const NID_secretary: c_int = 474;
            pub const NID_otherMailbox: c_int = 475;
            pub const NID_lastModifiedTime: c_int = 476;
            pub const NID_lastModifiedBy: c_int = 477;
            pub const NID_domainComponent: c_int = 391;
            pub const NID_aRecord: c_int = 478;
            pub const NID_pilotAttributeType27: c_int = 479;
            pub const NID_mXRecord: c_int = 480;
            pub const NID_nSRecord: c_int = 481;
            pub const NID_sOARecord: c_int = 482;
            pub const NID_cNAMERecord: c_int = 483;
            pub const NID_associatedDomain: c_int = 484;
            pub const NID_associatedName: c_int = 485;
            pub const NID_homePostalAddress: c_int = 486;
            pub const NID_personalTitle: c_int = 487;
            pub const NID_mobileTelephoneNumber: c_int = 488;
            pub const NID_pagerTelephoneNumber: c_int = 489;
            pub const NID_friendlyCountryName: c_int = 490;
            pub const NID_organizationalStatus: c_int = 491;
            pub const NID_janetMailbox: c_int = 492;
            pub const NID_mailPreferenceOption: c_int = 493;
            pub const NID_buildingName: c_int = 494;
            pub const NID_dSAQuality: c_int = 495;
            pub const NID_singleLevelQuality: c_int = 496;
            pub const NID_subtreeMinimumQuality: c_int = 497;
            pub const NID_subtreeMaximumQuality: c_int = 498;
            pub const NID_personalSignature: c_int = 499;
            pub const NID_dITRedirect: c_int = 500;
            pub const NID_audio: c_int = 501;
            pub const NID_documentPublisher: c_int = 502;
            pub const NID_id_set: c_int = 512;
            pub const NID_set_ctype: c_int = 513;
            pub const NID_set_msgExt: c_int = 514;
            pub const NID_set_attr: c_int = 515;
            pub const NID_set_policy: c_int = 516;
            pub const NID_set_certExt: c_int = 517;
            pub const NID_set_brand: c_int = 518;
            pub const NID_setct_PANData: c_int = 519;
            pub const NID_setct_PANToken: c_int = 520;
            pub const NID_setct_PANOnly: c_int = 521;
            pub const NID_setct_OIData: c_int = 522;
            pub const NID_setct_PI: c_int = 523;
            pub const NID_setct_PIData: c_int = 524;
            pub const NID_setct_PIDataUnsigned: c_int = 525;
            pub const NID_setct_HODInput: c_int = 526;
            pub const NID_setct_AuthResBaggage: c_int = 527;
            pub const NID_setct_AuthRevReqBaggage: c_int = 528;
            pub const NID_setct_AuthRevResBaggage: c_int = 529;
            pub const NID_setct_CapTokenSeq: c_int = 530;
            pub const NID_setct_PInitResData: c_int = 531;
            pub const NID_setct_PI_TBS: c_int = 532;
            pub const NID_setct_PResData: c_int = 533;
            pub const NID_setct_AuthReqTBS: c_int = 534;
            pub const NID_setct_AuthResTBS: c_int = 535;
            pub const NID_setct_AuthResTBSX: c_int = 536;
            pub const NID_setct_AuthTokenTBS: c_int = 537;
            pub const NID_setct_CapTokenData: c_int = 538;
            pub const NID_setct_CapTokenTBS: c_int = 539;
            pub const NID_setct_AcqCardCodeMsg: c_int = 540;
            pub const NID_setct_AuthRevReqTBS: c_int = 541;
            pub const NID_setct_AuthRevResData: c_int = 542;
            pub const NID_setct_AuthRevResTBS: c_int = 543;
            pub const NID_setct_CapReqTBS: c_int = 544;
            pub const NID_setct_CapReqTBSX: c_int = 545;
            pub const NID_setct_CapResData: c_int = 546;
            pub const NID_setct_CapRevReqTBS: c_int = 547;
            pub const NID_setct_CapRevReqTBSX: c_int = 548;
            pub const NID_setct_CapRevResData: c_int = 549;
            pub const NID_setct_CredReqTBS: c_int = 550;
            pub const NID_setct_CredReqTBSX: c_int = 551;
            pub const NID_setct_CredResData: c_int = 552;
            pub const NID_setct_CredRevReqTBS: c_int = 553;
            pub const NID_setct_CredRevReqTBSX: c_int = 554;
            pub const NID_setct_CredRevResData: c_int = 555;
            pub const NID_setct_PCertReqData: c_int = 556;
            pub const NID_setct_PCertResTBS: c_int = 557;
            pub const NID_setct_BatchAdminReqData: c_int = 558;
            pub const NID_setct_BatchAdminResData: c_int = 559;
            pub const NID_setct_CardCInitResTBS: c_int = 560;
            pub const NID_setct_MeAqCInitResTBS: c_int = 561;
            pub const NID_setct_RegFormResTBS: c_int = 562;
            pub const NID_setct_CertReqData: c_int = 563;
            pub const NID_setct_CertReqTBS: c_int = 564;
            pub const NID_setct_CertResData: c_int = 565;
            pub const NID_setct_CertInqReqTBS: c_int = 566;
            pub const NID_setct_ErrorTBS: c_int = 567;
            pub const NID_setct_PIDualSignedTBE: c_int = 568;
            pub const NID_setct_PIUnsignedTBE: c_int = 569;
            pub const NID_setct_AuthReqTBE: c_int = 570;
            pub const NID_setct_AuthResTBE: c_int = 571;
            pub const NID_setct_AuthResTBEX: c_int = 572;
            pub const NID_setct_AuthTokenTBE: c_int = 573;
            pub const NID_setct_CapTokenTBE: c_int = 574;
            pub const NID_setct_CapTokenTBEX: c_int = 575;
            pub const NID_setct_AcqCardCodeMsgTBE: c_int = 576;
            pub const NID_setct_AuthRevReqTBE: c_int = 577;
            pub const NID_setct_AuthRevResTBE: c_int = 578;
            pub const NID_setct_AuthRevResTBEB: c_int = 579;
            pub const NID_setct_CapReqTBE: c_int = 580;
            pub const NID_setct_CapReqTBEX: c_int = 581;
            pub const NID_setct_CapResTBE: c_int = 582;
            pub const NID_setct_CapRevReqTBE: c_int = 583;
            pub const NID_setct_CapRevReqTBEX: c_int = 584;
            pub const NID_setct_CapRevResTBE: c_int = 585;
            pub const NID_setct_CredReqTBE: c_int = 586;
            pub const NID_setct_CredReqTBEX: c_int = 587;
            pub const NID_setct_CredResTBE: c_int = 588;
            pub const NID_setct_CredRevReqTBE: c_int = 589;
            pub const NID_setct_CredRevReqTBEX: c_int = 590;
            pub const NID_setct_CredRevResTBE: c_int = 591;
            pub const NID_setct_BatchAdminReqTBE: c_int = 592;
            pub const NID_setct_BatchAdminResTBE: c_int = 593;
            pub const NID_setct_RegFormReqTBE: c_int = 594;
            pub const NID_setct_CertReqTBE: c_int = 595;
            pub const NID_setct_CertReqTBEX: c_int = 596;
            pub const NID_setct_CertResTBE: c_int = 597;
            pub const NID_setct_CRLNotificationTBS: c_int = 598;
            pub const NID_setct_CRLNotificationResTBS: c_int = 599;
            pub const NID_setct_BCIDistributionTBS: c_int = 600;
            pub const NID_setext_genCrypt: c_int = 601;
            pub const NID_setext_miAuth: c_int = 602;
            pub const NID_setext_pinSecure: c_int = 603;
            pub const NID_setext_pinAny: c_int = 604;
            pub const NID_setext_track2: c_int = 605;
            pub const NID_setext_cv: c_int = 606;
            pub const NID_set_policy_root: c_int = 607;
            pub const NID_setCext_hashedRoot: c_int = 608;
            pub const NID_setCext_certType: c_int = 609;
            pub const NID_setCext_merchData: c_int = 610;
            pub const NID_setCext_cCertRequired: c_int = 611;
            pub const NID_setCext_tunneling: c_int = 612;
            pub const NID_setCext_setExt: c_int = 613;
            pub const NID_setCext_setQualf: c_int = 614;
            pub const NID_setCext_PGWYcapabilities: c_int = 615;
            pub const NID_setCext_TokenIdentifier: c_int = 616;
            pub const NID_setCext_Track2Data: c_int = 617;
            pub const NID_setCext_TokenType: c_int = 618;
            pub const NID_setCext_IssuerCapabilities: c_int = 619;
            pub const NID_setAttr_Cert: c_int = 620;
            pub const NID_setAttr_PGWYcap: c_int = 621;
            pub const NID_setAttr_TokenType: c_int = 622;
            pub const NID_setAttr_IssCap: c_int = 623;
            pub const NID_set_rootKeyThumb: c_int = 624;
            pub const NID_set_addPolicy: c_int = 625;
            pub const NID_setAttr_Token_EMV: c_int = 626;
            pub const NID_setAttr_Token_B0Prime: c_int = 627;
            pub const NID_setAttr_IssCap_CVM: c_int = 628;
            pub const NID_setAttr_IssCap_T2: c_int = 629;
            pub const NID_setAttr_IssCap_Sig: c_int = 630;
            pub const NID_setAttr_GenCryptgrm: c_int = 631;
            pub const NID_setAttr_T2Enc: c_int = 632;
            pub const NID_setAttr_T2cleartxt: c_int = 633;
            pub const NID_setAttr_TokICCsig: c_int = 634;
            pub const NID_setAttr_SecDevSig: c_int = 635;
            pub const NID_set_brand_IATA_ATA: c_int = 636;
            pub const NID_set_brand_Diners: c_int = 637;
            pub const NID_set_brand_AmericanExpress: c_int = 638;
            pub const NID_set_brand_JCB: c_int = 639;
            pub const NID_set_brand_Visa: c_int = 640;
            pub const NID_set_brand_MasterCard: c_int = 641;
            pub const NID_set_brand_Novus: c_int = 642;
            pub const NID_des_cdmf: c_int = 643;
            pub const NID_rsaOAEPEncryptionSET: c_int = 644;
            pub const NID_ipsec3: c_int = 749;
            pub const NID_ipsec4: c_int = 750;
            pub const NID_whirlpool: c_int = 804;
            pub const NID_cryptopro: c_int = 805;
            pub const NID_cryptocom: c_int = 806;
            pub const NID_id_GostR3411_94_with_GostR3410_2001: c_int = 807;
            pub const NID_id_GostR3411_94_with_GostR3410_94: c_int = 808;
            pub const NID_id_GostR3411_94: c_int = 809;
            pub const NID_id_HMACGostR3411_94: c_int = 810;
            pub const NID_id_GostR3410_2001: c_int = 811;
            pub const NID_id_GostR3410_94: c_int = 812;
            pub const NID_id_Gost28147_89: c_int = 813;
            pub const NID_gost89_cnt: c_int = 814;
            pub const NID_id_Gost28147_89_MAC: c_int = 815;
            pub const NID_id_GostR3411_94_prf: c_int = 816;
            pub const NID_id_GostR3410_2001DH: c_int = 817;
            pub const NID_id_GostR3410_94DH: c_int = 818;
            pub const NID_id_Gost28147_89_CryptoPro_KeyMeshing: c_int = 819;
            pub const NID_id_Gost28147_89_None_KeyMeshing: c_int = 820;
            pub const NID_id_GostR3411_94_TestParamSet: c_int = 821;
            pub const NID_id_GostR3411_94_CryptoProParamSet: c_int = 822;
            pub const NID_id_Gost28147_89_TestParamSet: c_int = 823;
            pub const NID_id_Gost28147_89_CryptoPro_A_ParamSet: c_int = 824;
            pub const NID_id_Gost28147_89_CryptoPro_B_ParamSet: c_int = 825;
            pub const NID_id_Gost28147_89_CryptoPro_C_ParamSet: c_int = 826;
            pub const NID_id_Gost28147_89_CryptoPro_D_ParamSet: c_int = 827;
            pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: c_int = 828;
            pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: c_int = 829;
            pub const NID_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: c_int = 830;
            pub const NID_id_GostR3410_94_TestParamSet: c_int = 831;
            pub const NID_id_GostR3410_94_CryptoPro_A_ParamSet: c_int = 832;
            pub const NID_id_GostR3410_94_CryptoPro_B_ParamSet: c_int = 833;
            pub const NID_id_GostR3410_94_CryptoPro_C_ParamSet: c_int = 834;
            pub const NID_id_GostR3410_94_CryptoPro_D_ParamSet: c_int = 835;
            pub const NID_id_GostR3410_94_CryptoPro_XchA_ParamSet: c_int = 836;
            pub const NID_id_GostR3410_94_CryptoPro_XchB_ParamSet: c_int = 837;
            pub const NID_id_GostR3410_94_CryptoPro_XchC_ParamSet: c_int = 838;
            pub const NID_id_GostR3410_2001_TestParamSet: c_int = 839;
            pub const NID_id_GostR3410_2001_CryptoPro_A_ParamSet: c_int = 840;
            pub const NID_id_GostR3410_2001_CryptoPro_B_ParamSet: c_int = 841;
            pub const NID_id_GostR3410_2001_CryptoPro_C_ParamSet: c_int = 842;
            pub const NID_id_GostR3410_2001_CryptoPro_XchA_ParamSet: c_int = 843;
            pub const NID_id_GostR3410_2001_CryptoPro_XchB_ParamSet: c_int = 844;
            pub const NID_id_GostR3410_94_a: c_int = 845;
            pub const NID_id_GostR3410_94_aBis: c_int = 846;
            pub const NID_id_GostR3410_94_b: c_int = 847;
            pub const NID_id_GostR3410_94_bBis: c_int = 848;
            pub const NID_id_Gost28147_89_cc: c_int = 849;
            pub const NID_id_GostR3410_94_cc: c_int = 850;
            pub const NID_id_GostR3410_2001_cc: c_int = 851;
            pub const NID_id_GostR3411_94_with_GostR3410_94_cc: c_int = 852;
            pub const NID_id_GostR3411_94_with_GostR3410_2001_cc: c_int = 853;
            pub const NID_id_GostR3410_2001_ParamSet_cc: c_int = 854;
            pub const NID_camellia_128_cbc: c_int = 751;
            pub const NID_camellia_192_cbc: c_int = 752;
            pub const NID_camellia_256_cbc: c_int = 753;
            pub const NID_id_camellia128_wrap: c_int = 907;
            pub const NID_id_camellia192_wrap: c_int = 908;
            pub const NID_id_camellia256_wrap: c_int = 909;
            pub const NID_camellia_128_ecb: c_int = 754;
            pub const NID_camellia_128_ofb128: c_int = 766;
            pub const NID_camellia_128_cfb128: c_int = 757;
            pub const NID_camellia_192_ecb: c_int = 755;
            pub const NID_camellia_192_ofb128: c_int = 767;
            pub const NID_camellia_192_cfb128: c_int = 758;
            pub const NID_camellia_256_ecb: c_int = 756;
            pub const NID_camellia_256_ofb128: c_int = 768;
            pub const NID_camellia_256_cfb128: c_int = 759;
            pub const NID_camellia_128_cfb1: c_int = 760;
            pub const NID_camellia_192_cfb1: c_int = 761;
            pub const NID_camellia_256_cfb1: c_int = 762;
            pub const NID_camellia_128_cfb8: c_int = 763;
            pub const NID_camellia_192_cfb8: c_int = 764;
            pub const NID_camellia_256_cfb8: c_int = 765;
            pub const NID_kisa: c_int = 773;
            pub const NID_seed_ecb: c_int = 776;
            pub const NID_seed_cbc: c_int = 777;
            pub const NID_seed_cfb128: c_int = 779;
            pub const NID_seed_ofb128: c_int = 778;
            pub const NID_hmac: c_int = 855;
            pub const NID_cmac: c_int = 894;
            pub const NID_rc4_hmac_md5: c_int = 915;
            pub const NID_aes_128_cbc_hmac_sha1: c_int = 916;
            pub const NID_aes_192_cbc_hmac_sha1: c_int = 917;
            pub const NID_aes_256_cbc_hmac_sha1: c_int = 918;
            #[cfg(ossl111)]
            pub const NID_X25519: c_int = 1034;
            #[cfg(libressl370)]
            pub const NID_X25519: c_int = 950;
            #[cfg(ossl111)]
            pub const NID_X448: c_int = 1035;
            #[cfg(ossl110)]
            pub const NID_hkdf: c_int = 1036;
            #[cfg(libressl360)]
            pub const NID_hkdf: c_int = 1022;
            #[cfg(ossl111)]
            pub const NID_poly1305: c_int = 1061;
            #[cfg(ossl111)]
            pub const NID_ED25519: c_int = 1087;
            #[cfg(libressl370)]
            pub const NID_ED25519: c_int = 952;
            #[cfg(ossl111)]
            pub const NID_ED448: c_int = 1088;
            #[cfg(ossl111)]
            pub const NID_sm2: c_int = 1172;
            #[cfg(ossl111)]
            pub const NID_sm3: c_int = 1143;
            #[cfg(libressl291)]
            pub const NID_sm3: c_int = 968;
            #[cfg(ossl111)]
            pub const NID_sm3WithRSAEncryption: c_int = 1144;
            #[cfg(libressl291)]
            pub const NID_sm3WithRSAEncryption: c_int = 969;
            #[cfg(ossl111)]
            pub const NID_sm4_ecb: c_int = 1133;
            #[cfg(libressl291)]
            pub const NID_sm4_ecb: c_int = 973;
            #[cfg(ossl111)]
            pub const NID_sm4_cbc: c_int = 1134;
            #[cfg(libressl291)]
            pub const NID_sm4_cbc: c_int = 974;
            #[cfg(ossl111)]
            pub const NID_sm4_ofb128: c_int = 1135;
            #[cfg(libressl291)]
            pub const NID_sm4_ofb128: c_int = 975;
            #[cfg(ossl111)]
            pub const NID_sm4_cfb128: c_int = 1137;
            #[cfg(libressl291)]
            pub const NID_sm4_cfb128: c_int = 976;
            #[cfg(ossl111)]
            pub const NID_sm4_cfb1: c_int = 1136;
            #[cfg(libressl291)]
            pub const NID_sm4_cfb1: c_int = 977;
            #[cfg(ossl111)]
            pub const NID_sm4_cfb8: c_int = 1138;
            #[cfg(libressl291)]
            pub const NID_sm4_cfb8: c_int = 978;
            #[cfg(ossl111)]
            pub const NID_sm4_ctr: c_int = 1139;
            #[cfg(libressl291)]
            pub const NID_sm4_ctr: c_int = 979;
            #[cfg(ossl111)]
            pub const NID_sha3_224: c_int = 1096;
            #[cfg(libressl380)]
            pub const NID_sha3_224: c_int = 1031;
            #[cfg(ossl111)]
            pub const NID_sha3_256: c_int = 1097;
            #[cfg(libressl380)]
            pub const NID_sha3_256: c_int = 1032;
            #[cfg(ossl111)]
            pub const NID_sha3_384: c_int = 1098;
            #[cfg(libressl380)]
            pub const NID_sha3_384: c_int = 1033;
            #[cfg(ossl111)]
            pub const NID_sha3_512: c_int = 1099;
            #[cfg(libressl380)]
            pub const NID_sha3_512: c_int = 1034;
            #[cfg(ossl111)]
            pub const NID_shake128: c_int = 1100;
            #[cfg(ossl111)]
            pub const NID_shake256: c_int = 1101;
            #[cfg(ossl110)]
            pub const NID_chacha20_poly1305: c_int = 1018;
            #[cfg(libressl271)]
            pub const NID_chacha20_poly1305: c_int = 967;
        }

        pub mod ocsp
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            pub const OCSP_REVOKED_STATUS_NOSTATUS: c_int = -1;
            pub const OCSP_REVOKED_STATUS_UNSPECIFIED: c_int = 0;
            pub const OCSP_REVOKED_STATUS_KEYCOMPROMISE: c_int = 1;
            pub const OCSP_REVOKED_STATUS_CACOMPROMISE: c_int = 2;
            pub const OCSP_REVOKED_STATUS_AFFILIATIONCHANGED: c_int = 3;
            pub const OCSP_REVOKED_STATUS_SUPERSEDED: c_int = 4;
            pub const OCSP_REVOKED_STATUS_CESSATIONOFOPERATION: c_int = 5;
            pub const OCSP_REVOKED_STATUS_CERTIFICATEHOLD: c_int = 6;
            pub const OCSP_REVOKED_STATUS_REMOVEFROMCRL: c_int = 8;
            pub const OCSP_NOCERTS: c_ulong = 0x1;
            pub const OCSP_NOINTERN: c_ulong = 0x2;
            pub const OCSP_NOSIGS: c_ulong = 0x4;
            pub const OCSP_NOCHAIN: c_ulong = 0x8;
            pub const OCSP_NOVERIFY: c_ulong = 0x10;
            pub const OCSP_NOEXPLICIT: c_ulong = 0x20;
            pub const OCSP_NOCASIGN: c_ulong = 0x40;
            pub const OCSP_NODELEGATED: c_ulong = 0x80;
            pub const OCSP_NOCHECKS: c_ulong = 0x100;
            pub const OCSP_TRUSTOTHER: c_ulong = 0x200;
            pub const OCSP_RESPID_KEY: c_ulong = 0x400;
            pub const OCSP_NOTIME: c_ulong = 0x800;
            pub const OCSP_RESPONSE_STATUS_SUCCESSFUL: c_int = 0;
            pub const OCSP_RESPONSE_STATUS_MALFORMEDREQUEST: c_int = 1;
            pub const OCSP_RESPONSE_STATUS_INTERNALERROR: c_int = 2;
            pub const OCSP_RESPONSE_STATUS_TRYLATER: c_int = 3;
            pub const OCSP_RESPONSE_STATUS_SIGREQUIRED: c_int = 5;
            pub const OCSP_RESPONSE_STATUS_UNAUTHORIZED: c_int = 6;
            pub const V_OCSP_CERTSTATUS_GOOD: c_int = 0;
            pub const V_OCSP_CERTSTATUS_REVOKED: c_int = 1;
            pub const V_OCSP_CERTSTATUS_UNKNOWN: c_int = 2;
        }

        pub mod pem
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            pub const PEM_R_NO_START_LINE: c_int = 108;            
        }

        pub mod pkcs7
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            pub const PKCS7_TEXT: c_int = 0x1;
            pub const PKCS7_NOCERTS: c_int = 0x2;
            pub const PKCS7_NOSIGS: c_int = 0x4;
            pub const PKCS7_NOCHAIN: c_int = 0x8;
            pub const PKCS7_NOINTERN: c_int = 0x10;
            pub const PKCS7_NOVERIFY: c_int = 0x20;
            pub const PKCS7_DETACHED: c_int = 0x40;
            pub const PKCS7_BINARY: c_int = 0x80;
            pub const PKCS7_NOATTR: c_int = 0x100;
            pub const PKCS7_NOSMIMECAP: c_int = 0x200;
            pub const PKCS7_NOOLDMIMETYPE: c_int = 0x400;
            pub const PKCS7_CRLFEOL: c_int = 0x800;
            pub const PKCS7_STREAM: c_int = 0x1000;
            pub const PKCS7_NOCRL: c_int = 0x2000;
            pub const PKCS7_PARTIAL: c_int = 0x4000;
            pub const PKCS7_REUSE_DIGEST: c_int = 0x8000;
            #[cfg(not(any(ossl101, ossl102, libressl)))]
            pub const PKCS7_NO_DUAL_CONTENT: c_int = 0x10000;
        }

        pub mod rsa
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                system::
                {
                    openssl::
                    {
                        evp::{ * },
                    },
                },
                *,
            };
            /*
            */
            pub const RSA_F4: c_long = 0x10001;

            cfg_if! {
                if #[cfg(not(ossl300))] {
                    pub unsafe fn EVP_PKEY_CTX_set_rsa_padding(ctx: *mut EVP_PKEY_CTX, pad: c_int) -> c_int {
                        EVP_PKEY_CTX_ctrl(
                            ctx,
                            EVP_PKEY_RSA,
                            -1,
                            EVP_PKEY_CTRL_RSA_PADDING,
                            pad,
                            ptr::null_mut(),
                        )
                    }
                    pub unsafe fn EVP_PKEY_CTX_get_rsa_padding(ctx: *mut EVP_PKEY_CTX, ppad: *mut c_int) -> c_int {
                        EVP_PKEY_CTX_ctrl(
                            ctx,
                            EVP_PKEY_RSA,
                            -1,
                            EVP_PKEY_CTRL_GET_RSA_PADDING,
                            0,
                            ppad as *mut c_void,
                        )
                    }

                    pub unsafe fn EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx: *mut EVP_PKEY_CTX, len: c_int) -> c_int {
                        EVP_PKEY_CTX_ctrl(
                            ctx,
                            EVP_PKEY_RSA,
                            EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY,
                            EVP_PKEY_CTRL_RSA_PSS_SALTLEN,
                            len,
                            ptr::null_mut(),
                        )
                    }

                    pub unsafe fn EVP_PKEY_CTX_set_rsa_mgf1_md(ctx: *mut EVP_PKEY_CTX, md: *mut EVP_MD) -> c_int {
                        EVP_PKEY_CTX_ctrl(
                            ctx,
                            EVP_PKEY_RSA,
                            EVP_PKEY_OP_TYPE_SIG | EVP_PKEY_OP_TYPE_CRYPT,
                            EVP_PKEY_CTRL_RSA_MGF1_MD,
                            0,
                            md as *mut c_void,
                        )
                    }
                }
            }

            #[cfg(any(ossl102, libressl310))]
            pub unsafe fn EVP_PKEY_CTX_set_rsa_oaep_md(ctx: *mut EVP_PKEY_CTX, md: *mut EVP_MD) -> c_int {
                EVP_PKEY_CTX_ctrl(
                    ctx,
                    EVP_PKEY_RSA,
                    EVP_PKEY_OP_TYPE_CRYPT,
                    EVP_PKEY_CTRL_RSA_OAEP_MD,
                    0,
                    md as *mut c_void,
                )
            }

            #[cfg(any(ossl102, libressl310))]
            pub unsafe fn EVP_PKEY_CTX_set0_rsa_oaep_label(
                ctx: *mut EVP_PKEY_CTX,
                label: *mut c_void,
                len: c_int,
            ) -> c_int {
                EVP_PKEY_CTX_ctrl(
                    ctx,
                    EVP_PKEY_RSA,
                    EVP_PKEY_OP_TYPE_CRYPT,
                    EVP_PKEY_CTRL_RSA_OAEP_LABEL,
                    len,
                    label,
                )
            }

            pub const EVP_PKEY_CTRL_RSA_PADDING: c_int = EVP_PKEY_ALG_CTRL + 1;
            pub const EVP_PKEY_CTRL_RSA_PSS_SALTLEN: c_int = EVP_PKEY_ALG_CTRL + 2;

            pub const EVP_PKEY_CTRL_RSA_MGF1_MD: c_int = EVP_PKEY_ALG_CTRL + 5;

            pub const EVP_PKEY_CTRL_GET_RSA_PADDING: c_int = EVP_PKEY_ALG_CTRL + 6;

            #[cfg(any(ossl102, libressl310))]
            pub const EVP_PKEY_CTRL_RSA_OAEP_MD: c_int = EVP_PKEY_ALG_CTRL + 9;
            #[cfg(any(ossl102, libressl310))]
            pub const EVP_PKEY_CTRL_RSA_OAEP_LABEL: c_int = EVP_PKEY_ALG_CTRL + 10;

            pub const RSA_PKCS1_PADDING: c_int = 1;
            #[cfg(not(ossl300))]
            pub const RSA_SSLV23_PADDING: c_int = 2;
            pub const RSA_NO_PADDING: c_int = 3;
            pub const RSA_PKCS1_OAEP_PADDING: c_int = 4;
            pub const RSA_X931_PADDING: c_int = 5;
            pub const RSA_PKCS1_PSS_PADDING: c_int = 6;
        }

        pub mod sha
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            #[cfg(not(osslconf = "OPENSSL_NO_DEPRECATED_3_0"))]
            pub const SHA_LBLOCK: c_int = 16;

            #[cfg(not(osslconf = "OPENSSL_NO_DEPRECATED_3_0"))]
            pub type SHA_LONG = c_uint;

            cfg_if! {
                if #[cfg(ossl300)] {
                    #[cfg(ossl300)]
                    // Ideally we'd macro define these, but that crashes ctest :(
                    pub unsafe fn SHA1(d: *const c_uchar, n: size_t, md: *mut c_uchar) -> *mut c_uchar {
                        if EVP_Q_digest(
                            ptr::null_mut(),
                            "SHA1\0".as_ptr() as *const c_char,
                            ptr::null(),
                            d as *const c_void,
                            n,
                            md,
                            ptr::null_mut(),
                        ) != 0
                        {
                            md
                        } else {
                            ptr::null_mut()
                        }
                    }

                    pub unsafe fn SHA224(d: *const c_uchar, n: size_t, md: *mut c_uchar) -> *mut c_uchar {
                        if EVP_Q_digest(
                            ptr::null_mut(),
                            "SHA224\0".as_ptr() as *const c_char,
                            ptr::null(),
                            d as *const c_void,
                            n,
                            md,
                            ptr::null_mut(),
                        ) != 0 {
                            md
                        } else {
                            ptr::null_mut()
                        }
                    }

                    pub unsafe fn SHA256(d: *const c_uchar, n: size_t, md: *mut c_uchar) -> *mut c_uchar {
                        if EVP_Q_digest(
                            ptr::null_mut(),
                            "SHA256\0".as_ptr() as *const c_char,
                            ptr::null(),
                            d as *const c_void,
                            n,
                            md,
                            ptr::null_mut(),
                        ) != 0 {
                            md
                        } else {
                            ptr::null_mut()
                        }
                    }
                }
            }

            #[cfg(not(osslconf = "OPENSSL_NO_DEPRECATED_3_0"))]
            pub type SHA_LONG64 = u64;

            cfg_if! {
                if #[cfg(ossl300)] {
                    pub unsafe fn SHA384(d: *const c_uchar, n: size_t, md: *mut c_uchar) -> *mut c_uchar {
                        if EVP_Q_digest(
                            ptr::null_mut(),
                            "SHA384\0".as_ptr() as *const c_char,
                            ptr::null(),
                            d as *const c_void,
                            n,
                            md,
                            ptr::null_mut(),
                        ) != 0 {
                            md
                        } else {
                            ptr::null_mut()
                        }
                    }

                    pub unsafe fn SHA512(d: *const c_uchar, n: size_t, md: *mut c_uchar) -> *mut c_uchar {
                        if EVP_Q_digest(
                            ptr::null_mut(),
                            "SHA512\0".as_ptr() as *const c_char,
                            ptr::null(),
                            d as *const c_void,
                            n,
                            md,
                            ptr::null_mut(),
                        ) != 0 {
                            md
                        } else {
                            ptr::null_mut()
                        }
                    }
                }
            }
        }

        pub mod srtp
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            pub const SRTP_AES128_CM_SHA1_80: c_ulong = 0x0001;
            pub const SRTP_AES128_CM_SHA1_32: c_ulong = 0x0002;
            pub const SRTP_AES128_F8_SHA1_80: c_ulong = 0x0003;
            pub const SRTP_AES128_F8_SHA1_32: c_ulong = 0x0004;
            pub const SRTP_NULL_SHA1_80: c_ulong = 0x0005;
            pub const SRTP_NULL_SHA1_32: c_ulong = 0x0006;

            /* AEAD SRTP protection profiles from RFC 7714 */
            #[cfg(ossl110)]
            pub const SRTP_AEAD_AES_128_GCM: c_ulong = 0x0007;
            #[cfg(ossl110)]
            pub const SRTP_AEAD_AES_256_GCM: c_ulong = 0x0008;
        }

        pub mod ssl
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                system::
                {
                    openssl::
                    {
                        ssl3::{ * },
                        tls1::{ * },
                        x509::{ * },
                    },
                },
                *,
            };
            /*
            */
            #[cfg(not(ossl110))]
            pub const SSL_MAX_KRB5_PRINCIPAL_LENGTH: c_int = 256;

            #[cfg(not(ossl110))]
            pub const SSL_MAX_SSL_SESSION_ID_LENGTH: c_int = 32;
            #[cfg(not(ossl110))]
            pub const SSL_MAX_SID_CTX_LENGTH: c_int = 32;

            #[cfg(not(ossl110))]
            pub const SSL_MAX_KEY_ARG_LENGTH: c_int = 8;
            #[cfg(not(ossl110))]
            pub const SSL_MAX_MASTER_KEY_LENGTH: c_int = 48;

            pub const SSL_SENT_SHUTDOWN: c_int = 1;
            pub const SSL_RECEIVED_SHUTDOWN: c_int = 2;

            pub const SSL_FILETYPE_PEM: c_int = X509_FILETYPE_PEM;
            pub const SSL_FILETYPE_ASN1: c_int = X509_FILETYPE_ASN1;

            #[cfg(ossl111)]
            pub const SSL_EXT_TLS_ONLY: c_uint = 0x0001;
            /* This extension is only allowed in DTLS */
            #[cfg(ossl111)]
            pub const SSL_EXT_DTLS_ONLY: c_uint = 0x0002;
            /* Some extensions may be allowed in DTLS but we don't implement them for it */
            #[cfg(ossl111)]
            pub const SSL_EXT_TLS_IMPLEMENTATION_ONLY: c_uint = 0x0004;
            /* Most extensions are not defined for SSLv3 but EXT_TYPE_renegotiate is */
            #[cfg(ossl111)]
            pub const SSL_EXT_SSL3_ALLOWED: c_uint = 0x0008;
            /* Extension is only defined for TLS1.2 and below */
            #[cfg(ossl111)]
            pub const SSL_EXT_TLS1_2_AND_BELOW_ONLY: c_uint = 0x0010;
            /* Extension is only defined for TLS1.3 and above */
            #[cfg(ossl111)]
            pub const SSL_EXT_TLS1_3_ONLY: c_uint = 0x0020;
            /* Ignore this extension during parsing if we are resuming */
            #[cfg(ossl111)]
            pub const SSL_EXT_IGNORE_ON_RESUMPTION: c_uint = 0x0040;
            #[cfg(ossl111)]
            pub const SSL_EXT_CLIENT_HELLO: c_uint = 0x0080;
            /* Really means TLS1.2 or below */
            #[cfg(ossl111)]
            pub const SSL_EXT_TLS1_2_SERVER_HELLO: c_uint = 0x0100;
            #[cfg(ossl111)]
            pub const SSL_EXT_TLS1_3_SERVER_HELLO: c_uint = 0x0200;
            #[cfg(ossl111)]
            pub const SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS: c_uint = 0x0400;
            #[cfg(ossl111)]
            pub const SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST: c_uint = 0x0800;
            #[cfg(ossl111)]
            pub const SSL_EXT_TLS1_3_CERTIFICATE: c_uint = 0x1000;
            #[cfg(ossl111)]
            pub const SSL_EXT_TLS1_3_NEW_SESSION_TICKET: c_uint = 0x2000;
            #[cfg(ossl111)]
            pub const SSL_EXT_TLS1_3_CERTIFICATE_REQUEST: c_uint = 0x4000;

            cfg_if! {
                if #[cfg(ossl300)] {
                    macro_rules! ssl_op_type {
                        () => {u64};
                    }
                } else {
                    macro_rules! ssl_op_type {
                        () => {c_ulong};
                    }
                }
            }

            pub const SSL_OP_LEGACY_SERVER_CONNECT: ssl_op_type!() = 0x00000004;
            cfg_if! {
                if #[cfg(libressl261)] {
                    pub const SSL_OP_TLSEXT_PADDING: ssl_op_type!() = 0x0;
                } else if #[cfg(any(ossl102, libressl))] {
                    pub const SSL_OP_TLSEXT_PADDING: ssl_op_type!() = 0x10;
                }
            }
            #[cfg(ossl101)]
            pub const SSL_OP_SAFARI_ECDHE_ECDSA_BUG: ssl_op_type!() = 0x00000040;

            pub const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: ssl_op_type!() = 0x00000800;

            pub const SSL_OP_NO_QUERY_MTU: ssl_op_type!() = 0x00001000;
            pub const SSL_OP_COOKIE_EXCHANGE: ssl_op_type!() = 0x00002000;
            pub const SSL_OP_NO_TICKET: ssl_op_type!() = 0x00004000;
            cfg_if! {
                if #[cfg(ossl101)] {
                    pub const SSL_OP_CISCO_ANYCONNECT: ssl_op_type!() = 0x00008000;
                } else {
                    pub const SSL_OP_CISCO_ANYCONNECT: ssl_op_type!() = 0x0;
                }
            }

            pub const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: ssl_op_type!() = 0x00010000;
            cfg_if! {
                if #[cfg(ossl101)] {
                    pub const SSL_OP_NO_COMPRESSION: ssl_op_type!() = 0x00020000;
                    pub const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: ssl_op_type!() = 0x00040000;
                } else {
                    pub const SSL_OP_NO_COMPRESSION: ssl_op_type!() = 0x0;
                    pub const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: ssl_op_type!() = 0x0;
                }
            }

            #[cfg(ossl111)]
            pub const SSL_OP_ENABLE_MIDDLEBOX_COMPAT: ssl_op_type!() = 0x00100000;
            #[cfg(ossl111)]
            pub const SSL_OP_PRIORITIZE_CHACHA: ssl_op_type!() = 0x00200000;

            pub const SSL_OP_CIPHER_SERVER_PREFERENCE: ssl_op_type!() = 0x00400000;
            cfg_if! {
                if #[cfg(libressl280)] {
                    pub const SSL_OP_TLS_ROLLBACK_BUG: ssl_op_type!() = 0;
                } else {
                    pub const SSL_OP_TLS_ROLLBACK_BUG: ssl_op_type!() = 0x00800000;
                }
            }

            cfg_if! {
                if #[cfg(ossl101)] {
                    pub const SSL_OP_NO_SSLv3: ssl_op_type!() = 0x02000000;
                } else {
                    pub const SSL_OP_NO_SSLv3: ssl_op_type!() = 0x0;
                }
            }
            pub const SSL_OP_NO_TLSv1_1: ssl_op_type!() = 0x10000000;
            pub const SSL_OP_NO_TLSv1_2: ssl_op_type!() = 0x08000000;

            pub const SSL_OP_NO_TLSv1: ssl_op_type!() = 0x04000000;
            cfg_if! {
                if #[cfg(ossl102)] {
                    pub const SSL_OP_NO_DTLSv1: ssl_op_type!() = 0x04000000;
                    pub const SSL_OP_NO_DTLSv1_2: ssl_op_type!() = 0x08000000;
                } else if #[cfg(libressl332)] {
                    pub const SSL_OP_NO_DTLSv1: ssl_op_type!() = 0x40000000;
                    pub const SSL_OP_NO_DTLSv1_2: ssl_op_type!() = 0x80000000;
                }
            }
            #[cfg(any(ossl111, libressl340))]
            pub const SSL_OP_NO_TLSv1_3: ssl_op_type!() = 0x20000000;

            #[cfg(ossl110h)]
            pub const SSL_OP_NO_RENEGOTIATION: ssl_op_type!() = 0x40000000;

            cfg_if! {
                if #[cfg(ossl111)] {
                    pub const SSL_OP_NO_SSL_MASK: ssl_op_type!() = SSL_OP_NO_SSLv2
                        | SSL_OP_NO_SSLv3
                        | SSL_OP_NO_TLSv1
                        | SSL_OP_NO_TLSv1_1
                        | SSL_OP_NO_TLSv1_2
                        | SSL_OP_NO_TLSv1_3;
                } else if #[cfg(ossl102)] {
                    pub const SSL_OP_NO_SSL_MASK: ssl_op_type!() =
                        SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2;
                }
            }

            cfg_if! {
                if #[cfg(libressl261)] {
                    pub const SSL_OP_CRYPTOPRO_TLSEXT_BUG: ssl_op_type!() = 0x0;
                } else {
                    pub const SSL_OP_CRYPTOPRO_TLSEXT_BUG: ssl_op_type!() = 0x80000000;
                }
            }

            cfg_if! {
                if #[cfg(ossl300)] {
                    pub const SSL_OP_ALL: ssl_op_type!() = SSL_OP_CRYPTOPRO_TLSEXT_BUG
                        | SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
                        | SSL_OP_TLSEXT_PADDING
                        | SSL_OP_SAFARI_ECDHE_ECDSA_BUG;
                } else if #[cfg(ossl110f)] {
                    pub const SSL_OP_ALL: ssl_op_type!() = SSL_OP_CRYPTOPRO_TLSEXT_BUG
                        | SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
                        | SSL_OP_LEGACY_SERVER_CONNECT
                        | SSL_OP_TLSEXT_PADDING
                        | SSL_OP_SAFARI_ECDHE_ECDSA_BUG;
                } else if #[cfg(libressl261)] {
                    pub const SSL_OP_ALL: ssl_op_type!() = 0x4;
                } else if #[cfg(libressl)] {
                    pub const SSL_OP_ALL: ssl_op_type!() = 0x80000014;
                } else {
                    pub const SSL_OP_ALL: ssl_op_type!() = 0x80000BFF;
                }
            }

            cfg_if! {
                if #[cfg(ossl110)] {
                    pub const SSL_OP_MICROSOFT_SESS_ID_BUG: ssl_op_type!() = 0x00000000;
                    pub const SSL_OP_NETSCAPE_CHALLENGE_BUG: ssl_op_type!() = 0x00000000;
                    pub const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: ssl_op_type!() = 0x00000000;
                    pub const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: ssl_op_type!() = 0x00000000;
                    pub const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: ssl_op_type!() = 0x00000000;
                    pub const SSL_OP_TLS_D5_BUG: ssl_op_type!() = 0x00000000;
                    pub const SSL_OP_TLS_BLOCK_PADDING_BUG: ssl_op_type!() = 0x00000000;
                    pub const SSL_OP_SINGLE_ECDH_USE: ssl_op_type!() = 0x00000000;
                    pub const SSL_OP_SINGLE_DH_USE: ssl_op_type!() = 0x00000000;
                    pub const SSL_OP_NO_SSLv2: ssl_op_type!() = 0x00000000;
                } else if #[cfg(ossl101)] {
                    pub const SSL_OP_MICROSOFT_SESS_ID_BUG: ssl_op_type!() = 0x00000001;
                    pub const SSL_OP_NETSCAPE_CHALLENGE_BUG: ssl_op_type!() = 0x00000002;
                    pub const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: ssl_op_type!() = 0x00000008;
                    pub const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: ssl_op_type!() = 0x00000020;
                    pub const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: ssl_op_type!() = 0x00000080;
                    pub const SSL_OP_TLS_D5_BUG: ssl_op_type!() = 0x00000100;
                    pub const SSL_OP_TLS_BLOCK_PADDING_BUG: ssl_op_type!() = 0x00000200;
                    pub const SSL_OP_SINGLE_ECDH_USE: ssl_op_type!() = 0x00080000;
                    pub const SSL_OP_SINGLE_DH_USE: ssl_op_type!() = 0x00100000;
                    pub const SSL_OP_NO_SSLv2: ssl_op_type!() = 0x01000000;
                } else {
                    pub const SSL_OP_MICROSOFT_SESS_ID_BUG: ssl_op_type!() = 0x0;
                    pub const SSL_OP_NETSCAPE_CHALLENGE_BUG: ssl_op_type!() = 0x0;
                    pub const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: ssl_op_type!() = 0x0;
                    pub const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: ssl_op_type!() = 0x0;
                    pub const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: ssl_op_type!() = 0x0;
                    pub const SSL_OP_TLS_D5_BUG: ssl_op_type!() = 0x0;
                    pub const SSL_OP_TLS_BLOCK_PADDING_BUG: ssl_op_type!() = 0x0;
                    #[cfg(libressl261)]
                    pub const SSL_OP_SINGLE_ECDH_USE: ssl_op_type!() = 0x0;
                    #[cfg(not(libressl261))]
                    pub const SSL_OP_SINGLE_ECDH_USE: ssl_op_type!() = 0x00080000;
                    pub const SSL_OP_SINGLE_DH_USE: ssl_op_type!() = 0x00100000;
                    pub const SSL_OP_NO_SSLv2: ssl_op_type!() = 0x0;
                }
            }

            pub const SSL_MODE_ENABLE_PARTIAL_WRITE: c_long = 0x1;
            pub const SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER: c_long = 0x2;
            pub const SSL_MODE_AUTO_RETRY: c_long = 0x4;
            pub const SSL_MODE_NO_AUTO_CHAIN: c_long = 0x8;
            pub const SSL_MODE_RELEASE_BUFFERS: c_long = 0x10;
            #[cfg(ossl101)]
            pub const SSL_MODE_SEND_CLIENTHELLO_TIME: c_long = 0x20;
            #[cfg(ossl101)]
            pub const SSL_MODE_SEND_SERVERHELLO_TIME: c_long = 0x40;
            #[cfg(ossl101)]
            pub const SSL_MODE_SEND_FALLBACK_SCSV: c_long = 0x80;

            pub unsafe fn SSL_CTX_set_mode(ctx: *mut SSL_CTX, op: c_long) -> c_long {
                SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, op, ptr::null_mut())
            }

            #[cfg(ossl111)]
            pub const SSL_COOKIE_LENGTH: c_int = 4096;

            cfg_if! {
                if #[cfg(not(ossl110))] {
                    pub unsafe fn SSL_CTX_get_options(ctx: *const SSL_CTX) -> c_ulong {
                        SSL_CTX_ctrl(ctx as *mut _, SSL_CTRL_OPTIONS, 0, ptr::null_mut()) as c_ulong
                    }

                    pub unsafe fn SSL_CTX_set_options(ctx: *const SSL_CTX, op: c_ulong) -> c_ulong {
                        SSL_CTX_ctrl(
                            ctx as *mut _,
                            SSL_CTRL_OPTIONS,
                            op as c_long,
                            ptr::null_mut(),
                        ) as c_ulong
                    }

                    pub unsafe fn SSL_CTX_clear_options(ctx: *const SSL_CTX, op: c_ulong) -> c_ulong {
                        SSL_CTX_ctrl(
                            ctx as *mut _,
                            SSL_CTRL_CLEAR_OPTIONS,
                            op as c_long,
                            ptr::null_mut(),
                        ) as c_ulong
                    }
                }
            }

            pub unsafe fn SSL_set_mtu(ssl: *mut SSL, mtu: c_long) -> c_long {
                SSL_ctrl(ssl, SSL_CTRL_SET_MTU, mtu, ptr::null_mut())
            }

            #[cfg(ossl110)]
            pub unsafe fn SSL_get_extms_support(ssl: *mut SSL) -> c_long {
                SSL_ctrl(ssl, SSL_CTRL_GET_EXTMS_SUPPORT, 0, ptr::null_mut())
            }

            pub const SSL_SESS_CACHE_OFF: c_long = 0x0;
            pub const SSL_SESS_CACHE_CLIENT: c_long = 0x1;
            pub const SSL_SESS_CACHE_SERVER: c_long = 0x2;
            pub const SSL_SESS_CACHE_BOTH: c_long = SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_SERVER;
            pub const SSL_SESS_CACHE_NO_AUTO_CLEAR: c_long = 0x80;
            pub const SSL_SESS_CACHE_NO_INTERNAL_LOOKUP: c_long = 0x100;
            pub const SSL_SESS_CACHE_NO_INTERNAL_STORE: c_long = 0x200;
            pub const SSL_SESS_CACHE_NO_INTERNAL: c_long =
                SSL_SESS_CACHE_NO_INTERNAL_LOOKUP | SSL_SESS_CACHE_NO_INTERNAL_STORE;

            pub const OPENSSL_NPN_UNSUPPORTED: c_int = 0;
            pub const OPENSSL_NPN_NEGOTIATED: c_int = 1;
            pub const OPENSSL_NPN_NO_OVERLAP: c_int = 2;

            pub const SSL_AD_ILLEGAL_PARAMETER: c_int = SSL3_AD_ILLEGAL_PARAMETER;
            pub const SSL_AD_DECODE_ERROR: c_int = TLS1_AD_DECODE_ERROR;
            pub const SSL_AD_UNRECOGNIZED_NAME: c_int = TLS1_AD_UNRECOGNIZED_NAME;
            pub const SSL_ERROR_NONE: c_int = 0;
            pub const SSL_ERROR_SSL: c_int = 1;
            pub const SSL_ERROR_SYSCALL: c_int = 5;
            pub const SSL_ERROR_WANT_ACCEPT: c_int = 8;
            pub const SSL_ERROR_WANT_CONNECT: c_int = 7;
            pub const SSL_ERROR_WANT_READ: c_int = 2;
            pub const SSL_ERROR_WANT_WRITE: c_int = 3;
            pub const SSL_ERROR_WANT_X509_LOOKUP: c_int = 4;
            pub const SSL_ERROR_ZERO_RETURN: c_int = 6;
            #[cfg(ossl111)]
            pub const SSL_ERROR_WANT_CLIENT_HELLO_CB: c_int = 11;
            pub const SSL_VERIFY_NONE: c_int = 0;
            pub const SSL_VERIFY_PEER: c_int = 1;
            pub const SSL_VERIFY_FAIL_IF_NO_PEER_CERT: c_int = 2;
            pub const SSL_CTRL_SET_TMP_DH: c_int = 3;
            pub const SSL_CTRL_SET_TMP_ECDH: c_int = 4;
            #[cfg(any(libressl, all(ossl101, not(ossl110))))]
            pub const SSL_CTRL_GET_SESSION_REUSED: c_int = 8;
            pub const SSL_CTRL_EXTRA_CHAIN_CERT: c_int = 14;
            pub const SSL_CTRL_SET_MTU: c_int = 17;
            #[cfg(any(libressl, all(ossl101, not(ossl110))))]
            pub const SSL_CTRL_OPTIONS: c_int = 32;
            pub const SSL_CTRL_MODE: c_int = 33;
            pub const SSL_CTRL_SET_READ_AHEAD: c_int = 41;
            pub const SSL_CTRL_SET_SESS_CACHE_SIZE: c_int = 42;
            pub const SSL_CTRL_GET_SESS_CACHE_SIZE: c_int = 43;
            pub const SSL_CTRL_SET_SESS_CACHE_MODE: c_int = 44;
            pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_CB: c_int = 53;
            pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG: c_int = 54;
            pub const SSL_CTRL_SET_TLSEXT_HOSTNAME: c_int = 55;
            pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB: c_int = 63;
            pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG: c_int = 64;
            pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE: c_int = 65;
            pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP: c_int = 70;
            pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP: c_int = 71;
            #[cfg(any(libressl, all(ossl101, not(ossl110))))]
            pub const SSL_CTRL_CLEAR_OPTIONS: c_int = 77;
            pub const SSL_CTRL_GET_EXTRA_CHAIN_CERTS: c_int = 82;
            #[cfg(ossl102)]
            pub const SSL_CTRL_CHAIN_CERT: c_int = 89;
            #[cfg(any(ossl111, libressl252))]
            pub const SSL_CTRL_SET_GROUPS_LIST: c_int = 92;
            #[cfg(any(libressl, all(ossl102, not(ossl110))))]
            pub const SSL_CTRL_SET_ECDH_AUTO: c_int = 94;
            #[cfg(ossl102)]
            pub const SSL_CTRL_SET_SIGALGS_LIST: c_int = 98;
            #[cfg(ossl102)]
            pub const SSL_CTRL_SET_VERIFY_CERT_STORE: c_int = 106;
            #[cfg(ossl300)]
            pub const SSL_CTRL_GET_PEER_TMP_KEY: c_int = 109;
            #[cfg(ossl110)]
            pub const SSL_CTRL_GET_EXTMS_SUPPORT: c_int = 122;
            #[cfg(any(ossl110, libressl261))]
            pub const SSL_CTRL_SET_MIN_PROTO_VERSION: c_int = 123;
            #[cfg(any(ossl110, libressl261))]
            pub const SSL_CTRL_SET_MAX_PROTO_VERSION: c_int = 124;
            #[cfg(any(ossl110g, libressl270))]
            pub const SSL_CTRL_GET_MIN_PROTO_VERSION: c_int = 130;
            #[cfg(any(ossl110g, libressl270))]
            pub const SSL_CTRL_GET_MAX_PROTO_VERSION: c_int = 131;
            #[cfg(ossl300)]
            pub const SSL_CTRL_GET_TMP_KEY: c_int = 133;

            pub unsafe fn SSL_CTX_set_tmp_dh(ctx: *mut SSL_CTX, dh: *mut DH) -> c_long {
                SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TMP_DH, 0, dh as *mut c_void)
            }

            pub unsafe fn SSL_CTX_set_tmp_ecdh(ctx: *mut SSL_CTX, key: *mut EC_KEY) -> c_long {
                SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TMP_ECDH, 0, key as *mut c_void)
            }

            pub unsafe fn SSL_set_tmp_dh(ssl: *mut SSL, dh: *mut DH) -> c_long {
                SSL_ctrl(ssl, SSL_CTRL_SET_TMP_DH, 0, dh as *mut c_void)
            }

            pub unsafe fn SSL_set_tmp_ecdh(ssl: *mut SSL, key: *mut EC_KEY) -> c_long {
                SSL_ctrl(ssl, SSL_CTRL_SET_TMP_ECDH, 0, key as *mut c_void)
            }

            pub unsafe fn SSL_CTX_add_extra_chain_cert(ctx: *mut SSL_CTX, x509: *mut X509) -> c_long {
                SSL_CTX_ctrl(ctx, SSL_CTRL_EXTRA_CHAIN_CERT, 0, x509 as *mut c_void)
            }

            pub unsafe fn SSL_CTX_get_extra_chain_certs(
                ctx: *mut SSL_CTX,
                chain: *mut *mut stack_st_X509,
            ) -> c_long {
                SSL_CTX_ctrl(ctx, SSL_CTRL_GET_EXTRA_CHAIN_CERTS, 0, chain as *mut c_void)
            }

            #[cfg(ossl102)]
            pub unsafe fn SSL_CTX_set0_verify_cert_store(ctx: *mut SSL_CTX, st: *mut X509_STORE) -> c_long {
                SSL_CTX_ctrl(ctx, SSL_CTRL_SET_VERIFY_CERT_STORE, 0, st as *mut c_void)
            }

            #[cfg(ossl102)]
            pub unsafe fn SSL_set0_verify_cert_store(ssl: *mut SSL, st: *mut X509_STORE) -> c_long {
                SSL_ctrl(ssl, SSL_CTRL_SET_VERIFY_CERT_STORE, 0, st as *mut c_void)
            }

            cfg_if! {
                if #[cfg(ossl111)] {
                    pub unsafe fn SSL_CTX_set1_groups_list(ctx: *mut SSL_CTX, s: *const c_char) -> c_long {
                        SSL_CTX_ctrl(
                            ctx,
                            SSL_CTRL_SET_GROUPS_LIST,
                            0,
                            s as *const c_void as *mut c_void,
                        )
                    }
                } else if #[cfg(libressl251)] {
                    extern "C" {
                        pub fn SSL_CTX_set1_groups_list(ctx: *mut SSL_CTX, s: *const c_char) -> c_int;
                    }
                }
            }

            #[cfg(ossl102)]
            pub unsafe fn SSL_add0_chain_cert(ssl: *mut SSL, ptr: *mut X509) -> c_long {
                SSL_ctrl(ssl, SSL_CTRL_CHAIN_CERT, 0, ptr as *mut c_void)
            }

            #[cfg(ossl102)]
            pub unsafe fn SSL_CTX_set1_sigalgs_list(ctx: *mut SSL_CTX, s: *const c_char) -> c_long {
                SSL_CTX_ctrl(
                    ctx,
                    SSL_CTRL_SET_SIGALGS_LIST,
                    0,
                    s as *const c_void as *mut c_void,
                )
            }

            #[cfg(any(libressl, all(ossl102, not(ossl110))))]
            pub unsafe fn SSL_CTX_set_ecdh_auto(ctx: *mut SSL_CTX, onoff: c_int) -> c_int {
                SSL_CTX_ctrl(
                    ctx,
                    SSL_CTRL_SET_ECDH_AUTO,
                    onoff as c_long,
                    ptr::null_mut(),
                ) as c_int
            }

            #[cfg(any(libressl, all(ossl102, not(ossl110))))]
            pub unsafe fn SSL_set_ecdh_auto(ssl: *mut SSL, onoff: c_int) -> c_int {
                SSL_ctrl(
                    ssl,
                    SSL_CTRL_SET_ECDH_AUTO,
                    onoff as c_long,
                    ptr::null_mut(),
                ) as c_int
            }

            cfg_if! {
                if #[cfg(ossl110)] {
                    pub unsafe fn SSL_CTX_set_min_proto_version(ctx: *mut SSL_CTX, version: c_int) -> c_int {
                        SSL_CTX_ctrl(
                            ctx,
                            SSL_CTRL_SET_MIN_PROTO_VERSION,
                            version as c_long,
                            ptr::null_mut(),
                        ) as c_int
                    }

                    pub unsafe fn SSL_CTX_set_max_proto_version(ctx: *mut SSL_CTX, version: c_int) -> c_int {
                        SSL_CTX_ctrl(
                            ctx,
                            SSL_CTRL_SET_MAX_PROTO_VERSION,
                            version as c_long,
                            ptr::null_mut(),
                        ) as c_int
                    }

                    pub unsafe fn SSL_set_min_proto_version(s: *mut SSL, version: c_int) -> c_int {
                        SSL_ctrl(
                            s,
                            SSL_CTRL_SET_MIN_PROTO_VERSION,
                            version as c_long,
                            ptr::null_mut(),
                        ) as c_int
                    }

                    pub unsafe fn SSL_set_max_proto_version(s: *mut SSL, version: c_int) -> c_int {
                        SSL_ctrl(
                            s,
                            SSL_CTRL_SET_MAX_PROTO_VERSION,
                            version as c_long,
                            ptr::null_mut(),
                        ) as c_int
                    }
                }
            }

            cfg_if! {
                if #[cfg(ossl110g)] {
                    pub unsafe fn SSL_CTX_get_min_proto_version(ctx: *mut SSL_CTX) -> c_int {
                        SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MIN_PROTO_VERSION, 0, ptr::null_mut()) as c_int
                    }

                    pub unsafe fn SSL_CTX_get_max_proto_version(ctx: *mut SSL_CTX) -> c_int {
                        SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_PROTO_VERSION, 0, ptr::null_mut()) as c_int
                    }
                    pub unsafe fn SSL_get_min_proto_version(s: *mut SSL) -> c_int {
                        SSL_ctrl(s, SSL_CTRL_GET_MIN_PROTO_VERSION, 0, ptr::null_mut()) as c_int
                    }
                    pub unsafe fn SSL_get_max_proto_version(s: *mut SSL) -> c_int {
                        SSL_ctrl(s, SSL_CTRL_GET_MAX_PROTO_VERSION, 0, ptr::null_mut()) as c_int
                    }
                }
            }
            cfg_if! {
                if #[cfg(ossl300)] {
                    pub unsafe fn SSL_get_peer_tmp_key(ssl: *mut SSL, key: *mut *mut EVP_PKEY) -> c_long {
                        SSL_ctrl(ssl, SSL_CTRL_GET_PEER_TMP_KEY, 0, key as *mut c_void)
                    }

                    pub unsafe fn SSL_get_tmp_key(ssl: *mut SSL, key: *mut *mut EVP_PKEY) -> c_long {
                        SSL_ctrl(ssl, SSL_CTRL_GET_TMP_KEY, 0, key as *mut c_void)
                    }
                }
            }

            #[cfg(ossl111)]
            pub const SSL_CLIENT_HELLO_SUCCESS: c_int = 1;
            #[cfg(ossl111)]
            pub const SSL_CLIENT_HELLO_ERROR: c_int = 0;
            #[cfg(ossl111)]
            pub const SSL_CLIENT_HELLO_RETRY: c_int = -1;

            #[cfg(any(ossl111, libressl340))]
            pub const SSL_READ_EARLY_DATA_ERROR: c_int = 0;
            #[cfg(any(ossl111, libressl340))]
            pub const SSL_READ_EARLY_DATA_SUCCESS: c_int = 1;
            #[cfg(any(ossl111, libressl340))]
            pub const SSL_READ_EARLY_DATA_FINISH: c_int = 2;

            cfg_if! {
                if #[cfg(ossl110)] {
                    pub unsafe fn SSL_get_ex_new_index(
                        l: c_long,
                        p: *mut c_void,
                        newf: Option<CRYPTO_EX_new>,
                        dupf: Option<CRYPTO_EX_dup>,
                        freef: Option<CRYPTO_EX_free>,
                    ) -> c_int {
                        CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, l, p, newf, dupf, freef)
                    }
                }
            }
            cfg_if! {
                if #[cfg(ossl110)] {
                    pub unsafe fn SSL_CTX_get_ex_new_index(
                        l: c_long,
                        p: *mut c_void,
                        newf: Option<CRYPTO_EX_new>,
                        dupf: Option<CRYPTO_EX_dup>,
                        freef: Option<CRYPTO_EX_free>,
                    ) -> c_int {
                        CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, l, p, newf, dupf, freef)
                    }
                }
            }

            pub unsafe fn SSL_CTX_sess_set_cache_size(ctx: *mut SSL_CTX, t: c_long) -> c_long {
                SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_SIZE, t, ptr::null_mut())
            }

            pub unsafe fn SSL_CTX_sess_get_cache_size(ctx: *mut SSL_CTX) -> c_long {
                SSL_CTX_ctrl(ctx, SSL_CTRL_GET_SESS_CACHE_SIZE, 0, ptr::null_mut())
            }

            pub unsafe fn SSL_CTX_set_session_cache_mode(ctx: *mut SSL_CTX, m: c_long) -> c_long {
                SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_MODE, m, ptr::null_mut())
            }

            pub unsafe fn SSL_CTX_set_read_ahead(ctx: *mut SSL_CTX, m: c_long) -> c_long {
                SSL_CTX_ctrl(ctx, SSL_CTRL_SET_READ_AHEAD, m, ptr::null_mut())
            }

            #[allow(clashing_extern_declarations)]
            extern "C" {
                #[deprecated(note = "use SSL_CTX_set_tmp_dh_callback__fixed_rust instead")]
                pub fn SSL_CTX_set_tmp_dh_callback(
                    ctx: *mut SSL_CTX,
                    dh: unsafe extern "C" fn(ssl: *mut SSL, is_export: c_int, keylength: c_int) -> *mut DH,
                );
                #[deprecated(note = "use SSL_set_tmp_dh_callback__fixed_rust instead")]
                pub fn SSL_set_tmp_dh_callback(
                    ctx: *mut SSL,
                    dh: unsafe extern "C" fn(ssl: *mut SSL, is_export: c_int, keylength: c_int) -> *mut DH,
                );
                #[deprecated(note = "use SSL_CTX_set_tmp_ecdh_callback__fixed_rust instead")]
                #[cfg(not(ossl110))]
                pub fn SSL_CTX_set_tmp_ecdh_callback(
                    ctx: *mut SSL_CTX,
                    ecdh: unsafe extern "C" fn(
                        ssl: *mut SSL,
                        is_export: c_int,
                        keylength: c_int,
                    ) -> *mut EC_KEY,
                );
                #[deprecated(note = "use SSL_set_tmp_ecdh_callback__fixed_rust instead")]
                #[cfg(not(ossl110))]
                pub fn SSL_set_tmp_ecdh_callback(
                    ssl: *mut SSL,
                    ecdh: unsafe extern "C" fn(
                        ssl: *mut SSL,
                        is_export: c_int,
                        keylength: c_int,
                    ) -> *mut EC_KEY,
                );

                #[deprecated(note = "use SSL_CTX_callback_ctrl__fixed_rust instead")]
                pub fn SSL_CTX_callback_ctrl(
                    ctx: *mut SSL_CTX,
                    cmd: c_int,
                    fp: Option<extern "C" fn()>,
                ) -> c_long;

                #[deprecated(note = "use SSL_CTX_set_alpn_select_cb__fixed_rust instead")]
                #[cfg(any(ossl102, libressl261))]
                pub fn SSL_CTX_set_alpn_select_cb(
                    ssl: *mut SSL_CTX,
                    cb: extern "C" fn(
                        ssl: *mut SSL,
                        out: *mut *const c_uchar,
                        outlen: *mut c_uchar,
                        inbuf: *const c_uchar,
                        inlen: c_uint,
                        arg: *mut c_void,
                    ) -> c_int,
                    arg: *mut c_void,
                );
            }

            #[cfg(not(ossl110))]
            pub unsafe fn SSL_session_reused(ssl: *mut SSL) -> c_int {
                SSL_ctrl(ssl, SSL_CTRL_GET_SESSION_REUSED, 0, ptr::null_mut()) as c_int
            }

            #[cfg(ossl110)]
            pub const OPENSSL_INIT_LOAD_SSL_STRINGS: u64 = 0x00200000;
            #[cfg(ossl111b)]
            pub const OPENSSL_INIT_NO_ATEXIT: u64 = 0x00080000;

            cfg_if! {
                if #[cfg(ossl330)] {
                    pub const SSL_VALUE_CLASS_GENERIC: c_uint = 0;
                    pub const SSL_VALUE_CLASS_FEATURE_REQUEST: c_uint = 1;
                    pub const SSL_VALUE_CLASS_FEATURE_PEER_REQUEST: c_uint = 2;
                    pub const SSL_VALUE_CLASS_FEATURE_NEGOTIATED: c_uint = 3;

                    pub const SSL_VALUE_NONE: c_uint = 0;
                    pub const SSL_VALUE_QUIC_STREAM_BIDI_LOCAL_AVAIL: c_uint = 1;
                    pub const SSL_VALUE_QUIC_STREAM_BIDI_REMOTE_AVAIL: c_uint = 2;
                    pub const SSL_VALUE_QUIC_STREAM_UNI_LOCAL_AVAIL: c_uint = 3;
                    pub const SSL_VALUE_QUIC_STREAM_UNI_REMOTE_AVAIL: c_uint = 4;
                    pub const SSL_VALUE_QUIC_IDLE_TIMEOUT: c_uint = 5;
                    pub const SSL_VALUE_EVENT_HANDLING_MODE: c_uint = 6;
                    pub const SSL_VALUE_STREAM_WRITE_BUF_SIZE: c_uint = 7;
                    pub const SSL_VALUE_STREAM_WRITE_BUF_USED: c_uint = 8;
                    pub const SSL_VALUE_STREAM_WRITE_BUF_AVAIL: c_uint = 9;

                    pub const SSL_VALUE_EVENT_HANDLING_MODE_INHERIT: c_uint = 0;
                    pub const SSL_VALUE_EVENT_HANDLING_MODE_IMPLICIT: c_uint = 1;
                    pub const SSL_VALUE_EVENT_HANDLING_MODE_EXPLICIT: c_uint = 2;

                    pub unsafe fn SSL_get_generic_value_uint(ssl: *mut SSL, id: u32, value: *mut u64) -> c_int {
                        SSL_get_value_uint(ssl, SSL_VALUE_CLASS_GENERIC, id, value)
                    }
                    pub unsafe fn SSL_set_generic_value_uint(ssl: *mut SSL, id: u32, value: u64) -> c_int {
                        SSL_set_value_uint(ssl, SSL_VALUE_CLASS_GENERIC, id, value)
                    }
                    pub unsafe fn SSL_get_feature_request_uint(ssl: *mut SSL, id: u32, value: *mut u64) -> c_int {
                        SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_REQUEST, id, value)
                    }
                    pub unsafe fn SSL_set_feature_request_uint(ssl: *mut SSL, id: u32, value: u64) -> c_int {
                        SSL_set_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_REQUEST, id, value)
                    }
                    pub unsafe fn SSL_get_feature_peer_request_uint(ssl: *mut SSL, id: u32, value: *mut u64) -> c_int {
                        SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_PEER_REQUEST, id, value)
                    }
                    pub unsafe fn SSL_get_feature_negotiated_uint(ssl: *mut SSL, id: u32, value: *mut u64) -> c_int {
                        SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_NEGOTIATED, id, value)
                    }
                    pub unsafe fn SSL_get_quic_stream_bidi_local_avail(ssl: *mut SSL, value: *mut u64) -> c_int {
                        SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_BIDI_LOCAL_AVAIL, value)
                    }
                    pub unsafe fn SSL_get_quic_stream_bidi_remote_avail(ssl: *mut SSL, value: *mut u64) -> c_int {
                        SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_BIDI_REMOTE_AVAIL, value)
                    }
                    pub unsafe fn SSL_get_quic_stream_uni_local_avail(ssl: *mut SSL, value: *mut u64) -> c_int {
                        SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_UNI_LOCAL_AVAIL, value)
                    }
                    pub unsafe fn SSL_get_quic_stream_uni_remote_avail(ssl: *mut SSL, value: *mut u64) -> c_int {
                        SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_UNI_REMOTE_AVAIL, value)
                    }
                    pub unsafe fn SSL_get_event_handling_mode(ssl: *mut SSL, value: *mut u64) -> c_int {
                        SSL_get_generic_value_uint(ssl, SSL_VALUE_EVENT_HANDLING_MODE, value)
                    }
                    pub unsafe fn SSL_set_event_handling_mode(ssl: *mut SSL, value: u64) -> c_int {
                        SSL_set_generic_value_uint(ssl, SSL_VALUE_EVENT_HANDLING_MODE, value)
                    }
                    pub unsafe fn SSL_get_stream_write_buf_size(ssl: *mut SSL, value: *mut u64) -> c_int {
                        SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_SIZE, value)
                    }
                    pub unsafe fn SSL_get_stream_write_buf_avail(ssl: *mut SSL, value: *mut u64) -> c_int {
                        SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_AVAIL, value)
                    }
                    pub unsafe fn SSL_get_stream_write_buf_used(ssl: *mut SSL, value: *mut u64) -> c_int {
                        SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_USED, value)
                    }
                }
            }
        }

        pub mod ssl3
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */            
            pub const SSL3_VERSION: c_int = 0x300;
            pub const SSL3_AD_ILLEGAL_PARAMETER: c_int = 47;
        }

        pub mod tls1
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                system::
                {
                    openssl::ssl::{ *, },
                },
                *,
            };
            /*
            */
            pub const TLS1_VERSION: c_int = 0x301;
            pub const TLS1_1_VERSION: c_int = 0x302;
            pub const TLS1_2_VERSION: c_int = 0x303;
            #[cfg(any(ossl111, libressl340))]
            pub const TLS1_3_VERSION: c_int = 0x304;

            pub const DTLS1_VERSION: c_int = 0xFEFF;
            #[cfg(any(ossl102, libressl332))]
            pub const DTLS1_2_VERSION: c_int = 0xFEFD;

            pub const TLS1_AD_DECODE_ERROR: c_int = 50;
            pub const TLS1_AD_UNRECOGNIZED_NAME: c_int = 112;

            pub const TLSEXT_NAMETYPE_host_name: c_int = 0;
            pub const TLSEXT_STATUSTYPE_ocsp: c_int = 1;

            pub const SSL_TLSEXT_ERR_OK: c_int = 0;
            pub const SSL_TLSEXT_ERR_ALERT_WARNING: c_int = 1;
            pub const SSL_TLSEXT_ERR_ALERT_FATAL: c_int = 2;
            pub const SSL_TLSEXT_ERR_NOACK: c_int = 3;

            pub unsafe fn SSL_set_tlsext_host_name(s: *mut SSL, name: *mut c_char) -> c_long
            {
                SSL_ctrl
                (
                    s,
                    SSL_CTRL_SET_TLSEXT_HOSTNAME,
                    TLSEXT_NAMETYPE_host_name as c_long,
                    name as *mut c_void,
                )
            }

            pub unsafe fn SSL_set_tlsext_status_type(s: *mut SSL, type_: c_int) -> c_long
            {
                SSL_ctrl
                (
                    s,
                    SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE,
                    type_ as c_long,
                    ptr::null_mut(),
                )
            }

            pub unsafe fn SSL_get_tlsext_status_ocsp_resp(ssl: *mut SSL, resp: *mut *mut c_uchar) -> c_long 
            {
                SSL_ctrl
                (
                    ssl,
                    SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP,
                    0,
                    resp as *mut c_void,
                )
            }

            pub unsafe fn SSL_set_tlsext_status_ocsp_resp
            (
                ssl: *mut SSL,
                resp: *mut c_uchar,
                len: c_long,
            ) -> c_long
            {
                SSL_ctrl
                (
                    ssl,
                    SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP,
                    len,
                    resp as *mut c_void,
                )
            }

            #[deprecated(note = "use SSL_CTX_set_tlsext_servername_callback__fixed_rust instead")]
            #[allow(deprecated)]
            pub unsafe fn SSL_CTX_set_tlsext_servername_callback
            (
                ctx: *mut SSL_CTX,
                cb: Option<extern "C" fn()>,
            ) -> c_long 
            { SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_CB, cb) }

            pub unsafe fn SSL_CTX_set_tlsext_servername_callback__fixed_rust
            (
                ctx: *mut SSL_CTX,
                cb: Option<unsafe extern "C" fn(*mut SSL, *mut c_int, *mut c_void) -> c_int>,
            ) -> c_long
            {
                SSL_CTX_callback_ctrl__fixed_rust
                (
                    ctx,
                    SSL_CTRL_SET_TLSEXT_SERVERNAME_CB,
                    mem::transmute::
                    <
                        ::option::Option
                        <
                            unsafe extern "C" fn(*mut SSL, *mut c_int, *mut libc::c_void) -> i32,
                        >,
                        ::option::Option<unsafe extern "C" fn()>,
                    >(cb),
                )
            }
            
            pub unsafe fn SSL_CTX_set_tlsext_servername_arg(ctx: *mut SSL_CTX, arg: *mut c_void) -> c_long 
            { SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, arg) }

            pub unsafe fn SSL_CTX_set_tlsext_status_cb
            (
                ctx: *mut SSL_CTX,
                cb: Option<unsafe extern "C" fn(*mut SSL, *mut c_void) -> c_int>,
            ) -> c_long
            {
                SSL_CTX_callback_ctrl__fixed_rust
                (
                    ctx,
                    SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB,
                    mem::transmute::
                    <
                        ::option::Option<unsafe extern "C" fn(*mut SSL, *mut c_void) -> i32>,
                        ::option::Option<unsafe extern "C" fn()>,
                    >(cb),
                )
            }

            pub unsafe fn SSL_CTX_set_tlsext_status_arg(ctx: *mut SSL_CTX, arg: *mut c_void) -> c_long
            { SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG, 0, arg) }
        }

        pub mod types
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            cfg_if!
            {
                if #[cfg(any(ossl110, libressl280))]
                { pub enum EVP_PKEY {} }

                else
                {
                    #[repr(C)] pub struct EVP_PKEY
                    {
                        pub type_: c_int,
                        pub save_type: c_int,
                        pub references: c_int,
                        pub ameth: *const EVP_PKEY_ASN1_METHOD,
                        pub engine: *mut ENGINE,
                        pub pkey: *mut c_void,
                        pub save_parameters: c_int,
                        pub attributes: *mut stack_st_X509_ATTRIBUTE,
                    }
                }
            }
        }

        pub mod x509
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */

            pub const X509_FILETYPE_PEM: c_int = 1;
            pub const X509_FILETYPE_ASN1: c_int = 2;
            pub const X509_FILETYPE_DEFAULT: c_int = 3;

            pub const ASN1_R_HEADER_TOO_LONG: c_int = 123;

            cfg_if! {
                if #[cfg(not(any(ossl110, libressl350)))] {
                    pub const X509_LU_FAIL: c_int = 0;
                    pub const X509_LU_X509: c_int = 1;
                    pub const X509_LU_CRL: c_int = 2;
                }
            }
            
        }

        pub mod x509_vfy
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */
            pub const X509_V_OK: c_int = 0;
            #[cfg(ossl102f)]
            pub const X509_V_ERR_UNSPECIFIED: c_int = 1;
            pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: c_int = 2;
            pub const X509_V_ERR_UNABLE_TO_GET_CRL: c_int = 3;
            pub const X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: c_int = 4;
            pub const X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: c_int = 5;
            pub const X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: c_int = 6;
            pub const X509_V_ERR_CERT_SIGNATURE_FAILURE: c_int = 7;
            pub const X509_V_ERR_CRL_SIGNATURE_FAILURE: c_int = 8;
            pub const X509_V_ERR_CERT_NOT_YET_VALID: c_int = 9;
            pub const X509_V_ERR_CERT_HAS_EXPIRED: c_int = 10;
            pub const X509_V_ERR_CRL_NOT_YET_VALID: c_int = 11;
            pub const X509_V_ERR_CRL_HAS_EXPIRED: c_int = 12;
            pub const X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: c_int = 13;
            pub const X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: c_int = 14;
            pub const X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: c_int = 15;
            pub const X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: c_int = 16;
            pub const X509_V_ERR_OUT_OF_MEM: c_int = 17;
            pub const X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: c_int = 18;
            pub const X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN: c_int = 19;
            pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: c_int = 20;
            pub const X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: c_int = 21;
            pub const X509_V_ERR_CERT_CHAIN_TOO_LONG: c_int = 22;
            pub const X509_V_ERR_CERT_REVOKED: c_int = 23;
            cfg_if! {
                if #[cfg(ossl300)] {
                    pub const X509_V_ERR_NO_ISSUER_PUBLIC_KEY: c_int = 24;
                } else {
                    pub const X509_V_ERR_INVALID_CA: c_int = 24;
                }
            }
            pub const X509_V_ERR_PATH_LENGTH_EXCEEDED: c_int = 25;
            pub const X509_V_ERR_INVALID_PURPOSE: c_int = 26;
            pub const X509_V_ERR_CERT_UNTRUSTED: c_int = 27;
            pub const X509_V_ERR_CERT_REJECTED: c_int = 28;
            pub const X509_V_ERR_SUBJECT_ISSUER_MISMATCH: c_int = 29;
            pub const X509_V_ERR_AKID_SKID_MISMATCH: c_int = 30;
            pub const X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH: c_int = 31;
            pub const X509_V_ERR_KEYUSAGE_NO_CERTSIGN: c_int = 32;
            pub const X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER: c_int = 33;
            pub const X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION: c_int = 34;
            pub const X509_V_ERR_KEYUSAGE_NO_CRL_SIGN: c_int = 35;
            pub const X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION: c_int = 36;
            pub const X509_V_ERR_INVALID_NON_CA: c_int = 37;
            pub const X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED: c_int = 38;
            pub const X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE: c_int = 39;
            pub const X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED: c_int = 40;
            pub const X509_V_ERR_INVALID_EXTENSION: c_int = 41;
            pub const X509_V_ERR_INVALID_POLICY_EXTENSION: c_int = 42;
            pub const X509_V_ERR_NO_EXPLICIT_POLICY: c_int = 43;
            pub const X509_V_ERR_DIFFERENT_CRL_SCOPE: c_int = 44;
            pub const X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE: c_int = 45;
            pub const X509_V_ERR_UNNESTED_RESOURCE: c_int = 46;
            pub const X509_V_ERR_PERMITTED_VIOLATION: c_int = 47;
            pub const X509_V_ERR_EXCLUDED_VIOLATION: c_int = 48;
            pub const X509_V_ERR_SUBTREE_MINMAX: c_int = 49;
            pub const X509_V_ERR_APPLICATION_VERIFICATION: c_int = 50;
            pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE: c_int = 51;
            pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX: c_int = 52;
            pub const X509_V_ERR_UNSUPPORTED_NAME_SYNTAX: c_int = 53;
            pub const X509_V_ERR_CRL_PATH_VALIDATION_ERROR: c_int = 54;
            #[cfg(ossl102)]
            pub const X509_V_ERR_SUITE_B_INVALID_VERSION: c_int = 56;
            #[cfg(ossl102)]
            pub const X509_V_ERR_SUITE_B_INVALID_ALGORITHM: c_int = 57;
            #[cfg(ossl102)]
            pub const X509_V_ERR_SUITE_B_INVALID_CURVE: c_int = 58;
            #[cfg(ossl102)]
            pub const X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM: c_int = 59;
            #[cfg(ossl102)]
            pub const X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED: c_int = 60;
            #[cfg(ossl102)]
            pub const X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256: c_int = 61;
            #[cfg(ossl102)]
            pub const X509_V_ERR_HOSTNAME_MISMATCH: c_int = 62;
            #[cfg(ossl102)]
            pub const X509_V_ERR_EMAIL_MISMATCH: c_int = 63;
            #[cfg(ossl102)]
            pub const X509_V_ERR_IP_ADDRESS_MISMATCH: c_int = 64;
            cfg_if! {
                if #[cfg(ossl110)] {
                    pub const X509_V_ERR_DANE_NO_MATCH: c_int = 65;
                    pub const X509_V_ERR_EE_KEY_TOO_SMALL: c_int = 66;
                    pub const X509_V_ERR_CA_KEY_TOO_SMALL: c_int = 67;
                    pub const X509_V_ERR_CA_MD_TOO_WEAK: c_int = 68;
                    pub const X509_V_ERR_INVALID_CALL: c_int = 69;
                    pub const X509_V_ERR_STORE_LOOKUP: c_int = 70;
                    pub const X509_V_ERR_NO_VALID_SCTS: c_int = 71;
                } else if #[cfg(ossl102h)] {
                    pub const X509_V_ERR_INVALID_CALL: c_int = 65;
                    pub const X509_V_ERR_STORE_LOOKUP: c_int = 66;
                    pub const X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION: c_int = 67;
                }
            }
            #[cfg(ossl300)]
            pub const X509_V_ERR_INVALID_CA: c_int = 79;

            #[cfg(not(any(ossl110, libressl370)))]
            pub const X509_V_FLAG_CB_ISSUER_CHECK: c_ulong = 0x1;
            #[cfg(any(ossl110, libressl370))]
            pub const X509_V_FLAG_CB_ISSUER_CHECK: c_ulong = 0x0;
            pub const X509_V_FLAG_USE_CHECK_TIME: c_ulong = 0x2;
            pub const X509_V_FLAG_CRL_CHECK: c_ulong = 0x4;
            pub const X509_V_FLAG_CRL_CHECK_ALL: c_ulong = 0x8;
            pub const X509_V_FLAG_IGNORE_CRITICAL: c_ulong = 0x10;
            pub const X509_V_FLAG_X509_STRICT: c_ulong = 0x20;
            pub const X509_V_FLAG_ALLOW_PROXY_CERTS: c_ulong = 0x40;
            pub const X509_V_FLAG_POLICY_CHECK: c_ulong = 0x80;
            pub const X509_V_FLAG_EXPLICIT_POLICY: c_ulong = 0x100;
            pub const X509_V_FLAG_INHIBIT_ANY: c_ulong = 0x200;
            pub const X509_V_FLAG_INHIBIT_MAP: c_ulong = 0x400;
            pub const X509_V_FLAG_NOTIFY_POLICY: c_ulong = 0x800;
            pub const X509_V_FLAG_EXTENDED_CRL_SUPPORT: c_ulong = 0x1000;
            pub const X509_V_FLAG_USE_DELTAS: c_ulong = 0x2000;
            pub const X509_V_FLAG_CHECK_SS_SIGNATURE: c_ulong = 0x4000;
            #[cfg(ossl102)]
            pub const X509_V_FLAG_TRUSTED_FIRST: c_ulong = 0x8000;
            #[cfg(ossl102)]
            pub const X509_V_FLAG_SUITEB_128_LOS_ONLY: c_ulong = 0x10000;
            #[cfg(ossl102)]
            pub const X509_V_FLAG_SUITEB_192_LOS: c_ulong = 0x20000;
            #[cfg(ossl102)]
            pub const X509_V_FLAG_SUITEB_128_LOS: c_ulong = 0x30000;
            #[cfg(ossl102)]
            pub const X509_V_FLAG_PARTIAL_CHAIN: c_ulong = 0x80000;
            #[cfg(ossl110)]
            pub const X509_V_FLAG_NO_ALT_CHAINS: c_ulong = 0x100000;
            #[cfg(ossl110)]
            pub const X509_V_FLAG_NO_CHECK_TIME: c_ulong = 0x200000;

            pub unsafe fn X509_LOOKUP_add_dir(
                ctx: *mut X509_LOOKUP,
                name: *const c_char,
                _type: c_int,
            ) -> c_int {
                const X509_L_ADD_DIR: c_int = 2;
                X509_LOOKUP_ctrl(
                    ctx,
                    X509_L_ADD_DIR,
                    name,
                    _type as c_long,
                    ::ptr::null_mut(),
                )
            }
        }

        pub mod x509v3
        {
            /*!
            */
            use ::
            {
                libc::{ * },
                *,
            };
            /*
            */            
            #[repr(C)] pub struct GENERAL_NAME 
            {
                pub type_: c_int,
                pub d: *mut c_void,
            }

            stack!(stack_st_GENERAL_NAME);

            pub const GEN_OTHERNAME: c_int = 0;
            pub const GEN_EMAIL: c_int = 1;
            pub const GEN_DNS: c_int = 2;
            pub const GEN_X400: c_int = 3;
            pub const GEN_DIRNAME: c_int = 4;
            pub const GEN_EDIPARTY: c_int = 5;
            pub const GEN_URI: c_int = 6;
            pub const GEN_IPADD: c_int = 7;
            pub const GEN_RID: c_int = 8;

            #[cfg(any(ossl102, libressl261))]
            pub const X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT: c_uint = 0x1;
            #[cfg(any(ossl102, libressl261))]
            pub const X509_CHECK_FLAG_NO_WILDCARDS: c_uint = 0x2;
            #[cfg(any(ossl102, libressl261))]
            pub const X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS: c_uint = 0x4;
            #[cfg(any(ossl102, libressl261))]
            pub const X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS: c_uint = 0x8;
            #[cfg(any(ossl102, libressl261))]
            pub const X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS: c_uint = 0x10;
            #[cfg(ossl110)]
            pub const X509_CHECK_FLAG_NEVER_CHECK_SUBJECT: c_uint = 0x20;

            pub const X509V3_ADD_DEFAULT: c_ulong = 0;
            pub const X509V3_ADD_APPEND: c_ulong = 1;
            pub const X509V3_ADD_REPLACE: c_ulong = 2;
            pub const X509V3_ADD_REPLACE_EXISTING: c_ulong = 3;
            pub const X509V3_ADD_KEEP_EXISTING: c_ulong = 4;
            pub const X509V3_ADD_DELETE: c_ulong = 5;
            pub const X509V3_ADD_SILENT: c_ulong = 0x10;

            pub const EXFLAG_BCONS: u32 = 0x1;
            pub const EXFLAG_KUSAGE: u32 = 0x2;
            pub const EXFLAG_XKUSAGE: u32 = 0x4;
            pub const EXFLAG_NSCERT: u32 = 0x8;
            pub const EXFLAG_CA: u32 = 0x10;
            pub const EXFLAG_SI: u32 = 0x20;
            pub const EXFLAG_V1: u32 = 0x40;
            pub const EXFLAG_INVALID: u32 = 0x80;
            pub const EXFLAG_SET: u32 = 0x100;
            pub const EXFLAG_CRITICAL: u32 = 0x200;
            pub const EXFLAG_PROXY: u32 = 0x400;
            pub const EXFLAG_INVALID_POLICY: u32 = 0x800;
            pub const EXFLAG_FRESHEST: u32 = 0x1000;
            #[cfg(any(ossl102, libressl261))]
            pub const EXFLAG_SS: u32 = 0x2000;

            pub const X509v3_KU_DIGITAL_SIGNATURE: u32 = 0x0080;
            pub const X509v3_KU_NON_REPUDIATION: u32 = 0x0040;
            pub const X509v3_KU_KEY_ENCIPHERMENT: u32 = 0x0020;
            pub const X509v3_KU_DATA_ENCIPHERMENT: u32 = 0x0010;
            pub const X509v3_KU_KEY_AGREEMENT: u32 = 0x0008;
            pub const X509v3_KU_KEY_CERT_SIGN: u32 = 0x0004;
            pub const X509v3_KU_CRL_SIGN: u32 = 0x0002;
            pub const X509v3_KU_ENCIPHER_ONLY: u32 = 0x0001;
            pub const X509v3_KU_DECIPHER_ONLY: u32 = 0x8000;
            pub const X509v3_KU_UNDEF: u32 = 0xffff;

            pub const XKU_SSL_SERVER: u32 = 0x1;
            pub const XKU_SSL_CLIENT: u32 = 0x2;
            pub const XKU_SMIME: u32 = 0x4;
            pub const XKU_CODE_SIGN: u32 = 0x8;
            pub const XKU_SGC: u32 = 0x10;
            pub const XKU_OCSP_SIGN: u32 = 0x20;
            pub const XKU_TIMESTAMP: u32 = 0x40;
            pub const XKU_DVCS: u32 = 0x80;
            #[cfg(ossl110)]
            pub const XKU_ANYEKU: u32 = 0x100;

            pub const X509_PURPOSE_SSL_CLIENT: c_int = 1;
            pub const X509_PURPOSE_SSL_SERVER: c_int = 2;
            pub const X509_PURPOSE_NS_SSL_SERVER: c_int = 3;
            pub const X509_PURPOSE_SMIME_SIGN: c_int = 4;
            pub const X509_PURPOSE_SMIME_ENCRYPT: c_int = 5;
            pub const X509_PURPOSE_CRL_SIGN: c_int = 6;
            pub const X509_PURPOSE_ANY: c_int = 7;
            pub const X509_PURPOSE_OCSP_HELPER: c_int = 8;
            pub const X509_PURPOSE_TIMESTAMP_SIGN: c_int = 9;
            #[cfg(ossl320)]
            pub const X509_PURPOSE_CODE_SIGN: c_int = 10;
            pub const X509_PURPOSE_MIN: c_int = 1;
            cfg_if! {
                if #[cfg(ossl320)] {
                    pub const X509_PURPOSE_MAX: c_int = 10;
                } else {
                    pub const X509_PURPOSE_MAX: c_int = 9;
                }
            }

            pub const CRL_REASON_UNSPECIFIED: c_int = 0;
            pub const CRL_REASON_KEY_COMPROMISE: c_int = 1;
            pub const CRL_REASON_CA_COMPROMISE: c_int = 2;
            pub const CRL_REASON_AFFILIATION_CHANGED: c_int = 3;
            pub const CRL_REASON_SUPERSEDED: c_int = 4;
            pub const CRL_REASON_CESSATION_OF_OPERATION: c_int = 5;
            pub const CRL_REASON_CERTIFICATE_HOLD: c_int = 6;
            pub const CRL_REASON_REMOVE_FROM_CRL: c_int = 8;
            pub const CRL_REASON_PRIVILEGE_WITHDRAWN: c_int = 9;
            pub const CRL_REASON_AA_COMPROMISE: c_int = 10;
        }
        
        pub type PasswordCallback = unsafe extern "C" fn
        (
            buf: *mut c_char,
            size: c_int,
            rwflag: c_int,
            user_data: *mut c_void,
        ) -> c_int;

        #[cfg(ossl110)] pub fn init()
        {
            use std::ptr;

            #[cfg(not(ossl111b))]
            let init_options = OPENSSL_INIT_LOAD_SSL_STRINGS;
            #[cfg(ossl111b)]
            let init_options = OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_NO_ATEXIT;

            INIT.call_once(|| unsafe 
            {
                OPENSSL_init_ssl(init_options, ptr::null_mut());
            })
        }

        #[cfg(not(ossl110))] pub fn init()
        {
            use std::io::{self, Write};
            use std::mem;
            use std::process;
            use std::sync::{Mutex, MutexGuard};

            static mut MUTEXES: *mut Vec<Mutex<()>> = 0 as *mut Vec<Mutex<()>>;
            static mut GUARDS: *mut Vec<Option<MutexGuard<'static, ()>>> =
                0 as *mut Vec<Option<MutexGuard<'static, ()>>>;

            unsafe extern "C" fn locking_function(
                mode: c_int,
                n: c_int,
                _file: *const c_char,
                _line: c_int,
            ) {
                let mutex = &(*MUTEXES)[n as usize];

                if mode & CRYPTO_LOCK != 0 {
                    (*GUARDS)[n as usize] = Some(mutex.lock().unwrap());
                } else {
                    if let None = (*GUARDS)[n as usize].take() {
                        let _ = writeln!(
                            io::stderr(),
                            "BUG: rust-openssl lock {} already unlocked, aborting",
                            n
                        );
                        process::abort();
                    }
                }
            }

            cfg_if! {
                if #[cfg(unix)] {
                    fn set_id_callback() {
                        unsafe extern "C" fn thread_id() -> c_ulong {
                            ::libc::pthread_self() as c_ulong
                        }

                        unsafe {
                            CRYPTO_set_id_callback__fixed_rust(Some(thread_id));
                        }
                    }
                } else {
                    fn set_id_callback() {}
                }
            }

            INIT.call_once(|| unsafe {
                SSL_library_init();
                SSL_load_error_strings();
                OPENSSL_add_all_algorithms_noconf();

                let num_locks = CRYPTO_num_locks();
                let mut mutexes = Box::new(Vec::new());
                for _ in 0..num_locks {
                    mutexes.push(Mutex::new(()));
                }
                MUTEXES = mem::transmute(mutexes);
                let guards: Box<Vec<Option<MutexGuard<()>>>> =
                    Box::new((0..num_locks).map(|_| None).collect());
                GUARDS = mem::transmute(guards);

                CRYPTO_set_locking_callback__fixed_rust(Some(locking_function));
                set_id_callback();
            })
        }
        /// Disable explicit initialization of the openssl libs.
        pub unsafe fn assume_init()
        {
            INIT.call_once(|| {});
        }
    }
}
/*
4408 */
