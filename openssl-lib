/*!
*/
#![feature
(

)]

#![allow
(
    clashing_extern_declarations,
    dead_code,
    non_camel_case_types,
    non_snake_case,
    unused_attributes,
    unused_imports,
    unused_macros,
)]

#[macro_use] extern crate cfg_if;

extern crate libc;

/*
openssl-sys = { version = "0.9.103", optional = true }
    [package]
        name = "openssl"
        version = "0.10.65"
        authors = ["Steven Fackler <sfackler@gmail.com>"]
        license = "Apache-2.0"
        description = "OpenSSL bindings"
        repository = "https://github.com/sfackler/rust-openssl"
        readme = "README.md"
        keywords = ["crypto", "tls", "ssl", "dtls"]
        categories = ["cryptography", "api-bindings"]
        edition = "2018"
        
        [features]
            v101 = []
            v102 = []
            v110 = []
            v111 = []

            vendored = ['ffi/vendored']
            bindgen = ['ffi/bindgen']
            unstable_boringssl = ["ffi/unstable_boringssl"]
            default = []

        [dependencies]
                foreign-types-shared = "0.1.0"
                foreign-types = "0.3.1"

            openssl-macros = { version = "0.1.0", path = "../openssl-macros" }
            ffi = { package = "openssl-sys", version = "0.9.103", path = "../openssl-sys" }
                bitflags = "2.2.1"
                cfg-if = "1.0"
                libc = "0.2"
                once_cell = "1.5.2"

[package]
    name = "libsqlite3-sys"
    version = "0.35.0"
    authors = ["The rusqlite developers"]
    edition = "2021"
    repository = "https://github.com/rusqlite/rusqlite"
    description = "Native bindings to the libsqlite3 library"
    license = "MIT"
    links = "sqlite3"
    build = "build.rs"
    keywords = ["sqlite", "sqlcipher", "ffi"]
    categories = ["external-ffi-bindings"]

[features]
    default = ["min_sqlite_version_3_14_0"]
    bundled = ["cc", "bundled_bindings"]
    bundled-windows = ["cc", "bundled_bindings"]
    bundled-sqlcipher = ["bundled"]
    bundled-sqlcipher-vendored-openssl = 
    [
        "bundled-sqlcipher",
        "openssl-sys/vendored",
    ]
    buildtime_bindgen = ["bindgen", "pkg-config", "vcpkg"]
    sqlcipher = []
    min_sqlite_version_3_14_0 = ["pkg-config", "vcpkg"]
    # Bundle only the bindings file. Note that this does nothing if `buildtime_bindgen` is enabled.
    bundled_bindings = []
    loadable_extension = ["prettyplease", "quote", "syn"]
    unlock_notify = []
    column_metadata = []
    preupdate_hook = ["buildtime_bindgen"]
    session = ["preupdate_hook", "buildtime_bindgen"]
    in_gecko = []
    with-asan = []
    wasm32-wasi-vfs = []

[dependencies]
    

[build-dependencies]
    bindgen =
    { 
        version = "0.72", optional = true, default-features = false, features = 
        [
            "runtime",
        ]
    }
    pkg-config = { version = "0.3.19", optional = true }
    cc = { version = "1.1.6", optional = true }
    vcpkg = { version = "0.2.15", optional = true }
    prettyplease = { version = "0.2.20", optional = true }
    quote = { version = "1.0.36", optional = true, default-features = false }
    syn = 
    { 
        version = "2.0.72", optional = true, features = 
        [
            "full",
            "extra-traits",
            "visit-mut",
        ] 
    }


{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
}

pub mod _
{
    pub use std::_::{ * };
}
*/

#[macro_use] pub mod macros
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
}

pub mod alloc
{
    pub use std::alloc::{ * };
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod convert
{
    pub use std::convert::{ * };
}

pub mod cell
{
    pub use std::cell::{ * };
}

pub mod default
{
    pub use std::default::{ * };
}

pub mod error
{
    pub use std::error::{ * };
    
    pub mod libsqlite3
    {
        /*!
        */
        use ::
        {
            os::raw::c_int,
            system::libsqlite3 as lib,
            *,
        };
        /*
        */
        /// Error Codes
        #[non_exhaustive] #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ErrorCode
        {
            /// Internal logic error in SQLite
            InternalMalfunction,
            /// Access permission denied
            PermissionDenied,
            /// Callback routine requested an abort
            OperationAborted,
            /// The database file is locked
            DatabaseBusy,
            /// A table in the database is locked
            DatabaseLocked,
            /// A `malloc()` failed
            OutOfMemory,
            /// Attempt to write a readonly database
            ReadOnly,
            /// Operation terminated by `sqlite3_interrupt()`
            OperationInterrupted,
            /// Some kind of disk I/O error occurred
            SystemIoFailure,
            /// The database disk image is malformed
            DatabaseCorrupt,
            /// Unknown opcode in `sqlite3_file_control()`
            NotFound,
            /// Insertion failed because database is full
            DiskFull,
            /// Unable to open the database file
            CannotOpen,
            /// Database lock protocol error
            FileLockingProtocolFailed,
            /// The database schema changed
            SchemaChanged,
            /// String or BLOB exceeds size limit
            TooBig,
            /// Abort due to constraint violation
            ConstraintViolation,
            /// Data type mismatch
            TypeMismatch,
            /// Library used incorrectly
            ApiMisuse,
            /// Uses OS features not supported on host
            NoLargeFileSupport,
            /// Authorization denied
            AuthorizationForStatementDenied,
            /// 2nd parameter to `sqlite3_bind` out of range
            ParameterOutOfRange,
            /// File opened that is not a database file
            NotADatabase,
            /// SQL error or missing database
            Unknown,
        }

        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub struct Error 
        {
            pub code: ErrorCode,
            pub extended_code: c_int,
        }

        impl Error
        {
            #[must_use] pub fn new(result_code: c_int) -> Self
            {
                let code = match result_code & 0xff
                {
                    lib::SQLITE_INTERNAL => ErrorCode::InternalMalfunction,
                    lib::SQLITE_PERM => ErrorCode::PermissionDenied,
                    lib::SQLITE_ABORT => ErrorCode::OperationAborted,
                    lib::SQLITE_BUSY => ErrorCode::DatabaseBusy,
                    lib::SQLITE_LOCKED => ErrorCode::DatabaseLocked,
                    lib::SQLITE_NOMEM => ErrorCode::OutOfMemory,
                    lib::SQLITE_READONLY => ErrorCode::ReadOnly,
                    lib::SQLITE_INTERRUPT => ErrorCode::OperationInterrupted,
                    lib::SQLITE_IOERR => ErrorCode::SystemIoFailure,
                    lib::SQLITE_CORRUPT => ErrorCode::DatabaseCorrupt,
                    lib::SQLITE_NOTFOUND => ErrorCode::NotFound,
                    lib::SQLITE_FULL => ErrorCode::DiskFull,
                    lib::SQLITE_CANTOPEN => ErrorCode::CannotOpen,
                    lib::SQLITE_PROTOCOL => ErrorCode::FileLockingProtocolFailed,
                    lib::SQLITE_SCHEMA => ErrorCode::SchemaChanged,
                    lib::SQLITE_TOOBIG => ErrorCode::TooBig,
                    lib::SQLITE_CONSTRAINT => ErrorCode::ConstraintViolation,
                    lib::SQLITE_MISMATCH => ErrorCode::TypeMismatch,
                    lib::SQLITE_MISUSE => ErrorCode::ApiMisuse,
                    lib::SQLITE_NOLFS => ErrorCode::NoLargeFileSupport,
                    lib::SQLITE_AUTH => ErrorCode::AuthorizationForStatementDenied,
                    lib::SQLITE_RANGE => ErrorCode::ParameterOutOfRange,
                    lib::SQLITE_NOTADB => ErrorCode::NotADatabase,
                    _ => ErrorCode::Unknown,
                };

                Self {
                    code,
                    extended_code: result_code,
                }
            }
        }

        impl fmt::Display for Error
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
            {
                write!
                (
                    f,
                    "Error code {}: {}",
                    self.extended_code,
                    code_to_str(self.extended_code)
                )
            }
        }

        impl error::Error for Error
        {
            fn description(&self) -> &str { code_to_str(self.extended_code) }
        }
        /// Extended result codes.
        const SQLITE_ERROR_MISSING_COLLSEQ: c_int = lib::SQLITE_ERROR | (1 << 8);
        const SQLITE_ERROR_RETRY: c_int = lib::SQLITE_ERROR | (2 << 8);
        const SQLITE_ERROR_SNAPSHOT: c_int = lib::SQLITE_ERROR | (3 << 8);

        const SQLITE_IOERR_BEGIN_ATOMIC: c_int = lib::SQLITE_IOERR | (29 << 8);
        const SQLITE_IOERR_COMMIT_ATOMIC: c_int = lib::SQLITE_IOERR | (30 << 8);
        const SQLITE_IOERR_ROLLBACK_ATOMIC: c_int = lib::SQLITE_IOERR | (31 << 8);
        const SQLITE_IOERR_DATA: c_int = lib::SQLITE_IOERR | (32 << 8);
        const SQLITE_IOERR_CORRUPTFS: c_int = lib::SQLITE_IOERR | (33 << 8);
        const SQLITE_IOERR_IN_PAGE: c_int = lib::SQLITE_IOERR | (34 << 8);

        const SQLITE_LOCKED_VTAB: c_int = lib::SQLITE_LOCKED | (2 << 8);

        const SQLITE_BUSY_TIMEOUT: c_int = lib::SQLITE_BUSY | (3 << 8);

        const SQLITE_CANTOPEN_SYMLINK: c_int = lib::SQLITE_CANTOPEN | (6 << 8);

        const SQLITE_CORRUPT_SEQUENCE: c_int = lib::SQLITE_CORRUPT | (2 << 8);
        const SQLITE_CORRUPT_INDEX: c_int = lib::SQLITE_CORRUPT | (3 << 8);

        const SQLITE_READONLY_CANTINIT: c_int = lib::SQLITE_READONLY | (5 << 8);
        const SQLITE_READONLY_DIRECTORY: c_int = lib::SQLITE_READONLY | (6 << 8);

        const SQLITE_CONSTRAINT_PINNED: c_int = lib::SQLITE_CONSTRAINT | (11 << 8);
        const SQLITE_CONSTRAINT_DATATYPE: c_int = lib::SQLITE_CONSTRAINT | (12 << 8);

        #[must_use] pub fn code_to_str(code: c_int) -> &'static str
        {
            match code
            {
                lib::SQLITE_OK        => "Successful result",
                lib::SQLITE_ERROR     => "SQL error or missing database",
                lib::SQLITE_INTERNAL  => "Internal logic error in SQLite",
                lib::SQLITE_PERM      => "Access permission denied",
                lib::SQLITE_ABORT     => "Callback routine requested an abort",
                lib::SQLITE_BUSY      => "The database file is locked",
                lib::SQLITE_LOCKED    => "A table in the database is locked",
                lib::SQLITE_NOMEM     => "A malloc() failed",
                lib::SQLITE_READONLY  => "Attempt to write a readonly database",
                lib::SQLITE_INTERRUPT => "Operation terminated by sqlite3_interrupt()",
                lib::SQLITE_IOERR     => "Some kind of disk I/O error occurred",
                lib::SQLITE_CORRUPT   => "The database disk image is malformed",
                lib::SQLITE_NOTFOUND  => "Unknown opcode in sqlite3_file_control()",
                lib::SQLITE_FULL      => "Insertion failed because database is full",
                lib::SQLITE_CANTOPEN  => "Unable to open the database file",
                lib::SQLITE_PROTOCOL  => "Database lock protocol error",
                lib::SQLITE_EMPTY     => "Database is empty",
                lib::SQLITE_SCHEMA    => "The database schema changed",
                lib::SQLITE_TOOBIG    => "String or BLOB exceeds size limit",
                lib::SQLITE_CONSTRAINT=> "Abort due to constraint violation",
                lib::SQLITE_MISMATCH  => "Data type mismatch",
                lib::SQLITE_MISUSE    => "Library used incorrectly",
                lib::SQLITE_NOLFS     => "Uses OS features not supported on host",
                lib::SQLITE_AUTH      => "Authorization denied",
                lib::SQLITE_FORMAT    => "Auxiliary database format error",
                lib::SQLITE_RANGE     => "2nd parameter to sqlite3_bind out of range",
                lib::SQLITE_NOTADB    => "File opened that is not a database file",
                lib::SQLITE_NOTICE    => "Notifications from sqlite3_log()",
                lib::SQLITE_WARNING   => "Warnings from sqlite3_log()",
                lib::SQLITE_ROW       => "sqlite3_step() has another row ready",
                lib::SQLITE_DONE      => "sqlite3_step() has finished executing",

                SQLITE_ERROR_MISSING_COLLSEQ   => "SQLITE_ERROR_MISSING_COLLSEQ",
                SQLITE_ERROR_RETRY   => "SQLITE_ERROR_RETRY",
                SQLITE_ERROR_SNAPSHOT   => "SQLITE_ERROR_SNAPSHOT",

                lib::SQLITE_IOERR_READ              => "Error reading from disk",
                lib::SQLITE_IOERR_SHORT_READ        => "Unable to obtain number of requested bytes (file truncated?)",
                lib::SQLITE_IOERR_WRITE             => "Error writing to disk",
                lib::SQLITE_IOERR_FSYNC             => "Error flushing data to persistent storage (fsync)",
                lib::SQLITE_IOERR_DIR_FSYNC         => "Error calling fsync on a directory",
                lib::SQLITE_IOERR_TRUNCATE          => "Error attempting to truncate file",
                lib::SQLITE_IOERR_FSTAT             => "Error invoking fstat to get file metadata",
                lib::SQLITE_IOERR_UNLOCK            => "I/O error within xUnlock of a VFS object",
                lib::SQLITE_IOERR_RDLOCK            => "I/O error within xLock of a VFS object (trying to obtain a read lock)",
                lib::SQLITE_IOERR_DELETE            => "I/O error within xDelete of a VFS object",
                lib::SQLITE_IOERR_BLOCKED           => "SQLITE_IOERR_BLOCKED", // no longer used
                lib::SQLITE_IOERR_NOMEM             => "Out of memory in I/O layer",
                lib::SQLITE_IOERR_ACCESS            => "I/O error within xAccess of a VFS object",
                lib::SQLITE_IOERR_CHECKRESERVEDLOCK => "I/O error within then xCheckReservedLock method",
                lib::SQLITE_IOERR_LOCK              => "I/O error in the advisory file locking layer",
                lib::SQLITE_IOERR_CLOSE             => "I/O error within the xClose method",
                lib::SQLITE_IOERR_DIR_CLOSE         => "SQLITE_IOERR_DIR_CLOSE", // no longer used
                lib::SQLITE_IOERR_SHMOPEN           => "I/O error within the xShmMap method (trying to open a new shared-memory segment)",
                lib::SQLITE_IOERR_SHMSIZE           => "I/O error within the xShmMap method (trying to resize an existing shared-memory segment)",
                lib::SQLITE_IOERR_SHMLOCK           => "SQLITE_IOERR_SHMLOCK", // no longer used
                lib::SQLITE_IOERR_SHMMAP            => "I/O error within the xShmMap method (trying to map a shared-memory segment into process address space)",
                lib::SQLITE_IOERR_SEEK              => "I/O error within the xRead or xWrite (trying to seek within a file)",
                lib::SQLITE_IOERR_DELETE_NOENT      => "File being deleted does not exist",
                lib::SQLITE_IOERR_MMAP              => "I/O error while trying to map or unmap part of the database file into process address space",
                lib::SQLITE_IOERR_GETTEMPPATH       => "VFS is unable to determine a suitable directory for temporary files",
                lib::SQLITE_IOERR_CONVPATH          => "cygwin_conv_path() system call failed",
                lib::SQLITE_IOERR_VNODE             => "SQLITE_IOERR_VNODE", // not documented?
                lib::SQLITE_IOERR_AUTH              => "SQLITE_IOERR_AUTH",
                SQLITE_IOERR_BEGIN_ATOMIC      => "SQLITE_IOERR_BEGIN_ATOMIC",
                SQLITE_IOERR_COMMIT_ATOMIC     => "SQLITE_IOERR_COMMIT_ATOMIC",
                SQLITE_IOERR_ROLLBACK_ATOMIC   => "SQLITE_IOERR_ROLLBACK_ATOMIC",
                SQLITE_IOERR_DATA   => "SQLITE_IOERR_DATA",
                SQLITE_IOERR_CORRUPTFS   => "SQLITE_IOERR_CORRUPTFS",
                SQLITE_IOERR_IN_PAGE   => "SQLITE_IOERR_IN_PAGE",

                lib::SQLITE_LOCKED_SHAREDCACHE      => "Locking conflict due to another connection with a shared cache",
                SQLITE_LOCKED_VTAB             => "SQLITE_LOCKED_VTAB",

                lib::SQLITE_BUSY_RECOVERY           => "Another process is recovering a WAL mode database file",
                lib::SQLITE_BUSY_SNAPSHOT           => "Cannot promote read transaction to write transaction because of writes by another connection",
                SQLITE_BUSY_TIMEOUT           => "SQLITE_BUSY_TIMEOUT",

                lib::SQLITE_CANTOPEN_NOTEMPDIR      => "SQLITE_CANTOPEN_NOTEMPDIR", // no longer used
                lib::SQLITE_CANTOPEN_ISDIR          => "Attempted to open directory as file",
                lib::SQLITE_CANTOPEN_FULLPATH       => "Unable to convert filename into full pathname",
                lib::SQLITE_CANTOPEN_CONVPATH       => "cygwin_conv_path() system call failed",
                SQLITE_CANTOPEN_SYMLINK       => "SQLITE_CANTOPEN_SYMLINK",

                lib::SQLITE_CORRUPT_VTAB            => "Content in the virtual table is corrupt",
                SQLITE_CORRUPT_SEQUENCE        => "SQLITE_CORRUPT_SEQUENCE",
                SQLITE_CORRUPT_INDEX        => "SQLITE_CORRUPT_INDEX",

                lib::SQLITE_READONLY_RECOVERY       => "WAL mode database file needs recovery (requires write access)",
                lib::SQLITE_READONLY_CANTLOCK       => "Shared-memory file associated with WAL mode database is read-only",
                lib::SQLITE_READONLY_ROLLBACK       => "Database has hot journal that must be rolled back (requires write access)",
                lib::SQLITE_READONLY_DBMOVED        => "Database cannot be modified because database file has moved",
                SQLITE_READONLY_CANTINIT       => "SQLITE_READONLY_CANTINIT",
                SQLITE_READONLY_DIRECTORY      => "SQLITE_READONLY_DIRECTORY",

                lib::SQLITE_ABORT_ROLLBACK          => "Transaction was rolled back",

                lib::SQLITE_CONSTRAINT_CHECK        => "A CHECK constraint failed",
                lib::SQLITE_CONSTRAINT_COMMITHOOK   => "Commit hook caused rollback",
                lib::SQLITE_CONSTRAINT_FOREIGNKEY   => "Foreign key constraint failed",
                lib::SQLITE_CONSTRAINT_FUNCTION     => "Error returned from extension function",
                lib::SQLITE_CONSTRAINT_NOTNULL      => "A NOT NULL constraint failed",
                lib::SQLITE_CONSTRAINT_PRIMARYKEY   => "A PRIMARY KEY constraint failed",
                lib::SQLITE_CONSTRAINT_TRIGGER      => "A RAISE function within a trigger fired",
                lib::SQLITE_CONSTRAINT_UNIQUE       => "A UNIQUE constraint failed",
                lib::SQLITE_CONSTRAINT_VTAB         => "An application-defined virtual table error occurred",
                lib::SQLITE_CONSTRAINT_ROWID        => "A non-unique rowid occurred",
                SQLITE_CONSTRAINT_PINNED        => "SQLITE_CONSTRAINT_PINNED",
                SQLITE_CONSTRAINT_DATATYPE        => "SQLITE_CONSTRAINT_DATATYPE",

                lib::SQLITE_NOTICE_RECOVER_WAL      => "A WAL mode database file was recovered",
                lib::SQLITE_NOTICE_RECOVER_ROLLBACK => "Hot journal was rolled back",

                lib::SQLITE_WARNING_AUTOINDEX       => "Automatic indexing used - database might benefit from additional indexes",

                lib::SQLITE_AUTH_USER               => "SQLITE_AUTH_USER", // not documented?

                _ => "Unknown error code",
            }
        }
        /*
        /// Loadable extension initialization error
        #[cfg(feature = "loadable_extension")]
        #[non_exhaustive] #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        
        pub enum InitError
        {
            /// Version mismatch between the extension and the SQLite3 library
            VersionMismatch { compile_time: i32, runtime: i32 },
            /// Invalid function pointer in one of `sqlite3_api_routines` fields
            NullFunctionPointer,
        }

        #[cfg(feature = "loadable_extension")]
        impl fmt::Display for InitError {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match *self {
                    Self::VersionMismatch {
                        compile_time,
                        runtime,
                    } => {
                        write!(f, "SQLite version mismatch: {runtime} < {compile_time}")
                    }
                    Self::NullFunctionPointer => {
                        write!(f, "Some sqlite3_api_routines fields are null")
                    }
                }
            }
        }
        #[cfg(feature = "loadable_extension")]
        impl error::Error for InitError {} */
    }

    pub mod sqlite3
    {
        /*!
        */
        use ::
        {
            ffi::{c_char, c_int, NulError},
            path::{ PathBuf },
            *,
        };
        /*
        use crate::types::FromSqlError;
        use crate::types::Type;
        use crate::{errmsg_to_string, ffi, Result};
        */
        /// Enum listing possible errors from rusqlite.
        #[derive(Debug)]
        #[non_exhaustive]
        pub enum Error 
        {
            /// An error from an underlying SQLite call.
            SqliteFailure(ffi::Error, Option<String>),

            /// Error reported when attempting to open a connection when SQLite was
            /// configured to allow single-threaded use only.
            SqliteSingleThreadedMode,

            /// Error when the value of a particular column is requested, but it cannot
            /// be converted to the requested Rust type.
            FromSqlConversionFailure(usize, Type, Box<dyn error::Error + Send + Sync + 'static>),

            /// Error when SQLite gives us an integral value outside the range of the
            /// requested type (e.g., trying to get the value 1000 into a `u8`).
            /// The associated `usize` is the column index,
            /// and the associated `i64` is the value returned by SQLite.
            IntegralValueOutOfRange(usize, i64),

            /// Error converting a string to UTF-8.
            Utf8Error(str::Utf8Error),

            /// Error converting a string to a C-compatible string because it contained
            /// an embedded nul.
            NulError(NulError),

            /// Error when using SQL named parameters and passing a parameter name not
            /// present in the SQL.
            InvalidParameterName(String),

            /// Error converting a file path to a string.
            InvalidPath(PathBuf),

            /// Error returned when an [`execute`](crate::Connection::execute) call
            /// returns rows.
            ExecuteReturnedResults,

            /// Error when a query that was expected to return at least one row (e.g.,
            /// for [`query_row`](crate::Connection::query_row)) did not return any.
            QueryReturnedNoRows,

            /// Error when a query that was expected to return only one row (e.g.,
            /// for [`query_one`](crate::Connection::query_one)) did return more than one.
            QueryReturnedMoreThanOneRow,

            /// Error when the value of a particular column is requested, but the index
            /// is out of range for the statement.
            InvalidColumnIndex(usize),

            /// Error when the value of a named column is requested, but no column
            /// matches the name for the statement.
            InvalidColumnName(String),

            /// Error when the value of a particular column is requested, but the type
            /// of the result in that column cannot be converted to the requested
            /// Rust type.
            InvalidColumnType(usize, String, Type),

            /// Error when a query that was expected to insert one row did not insert
            /// any or insert many.
            StatementChangedRows(usize),

            /// Error available for the implementors of the
            /// [`ToSql`](crate::types::ToSql) trait.
            ToSqlConversionFailure(Box<dyn error::Error + Send + Sync + 'static>),

            /// Error when the SQL is not a `SELECT`, is not read-only.
            InvalidQuery,
            /// An unwinding panic occurs in a UDF (user-defined function).
            UnwindingPanic,

            /// Error when the SQL contains multiple statements.
            MultipleStatement,
            /// Error when the number of bound parameters does not match the number of
            /// parameters in the query. The first `usize` is how many parameters were
            /// given, the 2nd is how many were expected.
            InvalidParameterCount(usize, usize),
            
            SqlInputError 
            {
                /// error code
                error: ffi::Error,
                /// error message
                msg: String,
                /// SQL input
                sql: String,
                /// byte offset of the start of invalid token
                offset: c_int,
            },
            
            InvalidDatabaseIndex(usize),
        }

        impl PartialEq for Error {
            fn eq(&self, other: &Self) -> bool {
                match (self, other) {
                    (Self::SqliteFailure(e1, s1), Self::SqliteFailure(e2, s2)) => e1 == e2 && s1 == s2,
                    (Self::SqliteSingleThreadedMode, Self::SqliteSingleThreadedMode) => true,
                    (Self::IntegralValueOutOfRange(i1, n1), Self::IntegralValueOutOfRange(i2, n2)) => {
                        i1 == i2 && n1 == n2
                    }
                    (Self::Utf8Error(e1), Self::Utf8Error(e2)) => e1 == e2,
                    (Self::NulError(e1), Self::NulError(e2)) => e1 == e2,
                    (Self::InvalidParameterName(n1), Self::InvalidParameterName(n2)) => n1 == n2,
                    (Self::InvalidPath(p1), Self::InvalidPath(p2)) => p1 == p2,
                    (Self::ExecuteReturnedResults, Self::ExecuteReturnedResults) => true,
                    (Self::QueryReturnedNoRows, Self::QueryReturnedNoRows) => true,
                    (Self::QueryReturnedMoreThanOneRow, Self::QueryReturnedMoreThanOneRow) => true,
                    (Self::InvalidColumnIndex(i1), Self::InvalidColumnIndex(i2)) => i1 == i2,
                    (Self::InvalidColumnName(n1), Self::InvalidColumnName(n2)) => n1 == n2,
                    (Self::InvalidColumnType(i1, n1, t1), Self::InvalidColumnType(i2, n2, t2)) => {
                        i1 == i2 && t1 == t2 && n1 == n2
                    }
                    (Self::StatementChangedRows(n1), Self::StatementChangedRows(n2)) => n1 == n2,
                    (Self::InvalidQuery, Self::InvalidQuery) => true,
                    (Self::UnwindingPanic, Self::UnwindingPanic) => true,
                    (Self::InvalidParameterCount(i1, n1), Self::InvalidParameterCount(i2, n2)) => {
                        i1 == i2 && n1 == n2
                    }
                    (
                        Self::SqlInputError {
                            error: e1,
                            msg: m1,
                            sql: s1,
                            offset: o1,
                        },
                        Self::SqlInputError {
                            error: e2,
                            msg: m2,
                            sql: s2,
                            offset: o2,
                        },
                    ) => e1 == e2 && m1 == m2 && s1 == s2 && o1 == o2,
                    (Self::InvalidDatabaseIndex(i1), Self::InvalidDatabaseIndex(i2)) => i1 == i2,
                    (..) => false,
                }
            }
        }

        impl From<str::Utf8Error> for Error {
            #[cold]
            fn from(err: str::Utf8Error) -> Self {
                Self::Utf8Error(err)
            }
        }

        impl From<NulError> for Error {
            #[cold]
            fn from(err: NulError) -> Self {
                Self::NulError(err)
            }
        }

        const UNKNOWN_COLUMN: usize = usize::MAX;

        /// The conversion isn't precise, but it's convenient to have it
        /// to allow use of `get_raw(…).as_…()?` in callbacks that take `Error`.
        impl From<FromSqlError> for Error {
            #[cold]
            fn from(err: FromSqlError) -> Self {
                // The error type requires index and type fields, but they aren't known in this
                // context.
                match err {
                    FromSqlError::OutOfRange(val) => Self::IntegralValueOutOfRange(UNKNOWN_COLUMN, val),
                    FromSqlError::InvalidBlobSize { .. } => {
                        Self::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Blob, Box::new(err))
                    }
                    FromSqlError::Other(source) => {
                        Self::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Null, source)
                    }
                    _ => Self::FromSqlConversionFailure(UNKNOWN_COLUMN, Type::Null, Box::new(err)),
                }
            }
        }

        #[cfg(feature = "loadable_extension")]
        impl From<ffi::InitError> for Error {
            #[cold]
            fn from(err: ffi::InitError) -> Self {
                Self::InitError(err)
            }
        }

        impl fmt::Display for Error {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match *self {
                    Self::SqliteFailure(ref err, None) => err.fmt(f),
                    Self::SqliteFailure(_, Some(ref s)) => write!(f, "{s}"),
                    Self::SqliteSingleThreadedMode => write!(
                        f,
                        "SQLite was compiled or configured for single-threaded use only"
                    ),
                    Self::FromSqlConversionFailure(i, ref t, ref err) => {
                        if i != UNKNOWN_COLUMN {
                            write!(f, "Conversion error from type {t} at index: {i}, {err}")
                        } else {
                            err.fmt(f)
                        }
                    }
                    Self::IntegralValueOutOfRange(col, val) => {
                        if col != UNKNOWN_COLUMN {
                            write!(f, "Integer {val} out of range at index {col}")
                        } else {
                            write!(f, "Integer {val} out of range")
                        }
                    }
                    Self::Utf8Error(ref err) => err.fmt(f),
                    Self::NulError(ref err) => err.fmt(f),
                    Self::InvalidParameterName(ref name) => write!(f, "Invalid parameter name: {name}"),
                    Self::InvalidPath(ref p) => write!(f, "Invalid path: {}", p.to_string_lossy()),
                    Self::ExecuteReturnedResults => {
                        write!(f, "Execute returned results - did you mean to call query?")
                    }
                    Self::QueryReturnedNoRows => write!(f, "Query returned no rows"),
                    Self::QueryReturnedMoreThanOneRow => write!(f, "Query returned more than one row"),
                    Self::InvalidColumnIndex(i) => write!(f, "Invalid column index: {i}"),
                    Self::InvalidColumnName(ref name) => write!(f, "Invalid column name: {name}"),
                    Self::InvalidColumnType(i, ref name, ref t) => {
                        write!(f, "Invalid column type {t} at index: {i}, name: {name}")
                    }
                    Self::InvalidParameterCount(i1, n1) => write!(
                        f,
                        "Wrong number of parameters passed to query. Got {i1}, needed {n1}"
                    ),
                    Self::StatementChangedRows(i) => write!(f, "Query changed {i} rows"),

                    #[cfg(feature = "functions")]
                    Self::InvalidFunctionParameterType(i, ref t) => {
                        write!(f, "Invalid function parameter type {t} at index {i}")
                    }
                    #[cfg(feature = "vtab")]
                    Self::InvalidFilterParameterType(i, ref t) => {
                        write!(f, "Invalid filter parameter type {t} at index {i}")
                    }
                    #[cfg(feature = "functions")]
                    Self::UserFunctionError(ref err) => err.fmt(f),
                    Self::ToSqlConversionFailure(ref err) => err.fmt(f),
                    Self::InvalidQuery => write!(f, "Query is not read-only"),
                    #[cfg(feature = "vtab")]
                    Self::ModuleError(ref desc) => write!(f, "{desc}"),
                    Self::UnwindingPanic => write!(f, "unwinding panic"),
                    #[cfg(feature = "functions")]
                    Self::GetAuxWrongType => write!(f, "get_aux called with wrong type"),
                    Self::MultipleStatement => write!(f, "Multiple statements provided"),
                    #[cfg(feature = "blob")]
                    Self::BlobSizeError => "Blob size is insufficient".fmt(f),
                    #[cfg(feature = "modern_sqlite")]
                    Self::SqlInputError {
                        ref msg,
                        offset,
                        ref sql,
                        ..
                    } => write!(f, "{msg} in {sql} at offset {offset}"),
                    #[cfg(feature = "loadable_extension")]
                    Self::InitError(ref err) => err.fmt(f),
                    #[cfg(feature = "modern_sqlite")]
                    Self::InvalidDatabaseIndex(i) => write!(f, "Invalid database index: {i}"),
                }
            }
        }

        impl error::Error for Error {
            fn source(&self) -> Option<&(dyn error::Error + 'static)> {
                match *self {
                    Self::SqliteFailure(ref err, _) => Some(err),
                    Self::Utf8Error(ref err) => Some(err),
                    Self::NulError(ref err) => Some(err),

                    Self::IntegralValueOutOfRange(..)
                    | Self::SqliteSingleThreadedMode
                    | Self::InvalidParameterName(_)
                    | Self::ExecuteReturnedResults
                    | Self::QueryReturnedNoRows
                    | Self::QueryReturnedMoreThanOneRow
                    | Self::InvalidColumnIndex(_)
                    | Self::InvalidColumnName(_)
                    | Self::InvalidColumnType(..)
                    | Self::InvalidPath(_)
                    | Self::InvalidParameterCount(..)
                    | Self::StatementChangedRows(_)
                    | Self::InvalidQuery
                    | Self::MultipleStatement => None,

                    #[cfg(feature = "functions")]
                    Self::InvalidFunctionParameterType(..) => None,
                    #[cfg(feature = "vtab")]
                    Self::InvalidFilterParameterType(..) => None,

                    #[cfg(feature = "functions")]
                    Self::UserFunctionError(ref err) => Some(&**err),

                    Self::FromSqlConversionFailure(_, _, ref err)
                    | Self::ToSqlConversionFailure(ref err) => Some(&**err),

                    #[cfg(feature = "vtab")]
                    Self::ModuleError(_) => None,

                    Self::UnwindingPanic => None,

                    #[cfg(feature = "functions")]
                    Self::GetAuxWrongType => None,

                    #[cfg(feature = "blob")]
                    Self::BlobSizeError => None,
                    #[cfg(feature = "modern_sqlite")]
                    Self::SqlInputError { ref error, .. } => Some(error),
                    #[cfg(feature = "loadable_extension")]
                    Self::InitError(ref err) => Some(err),
                    #[cfg(feature = "modern_sqlite")]
                    Self::InvalidDatabaseIndex(_) => None,
                }
            }
        }

        impl Error {
            /// Returns the underlying SQLite error if this is [`Error::SqliteFailure`].
            #[inline]
            #[must_use]
            pub fn sqlite_error(&self) -> Option<&ffi::Error> {
                match self {
                    Self::SqliteFailure(error, _) => Some(error),
                    _ => None,
                }
            }

            /// Returns the underlying SQLite error code if this is
            /// [`Error::SqliteFailure`].
            #[inline]
            #[must_use]
            pub fn sqlite_error_code(&self) -> Option<ffi::ErrorCode> {
                self.sqlite_error().map(|error| error.code)
            }
        }

        // These are public but not re-exported by lib.rs, so only visible within crate.

        #[cold]
        pub fn error_from_sqlite_code(code: c_int, message: Option<String>) -> Error {
            Error::SqliteFailure(ffi::Error::new(code), message)
        }

        macro_rules! err {
            ($code:expr $(,)?) => {
                $crate::error::error_from_sqlite_code($code, None)
            };
            ($code:expr, $msg:literal $(,)?) => {
                $crate::error::error_from_sqlite_code($code, Some(format!($msg)))
            };
            ($code:expr, $err:expr $(,)?) => {
                $crate::error::error_from_sqlite_code($code, Some(format!($err)))
            };
            ($code:expr, $fmt:expr, $($arg:tt)*) => {
                $crate::error::error_from_sqlite_code($code, Some(format!($fmt, $($arg)*)))
            };
        }

        #[cold]
        pub unsafe fn error_from_handle(db: *mut ffi::sqlite3, code: c_int) -> Error {
            error_from_sqlite_code(code, error_msg(db, code))
        }

        unsafe fn error_msg(db: *mut ffi::sqlite3, code: c_int) -> Option<String> {
            if db.is_null() || ffi::sqlite3_errcode(db) != code {
                let err_str = ffi::sqlite3_errstr(code);
                if err_str.is_null() {
                    None
                } else {
                    Some(errmsg_to_string(err_str))
                }
            } else {
                Some(errmsg_to_string(ffi::sqlite3_errmsg(db)))
            }
        }

        pub unsafe fn decode_result_raw(db: *mut ffi::sqlite3, code: c_int) -> Result<()> {
            if code == ffi::SQLITE_OK {
                Ok(())
            } else {
                Err(error_from_handle(db, code))
            }
        }

        #[cold]
        #[cfg(not(feature = "modern_sqlite"))] // SQLite >= 3.38.0
        pub unsafe fn error_with_offset(db: *mut ffi::sqlite3, code: c_int, _sql: &str) -> Error {
            error_from_handle(db, code)
        }

        #[cold]
        #[cfg(feature = "modern_sqlite")] // SQLite >= 3.38.0
        pub unsafe fn error_with_offset(db: *mut ffi::sqlite3, code: c_int, sql: &str) -> Error {
            if db.is_null() {
                error_from_sqlite_code(code, None)
            } else {
                let error = ffi::Error::new(code);
                let msg = error_msg(db, code);
                if ffi::ErrorCode::Unknown == error.code {
                    let offset = ffi::sqlite3_error_offset(db);
                    if offset >= 0 {
                        return Error::SqlInputError {
                            error,
                            msg: msg.unwrap_or("error".to_owned()),
                            sql: sql.to_owned(),
                            offset,
                        };
                    }
                }
                Error::SqliteFailure(error, msg)
            }
        }

        pub fn check(code: c_int) -> Result<()> {
            if code != ffi::SQLITE_OK {
                Err(error_from_sqlite_code(code, None))
            } else {
                Ok(())
            }
        }

        /// Transform Rust error to SQLite error (message and code).
        /// # Safety
        /// This function is unsafe because it uses raw pointer
        pub unsafe fn to_sqlite_error(e: &Error, err_msg: *mut *mut c_char) -> c_int {
            use crate::util::alloc;
            match e {
                Error::SqliteFailure(err, s) => {
                    if let Some(s) = s {
                        *err_msg = alloc(s);
                    }
                    err.extended_code
                }
                err => {
                    *err_msg = alloc(&err.to_string());
                    ffi::SQLITE_ERROR
                }
            }
        }
    }
}

pub mod foreign
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
    pub mod shared
    {
        /*!
        An internal crate used by foreign-types */
        use ::
        {
            cell::{ UnsafeCell },
            *,
        };
        /*
        */
        /// An opaque type used to define `ForeignTypeRef` types.
        pub struct Opaque( UnsafeCell<()> );
        /// A trait implemented by types which reference borrowed foreign types.
        pub trait ForeignTypeRef:Sized
        {
            /// The raw C type.
            type CType;
            /// Constructs a shared instance of this type from its raw type.
            #[inline] unsafe fn from_ptr<'a>(ptr: *mut Self::CType) -> &'a Self
            {
                &*(ptr as *mut _)
            }
            /// Constructs a mutable reference of this type from its raw type.
            #[inline] unsafe fn from_ptr_mut<'a>(ptr: *mut Self::CType) -> &'a mut Self
            {
                &mut *(ptr as *mut _)
            }
            /// Returns a raw pointer to the wrapped value.
            #[inline] fn as_ptr(&self) -> *mut Self::CType
            {
                self as *const _ as *mut _
            }
        }
        /// A type implemented by wrappers over foreign types.
        pub trait ForeignType:Sized
        {
            /// The raw C type.
            type CType;
            /// The type representing a reference to this type.
            type Ref: ForeignTypeRef<CType = Self::CType>;
            /// Constructs an instance of this type from its raw type.
            unsafe fn from_ptr(ptr: *mut Self::CType) -> Self;
            /// Returns a raw pointer to the wrapped value.
            fn as_ptr(&self) -> *mut Self::CType;
        }

    }
    /*
    */
    pub mod types
    {
        /*!
        A framework for Rust wrappers over C APIs. */
        use ::
        {
            foreign::shared::{ self, * },
            *,
        };
        /*
        */
        /// A macro to easily define wrappers for foreign types.
        #[macro_export] macro_rules! foreign_type
        {
            (
                $(#[$impl_attr:meta])*
                type CType = $ctype:ty;
                fn drop = $drop:expr;
                $(fn clone = $clone:expr;)*
                $(#[$owned_attr:meta])*
                pub struct $owned:ident;
                $(#[$borrowed_attr:meta])*
                pub struct $borrowed:ident;
            ) =>
            {
                $(#[$owned_attr])*
                pub struct $owned(*mut $ctype);

                $(#[$impl_attr])*
                impl ::foreign::types::ForeignType for $owned
                {
                    type CType = $ctype;
                    type Ref = $borrowed;
                    #[inline] unsafe fn from_ptr(ptr: *mut $ctype) -> $owned 
                    {
                        $owned(ptr)
                    }

                    #[inline] fn as_ptr(&self) -> *mut $ctype
                    {
                        self.0
                    }
                }

                impl Drop for $owned
                {
                    #[inline] fn drop(&mut self) { unsafe { $drop(self.0) } }
                }

                $(
                    impl Clone for $owned
                    {
                        #[inline] fn clone(&self) -> $owned
                        {
                            unsafe
                            {
                                let handle: *mut $ctype = $clone(self.0);
                                ::foreign::types::ForeignType::from_ptr( handle )
                            }
                        }
                    }

                    impl ::borrow::ToOwned for $borrowed 
                    {
                        type Owned = $owned;
                        #[inline] fn to_owned(&self) -> $owned
                        {
                            unsafe
                            {
                                let handle: *mut $ctype = $clone( ::foreign::types::ForeignTypeRef::as_ptr( self ) );
                                ::foreign::types::ForeignType::from_ptr( handle )
                            }
                        }
                    }
                )*

                impl ::ops::Deref for $owned
                {
                    type Target = $borrowed;
                    #[inline] fn deref(&self) -> &$borrowed
                    {
                        unsafe { ::foreign::types::ForeignTypeRef::from_ptr(self.0) }
                    }
                }

                impl ::ops::DerefMut for $owned
                {
                    #[inline] fn deref_mut(&mut self) -> &mut $borrowed
                    {
                        unsafe { ::foreign::types::ForeignTypeRef::from_ptr_mut(self.0) }
                    }
                }

                impl ::borrow::Borrow<$borrowed> for $owned
                {
                    #[inline] fn borrow(&self) -> &$borrowed { &**self }
                }

                impl ::convert::AsRef<$borrowed> for $owned
                {
                    #[inline] fn as_ref(&self) -> &$borrowed { &**self }
                }

                $(#[$borrowed_attr])*
                pub struct $borrowed($crate::Opaque);

                $(#[$impl_attr])*
                impl ::foreign::types::ForeignTypeRef for $borrowed
                {
                    type CType = $ctype;
                }
            }
        }
    }
}

pub mod ffi
{
    pub use std::ffi::{ * };
}

pub mod fmt
{
    pub use std::fmt::{ * };
}

pub mod hash
{
    pub use std::hash::{ * };
}

pub mod io
{
    pub use std::io::{ * };
}

pub mod marker
{
    pub use std::marker::{ * };
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod ops
{
    pub use std::ops::{ * };
}

pub mod os
{
    pub use std::os::{ * };
}

pub mod option
{
    pub use std::option::{ * };
}

pub mod path
{
    pub use std::path::{ * };
}

pub mod process
{
    pub use std::process::{ * };
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod result
{
    pub use std::result::{ * };
}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod str
{
    pub use std::str::{ * };
}

pub mod string
{
    pub use std::string::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };
}

pub mod system
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
    pub mod libsqlite3
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        #![expect(non_snake_case, non_camel_case_types)]

        // force linking to openssl
        #[cfg(feature = "bundled-sqlcipher-vendored-openssl")]
        extern crate openssl_sys;

        pub use self::error::*;

        use std::mem;

        mod error;
        */
        pub use ::error::libsqlite3::*;

        #[must_use] pub fn SQLITE_STATIC() -> sqlite3_destructor_type { None }

        #[must_use] pub fn SQLITE_TRANSIENT() -> sqlite3_destructor_type 
        {
            Some(unsafe { mem::transmute::<isize, unsafe extern "C" fn(*mut ffi::c_void)>(-1_isize) })
        }
        
        mod bindings
        {
            /*!
             automatically generated by rust-bindgen 0.71.1 */
            use ::
            {
                *,
            };
            /*
            */
            extern "C"
            {
                pub fn sqlite3_auto_extension
                
                (
                    xEntryPoint: option::Option
                    <
                        unsafe extern "C" fn
                        (
                            db: *mut sqlite3,
                            pzErrMsg: *mut *mut os::raw::c_char,
                            _: *const sqlite3_api_routines,
                        ) -> os::raw::c_int,
                    >,
                ) -> os::raw::c_int;
                
                pub fn sqlite3_cancel_auto_extension
                
                (
                    xEntryPoint: option::Option
                    <
                        unsafe extern "C" fn
                        (
                            db: *mut sqlite3,
                            pzErrMsg: *mut *mut os::raw::c_char,
                            _: *const sqlite3_api_routines,
                        ) -> os::raw::c_int,
                    >,
                ) -> os::raw::c_int;
            }

            //pub const SQLITE_VERSION: &ffi::CStr = r#"3.14.0"#;
            //pub const SQLITE_SOURCE_ID: &ffi::CStr = r#"2016-08-08 13:40:27 d5e98057028abcf7217d0d2b2e29bbbcdf09d6de"#;
            pub const SQLITE_VERSION_NUMBER: i32 = 3014000;            
            pub const SQLITE_OK: i32 = 0;
            pub const SQLITE_ERROR: i32 = 1;
            pub const SQLITE_INTERNAL: i32 = 2;
            pub const SQLITE_PERM: i32 = 3;
            pub const SQLITE_ABORT: i32 = 4;
            pub const SQLITE_BUSY: i32 = 5;
            pub const SQLITE_LOCKED: i32 = 6;
            pub const SQLITE_NOMEM: i32 = 7;
            pub const SQLITE_READONLY: i32 = 8;
            pub const SQLITE_INTERRUPT: i32 = 9;
            pub const SQLITE_IOERR: i32 = 10;
            pub const SQLITE_CORRUPT: i32 = 11;
            pub const SQLITE_NOTFOUND: i32 = 12;
            pub const SQLITE_FULL: i32 = 13;
            pub const SQLITE_CANTOPEN: i32 = 14;
            pub const SQLITE_PROTOCOL: i32 = 15;
            pub const SQLITE_EMPTY: i32 = 16;
            pub const SQLITE_SCHEMA: i32 = 17;
            pub const SQLITE_TOOBIG: i32 = 18;
            pub const SQLITE_CONSTRAINT: i32 = 19;
            pub const SQLITE_MISMATCH: i32 = 20;
            pub const SQLITE_MISUSE: i32 = 21;
            pub const SQLITE_NOLFS: i32 = 22;
            pub const SQLITE_AUTH: i32 = 23;
            pub const SQLITE_FORMAT: i32 = 24;
            pub const SQLITE_RANGE: i32 = 25;
            pub const SQLITE_NOTADB: i32 = 26;
            pub const SQLITE_NOTICE: i32 = 27;
            pub const SQLITE_WARNING: i32 = 28;
            pub const SQLITE_ROW: i32 = 100;
            pub const SQLITE_DONE: i32 = 101;
            pub const SQLITE_IOERR_READ: i32 = 266;
            pub const SQLITE_IOERR_SHORT_READ: i32 = 522;
            pub const SQLITE_IOERR_WRITE: i32 = 778;
            pub const SQLITE_IOERR_FSYNC: i32 = 1034;
            pub const SQLITE_IOERR_DIR_FSYNC: i32 = 1290;
            pub const SQLITE_IOERR_TRUNCATE: i32 = 1546;
            pub const SQLITE_IOERR_FSTAT: i32 = 1802;
            pub const SQLITE_IOERR_UNLOCK: i32 = 2058;
            pub const SQLITE_IOERR_RDLOCK: i32 = 2314;
            pub const SQLITE_IOERR_DELETE: i32 = 2570;
            pub const SQLITE_IOERR_BLOCKED: i32 = 2826;
            pub const SQLITE_IOERR_NOMEM: i32 = 3082;
            pub const SQLITE_IOERR_ACCESS: i32 = 3338;
            pub const SQLITE_IOERR_CHECKRESERVEDLOCK: i32 = 3594;
            pub const SQLITE_IOERR_LOCK: i32 = 3850;
            pub const SQLITE_IOERR_CLOSE: i32 = 4106;
            pub const SQLITE_IOERR_DIR_CLOSE: i32 = 4362;
            pub const SQLITE_IOERR_SHMOPEN: i32 = 4618;
            pub const SQLITE_IOERR_SHMSIZE: i32 = 4874;
            pub const SQLITE_IOERR_SHMLOCK: i32 = 5130;
            pub const SQLITE_IOERR_SHMMAP: i32 = 5386;
            pub const SQLITE_IOERR_SEEK: i32 = 5642;
            pub const SQLITE_IOERR_DELETE_NOENT: i32 = 5898;
            pub const SQLITE_IOERR_MMAP: i32 = 6154;
            pub const SQLITE_IOERR_GETTEMPPATH: i32 = 6410;
            pub const SQLITE_IOERR_CONVPATH: i32 = 6666;
            pub const SQLITE_IOERR_VNODE: i32 = 6922;
            pub const SQLITE_IOERR_AUTH: i32 = 7178;
            pub const SQLITE_LOCKED_SHAREDCACHE: i32 = 262;
            pub const SQLITE_BUSY_RECOVERY: i32 = 261;
            pub const SQLITE_BUSY_SNAPSHOT: i32 = 517;
            pub const SQLITE_CANTOPEN_NOTEMPDIR: i32 = 270;
            pub const SQLITE_CANTOPEN_ISDIR: i32 = 526;
            pub const SQLITE_CANTOPEN_FULLPATH: i32 = 782;
            pub const SQLITE_CANTOPEN_CONVPATH: i32 = 1038;
            pub const SQLITE_CORRUPT_VTAB: i32 = 267;
            pub const SQLITE_READONLY_RECOVERY: i32 = 264;
            pub const SQLITE_READONLY_CANTLOCK: i32 = 520;
            pub const SQLITE_READONLY_ROLLBACK: i32 = 776;
            pub const SQLITE_READONLY_DBMOVED: i32 = 1032;
            pub const SQLITE_ABORT_ROLLBACK: i32 = 516;
            pub const SQLITE_CONSTRAINT_CHECK: i32 = 275;
            pub const SQLITE_CONSTRAINT_COMMITHOOK: i32 = 531;
            pub const SQLITE_CONSTRAINT_FOREIGNKEY: i32 = 787;
            pub const SQLITE_CONSTRAINT_FUNCTION: i32 = 1043;
            pub const SQLITE_CONSTRAINT_NOTNULL: i32 = 1299;
            pub const SQLITE_CONSTRAINT_PRIMARYKEY: i32 = 1555;
            pub const SQLITE_CONSTRAINT_TRIGGER: i32 = 1811;
            pub const SQLITE_CONSTRAINT_UNIQUE: i32 = 2067;
            pub const SQLITE_CONSTRAINT_VTAB: i32 = 2323;
            pub const SQLITE_CONSTRAINT_ROWID: i32 = 2579;
            pub const SQLITE_NOTICE_RECOVER_WAL: i32 = 283;
            pub const SQLITE_NOTICE_RECOVER_ROLLBACK: i32 = 539;
            pub const SQLITE_WARNING_AUTOINDEX: i32 = 284;
            pub const SQLITE_AUTH_USER: i32 = 279;
            pub const SQLITE_OK_LOAD_PERMANENTLY: i32 = 256;
            pub const SQLITE_OPEN_READONLY: i32 = 1;
            pub const SQLITE_OPEN_READWRITE: i32 = 2;
            pub const SQLITE_OPEN_CREATE: i32 = 4;
            pub const SQLITE_OPEN_DELETEONCLOSE: i32 = 8;
            pub const SQLITE_OPEN_EXCLUSIVE: i32 = 16;
            pub const SQLITE_OPEN_AUTOPROXY: i32 = 32;
            pub const SQLITE_OPEN_URI: i32 = 64;
            pub const SQLITE_OPEN_MEMORY: i32 = 128;
            pub const SQLITE_OPEN_MAIN_DB: i32 = 256;
            pub const SQLITE_OPEN_TEMP_DB: i32 = 512;
            pub const SQLITE_OPEN_TRANSIENT_DB: i32 = 1024;
            pub const SQLITE_OPEN_MAIN_JOURNAL: i32 = 2048;
            pub const SQLITE_OPEN_TEMP_JOURNAL: i32 = 4096;
            pub const SQLITE_OPEN_SUBJOURNAL: i32 = 8192;
            pub const SQLITE_OPEN_MASTER_JOURNAL: i32 = 16384;
            pub const SQLITE_OPEN_NOMUTEX: i32 = 32768;
            pub const SQLITE_OPEN_FULLMUTEX: i32 = 65536;
            pub const SQLITE_OPEN_SHAREDCACHE: i32 = 131072;
            pub const SQLITE_OPEN_PRIVATECACHE: i32 = 262144;
            pub const SQLITE_OPEN_WAL: i32 = 524288;
            pub const SQLITE_IOCAP_ATOMIC: i32 = 1;
            pub const SQLITE_IOCAP_ATOMIC512: i32 = 2;
            pub const SQLITE_IOCAP_ATOMIC1K: i32 = 4;
            pub const SQLITE_IOCAP_ATOMIC2K: i32 = 8;
            pub const SQLITE_IOCAP_ATOMIC4K: i32 = 16;
            pub const SQLITE_IOCAP_ATOMIC8K: i32 = 32;
            pub const SQLITE_IOCAP_ATOMIC16K: i32 = 64;
            pub const SQLITE_IOCAP_ATOMIC32K: i32 = 128;
            pub const SQLITE_IOCAP_ATOMIC64K: i32 = 256;
            pub const SQLITE_IOCAP_SAFE_APPEND: i32 = 512;
            pub const SQLITE_IOCAP_SEQUENTIAL: i32 = 1024;
            pub const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN: i32 = 2048;
            pub const SQLITE_IOCAP_POWERSAFE_OVERWRITE: i32 = 4096;
            pub const SQLITE_IOCAP_IMMUTABLE: i32 = 8192;
            pub const SQLITE_LOCK_NONE: i32 = 0;
            pub const SQLITE_LOCK_SHARED: i32 = 1;
            pub const SQLITE_LOCK_RESERVED: i32 = 2;
            pub const SQLITE_LOCK_PENDING: i32 = 3;
            pub const SQLITE_LOCK_EXCLUSIVE: i32 = 4;
            pub const SQLITE_SYNC_NORMAL: i32 = 2;
            pub const SQLITE_SYNC_FULL: i32 = 3;
            pub const SQLITE_SYNC_DATAONLY: i32 = 16;
            pub const SQLITE_FCNTL_LOCKSTATE: i32 = 1;
            pub const SQLITE_FCNTL_GET_LOCKPROXYFILE: i32 = 2;
            pub const SQLITE_FCNTL_SET_LOCKPROXYFILE: i32 = 3;
            pub const SQLITE_FCNTL_LAST_ERRNO: i32 = 4;
            pub const SQLITE_FCNTL_SIZE_HINT: i32 = 5;
            pub const SQLITE_FCNTL_CHUNK_SIZE: i32 = 6;
            pub const SQLITE_FCNTL_FILE_POINTER: i32 = 7;
            pub const SQLITE_FCNTL_SYNC_OMITTED: i32 = 8;
            pub const SQLITE_FCNTL_WIN32_AV_RETRY: i32 = 9;
            pub const SQLITE_FCNTL_PERSIST_WAL: i32 = 10;
            pub const SQLITE_FCNTL_OVERWRITE: i32 = 11;
            pub const SQLITE_FCNTL_VFSNAME: i32 = 12;
            pub const SQLITE_FCNTL_POWERSAFE_OVERWRITE: i32 = 13;
            pub const SQLITE_FCNTL_PRAGMA: i32 = 14;
            pub const SQLITE_FCNTL_BUSYHANDLER: i32 = 15;
            pub const SQLITE_FCNTL_TEMPFILENAME: i32 = 16;
            pub const SQLITE_FCNTL_MMAP_SIZE: i32 = 18;
            pub const SQLITE_FCNTL_TRACE: i32 = 19;
            pub const SQLITE_FCNTL_HAS_MOVED: i32 = 20;
            pub const SQLITE_FCNTL_SYNC: i32 = 21;
            pub const SQLITE_FCNTL_COMMIT_PHASETWO: i32 = 22;
            pub const SQLITE_FCNTL_WIN32_SET_HANDLE: i32 = 23;
            pub const SQLITE_FCNTL_WAL_BLOCK: i32 = 24;
            pub const SQLITE_FCNTL_ZIPVFS: i32 = 25;
            pub const SQLITE_FCNTL_RBU: i32 = 26;
            pub const SQLITE_FCNTL_VFS_POINTER: i32 = 27;
            pub const SQLITE_FCNTL_JOURNAL_POINTER: i32 = 28;
            pub const SQLITE_GET_LOCKPROXYFILE: i32 = 2;
            pub const SQLITE_SET_LOCKPROXYFILE: i32 = 3;
            pub const SQLITE_LAST_ERRNO: i32 = 4;
            pub const SQLITE_ACCESS_EXISTS: i32 = 0;
            pub const SQLITE_ACCESS_READWRITE: i32 = 1;
            pub const SQLITE_ACCESS_READ: i32 = 2;
            pub const SQLITE_SHM_UNLOCK: i32 = 1;
            pub const SQLITE_SHM_LOCK: i32 = 2;
            pub const SQLITE_SHM_SHARED: i32 = 4;
            pub const SQLITE_SHM_EXCLUSIVE: i32 = 8;
            pub const SQLITE_SHM_NLOCK: i32 = 8;
            pub const SQLITE_CONFIG_SINGLETHREAD: i32 = 1;
            pub const SQLITE_CONFIG_MULTITHREAD: i32 = 2;
            pub const SQLITE_CONFIG_SERIALIZED: i32 = 3;
            pub const SQLITE_CONFIG_MALLOC: i32 = 4;
            pub const SQLITE_CONFIG_GETMALLOC: i32 = 5;
            pub const SQLITE_CONFIG_SCRATCH: i32 = 6;
            pub const SQLITE_CONFIG_PAGECACHE: i32 = 7;
            pub const SQLITE_CONFIG_HEAP: i32 = 8;
            pub const SQLITE_CONFIG_MEMSTATUS: i32 = 9;
            pub const SQLITE_CONFIG_MUTEX: i32 = 10;
            pub const SQLITE_CONFIG_GETMUTEX: i32 = 11;
            pub const SQLITE_CONFIG_LOOKASIDE: i32 = 13;
            pub const SQLITE_CONFIG_PCACHE: i32 = 14;
            pub const SQLITE_CONFIG_GETPCACHE: i32 = 15;
            pub const SQLITE_CONFIG_LOG: i32 = 16;
            pub const SQLITE_CONFIG_URI: i32 = 17;
            pub const SQLITE_CONFIG_PCACHE2: i32 = 18;
            pub const SQLITE_CONFIG_GETPCACHE2: i32 = 19;
            pub const SQLITE_CONFIG_COVERING_INDEX_SCAN: i32 = 20;
            pub const SQLITE_CONFIG_SQLLOG: i32 = 21;
            pub const SQLITE_CONFIG_MMAP_SIZE: i32 = 22;
            pub const SQLITE_CONFIG_WIN32_HEAPSIZE: i32 = 23;
            pub const SQLITE_CONFIG_PCACHE_HDRSZ: i32 = 24;
            pub const SQLITE_CONFIG_PMASZ: i32 = 25;
            pub const SQLITE_CONFIG_STMTJRNL_SPILL: i32 = 26;
            pub const SQLITE_DBCONFIG_LOOKASIDE: i32 = 1001;
            pub const SQLITE_DBCONFIG_ENABLE_FKEY: i32 = 1002;
            pub const SQLITE_DBCONFIG_ENABLE_TRIGGER: i32 = 1003;
            pub const SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER: i32 = 1004;
            pub const SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION: i32 = 1005;
            pub const SQLITE_DENY: i32 = 1;
            pub const SQLITE_IGNORE: i32 = 2;
            pub const SQLITE_CREATE_INDEX: i32 = 1;
            pub const SQLITE_CREATE_TABLE: i32 = 2;
            pub const SQLITE_CREATE_TEMP_INDEX: i32 = 3;
            pub const SQLITE_CREATE_TEMP_TABLE: i32 = 4;
            pub const SQLITE_CREATE_TEMP_TRIGGER: i32 = 5;
            pub const SQLITE_CREATE_TEMP_VIEW: i32 = 6;
            pub const SQLITE_CREATE_TRIGGER: i32 = 7;
            pub const SQLITE_CREATE_VIEW: i32 = 8;
            pub const SQLITE_DELETE: i32 = 9;
            pub const SQLITE_DROP_INDEX: i32 = 10;
            pub const SQLITE_DROP_TABLE: i32 = 11;
            pub const SQLITE_DROP_TEMP_INDEX: i32 = 12;
            pub const SQLITE_DROP_TEMP_TABLE: i32 = 13;
            pub const SQLITE_DROP_TEMP_TRIGGER: i32 = 14;
            pub const SQLITE_DROP_TEMP_VIEW: i32 = 15;
            pub const SQLITE_DROP_TRIGGER: i32 = 16;
            pub const SQLITE_DROP_VIEW: i32 = 17;
            pub const SQLITE_INSERT: i32 = 18;
            pub const SQLITE_PRAGMA: i32 = 19;
            pub const SQLITE_READ: i32 = 20;
            pub const SQLITE_SELECT: i32 = 21;
            pub const SQLITE_TRANSACTION: i32 = 22;
            pub const SQLITE_UPDATE: i32 = 23;
            pub const SQLITE_ATTACH: i32 = 24;
            pub const SQLITE_DETACH: i32 = 25;
            pub const SQLITE_ALTER_TABLE: i32 = 26;
            pub const SQLITE_REINDEX: i32 = 27;
            pub const SQLITE_ANALYZE: i32 = 28;
            pub const SQLITE_CREATE_VTABLE: i32 = 29;
            pub const SQLITE_DROP_VTABLE: i32 = 30;
            pub const SQLITE_FUNCTION: i32 = 31;
            pub const SQLITE_SAVEPOINT: i32 = 32;
            pub const SQLITE_COPY: i32 = 0;
            pub const SQLITE_RECURSIVE: i32 = 33;
            pub const SQLITE_TRACE_STMT: os::raw::c_uint = 1;
            pub const SQLITE_TRACE_PROFILE: os::raw::c_uint = 2;
            pub const SQLITE_TRACE_ROW: os::raw::c_uint = 4;
            pub const SQLITE_TRACE_CLOSE: os::raw::c_uint = 8;
            pub const SQLITE_LIMIT_LENGTH: i32 = 0;
            pub const SQLITE_LIMIT_SQL_LENGTH: i32 = 1;
            pub const SQLITE_LIMIT_COLUMN: i32 = 2;
            pub const SQLITE_LIMIT_EXPR_DEPTH: i32 = 3;
            pub const SQLITE_LIMIT_COMPOUND_SELECT: i32 = 4;
            pub const SQLITE_LIMIT_VDBE_OP: i32 = 5;
            pub const SQLITE_LIMIT_FUNCTION_ARG: i32 = 6;
            pub const SQLITE_LIMIT_ATTACHED: i32 = 7;
            pub const SQLITE_LIMIT_LIKE_PATTERN_LENGTH: i32 = 8;
            pub const SQLITE_LIMIT_VARIABLE_NUMBER: i32 = 9;
            pub const SQLITE_LIMIT_TRIGGER_DEPTH: i32 = 10;
            pub const SQLITE_LIMIT_WORKER_THREADS: i32 = 11;
            pub const SQLITE_INTEGER: i32 = 1;
            pub const SQLITE_FLOAT: i32 = 2;
            pub const SQLITE_BLOB: i32 = 4;
            pub const SQLITE_NULL: i32 = 5;
            pub const SQLITE_TEXT: i32 = 3;
            pub const SQLITE3_TEXT: i32 = 3;
            pub const SQLITE_UTF8: i32 = 1;
            pub const SQLITE_UTF16LE: i32 = 2;
            pub const SQLITE_UTF16BE: i32 = 3;
            pub const SQLITE_UTF16: i32 = 4;
            pub const SQLITE_ANY: i32 = 5;
            pub const SQLITE_UTF16_ALIGNED: i32 = 8;
            pub const SQLITE_DETERMINISTIC: i32 = 2048;
            pub const SQLITE_INDEX_SCAN_UNIQUE: i32 = 1;
            pub const SQLITE_INDEX_CONSTRAINT_EQ: i32 = 2;
            pub const SQLITE_INDEX_CONSTRAINT_GT: i32 = 4;
            pub const SQLITE_INDEX_CONSTRAINT_LE: i32 = 8;
            pub const SQLITE_INDEX_CONSTRAINT_LT: i32 = 16;
            pub const SQLITE_INDEX_CONSTRAINT_GE: i32 = 32;
            pub const SQLITE_INDEX_CONSTRAINT_MATCH: i32 = 64;
            pub const SQLITE_INDEX_CONSTRAINT_LIKE: i32 = 65;
            pub const SQLITE_INDEX_CONSTRAINT_GLOB: i32 = 66;
            pub const SQLITE_INDEX_CONSTRAINT_REGEXP: i32 = 67;
            pub const SQLITE_MUTEX_FAST: i32 = 0;
            pub const SQLITE_MUTEX_RECURSIVE: i32 = 1;
            pub const SQLITE_MUTEX_STATIC_MASTER: i32 = 2;
            pub const SQLITE_MUTEX_STATIC_MEM: i32 = 3;
            pub const SQLITE_MUTEX_STATIC_MEM2: i32 = 4;
            pub const SQLITE_MUTEX_STATIC_OPEN: i32 = 4;
            pub const SQLITE_MUTEX_STATIC_PRNG: i32 = 5;
            pub const SQLITE_MUTEX_STATIC_LRU: i32 = 6;
            pub const SQLITE_MUTEX_STATIC_LRU2: i32 = 7;
            pub const SQLITE_MUTEX_STATIC_PMEM: i32 = 7;
            pub const SQLITE_MUTEX_STATIC_APP1: i32 = 8;
            pub const SQLITE_MUTEX_STATIC_APP2: i32 = 9;
            pub const SQLITE_MUTEX_STATIC_APP3: i32 = 10;
            pub const SQLITE_MUTEX_STATIC_VFS1: i32 = 11;
            pub const SQLITE_MUTEX_STATIC_VFS2: i32 = 12;
            pub const SQLITE_MUTEX_STATIC_VFS3: i32 = 13;
            pub const SQLITE_TESTCTRL_FIRST: i32 = 5;
            pub const SQLITE_TESTCTRL_PRNG_SAVE: i32 = 5;
            pub const SQLITE_TESTCTRL_PRNG_RESTORE: i32 = 6;
            pub const SQLITE_TESTCTRL_PRNG_RESET: i32 = 7;
            pub const SQLITE_TESTCTRL_BITVEC_TEST: i32 = 8;
            pub const SQLITE_TESTCTRL_FAULT_INSTALL: i32 = 9;
            pub const SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: i32 = 10;
            pub const SQLITE_TESTCTRL_PENDING_BYTE: i32 = 11;
            pub const SQLITE_TESTCTRL_ASSERT: i32 = 12;
            pub const SQLITE_TESTCTRL_ALWAYS: i32 = 13;
            pub const SQLITE_TESTCTRL_RESERVE: i32 = 14;
            pub const SQLITE_TESTCTRL_OPTIMIZATIONS: i32 = 15;
            pub const SQLITE_TESTCTRL_ISKEYWORD: i32 = 16;
            pub const SQLITE_TESTCTRL_SCRATCHMALLOC: i32 = 17;
            pub const SQLITE_TESTCTRL_LOCALTIME_FAULT: i32 = 18;
            pub const SQLITE_TESTCTRL_EXPLAIN_STMT: i32 = 19;
            pub const SQLITE_TESTCTRL_NEVER_CORRUPT: i32 = 20;
            pub const SQLITE_TESTCTRL_VDBE_COVERAGE: i32 = 21;
            pub const SQLITE_TESTCTRL_BYTEORDER: i32 = 22;
            pub const SQLITE_TESTCTRL_ISINIT: i32 = 23;
            pub const SQLITE_TESTCTRL_SORTER_MMAP: i32 = 24;
            pub const SQLITE_TESTCTRL_IMPOSTER: i32 = 25;
            pub const SQLITE_TESTCTRL_LAST: i32 = 25;
            pub const SQLITE_STATUS_MEMORY_USED: i32 = 0;
            pub const SQLITE_STATUS_PAGECACHE_USED: i32 = 1;
            pub const SQLITE_STATUS_PAGECACHE_OVERFLOW: i32 = 2;
            pub const SQLITE_STATUS_SCRATCH_USED: i32 = 3;
            pub const SQLITE_STATUS_SCRATCH_OVERFLOW: i32 = 4;
            pub const SQLITE_STATUS_MALLOC_SIZE: i32 = 5;
            pub const SQLITE_STATUS_PARSER_STACK: i32 = 6;
            pub const SQLITE_STATUS_PAGECACHE_SIZE: i32 = 7;
            pub const SQLITE_STATUS_SCRATCH_SIZE: i32 = 8;
            pub const SQLITE_STATUS_MALLOC_COUNT: i32 = 9;
            pub const SQLITE_DBSTATUS_LOOKASIDE_USED: i32 = 0;
            pub const SQLITE_DBSTATUS_CACHE_USED: i32 = 1;
            pub const SQLITE_DBSTATUS_SCHEMA_USED: i32 = 2;
            pub const SQLITE_DBSTATUS_STMT_USED: i32 = 3;
            pub const SQLITE_DBSTATUS_LOOKASIDE_HIT: i32 = 4;
            pub const SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE: i32 = 5;
            pub const SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: i32 = 6;
            pub const SQLITE_DBSTATUS_CACHE_HIT: i32 = 7;
            pub const SQLITE_DBSTATUS_CACHE_MISS: i32 = 8;
            pub const SQLITE_DBSTATUS_CACHE_WRITE: i32 = 9;
            pub const SQLITE_DBSTATUS_DEFERRED_FKS: i32 = 10;
            pub const SQLITE_DBSTATUS_CACHE_USED_SHARED: i32 = 11;
            pub const SQLITE_DBSTATUS_MAX: i32 = 11;
            pub const SQLITE_STMTSTATUS_FULLSCAN_STEP: i32 = 1;
            pub const SQLITE_STMTSTATUS_SORT: i32 = 2;
            pub const SQLITE_STMTSTATUS_AUTOINDEX: i32 = 3;
            pub const SQLITE_STMTSTATUS_VM_STEP: i32 = 4;
            pub const SQLITE_CHECKPOINT_PASSIVE: i32 = 0;
            pub const SQLITE_CHECKPOINT_FULL: i32 = 1;
            pub const SQLITE_CHECKPOINT_RESTART: i32 = 2;
            pub const SQLITE_CHECKPOINT_TRUNCATE: i32 = 3;
            pub const SQLITE_VTAB_CONSTRAINT_SUPPORT: i32 = 1;
            pub const SQLITE_ROLLBACK: i32 = 1;
            pub const SQLITE_FAIL: i32 = 3;
            pub const SQLITE_REPLACE: i32 = 5;
            pub const SQLITE_SCANSTAT_NLOOP: i32 = 0;
            pub const SQLITE_SCANSTAT_NVISIT: i32 = 1;
            pub const SQLITE_SCANSTAT_EST: i32 = 2;
            pub const SQLITE_SCANSTAT_NAME: i32 = 3;
            pub const SQLITE_SCANSTAT_EXPLAIN: i32 = 4;
            pub const SQLITE_SCANSTAT_SELECTID: i32 = 5;
            pub const NOT_WITHIN: i32 = 0;
            pub const PARTLY_WITHIN: i32 = 1;
            pub const FULLY_WITHIN: i32 = 2;
            pub const SQLITE_CHANGESET_DATA: i32 = 1;
            pub const SQLITE_CHANGESET_NOTFOUND: i32 = 2;
            pub const SQLITE_CHANGESET_CONFLICT: i32 = 3;
            pub const SQLITE_CHANGESET_CONSTRAINT: i32 = 4;
            pub const SQLITE_CHANGESET_FOREIGN_KEY: i32 = 5;
            pub const SQLITE_CHANGESET_OMIT: i32 = 0;
            pub const SQLITE_CHANGESET_REPLACE: i32 = 1;
            pub const SQLITE_CHANGESET_ABORT: i32 = 2;
            pub const FTS5_TOKENIZE_QUERY: i32 = 1;
            pub const FTS5_TOKENIZE_PREFIX: i32 = 2;
            pub const FTS5_TOKENIZE_DOCUMENT: i32 = 4;
            pub const FTS5_TOKENIZE_AUX: i32 = 8;
            pub const FTS5_TOKEN_COLOCATED: i32 = 1;
            
            
            pub type sqlite3_value = Mem;
            pub type sqlite3_rtree_dbl = f64;
            pub type sqlite_int64 = os::raw::c_longlong;
            pub type sqlite_uint64 = os::raw::c_ulonglong;
            pub type sqlite3_int64 = sqlite_int64;
            pub type sqlite3_uint64 = sqlite_uint64;            
            pub type sqlite3_syscall_ptr = option::Option<unsafe extern "C" fn()>;
            pub type sqlite3_destructor_type = option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>;
            
            pub type sqlite3_callback = option::Option
            <
                unsafe extern "C" fn
                
                (
                    arg1: *mut os::raw::c_void,
                    arg2: os::raw::c_int,
                    arg3: *mut *mut os::raw::c_char,
                    arg4: *mut *mut os::raw::c_char,
                ) -> os::raw::c_int,
            >;
            
            pub type fts5_extension_function = option::Option
            <
                unsafe extern "C" fn
                
                (
                    pApi: *const Fts5ExtensionApi,
                    pFts: *mut Fts5Context,
                    pCtx: *mut sqlite3_context,
                    nVal: os::raw::c_int,
                    apVal: *mut *mut sqlite3_value,
                ),
            >;

            unsafe extern "C"
            {
                pub static sqlite3_version: [os::raw::c_char; 0usize];
                pub fn sqlite3_libversion() -> *const os::raw::c_char;
                pub fn sqlite3_libversion_number() -> os::raw::c_int;
                pub fn sqlite3_sourceid() -> *const os::raw::c_char;                
                pub fn sqlite3_compileoption_used( zOptName: *const os::raw::c_char ) -> os::raw::c_int;
                pub fn sqlite3_compileoption_get(N: os::raw::c_int) -> *const os::raw::c_char;
                pub fn sqlite3_threadsafe() -> os::raw::c_int;
                pub fn sqlite3_close(arg1: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_exec
                
                (
                    arg1: *mut sqlite3,
                    sql: *const os::raw::c_char,
                    callback: option::Option
                    <
                        unsafe extern "C" fn
                        (
                            arg1: *mut os::raw::c_void,
                            arg2: os::raw::c_int,
                            arg3: *mut *mut os::raw::c_char,
                            arg4: *mut *mut os::raw::c_char,
                        ) -> os::raw::c_int,
                    >,
                    arg2: *mut os::raw::c_void,
                    errmsg: *mut *mut os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_initialize() -> os::raw::c_int;
                pub fn sqlite3_shutdown() -> os::raw::c_int;
                pub fn sqlite3_os_init() -> os::raw::c_int;
                pub fn sqlite3_os_end() -> os::raw::c_int;
                pub fn sqlite3_config(arg1: os::raw::c_int, ...) -> os::raw::c_int;
                pub fn sqlite3_db_config
                
                (
                    arg1: *mut sqlite3,
                    op: os::raw::c_int,
                    ...
                ) -> os::raw::c_int;
                pub fn sqlite3_extended_result_codes
                
                (
                    arg1: *mut sqlite3,
                    onoff: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_last_insert_rowid(arg1: *mut sqlite3) -> sqlite3_int64;
                pub fn sqlite3_changes(arg1: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_total_changes(arg1: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_interrupt(arg1: *mut sqlite3);
                pub fn sqlite3_complete(sql: *const os::raw::c_char) -> os::raw::c_int;
                pub fn sqlite3_busy_handler
                
                (
                    arg1: *mut sqlite3,
                    arg2: option::Option
                    <
                        unsafe extern "C" fn
                        (
                            arg1: *mut os::raw::c_void,
                            arg2: os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    arg3: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3_busy_timeout
                
                (
                    arg1: *mut sqlite3,
                    ms: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_get_table
                
                (
                    db: *mut sqlite3,
                    zSql: *const os::raw::c_char,
                    pazResult: *mut *mut *mut os::raw::c_char,
                    pnRow: *mut os::raw::c_int,
                    pnColumn: *mut os::raw::c_int,
                    pzErrmsg: *mut *mut os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_free_table(result: *mut *mut os::raw::c_char);
                pub fn sqlite3_mprintf(arg1: *const os::raw::c_char, ...) -> *mut os::raw::c_char;
                pub fn sqlite3_snprintf
                
                (
                    arg1: os::raw::c_int,
                    arg2: *mut os::raw::c_char,
                    arg3: *const os::raw::c_char,
                    ...
                ) -> *mut os::raw::c_char;
                pub fn sqlite3_malloc(arg1: os::raw::c_int) -> *mut os::raw::c_void;
                pub fn sqlite3_malloc64(arg1: sqlite3_uint64) -> *mut os::raw::c_void;
                pub fn sqlite3_realloc
                
                (
                    arg1: *mut os::raw::c_void,
                    arg2: os::raw::c_int,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_realloc64
                
                (
                    arg1: *mut os::raw::c_void,
                    arg2: sqlite3_uint64,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_free(arg1: *mut os::raw::c_void);
                pub fn sqlite3_msize(arg1: *mut os::raw::c_void) -> sqlite3_uint64;
                pub fn sqlite3_memory_used() -> sqlite3_int64;
                pub fn sqlite3_memory_highwater(resetFlag: os::raw::c_int) -> sqlite3_int64;
                pub fn sqlite3_randomness(N: os::raw::c_int, P: *mut os::raw::c_void);
                pub fn sqlite3_set_authorizer
                
                (
                    arg1: *mut sqlite3,
                    xAuth: option::Option
                    <
                        unsafe extern "C" fn
                        (
                            arg1: *mut os::raw::c_void,
                            arg2: os::raw::c_int,
                            arg3: *const os::raw::c_char,
                            arg4: *const os::raw::c_char,
                            arg5: *const os::raw::c_char,
                            arg6: *const os::raw::c_char,
                        ) -> os::raw::c_int,
                    >,
                    pUserData: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3_trace
                
                (
                    arg1: *mut sqlite3,
                    xTrace: option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut os::raw::c_void,
                            arg2: *const os::raw::c_char,
                        ),
                    >,
                    arg2: *mut os::raw::c_void,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_profile
                
                (
                    arg1: *mut sqlite3,
                    xProfile: option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut os::raw::c_void,
                            arg2: *const os::raw::c_char,
                            arg3: sqlite3_uint64,
                        ),
                    >,
                    arg2: *mut os::raw::c_void,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_trace_v2
                
                (
                    arg1: *mut sqlite3,
                    uMask: os::raw::c_uint,
                    xCallback: option::Option<
                        unsafe extern "C" fn(
                            arg1: os::raw::c_uint,
                            arg2: *mut os::raw::c_void,
                            arg3: *mut os::raw::c_void,
                            arg4: *mut os::raw::c_void,
                        ) -> os::raw::c_int,
                    >,
                    pCtx: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3_progress_handler
                
                (
                    arg1: *mut sqlite3,
                    arg2: os::raw::c_int,
                    arg3: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void) -> os::raw::c_int>,
                    arg4: *mut os::raw::c_void,
                );
                pub fn sqlite3_open
                (
                    filename: *const os::raw::c_char,
                    ppDb: *mut *mut sqlite3,
                ) -> os::raw::c_int;
                pub fn sqlite3_open_v2
                (
                    filename: *const os::raw::c_char,
                    ppDb: *mut *mut sqlite3,
                    flags: os::raw::c_int,
                    zVfs: *const os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_uri_parameter
                (
                    zFilename: *const os::raw::c_char,
                    zParam: *const os::raw::c_char,
                ) -> *const os::raw::c_char;
                pub fn sqlite3_uri_boolean
                (
                    zFile: *const os::raw::c_char,
                    zParam: *const os::raw::c_char,
                    bDefault: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_uri_int64( a1:*const os::raw::c_char, a2:*const os::raw::c_char, a3:sqlite3_int64 ) -> sqlite3_int64;
                pub fn sqlite3_errcode(db: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_extended_errcode(db: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_errmsg(arg1: *mut sqlite3) -> *const os::raw::c_char;
                pub fn sqlite3_errstr(arg1: os::raw::c_int) -> *const os::raw::c_char;
                pub fn sqlite3_limit
                
                (
                    arg1: *mut sqlite3,
                    id: os::raw::c_int,
                    newVal: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_prepare_v2
                
                (
                    db: *mut sqlite3,
                    zSql: *const os::raw::c_char,
                    nByte: os::raw::c_int,
                    ppStmt: *mut *mut sqlite3_stmt,
                    pzTail: *mut *const os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_blob
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                    arg3: *const os::raw::c_void,
                    n: os::raw::c_int,
                    arg4: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                ) -> os::raw::c_int;
                pub fn sqlite3_sql(pStmt: *mut sqlite3_stmt) -> *const os::raw::c_char;
                pub fn sqlite3_expanded_sql(pStmt: *mut sqlite3_stmt) -> *mut os::raw::c_char;
                pub fn sqlite3_stmt_readonly(pStmt: *mut sqlite3_stmt) -> os::raw::c_int;
                pub fn sqlite3_stmt_busy(arg1: *mut sqlite3_stmt) -> os::raw::c_int;
                pub fn sqlite3_bind_blob64
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                    arg3: *const os::raw::c_void,
                    arg4: sqlite3_uint64,
                    arg5: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_double
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                    arg3: f64,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_int
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                    arg3: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_int64
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                    arg3: sqlite3_int64,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_null
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_text
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                    arg3: *const os::raw::c_char,
                    arg4: os::raw::c_int,
                    arg5: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_text64
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                    arg3: *const os::raw::c_char,
                    arg4: sqlite3_uint64,
                    arg5: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                    encoding: os::raw::c_uchar,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_value
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                    arg3: *const sqlite3_value,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_zeroblob
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                    n: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_zeroblob64
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                    arg3: sqlite3_uint64,
                ) -> os::raw::c_int;
                pub fn sqlite3_bind_parameter_count(arg1: *mut sqlite3_stmt) -> os::raw::c_int;
                pub fn sqlite3_bind_parameter_name
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                ) -> *const os::raw::c_char;
                pub fn sqlite3_bind_parameter_index
                (
                    arg1: *mut sqlite3_stmt,
                    zName: *const os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_clear_bindings(arg1: *mut sqlite3_stmt) -> os::raw::c_int;
                pub fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -> os::raw::c_int;
                pub fn sqlite3_column_name
                (
                    arg1: *mut sqlite3_stmt,
                    N: os::raw::c_int,
                ) -> *const os::raw::c_char;
                pub fn sqlite3_column_database_name
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                ) -> *const os::raw::c_char;
                pub fn sqlite3_column_table_name
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                ) -> *const os::raw::c_char;
                pub fn sqlite3_column_origin_name
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                ) -> *const os::raw::c_char;
                pub fn sqlite3_column_decltype
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: os::raw::c_int,
                ) -> *const os::raw::c_char;
                pub fn sqlite3_step(arg1: *mut sqlite3_stmt) -> os::raw::c_int;
                pub fn sqlite3_data_count(pStmt: *mut sqlite3_stmt) -> os::raw::c_int;
                pub fn sqlite3_column_blob
                (
                    arg1: *mut sqlite3_stmt,
                    iCol: os::raw::c_int,
                ) -> *const os::raw::c_void;
                pub fn sqlite3_column_bytes
                (
                    arg1: *mut sqlite3_stmt,
                    iCol: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_column_double(arg1: *mut sqlite3_stmt, iCol: os::raw::c_int) -> f64;
                pub fn sqlite3_column_int
                (
                    arg1: *mut sqlite3_stmt,
                    iCol: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_column_int64
                (
                    arg1: *mut sqlite3_stmt,
                    iCol: os::raw::c_int,
                ) -> sqlite3_int64;
                pub fn sqlite3_column_text
                (
                    arg1: *mut sqlite3_stmt,
                    iCol: os::raw::c_int,
                ) -> *const os::raw::c_uchar;
                pub fn sqlite3_column_type
                (
                    arg1: *mut sqlite3_stmt,
                    iCol: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_column_value
                (
                    arg1: *mut sqlite3_stmt,
                    iCol: os::raw::c_int,
                ) -> *mut sqlite3_value;
                pub fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -> os::raw::c_int;
                pub fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -> os::raw::c_int;
                pub fn sqlite3_create_function_v2
                
                (
                    db: *mut sqlite3,
                    zFunctionName: *const os::raw::c_char,
                    nArg: os::raw::c_int,
                    eTextRep: os::raw::c_int,
                    pApp: *mut os::raw::c_void,
                    xFunc: option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut sqlite3_context,
                            arg2: os::raw::c_int,
                            arg3: *mut *mut sqlite3_value,
                        ),
                    >,
                    xStep: option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut sqlite3_context,
                            arg2: os::raw::c_int,
                            arg3: *mut *mut sqlite3_value,
                        ),
                    >,
                    xFinal: option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_context)>,
                    xDestroy: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                ) -> os::raw::c_int;
                pub fn sqlite3_aggregate_count(arg1: *mut sqlite3_context) -> os::raw::c_int;
                pub fn sqlite3_expired(arg1: *mut sqlite3_stmt) -> os::raw::c_int;
                pub fn sqlite3_transfer_bindings
                
                (
                    arg1: *mut sqlite3_stmt,
                    arg2: *mut sqlite3_stmt,
                ) -> os::raw::c_int;
                pub fn sqlite3_global_recover() -> os::raw::c_int;
                pub fn sqlite3_thread_cleanup();
                pub fn sqlite3_memory_alarm
                
                (
                    arg1: option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut os::raw::c_void,
                            arg2: sqlite3_int64,
                            arg3: os::raw::c_int,
                        ),
                    >,
                    arg2: *mut os::raw::c_void,
                    arg3: sqlite3_int64,
                ) -> os::raw::c_int;
                pub fn sqlite3_value_blob(arg1: *mut sqlite3_value) -> *const os::raw::c_void;
                pub fn sqlite3_value_bytes(arg1: *mut sqlite3_value) -> os::raw::c_int;
                pub fn sqlite3_value_double(arg1: *mut sqlite3_value) -> f64;
                pub fn sqlite3_value_int(arg1: *mut sqlite3_value) -> os::raw::c_int;
                pub fn sqlite3_value_int64(arg1: *mut sqlite3_value) -> sqlite3_int64;
                pub fn sqlite3_value_text(arg1: *mut sqlite3_value) -> *const os::raw::c_uchar;
                pub fn sqlite3_value_type(arg1: *mut sqlite3_value) -> os::raw::c_int;
                pub fn sqlite3_value_numeric_type(arg1: *mut sqlite3_value) -> os::raw::c_int;
                pub fn sqlite3_value_subtype(arg1: *mut sqlite3_value) -> os::raw::c_uint;
                pub fn sqlite3_value_dup(arg1: *const sqlite3_value) -> *mut sqlite3_value;
                pub fn sqlite3_value_free(arg1: *mut sqlite3_value);
                pub fn sqlite3_aggregate_context
                
                (
                    arg1: *mut sqlite3_context,
                    nBytes: os::raw::c_int,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_user_data(arg1: *mut sqlite3_context) -> *mut os::raw::c_void;
                pub fn sqlite3_context_db_handle(arg1: *mut sqlite3_context) -> *mut sqlite3;
                pub fn sqlite3_get_auxdata
                
                (
                    arg1: *mut sqlite3_context,
                    N: os::raw::c_int,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_set_auxdata
                
                (
                    arg1: *mut sqlite3_context,
                    N: os::raw::c_int,
                    arg2: *mut os::raw::c_void,
                    arg3: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                );
                pub fn sqlite3_result_blob
                
                (
                    arg1: *mut sqlite3_context,
                    arg2: *const os::raw::c_void,
                    arg3: os::raw::c_int,
                    arg4: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                );
                pub fn sqlite3_result_blob64
                
                (
                    arg1: *mut sqlite3_context,
                    arg2: *const os::raw::c_void,
                    arg3: sqlite3_uint64,
                    arg4: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                );
                pub fn sqlite3_result_double(arg1: *mut sqlite3_context, arg2: f64);
                pub fn sqlite3_result_error
                
                (
                    arg1: *mut sqlite3_context,
                    arg2: *const os::raw::c_char,
                    arg3: os::raw::c_int,
                );
                pub fn sqlite3_result_error_toobig(arg1: *mut sqlite3_context);
                pub fn sqlite3_result_error_nomem(arg1: *mut sqlite3_context);
                pub fn sqlite3_result_error_code(arg1: *mut sqlite3_context, arg2: os::raw::c_int);
                pub fn sqlite3_result_int(arg1: *mut sqlite3_context, arg2: os::raw::c_int);
                pub fn sqlite3_result_int64(arg1: *mut sqlite3_context, arg2: sqlite3_int64);
                pub fn sqlite3_result_null(arg1: *mut sqlite3_context);
                pub fn sqlite3_result_text
                
                (
                    arg1: *mut sqlite3_context,
                    arg2: *const os::raw::c_char,
                    arg3: os::raw::c_int,
                    arg4: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                );
                pub fn sqlite3_result_text64
                
                (
                    arg1: *mut sqlite3_context,
                    arg2: *const os::raw::c_char,
                    arg3: sqlite3_uint64,
                    arg4: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                    encoding: os::raw::c_uchar,
                );
                pub fn sqlite3_result_value(arg1: *mut sqlite3_context, arg2: *mut sqlite3_value);
                pub fn sqlite3_result_zeroblob(arg1: *mut sqlite3_context, n: os::raw::c_int);
                pub fn sqlite3_result_zeroblob64
                
                (
                    arg1: *mut sqlite3_context,
                    n: sqlite3_uint64,
                ) -> os::raw::c_int;
                pub fn sqlite3_result_subtype(arg1: *mut sqlite3_context, arg2: os::raw::c_uint);
                pub fn sqlite3_create_collation_v2
                
                (
                    arg1: *mut sqlite3,
                    zName: *const os::raw::c_char,
                    eTextRep: os::raw::c_int,
                    pArg: *mut os::raw::c_void,
                    xCompare: option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut os::raw::c_void,
                            arg2: os::raw::c_int,
                            arg3: *const os::raw::c_void,
                            arg4: os::raw::c_int,
                            arg5: *const os::raw::c_void,
                        ) -> os::raw::c_int,
                    >,
                    xDestroy: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                ) -> os::raw::c_int;
                pub fn sqlite3_collation_needed
                
                (
                    arg1: *mut sqlite3,
                    arg2: *mut os::raw::c_void,
                    arg3: option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut os::raw::c_void,
                            arg2: *mut sqlite3,
                            eTextRep: os::raw::c_int,
                            arg3: *const os::raw::c_char,
                        ),
                    >,
                ) -> os::raw::c_int;
                pub fn sqlite3_sleep(arg1: os::raw::c_int) -> os::raw::c_int;
                pub static mut sqlite3_temp_directory: *mut os::raw::c_char;
                pub static mut sqlite3_data_directory: *mut os::raw::c_char;
                pub fn sqlite3_get_autocommit(arg1: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_db_handle(arg1: *mut sqlite3_stmt) -> *mut sqlite3;
                pub fn sqlite3_db_filename
                
                (
                    db: *mut sqlite3,
                    zDbName: *const os::raw::c_char,
                ) -> *const os::raw::c_char;
                pub fn sqlite3_db_readonly
                
                (
                    db: *mut sqlite3,
                    zDbName: *const os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_next_stmt(pDb: *mut sqlite3, pStmt: *mut sqlite3_stmt) -> *mut sqlite3_stmt;
                pub fn sqlite3_commit_hook
                
                (
                    arg1: *mut sqlite3,
                    arg2: option::Option<
                        unsafe extern "C" fn(arg1: *mut os::raw::c_void) -> os::raw::c_int,
                    >,
                    arg3: *mut os::raw::c_void,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_rollback_hook
                
                (
                    arg1: *mut sqlite3,
                    arg2: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                    arg3: *mut os::raw::c_void,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_update_hook
                
                (
                    arg1: *mut sqlite3,
                    arg2: option::Option
                    <
                        unsafe extern "C" fn
                        (
                            arg1: *mut os::raw::c_void,
                            arg2: os::raw::c_int,
                            arg3: *const os::raw::c_char,
                            arg4: *const os::raw::c_char,
                            arg5: sqlite3_int64,
                        ),
                    >,
                    arg3: *mut os::raw::c_void,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_enable_shared_cache(arg1: os::raw::c_int) -> os::raw::c_int;
                pub fn sqlite3_release_memory(arg1: os::raw::c_int) -> os::raw::c_int;
                pub fn sqlite3_db_release_memory(arg1: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_soft_heap_limit64(N: sqlite3_int64) -> sqlite3_int64;
                pub fn sqlite3_soft_heap_limit(N: os::raw::c_int);
                pub fn sqlite3_table_column_metadata
                
                (
                    db: *mut sqlite3,
                    zDbName: *const os::raw::c_char,
                    zTableName: *const os::raw::c_char,
                    zColumnName: *const os::raw::c_char,
                    pzDataType: *mut *const os::raw::c_char,
                    pzCollSeq: *mut *const os::raw::c_char,
                    pNotNull: *mut os::raw::c_int,
                    pPrimaryKey: *mut os::raw::c_int,
                    pAutoinc: *mut os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_load_extension
                
                (
                    db: *mut sqlite3,
                    zFile: *const os::raw::c_char,
                    zProc: *const os::raw::c_char,
                    pzErrMsg: *mut *mut os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_enable_load_extension
                
                (
                    db: *mut sqlite3,
                    onoff: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_reset_auto_extension();
                pub fn sqlite3_create_module_v2
                (
                    db: *mut sqlite3,
                    zName: *const os::raw::c_char,
                    p: *const sqlite3_module,
                    pClientData: *mut os::raw::c_void,
                    xDestroy: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                ) -> os::raw::c_int;
                pub fn sqlite3_declare_vtab
                (
                    arg1: *mut sqlite3,
                    zSQL: *const os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_overload_function
                (
                    arg1: *mut sqlite3,
                    zFuncName: *const os::raw::c_char,
                    nArg: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_blob_reopen
                (
                    arg1: *mut sqlite3_blob,
                    arg2: sqlite3_int64,
                ) -> os::raw::c_int;
                pub fn sqlite3_blob_close(arg1: *mut sqlite3_blob) -> os::raw::c_int;
                pub fn sqlite3_blob_bytes(arg1: *mut sqlite3_blob) -> os::raw::c_int;
                pub fn sqlite3_blob_read
                (
                    arg1: *mut sqlite3_blob,
                    Z: *mut os::raw::c_void,
                    N: os::raw::c_int,
                    iOffset: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_blob_write
                (
                    arg1: *mut sqlite3_blob,
                    z: *const os::raw::c_void,
                    n: os::raw::c_int,
                    iOffset: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_vfs_find(zVfsName: *const os::raw::c_char) -> *mut sqlite3_vfs;
                pub fn sqlite3_vfs_register
                (
                    arg1: *mut sqlite3_vfs,
                    makeDflt: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_vfs_unregister(arg1: *mut sqlite3_vfs) -> os::raw::c_int;
                pub fn sqlite3_mutex_alloc(arg1: os::raw::c_int) -> *mut sqlite3_mutex;
                pub fn sqlite3_mutex_free(arg1: *mut sqlite3_mutex);
                pub fn sqlite3_mutex_enter(arg1: *mut sqlite3_mutex);
                pub fn sqlite3_mutex_try(arg1: *mut sqlite3_mutex) -> os::raw::c_int;
                pub fn sqlite3_mutex_leave(arg1: *mut sqlite3_mutex);
                pub fn sqlite3_mutex_held(arg1: *mut sqlite3_mutex) -> os::raw::c_int;
                pub fn sqlite3_mutex_notheld(arg1: *mut sqlite3_mutex) -> os::raw::c_int;
                pub fn sqlite3_db_mutex(arg1: *mut sqlite3) -> *mut sqlite3_mutex;
                pub fn sqlite3_file_control
                (
                    arg1: *mut sqlite3,
                    zDbName: *const os::raw::c_char,
                    op: os::raw::c_int,
                    arg2: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3_test_control(op: os::raw::c_int, ...) -> os::raw::c_int;
                pub fn sqlite3_status
                (
                    op: os::raw::c_int,
                    pCurrent: *mut os::raw::c_int,
                    pHighwater: *mut os::raw::c_int,
                    resetFlag: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_status64
                (
                    op: os::raw::c_int,
                    pCurrent: *mut sqlite3_int64,
                    pHighwater: *mut sqlite3_int64,
                    resetFlag: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_db_status
                (
                    arg1: *mut sqlite3,
                    op: os::raw::c_int,
                    pCur: *mut os::raw::c_int,
                    pHiwtr: *mut os::raw::c_int,
                    resetFlg: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_stmt_status
                (
                    arg1: *mut sqlite3_stmt,
                    op: os::raw::c_int,
                    resetFlg: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_backup_init
                (
                    pDest: *mut sqlite3,
                    zDestName: *const os::raw::c_char,
                    pSource: *mut sqlite3,
                    zSourceName: *const os::raw::c_char,
                ) -> *mut sqlite3_backup;
                pub fn sqlite3_backup_step
                (
                    p: *mut sqlite3_backup,
                    nPage: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_backup_finish(p: *mut sqlite3_backup) -> os::raw::c_int;
                pub fn sqlite3_backup_remaining(p: *mut sqlite3_backup) -> os::raw::c_int;
                pub fn sqlite3_backup_pagecount(p: *mut sqlite3_backup) -> os::raw::c_int;
                pub fn sqlite3_unlock_notify
                (
                    pBlocked: *mut sqlite3,
                    xNotify: option::Option<
                        unsafe extern "C" fn(
                            apArg: *mut *mut os::raw::c_void,
                            nArg: os::raw::c_int,
                        ),
                    >,
                    pNotifyArg: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3_stricmp
                (
                    arg1: *const os::raw::c_char,
                    arg2: *const os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_strnicmp
                (
                    arg1: *const os::raw::c_char,
                    arg2: *const os::raw::c_char,
                    arg3: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_strglob
                (
                    zGlob: *const os::raw::c_char,
                    zStr: *const os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_strlike
                (
                    zGlob: *const os::raw::c_char,
                    zStr: *const os::raw::c_char,
                    cEsc: os::raw::c_uint,
                ) -> os::raw::c_int;
                pub fn sqlite3_log
                (
                    iErrCode: os::raw::c_int,
                    zFormat: *const os::raw::c_char,
                    ...
                );
                pub fn sqlite3_wal_hook
                (
                    arg1: *mut sqlite3,
                    arg2: option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut os::raw::c_void,
                            arg2: *mut sqlite3,
                            arg3: *const os::raw::c_char,
                            arg4: os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    arg3: *mut os::raw::c_void,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_wal_autocheckpoint
                (
                    db: *mut sqlite3,
                    N: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_wal_checkpoint
                (
                    db: *mut sqlite3,
                    zDb: *const os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3_wal_checkpoint_v2
                (
                    db: *mut sqlite3,
                    zDb: *const os::raw::c_char,
                    eMode: os::raw::c_int,
                    pnLog: *mut os::raw::c_int,
                    pnCkpt: *mut os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3_vtab_config
                (
                    arg1: *mut sqlite3,
                    op: os::raw::c_int,
                    ...
                ) -> os::raw::c_int;
                pub fn sqlite3_vtab_on_conflict(arg1: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_stmt_scanstatus
                (
                    pStmt: *mut sqlite3_stmt,
                    idx: os::raw::c_int,
                    iScanStatusOp: os::raw::c_int,
                    pOut: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3_stmt_scanstatus_reset(arg1: *mut sqlite3_stmt);
                pub fn sqlite3_db_cacheflush(arg1: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_preupdate_hook
                (
                    db: *mut sqlite3,
                    xPreUpdate: option::Option<
                        unsafe extern "C" fn(
                            pCtx: *mut os::raw::c_void,
                            db: *mut sqlite3,
                            op: os::raw::c_int,
                            zDb: *const os::raw::c_char,
                            zName: *const os::raw::c_char,
                            iKey1: sqlite3_int64,
                            iKey2: sqlite3_int64,
                        ),
                    >,
                    arg1: *mut os::raw::c_void,
                ) -> *mut os::raw::c_void;
                pub fn sqlite3_preupdate_old
                (
                    arg1: *mut sqlite3,
                    arg2: os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ) -> os::raw::c_int;
                pub fn sqlite3_preupdate_count(arg1: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_preupdate_depth(arg1: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_preupdate_new
                (
                    arg1: *mut sqlite3,
                    arg2: os::raw::c_int,
                    arg3: *mut *mut sqlite3_value,
                ) -> os::raw::c_int;
                pub fn sqlite3_system_errno(arg1: *mut sqlite3) -> os::raw::c_int;
                pub fn sqlite3_snapshot_get
                (
                    db: *mut sqlite3,
                    zSchema: *const os::raw::c_char,
                    ppSnapshot: *mut *mut sqlite3_snapshot,
                ) -> os::raw::c_int;
                pub fn sqlite3_snapshot_open
                (
                    db: *mut sqlite3,
                    zSchema: *const os::raw::c_char,
                    pSnapshot: *mut sqlite3_snapshot,
                ) -> os::raw::c_int;
                pub fn sqlite3_snapshot_free(arg1: *mut sqlite3_snapshot);
                pub fn sqlite3_snapshot_cmp
                (
                    p1: *mut sqlite3_snapshot,
                    p2: *mut sqlite3_snapshot,
                ) -> os::raw::c_int;
                pub fn sqlite3_rtree_geometry_callback
                (
                    db: *mut sqlite3,
                    zGeom: *const os::raw::c_char,
                    xGeom: option::Option<
                        unsafe extern "C" fn(
                            arg1: *mut sqlite3_rtree_geometry,
                            arg2: os::raw::c_int,
                            arg3: *mut sqlite3_rtree_dbl,
                            arg4: *mut os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pContext: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3_rtree_query_callback
                (
                    db: *mut sqlite3,
                    zQueryFunc: *const os::raw::c_char,
                    xQueryFunc: option::Option<
                        unsafe extern "C" fn(arg1: *mut sqlite3_rtree_query_info) -> os::raw::c_int,
                    >,
                    pContext: *mut os::raw::c_void,
                    xDestructor: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                ) -> os::raw::c_int;
                pub fn sqlite3session_create
                (
                    db: *mut sqlite3,
                    zDb: *const os::raw::c_char,
                    ppSession: *mut *mut sqlite3_session,
                ) -> os::raw::c_int;
                pub fn sqlite3session_delete(pSession: *mut sqlite3_session);
                pub fn sqlite3session_enable
                (
                    pSession: *mut sqlite3_session,
                    bEnable: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3session_indirect
                (
                    pSession: *mut sqlite3_session,
                    bIndirect: os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3session_attach
                (
                    pSession: *mut sqlite3_session,
                    zTab: *const os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3session_table_filter
                (
                    pSession: *mut sqlite3_session,
                    xFilter: option::Option<
                        unsafe extern "C" fn(
                            pCtx: *mut os::raw::c_void,
                            zTab: *const os::raw::c_char,
                        ) -> os::raw::c_int,
                    >,
                    pCtx: *mut os::raw::c_void,
                );
                pub fn sqlite3session_changeset
                (
                    pSession: *mut sqlite3_session,
                    pnChangeset: *mut os::raw::c_int,
                    ppChangeset: *mut *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3session_diff
                (
                    pSession: *mut sqlite3_session,
                    zFromDb: *const os::raw::c_char,
                    zTbl: *const os::raw::c_char,
                    pzErrMsg: *mut *mut os::raw::c_char,
                ) -> os::raw::c_int;
                pub fn sqlite3session_patchset
                (
                    pSession: *mut sqlite3_session,
                    pnPatchset: *mut os::raw::c_int,
                    ppPatchset: *mut *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3session_isempty(pSession: *mut sqlite3_session) -> os::raw::c_int;
                pub fn sqlite3changeset_start
                (
                    pp: *mut *mut sqlite3_changeset_iter,
                    nChangeset: os::raw::c_int,
                    pChangeset: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_next(pIter: *mut sqlite3_changeset_iter) -> os::raw::c_int;
                pub fn sqlite3changeset_op
                (
                    pIter: *mut sqlite3_changeset_iter,
                    pzTab: *mut *const os::raw::c_char,
                    pnCol: *mut os::raw::c_int,
                    pOp: *mut os::raw::c_int,
                    pbIndirect: *mut os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_pk
                (
                    pIter: *mut sqlite3_changeset_iter,
                    pabPK: *mut *mut os::raw::c_uchar,
                    pnCol: *mut os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_old
                (
                    pIter: *mut sqlite3_changeset_iter,
                    iVal: os::raw::c_int,
                    ppValue: *mut *mut sqlite3_value,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_new
                (
                    pIter: *mut sqlite3_changeset_iter,
                    iVal: os::raw::c_int,
                    ppValue: *mut *mut sqlite3_value,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_conflict
                (
                    pIter: *mut sqlite3_changeset_iter,
                    iVal: os::raw::c_int,
                    ppValue: *mut *mut sqlite3_value,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_fk_conflicts
                (
                    pIter: *mut sqlite3_changeset_iter,
                    pnOut: *mut os::raw::c_int,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_finalize(pIter: *mut sqlite3_changeset_iter) -> os::raw::c_int;
                pub fn sqlite3changeset_invert
                (
                    nIn: os::raw::c_int,
                    pIn: *const os::raw::c_void,
                    pnOut: *mut os::raw::c_int,
                    ppOut: *mut *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_concat
                (
                    nA: os::raw::c_int,
                    pA: *mut os::raw::c_void,
                    nB: os::raw::c_int,
                    pB: *mut os::raw::c_void,
                    pnOut: *mut os::raw::c_int,
                    ppOut: *mut *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changegroup_new(pp: *mut *mut sqlite3_changegroup) -> os::raw::c_int;
                pub fn sqlite3changegroup_add
                (
                    arg1: *mut sqlite3_changegroup,
                    nData: os::raw::c_int,
                    pData: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changegroup_output
                (
                    arg1: *mut sqlite3_changegroup,
                    pnData: *mut os::raw::c_int,
                    ppData: *mut *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changegroup_delete(arg1: *mut sqlite3_changegroup);
                pub fn sqlite3changeset_apply
                (
                    db: *mut sqlite3,
                    nChangeset: os::raw::c_int,
                    pChangeset: *mut os::raw::c_void,
                    xFilter: option::Option<
                        unsafe extern "C" fn(
                            pCtx: *mut os::raw::c_void,
                            zTab: *const os::raw::c_char,
                        ) -> os::raw::c_int,
                    >,
                    xConflict: option::Option<
                        unsafe extern "C" fn(
                            pCtx: *mut os::raw::c_void,
                            eConflict: os::raw::c_int,
                            p: *mut sqlite3_changeset_iter,
                        ) -> os::raw::c_int,
                    >,
                    pCtx: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_apply_strm
                (
                    db: *mut sqlite3,
                    xInput: option::Option<
                        unsafe extern "C" fn(
                            pIn: *mut os::raw::c_void,
                            pData: *mut os::raw::c_void,
                            pnData: *mut os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pIn: *mut os::raw::c_void,
                    xFilter: option::Option<
                        unsafe extern "C" fn(
                            pCtx: *mut os::raw::c_void,
                            zTab: *const os::raw::c_char,
                        ) -> os::raw::c_int,
                    >,
                    xConflict: option::Option<
                        unsafe extern "C" fn(
                            pCtx: *mut os::raw::c_void,
                            eConflict: os::raw::c_int,
                            p: *mut sqlite3_changeset_iter,
                        ) -> os::raw::c_int,
                    >,
                    pCtx: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_concat_strm
                (
                    xInputA: option::Option<
                        unsafe extern "C" fn(
                            pIn: *mut os::raw::c_void,
                            pData: *mut os::raw::c_void,
                            pnData: *mut os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pInA: *mut os::raw::c_void,
                    xInputB: option::Option<
                        unsafe extern "C" fn(
                            pIn: *mut os::raw::c_void,
                            pData: *mut os::raw::c_void,
                            pnData: *mut os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pInB: *mut os::raw::c_void,
                    xOutput: option::Option<
                        unsafe extern "C" fn(
                            pOut: *mut os::raw::c_void,
                            pData: *const os::raw::c_void,
                            nData: os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pOut: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_invert_strm
                (
                    xInput: option::Option<
                        unsafe extern "C" fn(
                            pIn: *mut os::raw::c_void,
                            pData: *mut os::raw::c_void,
                            pnData: *mut os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pIn: *mut os::raw::c_void,
                    xOutput: option::Option<
                        unsafe extern "C" fn(
                            pOut: *mut os::raw::c_void,
                            pData: *const os::raw::c_void,
                            nData: os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pOut: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changeset_start_strm
                (
                    pp: *mut *mut sqlite3_changeset_iter,
                    xInput: option::Option<
                        unsafe extern "C" fn(
                            pIn: *mut os::raw::c_void,
                            pData: *mut os::raw::c_void,
                            pnData: *mut os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pIn: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3session_changeset_strm
                (
                    pSession: *mut sqlite3_session,
                    xOutput: option::Option<
                        unsafe extern "C" fn(
                            pOut: *mut os::raw::c_void,
                            pData: *const os::raw::c_void,
                            nData: os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pOut: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3session_patchset_strm
                (
                    pSession: *mut sqlite3_session,
                    xOutput: option::Option<
                        unsafe extern "C" fn(
                            pOut: *mut os::raw::c_void,
                            pData: *const os::raw::c_void,
                            nData: os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pOut: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changegroup_add_strm
                (
                    arg1: *mut sqlite3_changegroup,
                    xInput: option::Option<
                        unsafe extern "C" fn(
                            pIn: *mut os::raw::c_void,
                            pData: *mut os::raw::c_void,
                            pnData: *mut os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pIn: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3changegroup_output_strm
                (
                    arg1: *mut sqlite3_changegroup,
                    xOutput: option::Option<
                        unsafe extern "C" fn(
                            pOut: *mut os::raw::c_void,
                            pData: *const os::raw::c_void,
                            nData: os::raw::c_int,
                        ) -> os::raw::c_int,
                    >,
                    pOut: *mut os::raw::c_void,
                ) -> os::raw::c_int;
                pub fn sqlite3_blob_open
                (
                    arg1: *mut sqlite3,
                    zDb: *const os::raw::c_char,
                    zTable: *const os::raw::c_char,
                    zColumn: *const os::raw::c_char,
                    iRow: sqlite3_int64,
                    flags: os::raw::c_int,
                    ppBlob: *mut *mut sqlite3_blob,
                ) -> os::raw::c_int;
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_file {
                pub pMethods: *const sqlite3_io_methods,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_io_methods
            {
                pub iVersion: os::raw::c_int,
                pub xClose: option::Option<unsafe extern "C" fn( arg1: *mut sqlite3_file ) -> os::raw::c_int>,
                pub xRead: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_file,
                        arg2: *mut os::raw::c_void,
                        iAmt: os::raw::c_int,
                        iOfst: sqlite3_int64,
                    ) -> os::raw::c_int,
                >,
                pub xWrite: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_file,
                        arg2: *const os::raw::c_void,
                        iAmt: os::raw::c_int,
                        iOfst: sqlite3_int64,
                    ) -> os::raw::c_int,
                >,
                pub xTruncate: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_file, size: sqlite3_int64) -> os::raw::c_int,
                >,
                pub xSync: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_file,
                        flags: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xFileSize: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_file,
                        pSize: *mut sqlite3_int64,
                    ) -> os::raw::c_int,
                >,
                pub xLock: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_file,
                        arg2: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xUnlock: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_file,
                        arg2: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xCheckReservedLock: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_file,
                        pResOut: *mut os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xFileControl: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_file,
                        op: os::raw::c_int,
                        pArg: *mut os::raw::c_void,
                    ) -> os::raw::c_int,
                >,
                pub xSectorSize: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_file) -> os::raw::c_int,
                >,
                pub xDeviceCharacteristics: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_file) -> os::raw::c_int,
                >,
                pub xShmMap: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_file,
                        iPg: os::raw::c_int,
                        pgsz: os::raw::c_int,
                        arg2: os::raw::c_int,
                        arg3: *mut *mut os::raw::c_void,
                    ) -> os::raw::c_int,
                >,
                pub xShmLock: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_file,
                        offset: os::raw::c_int,
                        n: os::raw::c_int,
                        flags: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xShmBarrier: option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_file)>,
                pub xShmUnmap: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_file,
                        deleteFlag: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xFetch: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_file,
                        iOfst: sqlite3_int64,
                        iAmt: os::raw::c_int,
                        pp: *mut *mut os::raw::c_void,
                    ) -> os::raw::c_int,
                >,
                pub xUnfetch: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_file,
                        iOfst: sqlite3_int64,
                        p: *mut os::raw::c_void,
                    ) -> os::raw::c_int,
                >,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_mutex
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_api_routines
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_vfs
            {
                pub iVersion: os::raw::c_int,
                pub szOsFile: os::raw::c_int,
                pub mxPathname: os::raw::c_int,
                pub pNext: *mut sqlite3_vfs,
                pub zName: *const os::raw::c_char,
                pub pAppData: *mut os::raw::c_void,
                pub xOpen: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        zName: *const os::raw::c_char,
                        arg2: *mut sqlite3_file,
                        flags: os::raw::c_int,
                        pOutFlags: *mut os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xDelete: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        zName: *const os::raw::c_char,
                        syncDir: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xAccess: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        zName: *const os::raw::c_char,
                        flags: os::raw::c_int,
                        pResOut: *mut os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xFullPathname: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        zName: *const os::raw::c_char,
                        nOut: os::raw::c_int,
                        zOut: *mut os::raw::c_char,
                    ) -> os::raw::c_int,
                >,
                pub xDlOpen: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        zFilename: *const os::raw::c_char,
                    ) -> *mut os::raw::c_void,
                >,
                pub xDlError: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        nByte: os::raw::c_int,
                        zErrMsg: *mut os::raw::c_char,
                    ),
                >,
                pub xDlSym: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        arg2: *mut os::raw::c_void,
                        zSymbol: *const os::raw::c_char,
                    ) -> option::Option
                    <
                        unsafe extern "C" fn
                        (
                            arg1: *mut sqlite3_vfs,
                            arg2: *mut os::raw::c_void,
                            zSymbol: *const os::raw::c_char,
                        ),
                    >,
                >,
                pub xDlClose: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_vfs, arg2: *mut os::raw::c_void),
                >,
                pub xRandomness: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        nByte: os::raw::c_int,
                        zOut: *mut os::raw::c_char,
                    ) -> os::raw::c_int,
                >,
                pub xSleep: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        microseconds: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xCurrentTime: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_vfs, arg2: *mut f64) -> os::raw::c_int,
                >,
                pub xGetLastError: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        arg2: os::raw::c_int,
                        arg3: *mut os::raw::c_char,
                    ) -> os::raw::c_int,
                >,
                pub xCurrentTimeInt64: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        arg2: *mut sqlite3_int64,
                    ) -> os::raw::c_int,
                >,
                pub xSetSystemCall: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        zName: *const os::raw::c_char,
                        arg2: sqlite3_syscall_ptr,
                    ) -> os::raw::c_int,
                >,
                pub xGetSystemCall: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        zName: *const os::raw::c_char,
                    ) -> sqlite3_syscall_ptr,
                >,
                pub xNextSystemCall: option::Option
                <
                    unsafe extern "C" fn
                    (
                        arg1: *mut sqlite3_vfs,
                        zName: *const os::raw::c_char,
                    ) -> *const os::raw::c_char,
                >,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_mem_methods
            {
                pub xMalloc: option::Option
                <
                    unsafe extern "C" fn(arg1: os::raw::c_int) -> *mut os::raw::c_void,
                >,
                pub xFree: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                pub xRealloc: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut os::raw::c_void,
                        arg2: os::raw::c_int,
                    ) -> *mut os::raw::c_void,
                >,
                pub xSize: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut os::raw::c_void) -> os::raw::c_int,
                >,
                pub xRoundup: option::Option
                <
                    unsafe extern "C" fn(arg1: os::raw::c_int) -> os::raw::c_int,
                >,
                pub xInit: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut os::raw::c_void) -> os::raw::c_int,
                >,
                pub xShutdown: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                pub pAppData: *mut os::raw::c_void,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_stmt
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct Mem
            {
                _unused: [u8; 0],
            }

            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_context
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_module {
                pub iVersion: os::raw::c_int,
                pub xCreate: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3,
                        pAux: *mut os::raw::c_void,
                        argc: os::raw::c_int,
                        argv: *const *const os::raw::c_char,
                        ppVTab: *mut *mut sqlite3_vtab,
                        arg2: *mut *mut os::raw::c_char,
                    ) -> os::raw::c_int,
                >,
                pub xConnect: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3,
                        pAux: *mut os::raw::c_void,
                        argc: os::raw::c_int,
                        argv: *const *const os::raw::c_char,
                        ppVTab: *mut *mut sqlite3_vtab,
                        arg2: *mut *mut os::raw::c_char,
                    ) -> os::raw::c_int,
                >,
                pub xBestIndex: option::Option
                <
                    unsafe extern "C" fn(
                        pVTab: *mut sqlite3_vtab,
                        arg1: *mut sqlite3_index_info,
                    ) -> os::raw::c_int,
                >,
                pub xDisconnect: option::Option
                <
                    unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> os::raw::c_int,
                >,
                pub xDestroy: option::Option
                <
                    unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> os::raw::c_int,
                >,
                pub xOpen: option::Option
                <
                    unsafe extern "C" fn(
                        pVTab: *mut sqlite3_vtab,
                        ppCursor: *mut *mut sqlite3_vtab_cursor,
                    ) -> os::raw::c_int,
                >,
                pub xClose: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> os::raw::c_int,
                >,
                pub xFilter: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_vtab_cursor,
                        idxNum: os::raw::c_int,
                        idxStr: *const os::raw::c_char,
                        argc: os::raw::c_int,
                        argv: *mut *mut sqlite3_value,
                    ) -> os::raw::c_int,
                >,
                pub xNext: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> os::raw::c_int,
                >,
                pub xEof: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_vtab_cursor) -> os::raw::c_int,
                >,
                pub xColumn: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_vtab_cursor,
                        arg2: *mut sqlite3_context,
                        arg3: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xRowid: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_vtab_cursor,
                        pRowid: *mut sqlite3_int64,
                    ) -> os::raw::c_int,
                >,
                pub xUpdate: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_vtab,
                        arg2: os::raw::c_int,
                        arg3: *mut *mut sqlite3_value,
                        arg4: *mut sqlite3_int64,
                    ) -> os::raw::c_int,
                >,
                pub xBegin: option::Option
                <
                    unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> os::raw::c_int,
                >,
                pub xSync: option::Option
                <
                    unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> os::raw::c_int,
                >,
                pub xCommit: option::Option
                <
                    unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> os::raw::c_int,
                >,
                pub xRollback: option::Option
                <
                    unsafe extern "C" fn(pVTab: *mut sqlite3_vtab) -> os::raw::c_int,
                >,
                pub xFindFunction: option::Option
                <
                    unsafe extern "C" fn(
                        pVtab: *mut sqlite3_vtab,
                        nArg: os::raw::c_int,
                        zName: *const os::raw::c_char,
                        pxFunc: *mut option::Option<
                            unsafe extern "C" fn(
                                arg1: *mut sqlite3_context,
                                arg2: os::raw::c_int,
                                arg3: *mut *mut sqlite3_value,
                            ),
                        >,
                        ppArg: *mut *mut os::raw::c_void,
                    ) -> os::raw::c_int,
                >,
                pub xRename: option::Option
                <
                    unsafe extern "C" fn(
                        pVtab: *mut sqlite3_vtab,
                        zNew: *const os::raw::c_char,
                    ) -> os::raw::c_int,
                >,
                pub xSavepoint: option::Option
                <
                    unsafe extern "C" fn(
                        pVTab: *mut sqlite3_vtab,
                        arg1: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xRelease: option::Option
                <
                    unsafe extern "C" fn(
                        pVTab: *mut sqlite3_vtab,
                        arg1: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xRollbackTo: option::Option
                <
                    unsafe extern "C" fn(
                        pVTab: *mut sqlite3_vtab,
                        arg1: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_index_info {
                pub nConstraint: os::raw::c_int,
                pub aConstraint: *mut sqlite3_index_constraint,
                pub nOrderBy: os::raw::c_int,
                pub aOrderBy: *mut sqlite3_index_orderby,
                pub aConstraintUsage: *mut sqlite3_index_constraint_usage,
                pub idxNum: os::raw::c_int,
                pub idxStr: *mut os::raw::c_char,
                pub needToFreeIdxStr: os::raw::c_int,
                pub orderByConsumed: os::raw::c_int,
                pub estimatedCost: f64,
                pub estimatedRows: sqlite3_int64,
                pub idxFlags: os::raw::c_int,
                pub colUsed: sqlite3_uint64,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_index_constraint {
                pub iColumn: os::raw::c_int,
                pub op: os::raw::c_uchar,
                pub usable: os::raw::c_uchar,
                pub iTermOffset: os::raw::c_int,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_index_orderby {
                pub iColumn: os::raw::c_int,
                pub desc: os::raw::c_uchar,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_index_constraint_usage {
                pub argvIndex: os::raw::c_int,
                pub omit: os::raw::c_uchar,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_vtab {
                pub pModule: *const sqlite3_module,
                pub nRef: os::raw::c_int,
                pub zErrMsg: *mut os::raw::c_char,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_vtab_cursor {
                pub pVtab: *mut sqlite3_vtab,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_blob
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_mutex_methods {
                pub xMutexInit: option::Option<unsafe extern "C" fn() -> os::raw::c_int>,
                pub xMutexEnd: option::Option<unsafe extern "C" fn() -> os::raw::c_int>,
                pub xMutexAlloc: option::Option
                <
                    unsafe extern "C" fn(arg1: os::raw::c_int) -> *mut sqlite3_mutex,
                >,
                pub xMutexFree: option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
                pub xMutexEnter: option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
                pub xMutexTry: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> os::raw::c_int,
                >,
                pub xMutexLeave: option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_mutex)>,
                pub xMutexHeld: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> os::raw::c_int,
                >,
                pub xMutexNotheld: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_mutex) -> os::raw::c_int,
                >,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_snapshot
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_pcache
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_pcache_page 
            {
                pub pBuf: *mut os::raw::c_void,
                pub pExtra: *mut os::raw::c_void,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_pcache_methods2 
            {
                pub iVersion: os::raw::c_int,
                pub pArg: *mut os::raw::c_void,
                pub xInit: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut os::raw::c_void) -> os::raw::c_int,
                >,
                pub xShutdown: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                pub xCreate: option::Option
                <
                    unsafe extern "C" fn(
                        szPage: os::raw::c_int,
                        szExtra: os::raw::c_int,
                        bPurgeable: os::raw::c_int,
                    ) -> *mut sqlite3_pcache,
                >,
                pub xCachesize: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_pcache, nCachesize: os::raw::c_int),
                >,
                pub xPagecount: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_pcache) -> os::raw::c_int,
                >,
                pub xFetch: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_pcache,
                        key: os::raw::c_uint,
                        createFlag: os::raw::c_int,
                    ) -> *mut sqlite3_pcache_page,
                >,
                pub xUnpin: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_pcache,
                        arg2: *mut sqlite3_pcache_page,
                        discard: os::raw::c_int,
                    ),
                >,
                pub xRekey: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_pcache,
                        arg2: *mut sqlite3_pcache_page,
                        oldKey: os::raw::c_uint,
                        newKey: os::raw::c_uint,
                    ),
                >,
                pub xTruncate: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_pcache, iLimit: os::raw::c_uint),
                >,
                pub xDestroy: option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
                pub xShrink: option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_pcache_methods 
            {
                pub pArg: *mut os::raw::c_void,
                pub xInit: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut os::raw::c_void) -> os::raw::c_int,
                >,
                pub xShutdown: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                pub xCreate: option::Option
                <
                    unsafe extern "C" fn(
                        szPage: os::raw::c_int,
                        bPurgeable: os::raw::c_int,
                    ) -> *mut sqlite3_pcache,
                >,
                pub xCachesize: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_pcache, nCachesize: os::raw::c_int),
                >,
                pub xPagecount: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_pcache) -> os::raw::c_int,
                >,
                pub xFetch: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_pcache,
                        key: os::raw::c_uint,
                        createFlag: os::raw::c_int,
                    ) -> *mut os::raw::c_void,
                >,
                pub xUnpin: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_pcache,
                        arg2: *mut os::raw::c_void,
                        discard: os::raw::c_int,
                    ),
                >,
                pub xRekey: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut sqlite3_pcache,
                        arg2: *mut os::raw::c_void,
                        oldKey: os::raw::c_uint,
                        newKey: os::raw::c_uint,
                    ),
                >,
                pub xTruncate: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut sqlite3_pcache, iLimit: os::raw::c_uint),
                >,
                pub xDestroy: option::Option<unsafe extern "C" fn(arg1: *mut sqlite3_pcache)>,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_backup
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_rtree_geometry 
            {
                pub pContext: *mut os::raw::c_void,
                pub nParam: os::raw::c_int,
                pub aParam: *mut sqlite3_rtree_dbl,
                pub pUser: *mut os::raw::c_void,
                pub xDelUser: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_rtree_query_info 
            {
                pub pContext: *mut os::raw::c_void,
                pub nParam: os::raw::c_int,
                pub aParam: *mut sqlite3_rtree_dbl,
                pub pUser: *mut os::raw::c_void,
                pub xDelUser: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                pub aCoord: *mut sqlite3_rtree_dbl,
                pub anQueue: *mut os::raw::c_uint,
                pub nCoord: os::raw::c_int,
                pub iLevel: os::raw::c_int,
                pub mxLevel: os::raw::c_int,
                pub iRowid: sqlite3_int64,
                pub rParentScore: sqlite3_rtree_dbl,
                pub eParentWithin: os::raw::c_int,
                pub eWithin: os::raw::c_int,
                pub rScore: sqlite3_rtree_dbl,
                pub apSqlParam: *mut *mut sqlite3_value,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_session
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_changeset_iter
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct sqlite3_changegroup
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct Fts5Context
            {
                _unused: [u8; 0],
            }

            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct Fts5PhraseIter
            {
                pub a: *const os::raw::c_uchar,
                pub b: *const os::raw::c_uchar,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct Fts5ExtensionApi
            {
                pub iVersion: os::raw::c_int,
                pub xUserData: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut Fts5Context) -> *mut os::raw::c_void,
                >,
                pub xColumnCount: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut Fts5Context) -> os::raw::c_int,
                >,
                pub xRowCount: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        pnRow: *mut sqlite3_int64,
                    ) -> os::raw::c_int,
                >,
                pub xColumnTotalSize: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        iCol: os::raw::c_int,
                        pnToken: *mut sqlite3_int64,
                    ) -> os::raw::c_int,
                >,
                pub xTokenize: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        pText: *const os::raw::c_char,
                        nText: os::raw::c_int,
                        pCtx: *mut os::raw::c_void,
                        xToken: option::Option<
                            unsafe extern "C" fn(
                                arg1: *mut os::raw::c_void,
                                arg2: os::raw::c_int,
                                arg3: *const os::raw::c_char,
                                arg4: os::raw::c_int,
                                arg5: os::raw::c_int,
                                arg6: os::raw::c_int,
                            ) -> os::raw::c_int,
                        >,
                    ) -> os::raw::c_int,
                >,
                pub xPhraseCount: option::Option
                <
                    unsafe extern "C" fn(arg1: *mut Fts5Context) -> os::raw::c_int,
                >,
                pub xPhraseSize: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        iPhrase: os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xInstCount: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        pnInst: *mut os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xInst: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        iIdx: os::raw::c_int,
                        piPhrase: *mut os::raw::c_int,
                        piCol: *mut os::raw::c_int,
                        piOff: *mut os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xRowid:
                    option::Option<unsafe extern "C" fn(arg1: *mut Fts5Context) -> sqlite3_int64>,
                pub xColumnText: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        iCol: os::raw::c_int,
                        pz: *mut *const os::raw::c_char,
                        pn: *mut os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xColumnSize: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        iCol: os::raw::c_int,
                        pnToken: *mut os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xQueryPhrase: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        iPhrase: os::raw::c_int,
                        pUserData: *mut os::raw::c_void,
                        arg2: option::Option<
                            unsafe extern "C" fn(
                                arg1: *const Fts5ExtensionApi,
                                arg2: *mut Fts5Context,
                                arg3: *mut os::raw::c_void,
                            ) -> os::raw::c_int,
                        >,
                    ) -> os::raw::c_int,
                >,
                pub xSetAuxdata: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        pAux: *mut os::raw::c_void,
                        xDelete: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                    ) -> os::raw::c_int,
                >,
                pub xGetAuxdata: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        bClear: os::raw::c_int,
                    ) -> *mut os::raw::c_void,
                >,
                pub xPhraseFirst: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        iPhrase: os::raw::c_int,
                        arg2: *mut Fts5PhraseIter,
                        arg3: *mut os::raw::c_int,
                        arg4: *mut os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xPhraseNext: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        arg2: *mut Fts5PhraseIter,
                        piCol: *mut os::raw::c_int,
                        piOff: *mut os::raw::c_int,
                    ),
                >,
                pub xPhraseFirstColumn: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        iPhrase: os::raw::c_int,
                        arg2: *mut Fts5PhraseIter,
                        arg3: *mut os::raw::c_int,
                    ) -> os::raw::c_int,
                >,
                pub xPhraseNextColumn: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Context,
                        arg2: *mut Fts5PhraseIter,
                        piCol: *mut os::raw::c_int,
                    ),
                >,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct Fts5Tokenizer
            {
                _unused: [u8; 0],
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct fts5_tokenizer
            {
                pub xCreate: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut os::raw::c_void,
                        azArg: *mut *const os::raw::c_char,
                        nArg: os::raw::c_int,
                        ppOut: *mut *mut Fts5Tokenizer,
                    ) -> os::raw::c_int,
                >,
                pub xDelete: option::Option<unsafe extern "C" fn(arg1: *mut Fts5Tokenizer)>,
                pub xTokenize: option::Option
                <
                    unsafe extern "C" fn(
                        arg1: *mut Fts5Tokenizer,
                        pCtx: *mut os::raw::c_void,
                        flags: os::raw::c_int,
                        pText: *const os::raw::c_char,
                        nText: os::raw::c_int,
                        xToken: option::Option<
                            unsafe extern "C" fn(
                                pCtx: *mut os::raw::c_void,
                                tflags: os::raw::c_int,
                                pToken: *const os::raw::c_char,
                                nToken: os::raw::c_int,
                                iStart: os::raw::c_int,
                                iEnd: os::raw::c_int,
                            ) -> os::raw::c_int,
                        >,
                    ) -> os::raw::c_int,
                >,
            }
            
            #[repr( C )] #[derive(Debug, Copy, Clone)]
            pub struct fts5_api 
            {
                pub iVersion: os::raw::c_int,
                pub xCreateTokenizer: option::Option
                <
                    unsafe extern "C" fn
                    (
                        pApi: *mut fts5_api,
                        zName: *const os::raw::c_char,
                        pContext: *mut os::raw::c_void,
                        pTokenizer: *mut fts5_tokenizer,
                        xDestroy: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                    ) -> os::raw::c_int,
                >,
                pub xFindTokenizer: option::Option
                <
                    unsafe extern "C" fn
                    (
                        pApi: *mut fts5_api,
                        zName: *const os::raw::c_char,
                        ppContext: *mut *mut os::raw::c_void,
                        pTokenizer: *mut fts5_tokenizer,
                    ) -> os::raw::c_int,
                >,
                pub xCreateFunction: option::Option
                <
                    unsafe extern "C" fn
                    (
                        pApi: *mut fts5_api,
                        zName: *const os::raw::c_char,
                        pContext: *mut os::raw::c_void,
                        xFunction: fts5_extension_function,
                        xDestroy: option::Option<unsafe extern "C" fn(arg1: *mut os::raw::c_void)>,
                    ) -> os::raw::c_int,
                >,
            }
        } pub use self::bindings::*;

        impl Default for sqlite3_vtab
        {
            fn default() -> Self { unsafe { mem::zeroed() } }
        }

        impl Default for sqlite3_vtab_cursor
        {
            fn default() -> Self { unsafe { mem::zeroed() } }
        }
    }

    pub mod sqlite
    {
        /*!
        sqlite is an ergonomic wrapper for using SQLite from Rust. */
        use ::
        {
            *,
        };

        pub use error::sqlite3::{to_sqlite_error, Error};
        /*
        pub use fallible_iterator;
        pub use fallible_streaming_iterator;
        pub use libsqlite3_sys as ffi;

        use std::cell::RefCell;
        use std::default::Default;
        use std::ffi::{c_char, c_int, c_uint, CStr, CString};
        use std::fmt;

        use std::path::Path;
        use std::result;
        use std::str;
        use std::sync::{Arc, Mutex};

        use crate::cache::StatementCache;
        use crate::inner_connection::InnerConnection;
        use crate::raw_statement::RawStatement;
        use crate::types::ValueRef;

        pub use crate::bind::BindIndex;
        pub use crate::cache::CachedStatement;
        #[cfg(feature = "column_decltype")]
        pub use crate::column::Column;
        #[cfg(feature = "column_metadata")]
        pub use crate::column::ColumnMetadata;
        
        pub use crate::ffi::ErrorCode;
        #[cfg(feature = "load_extension")]
        pub use crate::load_extension_guard::LoadExtensionGuard;
        pub use crate::params::{params_from_iter, Params, ParamsFromIter};
        pub use crate::row::{AndThenRows, Map, MappedRows, Row, RowIndex, Rows};
        pub use crate::statement::{Statement, StatementStatus};
        #[cfg(feature = "modern_sqlite")]
        pub use crate::transaction::TransactionState;
        pub use crate::transaction::{DropBehavior, Savepoint, Transaction, TransactionBehavior};
        pub use crate::types::ToSql;
        pub use crate::util::Name;
        pub use crate::version::*;
        #[cfg(feature = "rusqlite-macros")]
        #[doc(hidden)]
        pub use rusqlite_macros::__bind;
        */
        
        pub mod connection
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub mod inner
            {
                /*!
                */
                use ::
                {
                    ffi::{ c_char, c_int, CStr },
                    sync::{ Arc, Mutex },
                    system::sqlite::
                    {
                        error::{decode_result_raw, error_from_handle, error_with_offset, Error},
                        statement::{ raw::RawStatement, Statement },
                        ffi, str_for_sqlite, Connection, InterruptHandle, Name, OpenFlags, 
                        PrepFlags, Result, version_number
                    },
                    *,
                };
                /*
                */
                pub struct InnerConnection 
                {
                    pub db: *mut ffi::sqlite3,
                    interrupt_lock: Arc<Mutex<*mut ffi::sqlite3>>,
                    /*
                    #[cfg(feature = "hooks")]
                    pub commit_hook: Option<Box<dyn FnMut() -> bool + Send>>,
                    #[cfg(feature = "hooks")]
                    pub rollback_hook: Option<Box<dyn FnMut() + Send>>,
                    #[cfg(feature = "hooks")]
                    pub update_hook: Option<Box<dyn FnMut(crate::hooks::Action, &str, &str, i64) + Send>>,
                    #[cfg(feature = "hooks")]
                    pub progress_handler: Option<Box<dyn FnMut() -> bool + Send>>,
                    #[cfg(feature = "hooks")]
                    pub authorizer: Option<crate::hooks::BoxedAuthorizer>,
                    #[cfg(feature = "preupdate_hook")]
                    pub preupdate_hook: Option
                    <
                        Box<dyn FnMut(crate::hooks::Action, &str, &str, &crate::hooks::PreUpdateCase) + Send>,
                    >,*/
                    owned: bool,
                }

                unsafe impl Send for InnerConnection {}

                impl InnerConnection
                {
                    unsafe fn new(db: *mut ffi::sqlite3, owned: bool) -> Self
                    {
                        Self {
                            db,
                            interrupt_lock: Arc::new(Mutex::new(if owned { db } else { ptr::null_mut() })),
                            /*#[cfg(feature = "hooks")]
                            commit_hook: None,
                            #[cfg(feature = "hooks")]
                            rollback_hook: None,
                            #[cfg(feature = "hooks")]
                            update_hook: None,
                            #[cfg(feature = "hooks")]
                            progress_handler: None,
                            #[cfg(feature = "hooks")]
                            authorizer: None,
                            #[cfg(feature = "preupdate_hook")]
                            preupdate_hook: None,*/
                            owned,
                        }
                    }

                    pub fn open_with_flags(
                        c_path: &CStr,
                        mut flags: OpenFlags,
                        vfs: Option<&CStr>,
                    ) -> Result<Self> {
                        ensure_safe_sqlite_threading_mode()?;

                        let z_vfs = match vfs {
                            Some(c_vfs) => c_vfs.as_ptr(),
                            None => ptr::null(),
                        };

                        // turn on extended results code before opening database to have a better diagnostic if a failure happens
                        let exrescode = if version_number() >= 3_037_000 {
                            flags |= OpenFlags::SQLITE_OPEN_EXRESCODE;
                            true
                        } else {
                            false // flag SQLITE_OPEN_EXRESCODE is ignored by SQLite version < 3.37.0
                        };

                        unsafe {
                            let mut db: *mut ffi::sqlite3 = ptr::null_mut();
                            let r = ffi::sqlite3_open_v2(c_path.as_ptr(), &mut db, flags.bits(), z_vfs);
                            if r != ffi::SQLITE_OK {
                                let e = if db.is_null() {
                                    err!(r, "{}", c_path.to_string_lossy())
                                } else {
                                    let mut e = error_from_handle(db, r);
                                    if let Error::SqliteFailure(
                                        ffi::Error {
                                            code: ffi::ErrorCode::CannotOpen,
                                            ..
                                        },
                                        Some(msg),
                                    ) = e
                                    {
                                        e = err!(r, "{msg}: {}", c_path.to_string_lossy());
                                    }
                                    ffi::sqlite3_close(db);
                                    e
                                };

                                return Err(e);
                            }

                            // attempt to turn on extended results code; don't fail if we can't.
                            if !exrescode {
                                ffi::sqlite3_extended_result_codes(db, 1);
                            }

                            let r = ffi::sqlite3_busy_timeout(db, 5000);
                            if r != ffi::SQLITE_OK {
                                let e = error_from_handle(db, r);
                                ffi::sqlite3_close(db);
                                return Err(e);
                            }

                            Ok(Self::new(db, true))
                        }
                    }

                    #[inline] pub fn db(&self) -> *mut ffi::sqlite3 {
                        self.db
                    }

                    #[inline] pub fn decode_result(&self, code: c_int) -> Result<()> {
                        unsafe { decode_result_raw(self.db(), code) }
                    }

                    pub fn close(&mut self) -> Result<()> {
                        if self.db.is_null() {
                            return Ok(());
                        }
                        self.remove_hooks();
                        self.remove_preupdate_hook();
                        let mut shared_handle = self.interrupt_lock.lock().unwrap();
                        assert!(
                            !self.owned || !shared_handle.is_null(),
                            "Bug: Somehow interrupt_lock was cleared before the DB was closed"
                        );
                        if !self.owned {
                            self.db = ptr::null_mut();
                            return Ok(());
                        }
                        unsafe {
                            let r = ffi::sqlite3_close(self.db);
                            // Need to use _raw because _guard has a reference out, and
                            // decode_result takes &mut self.
                            let r = decode_result_raw(self.db, r);
                            if r.is_ok() {
                                *shared_handle = ptr::null_mut();
                                self.db = ptr::null_mut();
                            }
                            r
                        }
                    }

                    #[inline] pub fn get_interrupt_handle(&self) -> InterruptHandle {
                        InterruptHandle {
                            db_lock: Arc::clone(&self.interrupt_lock),
                        }
                    }
                    /*
                        #[inline]
                        #[cfg(feature = "load_extension")]
                        pub unsafe fn enable_load_extension(&mut self, onoff: c_int) -> Result<()> {
                            let r = ffi::sqlite3_enable_load_extension(self.db, onoff);
                            self.decode_result(r)
                        }

                        #[cfg(feature = "load_extension")]
                        pub unsafe fn load_extension<N: Name>(
                            &self,
                            dylib_path: &Path,
                            entry_point: Option<N>,
                        ) -> Result<()> {
                            let dylib_str = super::path_to_cstring(dylib_path)?;
                            let mut errmsg: *mut c_char = ptr::null_mut();
                            let cs = entry_point.as_ref().map(N::as_cstr).transpose()?;
                            let c_entry = cs.as_ref().map(|s| s.as_ptr()).unwrap_or(ptr::null());
                            let r = ffi::sqlite3_load_extension(self.db, dylib_str.as_ptr(), c_entry, &mut errmsg);
                            if r == ffi::SQLITE_OK {
                                Ok(())
                            } else {
                                let message = super::errmsg_to_string(errmsg);
                                ffi::sqlite3_free(errmsg.cast::<std::ffi::c_void>());
                                Err(crate::error::error_from_sqlite_code(r, Some(message)))
                            }
                        }
                    */
                    #[inline] pub fn last_insert_rowid(&self) -> i64 {
                        unsafe { ffi::sqlite3_last_insert_rowid(self.db()) }
                    }

                    pub fn prepare<'a>(
                        &mut self,
                        conn: &'a Connection,
                        sql: &str,
                        flags: PrepFlags,
                    ) -> Result<(Statement<'a>, usize)> {
                        let mut c_stmt: *mut ffi::sqlite3_stmt = ptr::null_mut();
                        let (c_sql, len, _) = str_for_sqlite(sql.as_bytes())?;
                        let mut c_tail: *const c_char = ptr::null();
                        //#[cfg(not(feature = "unlock_notify"))]
                        let r = unsafe { self.prepare_(c_sql, len, flags, &mut c_stmt, &mut c_tail) };
                        /*#[cfg(feature = "unlock_notify")]
                        let r = unsafe {
                            use crate::unlock_notify;
                            let mut rc;
                            loop {
                                rc = self.prepare_(c_sql, len, flags, &mut c_stmt, &mut c_tail);
                                if !unlock_notify::is_locked(self.db, rc) {
                                    break;
                                }
                                rc = unlock_notify::wait_for_unlock_notify(self.db);
                                if rc != ffi::SQLITE_OK {
                                    break;
                                }
                            }
                            rc
                        };*/
                        // If there is an error, *ppStmt is set to NULL.
                        if r != ffi::SQLITE_OK {
                            return Err(unsafe { error_with_offset(self.db, r, sql) });
                        }
                        // If the input text contains no SQL (if the input is an empty string or a
                        // comment) then *ppStmt is set to NULL.
                        let tail = if c_tail.is_null() {
                            0
                        } else {
                            let n = (c_tail as isize) - (c_sql as isize);
                            if n <= 0 || n >= len as isize {
                                0
                            } else {
                                n as usize
                            }
                        };
                        Ok((
                            Statement::new(conn, unsafe { RawStatement::new(c_stmt) }),
                            tail,
                        ))
                    }
                    /*
                        #[inline]
                        #[cfg(not(feature = "modern_sqlite"))]
                        unsafe fn prepare_(
                            &self,
                            z_sql: *const c_char,
                            n_byte: c_int,
                            _: PrepFlags,
                            pp_stmt: *mut *mut ffi::sqlite3_stmt,
                            pz_tail: *mut *const c_char,
                        ) -> c_int {
                            ffi::sqlite3_prepare_v2(self.db(), z_sql, n_byte, pp_stmt, pz_tail)
                        }

                        #[inline]
                        #[cfg(feature = "modern_sqlite")] */
                    #[inline] unsafe fn prepare_
                    (
                        &self,
                        z_sql: *const c_char,
                        n_byte: c_int,
                        flags: PrepFlags,
                        pp_stmt: *mut *mut ffi::sqlite3_stmt,
                        pz_tail: *mut *const c_char,
                    ) -> c_int {
                        ffi::sqlite3_prepare_v3(self.db(), z_sql, n_byte, flags.bits(), pp_stmt, pz_tail)
                    }

                    #[inline] pub fn changes(&self) -> u64 { unsafe { ffi::sqlite3_changes64(self.db()) as u64 } }

                    #[inline] pub fn total_changes(&self) -> u64 {
                        unsafe {
                            ffi::sqlite3_total_changes64(self.db()) as u64
                        }
                    }

                    #[inline] pub fn is_autocommit(&self) -> bool {
                        unsafe { get_autocommit(self.db()) }
                    }

                    pub fn is_busy(&self) -> bool {
                        let db = self.db();
                        unsafe {
                            let mut stmt = ffi::sqlite3_next_stmt(db, ptr::null_mut());
                            while !stmt.is_null() {
                                if ffi::sqlite3_stmt_busy(stmt) != 0 {
                                    return true;
                                }
                                stmt = ffi::sqlite3_next_stmt(db, stmt);
                            }
                        }
                        false
                    }

                    pub fn cache_flush(&mut self) -> Result<()> {
                        error::check(unsafe { ffi::sqlite3_db_cacheflush(self.db()) })
                    }
                    
                    #[inline] fn remove_hooks(&mut self) {}
                    
                    #[inline] fn remove_preupdate_hook(&mut self) {}

                    pub fn db_readonly<N: Name>(&self, db_name: N) -> Result<bool> {
                        let name = db_name.as_cstr()?;
                        let r = unsafe { ffi::sqlite3_db_readonly(self.db, name.as_ptr()) };
                        match r {
                            0 => Ok(false),
                            1 => Ok(true),
                            -1 => Err(err!(
                                ffi::SQLITE_MISUSE,
                                "{db_name:?} is not the name of a database"
                            )),
                            _ => Err(err!(r, "Unexpected result")),
                        }
                    }
                    
                    pub fn txn_state<N: Name>(
                        &self,
                        db_name: Option<N>,
                    ) -> Result<super::transaction::TransactionState> {
                        let cs = db_name.as_ref().map(N::as_cstr).transpose()?;
                        let name = cs.as_ref().map(|s| s.as_ptr()).unwrap_or(ptr::null());
                        let r = unsafe { ffi::sqlite3_txn_state(self.db, name) };
                        match r {
                            0 => Ok(super::transaction::TransactionState::None),
                            1 => Ok(super::transaction::TransactionState::Read),
                            2 => Ok(super::transaction::TransactionState::Write),
                            -1 => Err(err!(
                                ffi::SQLITE_MISUSE,
                                "{db_name:?} is not the name of a valid schema"
                            )),
                            _ => Err(err!(r, "Unexpected result")),
                        }
                    }

                    #[inline] pub fn release_memory(&self) -> Result<()> {
                        self.decode_result(unsafe { ffi::sqlite3_db_release_memory(self.db) })
                    }
                    
                    pub fn is_interrupted(&self) -> bool {
                        unsafe { ffi::sqlite3_is_interrupted(self.db) == 1 }
                    }
                }

                #[inline]  pub unsafe fn get_autocommit(ptr: *mut ffi::sqlite3) -> bool {
                    ffi::sqlite3_get_autocommit(ptr) != 0
                }

                #[inline]  pub unsafe fn db_filename<N: Name>(
                    _: std::marker::PhantomData<&()>,
                    ptr: *mut ffi::sqlite3,
                    db_name: N,
                ) -> Option<&str> {
                    let db_name = db_name.as_cstr().unwrap();
                    let db_filename = ffi::sqlite3_db_filename(ptr, db_name.as_ptr());
                    if db_filename.is_null() {
                        None
                    } else {
                        CStr::from_ptr(db_filename).to_str().ok()
                    }
                }

                impl Drop for InnerConnection {
                    #[expect(unused_must_use)]
                    #[inline] fn drop(&mut self) {
                        self.close();
                    }
                }

                // threading mode checks are not necessary (and do not work) on target
                // platforms that do not have threading (such as webassembly)
                fn ensure_safe_sqlite_threading_mode() -> Result<()> {
                    // Ensure SQLite was compiled in threadsafe mode.
                    if unsafe { ffi::sqlite3_threadsafe() == 0 } {
                        return Err(Error::SqliteSingleThreadedMode);
                    }

                    // Now we know SQLite is _capable_ of being in Multi-thread of Serialized mode,
                    // but it's possible someone configured it to be in Single-thread mode
                    // before calling into us. That would mean we're exposing an unsafe API via
                    // a safe one (in Rust terminology).
                    //
                    // We can ask SQLite for a mutex and check for
                    // the magic value 8. This isn't documented, but it's what SQLite
                    // returns for its mutex allocation function in Single-thread mode.
                    const SQLITE_SINGLETHREADED_MUTEX_MAGIC: usize = 8;
                    let is_singlethreaded = unsafe {
                        let mutex_ptr = ffi::sqlite3_mutex_alloc(0);
                        let is_singlethreaded = mutex_ptr as usize == SQLITE_SINGLETHREADED_MUTEX_MAGIC;
                        ffi::sqlite3_mutex_free(mutex_ptr);
                        is_singlethreaded
                    };
                    if is_singlethreaded {
                        Err(Error::SqliteSingleThreadedMode)
                    } else {
                        Ok(())
                    }
                }
            }
        }

        pub mod cache
        {
            /*!
             Prepared statements cache for faster execution. */
            use ::
            {
                borrow::{ Borrow },
                cell::{ RefCell },
                hash::{BuildHasher, Hash},
                ops::{ Deref, DerefMut },
                sync::{ Arc },
                system::statement::raw::RawStatement,
                *,
            };
            /*
            use crate::{Connection, PrepFlags, Result, Statement};
            use hashlink::LruCache;
                use hashlink::linked_hash_map::{self, LinkedHashMap};
                use hashlink::DefaultHashBuilder;
                
                pub use hashlink::linked_hash_map::
                {
                    Drain, Entry, IntoIter, Iter, IterMut, OccupiedEntry, RawEntryBuilder, RawEntryBuilderMut,
                    RawOccupiedEntryMut, RawVacantEntryMut, VacantEntry,
                };

                use core::{
                alloc::Layout,
                borrow::Borrow,
                cmp::Ordering,
                fmt,
                hash::{BuildHasher, Hash, Hasher},
                iter::FromIterator,
                marker::PhantomData,
                mem::{self, MaybeUninit},
                ops::{Index, IndexMut},
                ptr::{self, NonNull},
            };

            use alloc::boxed::Box;
            use hashbrown::hash_table::{self, HashTable};

            use hashlink::DefaultHashBuilder;

            #[cfg(feature = "default-hasher")]
                use {
                    core::hash::{BuildHasher, Hasher},
                    foldhash::fast::RandomState,
                };
            */
            pub mod parameters
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
            }

            /// An object representing an initialized global seed.
            ///
            /// Does not actually store the seed inside itself, it is a zero-sized type.
            /// This prevents inflating the RandomState size and in turn HashMap's size.
            #[derive(Copy, Clone, Debug)]
            pub struct GlobalSeed {
                // So we can't accidentally type GlobalSeed { } within this crate.
                _no_accidental_unsafe_init: (),
            }

            /// A [`BuildHasher`] for [`fast::FoldHasher`](FoldHasher) that is randomly initialized.
            #[derive(Clone, Debug)]
            pub struct RandomState {
                per_hasher_seed: u64,
                global_seed: GlobalSeed,
            }

            /// Default hash builder for the `S` type parameter of
            /// [`HashMap`](crate::HashMap) and [`HashSet`](crate::HashSet).
            #[derive(Clone, Debug, Default)]
            pub struct HashBuilder
            {
                inner: RandomState,
            }
            
            impl BuildHasher for HashBuilder
            {
                type Hasher = DefaultHasher;

                #[inline(always)]
                fn build_hasher(&self) -> Self::Hasher {
                    DefaultHasher {
                        inner: self.inner.build_hasher(),
                    }
                }
            }

            /// Default hasher for [`HashMap`](crate::HashMap) and [`HashSet`](crate::HashSet).
            #[derive(Clone)]
            pub struct DefaultHasher {
                inner: <RandomState as BuildHasher>::Hasher,
            }
            
            macro_rules! forward_writes {
                ($( $write:ident ( $ty:ty ) , )*) => {$(
                    #[inline(always)]
                    fn $write(&mut self, arg: $ty) {
                        self.inner.$write(arg);
                    }
                )*}
            }
            
            impl Hasher for DefaultHasher {
                forward_writes! {
                    write(&[u8]),
                    write_u8(u8),
                    write_u16(u16),
                    write_u32(u32),
                    write_u64(u64),
                    write_u128(u128),
                    write_usize(usize),
                    write_i8(i8),
                    write_i16(i16),
                    write_i32(i32),
                    write_i64(i64),
                    write_i128(i128),
                    write_isize(isize),
                }

                // feature(hasher_prefixfree_extras)
                #[cfg(feature = "nightly")]
                forward_writes! {
                    write_length_prefix(usize),
                    write_str(&str),
                }

                #[inline(always)]
                fn finish(&self) -> u64 {
                    self.inner.finish()
                }
            }

            /// Default hash builder, matches hashbrown's default hasher.
            ///
            /// See [`DefaultHasher`] for more details.
            #[derive(Clone, Copy, Default, Debug)]
            pub struct DefaultHashBuilder( HashBuilder );

            
            
            /// A version of `HashMap` that has a user controllable order for its entries.
            pub struct LinkedHashMap<K, V, S = DefaultHashBuilder>
            {
                            table: HashTable<NonNull<Node<K, V>>>,
                            // We always need to keep our custom hash builder outside of the HashTable, because it doesn't
                            // know how to do any hashing itself.
                            hash_builder: S,
                            // Circular linked list of nodes.  If `values` is non-null, it will point to a "guard node"
                            // which will never have an initialized key or value, `values.prev` will contain the last key /
                            // value in the list, `values.next` will contain the first key / value in the list.
                            values: Option<NonNull<Node<K, V>>>,
                            // *Singly* linked list of free nodes.  The `prev` pointers in the free list should be assumed
                            // invalid.
                            free: Option<NonNull<Node<K, V>>>,
            }

            
            pub struct LruCache<K, V, S = DefaultHashBuilder>
            {
                map: LinkedHashMap<K, V, S>,
                max_size: usize,
            }

            impl Connection
            {
                /// Prepare a SQL statement for execution, returning a previously prepared unused statement if one is available.
                #[inline] pub fn prepare_cached(&self, sql: &str) -> Result<CachedStatement<'_>> { self.cache.get(self, sql) }
                /// Set the maximum number of cached prepared statements this connection will hold.
                #[inline] pub fn set_prepared_statement_cache_capacity(&self, capacity: usize)
                { self.cache.set_capacity(capacity); }
                /// Remove/finalize all prepared statements currently in the cache.
                #[inline] pub fn flush_prepared_statement_cache(&self) { self.cache.flush(); }
            }
            /// Prepared statements LRU cache.
            #[derive(Debug)] pub struct StatementCache(RefCell<LruCache<Arc<str>, RawStatement>>);

            unsafe impl Send for StatementCache {}
            /// Cacheable statement.
            pub struct CachedStatement<'conn>
            {
                stmt: Option<Statement<'conn>>,
                cache: &'conn StatementCache,
            }

            impl<'conn> Deref for CachedStatement<'conn>
            {
                type Target = Statement<'conn>;
                #[inline] fn deref(&self) -> &Statement<'conn> { self.stmt.as_ref().unwrap() }
            }

            impl<'conn> DerefMut for CachedStatement<'conn>
            {
                #[inline] fn deref_mut(&mut self) -> &mut Statement<'conn> { self.stmt.as_mut().unwrap() }
            }

            impl Drop for CachedStatement<'_>
            {
                #[inline] fn drop(&mut self) {
                    if let Some(stmt) = self.stmt.take() {
                        self.cache.cache_stmt(unsafe { stmt.into_raw() });
                    }
                }
            }

            impl CachedStatement<'_>
            {
                #[inline] fn new<'conn>(stmt: Statement<'conn>, cache: &'conn StatementCache) -> CachedStatement<'conn> {
                    CachedStatement {
                        stmt: Some(stmt),
                        cache,
                    }
                }

                /// Discard the statement, preventing it from being returned to its
                /// [`Connection`]'s collection of cached statements.
                #[inline] pub fn discard(mut self) {
                    self.stmt = None;
                }
            }

            impl StatementCache
            {
                /// Create a statement cache.
                #[inline] pub fn with_capacity(capacity: usize) -> Self { Self(RefCell::new(LruCache::new(capacity))) }

                #[inline] fn set_capacity(&self, capacity: usize) { self.0.borrow_mut().set_capacity(capacity); }
                
                fn get<'conn>
                (
                    &'conn self,
                    conn: &'conn Connection,
                    sql: &str,
                ) -> Result<CachedStatement<'conn>>
                {
                    let trimmed = sql.trim();
                    let mut cache = self.0.borrow_mut();
                    let stmt = match cache.remove(trimmed)
                    {
                        Some(raw_stmt) => Ok(Statement::new(conn, raw_stmt)),
                        None => conn.prepare_with_flags(trimmed, PrepFlags::SQLITE_PREPARE_PERSISTENT),
                    };

                    stmt.map(|mut stmt|
                    {
                        stmt.stmt.set_statement_cache_key(trimmed);
                        CachedStatement::new(stmt, self)
                    })
                }
                
                fn cache_stmt(&self, mut stmt: RawStatement)
                {
                    if stmt.is_null() { return; }

                    let mut cache = self.0.borrow_mut();
                    stmt.clear_bindings();
                    
                    if let Some(sql) = stmt.statement_cache_key() { cache.insert(sql, stmt); }
                    else
                    {
                        debug_assert!
                        (
                            false,
                            "bug in statement cache code, statement returned to cache that without key"
                        );
                    }
                }

                #[inline] fn flush(&self)
                {
                    let mut cache = self.0.borrow_mut();
                    cache.clear();
                }
            }

        }

        pub mod statement
        {
            /*!
            */
            use ::
            {
                ffi::{ c_int, c_void },
                slice::{ from_raw_parts },
                *,
            };
            /*
            use super::ffi;
            use super::{len_as_c_int, str_for_sqlite};
            use super::
            {
                AndThenRows, Connection, Error, MappedRows, Params, RawStatement, Result, Row, Rows, ValueRef,
            };
            use crate::bind::BindIndex;
            use crate::types::{ToSql, ToSqlOutput};
            */
            pub mod raw
            {
                /*!
                */
                use ::
                {
                    ffi::{ c_int, CStr },
                    sync::{ Arc },
                    *,
                };
                /*
                use super::ffi;
                use super::StatementStatus;
                use crate::util::ParamIndexCache;
                use crate::util::SqliteMallocString;
                */
                #[derive(Debug)]
                pub struct RawStatement
                {
                    ptr: *mut ffi::sqlite3_stmt,
                    cache: ParamIndexCache,
                    statement_cache_key: Option<Arc<str>>,
                }

                impl RawStatement
                {
                    #[inline] pub unsafe fn new(stmt: *mut ffi::sqlite3_stmt) -> Self
                    {
                        Self
                        {
                            ptr: stmt,
                            cache: ParamIndexCache::default(),
                            statement_cache_key: None,
                        }
                    }

                    #[inline] pub fn is_null(&self) -> bool {
                        self.ptr.is_null()
                    }

                    #[inline] pub fn set_statement_cache_key(&mut self, p: impl Into<Arc<str>>) {
                        self.statement_cache_key = Some(p.into());
                    }

                    #[inline] pub fn statement_cache_key(&self) -> Option<Arc<str>> {
                        self.statement_cache_key.clone()
                    }

                    #[inline] pub unsafe fn ptr(&self) -> *mut ffi::sqlite3_stmt {
                        self.ptr
                    }

                    #[inline] pub fn column_count(&self) -> usize {
                        // Note: Can't cache this as it changes if the schema is altered.
                        unsafe { ffi::sqlite3_column_count(self.ptr) as usize }
                    }

                    #[inline] pub fn column_type(&self, idx: usize) -> c_int {
                        unsafe { ffi::sqlite3_column_type(self.ptr, idx as c_int) }
                    }
                    /*
                        #[inline]
                        #[cfg(feature = "column_metadata")]
                        pub fn column_database_name(&self, idx: usize) -> Option<&CStr> {
                            unsafe {
                                let db_name = ffi::sqlite3_column_database_name(self.ptr, idx as c_int);
                                if db_name.is_null() {
                                    None
                                } else {
                                    Some(CStr::from_ptr(db_name))
                                }
                            }
                        }

                        #[inline]
                        #[cfg(feature = "column_metadata")]
                        pub fn column_table_name(&self, idx: usize) -> Option<&CStr> {
                            unsafe {
                                let tbl_name = ffi::sqlite3_column_table_name(self.ptr, idx as c_int);
                                if tbl_name.is_null() {
                                    None
                                } else {
                                    Some(CStr::from_ptr(tbl_name))
                                }
                            }
                        }

                        #[inline]
                        #[cfg(feature = "column_metadata")]
                        pub fn column_origin_name(&self, idx: usize) -> Option<&CStr> {
                            unsafe {
                                let origin_name = ffi::sqlite3_column_origin_name(self.ptr, idx as c_int);
                                if origin_name.is_null() {
                                    None
                                } else {
                                    Some(CStr::from_ptr(origin_name))
                                }
                            }
                        }

                        #[inline]
                        #[cfg(feature = "column_decltype")]
                        pub fn column_decltype(&self, idx: usize) -> Option<&CStr> {
                            unsafe {
                                let decltype = ffi::sqlite3_column_decltype(self.ptr, idx as c_int);
                                if decltype.is_null() {
                                    None
                                } else {
                                    Some(CStr::from_ptr(decltype))
                                }
                            }
                        } */

                    #[inline] pub fn column_name(&self, idx: usize) -> Option<&CStr> {
                        let idx = idx as c_int;
                        if idx < 0 || idx >= self.column_count() as c_int {
                            return None;
                        }
                        unsafe {
                            let ptr = ffi::sqlite3_column_name(self.ptr, idx);
                            assert!(
                                !ptr.is_null(),
                                "Null pointer from sqlite3_column_name: Out of memory?"
                            );
                            Some(CStr::from_ptr(ptr))
                        }
                    }

                    #[inline] pub fn step(&self) -> c_int {
                        unsafe { ffi::sqlite3_step(self.ptr) }
                    }
                    
                    #[inline] pub fn reset(&self) -> c_int {
                        unsafe { ffi::sqlite3_reset(self.ptr) }
                    }

                    #[inline] pub fn bind_parameter_count(&self) -> usize {
                        unsafe { ffi::sqlite3_bind_parameter_count(self.ptr) as usize }
                    }

                    #[inline] pub fn bind_parameter_index(&self, name: &str) -> Option<usize> {
                        self.cache.get_or_insert_with(name, |param_cstr| {
                            let r = unsafe { ffi::sqlite3_bind_parameter_index(self.ptr, param_cstr.as_ptr()) };
                            match r {
                                0 => None,
                                i => Some(i as usize),
                            }
                        })
                    }

                    #[inline] pub fn bind_parameter_name(&self, index: i32) -> Option<&CStr> {
                        unsafe {
                            let name = ffi::sqlite3_bind_parameter_name(self.ptr, index);
                            if name.is_null() {
                                None
                            } else {
                                Some(CStr::from_ptr(name))
                            }
                        }
                    }

                    #[inline] pub fn clear_bindings(&mut self) {
                        unsafe {
                            ffi::sqlite3_clear_bindings(self.ptr);
                        } // rc is always SQLITE_OK
                    }

                    #[inline] pub fn sql(&self) -> Option<&CStr> {
                        if self.ptr.is_null() {
                            None
                        } else {
                            Some(unsafe { CStr::from_ptr(ffi::sqlite3_sql(self.ptr)) })
                        }
                    }

                    #[inline] pub fn finalize(mut self) -> c_int {
                        self.finalize_()
                    }

                    #[inline] fn finalize_(&mut self) -> c_int {
                        let r = unsafe { ffi::sqlite3_finalize(self.ptr) };
                        self.ptr = ptr::null_mut();
                        r
                    }

                    // does not work for PRAGMA
                    #[inline] pub fn readonly(&self) -> bool {
                        unsafe { ffi::sqlite3_stmt_readonly(self.ptr) != 0 }
                    }

                    #[inline] pub fn expanded_sql(&self) -> Option<SqliteMallocString> {
                        unsafe { expanded_sql(self.ptr) }
                    }

                    #[inline] pub fn get_status(&self, status: StatementStatus, reset: bool) -> i32 {
                        unsafe { stmt_status(self.ptr, status, reset) }
                    }

                    #[inline] pub fn is_explain(&self) -> i32 {
                        unsafe { ffi::sqlite3_stmt_isexplain(self.ptr) }
                    }

                    // TODO sqlite3_normalized_sql (https://sqlite.org/c3ref/expanded_sql.html) // 3.27.0 + SQLITE_ENABLE_NORMALIZE
                }

                #[inline] pub unsafe fn expanded_sql(ptr: *mut ffi::sqlite3_stmt) -> Option<SqliteMallocString> {
                    SqliteMallocString::from_raw(ffi::sqlite3_expanded_sql(ptr))
                }
                #[inline] pub unsafe fn stmt_status(
                    ptr: *mut ffi::sqlite3_stmt,
                    status: StatementStatus,
                    reset: bool,
                ) -> i32 {
                    assert!(!ptr.is_null());
                    ffi::sqlite3_stmt_status(ptr, status as i32, reset as i32)
                }

                impl Drop for RawStatement {
                    fn drop(&mut self) {
                        self.finalize_();
                    }
                }
            }
            /// A prepared statement.
            pub struct Statement<'conn> {
                pub conn: &'conn Connection,
                pub stmt: RawStatement,
            }

            impl Statement<'_> {
                /// Execute the prepared statement.
                #[inline] pub fn execute<P: Params>(&mut self, params: P) -> Result<usize> {
                    params.__bind_in(self)?;
                    self.execute_with_bound_parameters()
                }
                /// Execute an INSERT and return the ROWID.
                #[inline] pub fn insert<P: Params>(&mut self, params: P) -> Result<i64> {
                    let changes = self.execute(params)?;
                    match changes {
                        1 => Ok(self.conn.last_insert_rowid()),
                        _ => Err(Error::StatementChangedRows(changes)),
                    }
                }
                /// Execute the prepared statement, returning a handle to the resulting rows.
                #[inline] pub fn query<P: Params>(&mut self, params: P) -> Result<Rows<'_>> {
                    params.__bind_in(self)?;
                    Ok(Rows::new(self))
                }
                /// Executes the prepared statement and maps a function over the resulting
                /// rows, returning an iterator over the mapped function results.
                pub fn query_map<T, P, F>(&mut self, params: P, f: F) -> Result<MappedRows<'_, F>> where
                    P: Params,
                    F: FnMut(&Row<'_>) -> Result<T>,
                {
                    self.query(params).map(|rows| rows.mapped(f))
                }
                /// Executes the prepared statement and maps a function over the resulting
                /// rows, where the function returns a `Result` with `Error` type
                /// implementing `std::convert::From<Error>` (so errors can be unified).
                #[inline] pub fn query_and_then<T, E, P, F>(&mut self, params: P, f: F) -> Result<AndThenRows<'_, F>> where
                    P: Params,
                    E: From<Error>,
                    F: FnMut(&Row<'_>) -> Result<T, E>,
                {
                    self.query(params).map(|rows| rows.and_then(f))
                }
                /// Return `true` if a query in the SQL statement it executes returns one
                /// or more rows and `false` if the SQL returns an empty set.
                #[inline] pub fn exists<P: Params>(&mut self, params: P) -> Result<bool> {
                    let mut rows = self.query(params)?;
                    let exists = rows.next()?.is_some();
                    Ok(exists)
                }
                /// Convenience method to execute a query that is expected to return a single row.
                pub fn query_row<T, P, F>(&mut self, params: P, f: F) -> Result<T> where
                    P: Params,
                    F: FnOnce(&Row<'_>) -> Result<T>,
                {
                    let mut rows = self.query(params)?;

                    rows.get_expected_row().and_then(f)
                }
                /// Convenience method to execute a query that is expected to return exactly one row.
                pub fn query_one<T, P, F>(&mut self, params: P, f: F) -> Result<T> where
                    P: Params,
                    F: FnOnce(&Row<'_>) -> Result<T>,
                {
                    let mut rows = self.query(params)?;
                    let row = rows.get_expected_row().and_then(f)?;
                    if rows.next()?.is_some() {
                        return Err(Error::QueryReturnedMoreThanOneRow);
                    }
                    Ok(row)
                }
                /// Consumes the statement.
                #[inline] pub fn finalize(mut self) -> Result<()> {
                    self.finalize_()
                }
                /// Return the (one-based) index of an SQL parameter given its name.
                #[inline] pub fn parameter_index(&self, name: &str) -> Result<Option<usize>> {
                    Ok(self.stmt.bind_parameter_index(name))
                }
                /// Return the SQL parameter name given its (one-based) index (the inverse of [`Statement::parameter_index`]).
                #[inline] pub fn parameter_name(&self, index: usize) -> Option<&'_ str> {
                    self.stmt.bind_parameter_name(index as i32).map(|name| {
                        name.to_str()
                            .expect("Invalid UTF-8 sequence in parameter name")
                    })
                }

                #[inline] pub fn bind_parameters<P>(&mut self, params: P) -> Result<()> where
                    P: IntoIterator,
                    P::Item: ToSql,
                {
                    let expected = self.stmt.bind_parameter_count();
                    let mut index = 0;
                    for p in params {
                        index += 1;
                        if index > expected {
                            break;
                        }
                        self.bind_parameter(&p, index)?;
                    }
                    if index != expected {
                        Err(Error::InvalidParameterCount(index, expected))
                    } else {
                        Ok(())
                    }
                }

                #[inline] pub fn ensure_parameter_count(&self, n: usize) -> Result<()> {
                    let count = self.parameter_count();
                    if count != n {
                        Err(Error::InvalidParameterCount(n, count))
                    } else {
                        Ok(())
                    }
                }

                #[inline] pub fn bind_parameters_named<S: BindIndex, T: ToSql>(
                    &mut self,
                    params: &[(S, T)],
                ) -> Result<()> {
                    for (name, value) in params {
                        let i = name.idx(self)?;
                        let ts: &dyn ToSql = &value;
                        self.bind_parameter(ts, i)?;
                    }
                    Ok(())
                }
                /// Return the number of parameters that can be bound to this statement.
                #[inline] pub fn parameter_count(&self) -> usize {
                    self.stmt.bind_parameter_count()
                }
                /// Low level API to directly bind a parameter to a given index.
                #[inline] pub fn raw_bind_parameter<I: BindIndex, T: ToSql>(
                    &mut self,
                    one_based_index: I,
                    param: T,
                ) -> Result<()> {
                    // This is the same as `bind_parameter` but slightly more ergonomic and
                    // correctly takes `&mut self`.
                    self.bind_parameter(&param, one_based_index.idx(self)?)
                }
                /// Low level API to execute a statement given that all parameters were
                /// bound explicitly with the [`Statement::raw_bind_parameter`] API.
                #[inline] pub fn raw_execute(&mut self) -> Result<usize> {
                    self.execute_with_bound_parameters()
                }
                /// Low level API to get `Rows` for this query given that all parameters
                /// were bound explicitly with the [`Statement::raw_bind_parameter`] API.
                #[inline] pub fn raw_query(&mut self) -> Rows<'_> {
                    Rows::new(self)
                }
                
                fn bind_parameter<P: ?Sized + ToSql>(&self, param: &P, ndx: usize) -> Result<()> {
                    let value = param.to_sql()?;

                    let ptr = unsafe { self.stmt.ptr() };
                    let value = match value {
                        ToSqlOutput::Borrowed(v) => v,
                        ToSqlOutput::Owned(ref v) => ValueRef::from(v),
                        /*
                        #[cfg(feature = "blob")]
                        ToSqlOutput::ZeroBlob(len) => {
                            return self
                                .conn
                                .decode_result(unsafe { ffi::sqlite3_bind_zeroblob(ptr, ndx as c_int, len) });
                        }
                        #[cfg(feature = "functions")]
                        ToSqlOutput::Arg(_) => {
                            return Err(err!(ffi::SQLITE_MISUSE, "Unsupported value \"{value:?}\""));
                        }
                        #[cfg(feature = "array")]
                        ToSqlOutput::Array(a) => {
                            return self.conn.decode_result(unsafe {
                                ffi::sqlite3_bind_pointer(
                                    ptr,
                                    ndx as c_int,
                                    Rc::into_raw(a) as *mut c_void,
                                    ARRAY_TYPE,
                                    Some(free_array),
                                )
                            });
                        } */
                    };
                    self.conn.decode_result(match value {
                        ValueRef::Null => unsafe { ffi::sqlite3_bind_null(ptr, ndx as c_int) },
                        ValueRef::Integer(i) => unsafe { ffi::sqlite3_bind_int64(ptr, ndx as c_int, i) },
                        ValueRef::Real(r) => unsafe { ffi::sqlite3_bind_double(ptr, ndx as c_int, r) },
                        ValueRef::Text(s) => unsafe {
                            let (c_str, len, destructor) = str_for_sqlite(s)?;
                            ffi::sqlite3_bind_text(ptr, ndx as c_int, c_str, len, destructor)
                        },
                        ValueRef::Blob(b) => unsafe {
                            let length = len_as_c_int(b.len())?;
                            if length == 0 {
                                ffi::sqlite3_bind_zeroblob(ptr, ndx as c_int, 0)
                            } else {
                                ffi::sqlite3_bind_blob(
                                    ptr,
                                    ndx as c_int,
                                    b.as_ptr().cast::<c_void>(),
                                    length,
                                    ffi::SQLITE_TRANSIENT(),
                                )
                            }
                        },
                    })
                }

                #[inline] fn execute_with_bound_parameters(&mut self) -> Result<usize> {
                    self.check_update()?;
                    let r = self.stmt.step();
                    let rr = self.stmt.reset();
                    match r {
                        ffi::SQLITE_DONE => match rr {
                            ffi::SQLITE_OK => Ok(self.conn.changes() as usize),
                            _ => Err(self.conn.decode_result(rr).unwrap_err()),
                        },
                        ffi::SQLITE_ROW => Err(Error::ExecuteReturnedResults),
                        _ => Err(self.conn.decode_result(r).unwrap_err()),
                    }
                }

                #[inline] fn finalize_(&mut self) -> Result<()> {
                    let mut stmt = unsafe { RawStatement::new(ptr::null_mut()) };
                    mem::swap(&mut stmt, &mut self.stmt);
                    self.conn.decode_result(stmt.finalize())
                }
                
                #[inline] fn check_update(&self) -> Result<()> {
                    Ok(())
                }
                /// Returns a string containing the SQL text of prepared statement with
                /// bound parameters expanded.
                pub fn expanded_sql(&self) -> Option<String> {
                    self.stmt
                        .expanded_sql()
                        .map(|s| s.to_string_lossy().to_string())
                }
                /// Get the value for one of the status counters for this statement.
                #[inline] pub fn get_status(&self, status: StatementStatus) -> i32 {
                    self.stmt.get_status(status, false)
                }
                /// Reset the value of one of the status counters for this statement,
                #[inline]
                /// returning the value it had before resetting.
                pub fn reset_status(&self, status: StatementStatus) -> i32 {
                    self.stmt.get_status(status, true)
                }
                /// Returns 1 if the prepared statement is an EXPLAIN statement,
                /// or 2 if the statement is an EXPLAIN QUERY PLAN,
                /// or 0 if it is an ordinary statement or a NULL pointer.
                #[inline] pub fn is_explain(&self) -> i32 {
                    self.stmt.is_explain()
                }
                /// Returns true if the statement is read only.
                #[inline] pub fn readonly(&self) -> bool {
                    self.stmt.readonly()
                }
                /// Safety: This is unsafe, because using `sqlite3_stmt` after the
                /// connection has closed is illegal, but `RawStatement` does not enforce
                /// this, as it loses our protective `'conn` lifetime bound.
                #[inline] pub unsafe fn into_raw(mut self) -> RawStatement {
                    let mut stmt = RawStatement::new(ptr::null_mut());
                    mem::swap(&mut stmt, &mut self.stmt);
                    stmt
                }
                /// Reset all bindings
                pub fn clear_bindings(&mut self) {
                    self.stmt.clear_bindings();
                }

                pub unsafe fn ptr(&self) -> *mut ffi::sqlite3_stmt {
                    self.stmt.ptr()
                }
            }

            impl fmt::Debug for Statement<'_> {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let sql = if self.stmt.is_null() {
                        Ok("")
                    } else {
                        self.stmt.sql().unwrap().to_str()
                    };
                    f.debug_struct("Statement")
                        .field("conn", self.conn)
                        .field("stmt", &self.stmt)
                        .field("sql", &sql)
                        .finish()
                }
            }

            impl Drop for Statement<'_> {
                #[expect(unused_must_use)]
                #[inline] fn drop(&mut self) {
                    self.finalize_();
                }
            }

            impl Statement<'_> {
                #[inline] pub fn new(conn: &Connection, stmt: RawStatement) -> Statement<'_> {
                    Statement { conn, stmt }
                }

                pub(super) fn value_ref(&self, col: usize) -> ValueRef<'_> {
                    let raw = unsafe { self.stmt.ptr() };

                    match self.stmt.column_type(col) {
                        ffi::SQLITE_NULL => ValueRef::Null,
                        ffi::SQLITE_INTEGER => {
                            ValueRef::Integer(unsafe { ffi::sqlite3_column_int64(raw, col as c_int) })
                        }
                        ffi::SQLITE_FLOAT => {
                            ValueRef::Real(unsafe { ffi::sqlite3_column_double(raw, col as c_int) })
                        }
                        ffi::SQLITE_TEXT => {
                            let s = unsafe {
                                let text = ffi::sqlite3_column_text(raw, col as c_int);
                                let len = ffi::sqlite3_column_bytes(raw, col as c_int);
                                assert!(
                                    !text.is_null(),
                                    "unexpected SQLITE_TEXT column type with NULL data"
                                );
                                from_raw_parts(text.cast::<u8>(), len as usize)
                            };

                            ValueRef::Text(s)
                        }
                        ffi::SQLITE_BLOB => {
                            let (blob, len) = unsafe {
                                (
                                    ffi::sqlite3_column_blob(raw, col as c_int),
                                    ffi::sqlite3_column_bytes(raw, col as c_int),
                                )
                            };

                            assert!(
                                len >= 0,
                                "unexpected negative return from sqlite3_column_bytes"
                            );
                            if len > 0 {
                                assert!(
                                    !blob.is_null(),
                                    "unexpected SQLITE_BLOB column type with NULL data"
                                );
                                ValueRef::Blob(unsafe { from_raw_parts(blob.cast::<u8>(), len as usize) })
                            } else {
                                // The return value from sqlite3_column_blob() for a zero-length BLOB
                                // is a NULL pointer.
                                ValueRef::Blob(&[])
                            }
                        }
                        _ => unreachable!("sqlite3_column_type returned invalid value"),
                    }
                }

                #[inline] pub fn step(&self) -> Result<bool> {
                    match self.stmt.step() {
                        ffi::SQLITE_ROW => Ok(true),
                        ffi::SQLITE_DONE => Ok(false),
                        code => Err(self.conn.decode_result(code).unwrap_err()),
                    }
                }

                #[inline] pub fn reset(&self) -> Result<()> {
                    match self.stmt.reset() {
                        ffi::SQLITE_OK => Ok(()),
                        code => Err(self.conn.decode_result(code).unwrap_err()),
                    }
                }
            }

            /// Prepared statement status counters.
            #[repr(i32)]
            #[derive(Clone, Copy, PartialEq, Eq)]
            #[non_exhaustive]
            pub enum StatementStatus {
                /// Equivalent to `SQLITE_STMTSTATUS_FULLSCAN_STEP`
                FullscanStep = 1,
                /// Equivalent to `SQLITE_STMTSTATUS_SORT`
                Sort = 2,
                /// Equivalent to `SQLITE_STMTSTATUS_AUTOINDEX`
                AutoIndex = 3,
                /// Equivalent to `SQLITE_STMTSTATUS_VM_STEP`
                VmStep = 4,
                /// Equivalent to `SQLITE_STMTSTATUS_REPREPARE` (3.20.0)
                RePrepare = 5,
                /// Equivalent to `SQLITE_STMTSTATUS_RUN` (3.20.0)
                Run = 6,
                /// Equivalent to `SQLITE_STMTSTATUS_FILTER_MISS`
                FilterMiss = 7,
                /// Equivalent to `SQLITE_STMTSTATUS_FILTER_HIT`
                FilterHit = 8,
                /// Equivalent to `SQLITE_STMTSTATUS_MEMUSED` (3.20.0)
                MemUsed = 99,
            }

        }
    }
}
/*
5348 */
